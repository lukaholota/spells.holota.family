
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Character
 * 
 */
export type Character = $Result.DefaultSelection<Prisma.$CharacterPayload>
/**
 * Model CharacterSpells
 * 
 */
export type CharacterSpells = $Result.DefaultSelection<Prisma.$CharacterSpellsPayload>
/**
 * Model Creature
 * 
 */
export type Creature = $Result.DefaultSelection<Prisma.$CreaturePayload>
/**
 * Model Spell
 * 
 */
export type Spell = $Result.DefaultSelection<Prisma.$SpellPayload>
/**
 * Model SpellClasses
 * 
 */
export type SpellClasses = $Result.DefaultSelection<Prisma.$SpellClassesPayload>
/**
 * Model SpellRaces
 * 
 */
export type SpellRaces = $Result.DefaultSelection<Prisma.$SpellRacesPayload>
/**
 * Model Spellbook
 * 
 */
export type Spellbook = $Result.DefaultSelection<Prisma.$SpellbookPayload>
/**
 * Model SpellbookSpells
 * 
 */
export type SpellbookSpells = $Result.DefaultSelection<Prisma.$SpellbookSpellsPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model Subclass
 * 
 */
export type Subclass = $Result.DefaultSelection<Prisma.$SubclassPayload>
/**
 * Model Pers
 * 
 */
export type Pers = $Result.DefaultSelection<Prisma.$PersPayload>
/**
 * Model PersMulticlass
 * 
 */
export type PersMulticlass = $Result.DefaultSelection<Prisma.$PersMulticlassPayload>
/**
 * Model PersFeature
 * 
 */
export type PersFeature = $Result.DefaultSelection<Prisma.$PersFeaturePayload>
/**
 * Model Feature
 * 
 */
export type Feature = $Result.DefaultSelection<Prisma.$FeaturePayload>
/**
 * Model ClassFeature
 * 
 */
export type ClassFeature = $Result.DefaultSelection<Prisma.$ClassFeaturePayload>
/**
 * Model SubclassFeature
 * 
 */
export type SubclassFeature = $Result.DefaultSelection<Prisma.$SubclassFeaturePayload>
/**
 * Model RaceTrait
 * 
 */
export type RaceTrait = $Result.DefaultSelection<Prisma.$RaceTraitPayload>
/**
 * Model SubraceTrait
 * 
 */
export type SubraceTrait = $Result.DefaultSelection<Prisma.$SubraceTraitPayload>
/**
 * Model RaceVariantTrait
 * 
 */
export type RaceVariantTrait = $Result.DefaultSelection<Prisma.$RaceVariantTraitPayload>
/**
 * Model RaceChoiceOptionTrait
 * 
 */
export type RaceChoiceOptionTrait = $Result.DefaultSelection<Prisma.$RaceChoiceOptionTraitPayload>
/**
 * Model FeatFeature
 * 
 */
export type FeatFeature = $Result.DefaultSelection<Prisma.$FeatFeaturePayload>
/**
 * Model MagicItemFeature
 * 
 */
export type MagicItemFeature = $Result.DefaultSelection<Prisma.$MagicItemFeaturePayload>
/**
 * Model Race
 * 
 */
export type Race = $Result.DefaultSelection<Prisma.$RacePayload>
/**
 * Model Subrace
 * 
 */
export type Subrace = $Result.DefaultSelection<Prisma.$SubracePayload>
/**
 * Model RaceVariant
 * 
 */
export type RaceVariant = $Result.DefaultSelection<Prisma.$RaceVariantPayload>
/**
 * Model RaceChoiceOption
 * 
 */
export type RaceChoiceOption = $Result.DefaultSelection<Prisma.$RaceChoiceOptionPayload>
/**
 * Model Background
 * 
 */
export type Background = $Result.DefaultSelection<Prisma.$BackgroundPayload>
/**
 * Model Feat
 * 
 */
export type Feat = $Result.DefaultSelection<Prisma.$FeatPayload>
/**
 * Model FeatAbilityBoost
 * 
 */
export type FeatAbilityBoost = $Result.DefaultSelection<Prisma.$FeatAbilityBoostPayload>
/**
 * Model PersFeat
 * 
 */
export type PersFeat = $Result.DefaultSelection<Prisma.$PersFeatPayload>
/**
 * Model MagicItem
 * 
 */
export type MagicItem = $Result.DefaultSelection<Prisma.$MagicItemPayload>
/**
 * Model Weapon
 * 
 */
export type Weapon = $Result.DefaultSelection<Prisma.$WeaponPayload>
/**
 * Model Armor
 * 
 */
export type Armor = $Result.DefaultSelection<Prisma.$ArmorPayload>
/**
 * Model PersSkill
 * 
 */
export type PersSkill = $Result.DefaultSelection<Prisma.$PersSkillPayload>
/**
 * Model PersWeapon
 * 
 */
export type PersWeapon = $Result.DefaultSelection<Prisma.$PersWeaponPayload>
/**
 * Model PersArmor
 * 
 */
export type PersArmor = $Result.DefaultSelection<Prisma.$PersArmorPayload>
/**
 * Model PersMagicItem
 * 
 */
export type PersMagicItem = $Result.DefaultSelection<Prisma.$PersMagicItemPayload>
/**
 * Model EquipmentPack
 * 
 */
export type EquipmentPack = $Result.DefaultSelection<Prisma.$EquipmentPackPayload>
/**
 * Model ClassStartingEquipmentOption
 * 
 */
export type ClassStartingEquipmentOption = $Result.DefaultSelection<Prisma.$ClassStartingEquipmentOptionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Ability: {
  STR: 'STR',
  DEX: 'DEX',
  CON: 'CON',
  INT: 'INT',
  WIS: 'WIS',
  CHA: 'CHA'
};

export type Ability = (typeof Ability)[keyof typeof Ability]


export const SpellcastingType: {
  NONE: 'NONE',
  FULL: 'FULL',
  HALF: 'HALF',
  THIRD: 'THIRD',
  PACT: 'PACT'
};

export type SpellcastingType = (typeof SpellcastingType)[keyof typeof SpellcastingType]


export const Size: {
  TINY: 'TINY',
  SMALL: 'SMALL',
  MEDIUM: 'MEDIUM',
  LARGE: 'LARGE',
  HUGE: 'HUGE',
  GARGANTUAN: 'GARGANTUAN'
};

export type Size = (typeof Size)[keyof typeof Size]


export const SpellSchool: {
  ABJURATION: 'ABJURATION',
  CONJURATION: 'CONJURATION',
  DIVINATION: 'DIVINATION',
  ENCHANTMENT: 'ENCHANTMENT',
  EVOCATION: 'EVOCATION',
  ILLUSION: 'ILLUSION',
  NECROMANCY: 'NECROMANCY',
  TRANSMUTATION: 'TRANSMUTATION'
};

export type SpellSchool = (typeof SpellSchool)[keyof typeof SpellSchool]


export const ArmorCategory: {
  PADDED: 'PADDED',
  LEATHER: 'LEATHER',
  STUDDED_LEATHER: 'STUDDED_LEATHER',
  HIDE: 'HIDE',
  CHAIN_SHIRT: 'CHAIN_SHIRT',
  SCALE_MAIL: 'SCALE_MAIL',
  BREASTPLATE: 'BREASTPLATE',
  HALF_PLATE: 'HALF_PLATE',
  RING_MAIL: 'RING_MAIL',
  CHAIN_MAIL: 'CHAIN_MAIL',
  SPLINT: 'SPLINT',
  PLATE: 'PLATE',
  SHIELD: 'SHIELD',
  HOMEBREW: 'HOMEBREW'
};

export type ArmorCategory = (typeof ArmorCategory)[keyof typeof ArmorCategory]


export const ArmorType: {
  LIGHT: 'LIGHT',
  MEDIUM: 'MEDIUM',
  HEAVY: 'HEAVY',
  SHIELD: 'SHIELD'
};

export type ArmorType = (typeof ArmorType)[keyof typeof ArmorType]


export const SkillProficiencyType: {
  NONE: 'NONE',
  HALF: 'HALF',
  PROFICIENT: 'PROFICIENT',
  EXPERTISE: 'EXPERTISE'
};

export type SkillProficiencyType = (typeof SkillProficiencyType)[keyof typeof SkillProficiencyType]


export const RestType: {
  SHORT_REST: 'SHORT_REST',
  LONG_REST: 'LONG_REST',
  DAY: 'DAY'
};

export type RestType = (typeof RestType)[keyof typeof RestType]


export const Language: {
  COMMON: 'COMMON',
  DWARVISH: 'DWARVISH',
  ELVISH: 'ELVISH',
  GIANT: 'GIANT',
  GNOMISH: 'GNOMISH',
  GOBLIN: 'GOBLIN',
  HALFLING: 'HALFLING',
  ORC: 'ORC',
  ABYSSAL: 'ABYSSAL',
  CELESTIAL: 'CELESTIAL',
  DRACONIC: 'DRACONIC',
  DEEP_SPEECH: 'DEEP_SPEECH',
  INFERNAL: 'INFERNAL',
  PRIMORDIAL: 'PRIMORDIAL',
  SYLVAN: 'SYLVAN',
  UNDERCOMMON: 'UNDERCOMMON',
  DRUIDIC: 'DRUIDIC',
  THIEVES_CANT: 'THIEVES_CANT',
  COMMON_SIGN_LANGUAGE: 'COMMON_SIGN_LANGUAGE'
};

export type Language = (typeof Language)[keyof typeof Language]


export const DamageType: {
  BLUDGEONING: 'BLUDGEONING',
  PIERCING: 'PIERCING',
  SLASHING: 'SLASHING',
  ACID: 'ACID',
  COLD: 'COLD',
  FIRE: 'FIRE',
  LIGHTNING: 'LIGHTNING',
  THUNDER: 'THUNDER',
  FORCE: 'FORCE',
  NECROTIC: 'NECROTIC',
  POISON: 'POISON',
  PSYCHIC: 'PSYCHIC',
  RADIANT: 'RADIANT'
};

export type DamageType = (typeof DamageType)[keyof typeof DamageType]


export const EquipmentPackCategory: {
  BURGLARS_PACK: 'BURGLARS_PACK',
  DIPLOMATS_PACK: 'DIPLOMATS_PACK',
  DUNGEONEERS_PACK: 'DUNGEONEERS_PACK',
  ENTERTAINERS_PACK: 'ENTERTAINERS_PACK',
  EXPLORERS_PACK: 'EXPLORERS_PACK',
  PRIESTS_PACK: 'PRIESTS_PACK',
  SCHOLARS_PACK: 'SCHOLARS_PACK',
  COMPONENT_POUCH: 'COMPONENT_POUCH',
  SPELLBOOK: 'SPELLBOOK',
  HOMEBREW: 'HOMEBREW'
};

export type EquipmentPackCategory = (typeof EquipmentPackCategory)[keyof typeof EquipmentPackCategory]


export const Source: {
  PHB: 'PHB',
  DMG: 'DMG',
  MM: 'MM',
  XGTE: 'XGTE',
  TCOE: 'TCOE',
  FTOD: 'FTOD',
  EGTW: 'EGTW',
  SCAG: 'SCAG',
  GGTR: 'GGTR',
  AI: 'AI',
  IDROTF: 'IDROTF',
  SPELLJAMMER: 'SPELLJAMMER',
  COS: 'COS',
  BGDIA: 'BGDIA',
  VGTM: 'VGTM',
  MTOF: 'MTOF',
  MPMM: 'MPMM',
  BPGOTG: 'BPGOTG',
  VRGTR: 'VRGTR',
  MOOT: 'MOOT',
  SACOC: 'SACOC',
  WBTW: 'WBTW',
  EBERRON: 'EBERRON',
  DRAGONLANCE: 'DRAGONLANCE',
  PHB_2024: 'PHB_2024',
  DMG_2024: 'DMG_2024',
  MM_2024: 'MM_2024'
};

export type Source = (typeof Source)[keyof typeof Source]


export const WeaponType: {
  SIMPLE_WEAPON: 'SIMPLE_WEAPON',
  MARTIAL_WEAPON: 'MARTIAL_WEAPON',
  FIREARMS: 'FIREARMS'
};

export type WeaponType = (typeof WeaponType)[keyof typeof WeaponType]


export const WeaponCategory: {
  CLUB: 'CLUB',
  DAGGER: 'DAGGER',
  GREATCLUB: 'GREATCLUB',
  HANDAXE: 'HANDAXE',
  JAVELIN: 'JAVELIN',
  LIGHT_HAMMER: 'LIGHT_HAMMER',
  MACE: 'MACE',
  QUARTERSTAFF: 'QUARTERSTAFF',
  SICKLE: 'SICKLE',
  SPEAR: 'SPEAR',
  UNARMED_STRIKE: 'UNARMED_STRIKE',
  LIGHT_CROSSBOW: 'LIGHT_CROSSBOW',
  DART: 'DART',
  SHORTBOW: 'SHORTBOW',
  SLING: 'SLING',
  BATTLEAXE: 'BATTLEAXE',
  FLAIL: 'FLAIL',
  GLAIVE: 'GLAIVE',
  GREATAXE: 'GREATAXE',
  GREATSWORD: 'GREATSWORD',
  HALBERD: 'HALBERD',
  LANCE: 'LANCE',
  LONGSWORD: 'LONGSWORD',
  MAUL: 'MAUL',
  MORNINGSTAR: 'MORNINGSTAR',
  PIKE: 'PIKE',
  RAPIER: 'RAPIER',
  SCIMITAR: 'SCIMITAR',
  SHORTSWORD: 'SHORTSWORD',
  TRIDENT: 'TRIDENT',
  WAR_PICK: 'WAR_PICK',
  WARHAMMER: 'WARHAMMER',
  WHIP: 'WHIP',
  BLOWGUN: 'BLOWGUN',
  HAND_CROSSBOW: 'HAND_CROSSBOW',
  HEAVY_CROSSBOW: 'HEAVY_CROSSBOW',
  LONGBOW: 'LONGBOW',
  NET: 'NET',
  HOMEBREW: 'HOMEBREW'
};

export type WeaponCategory = (typeof WeaponCategory)[keyof typeof WeaponCategory]


export const Skills: {
  ATHLETICS: 'ATHLETICS',
  ACROBATICS: 'ACROBATICS',
  SLEIGHT_OF_HAND: 'SLEIGHT_OF_HAND',
  STEALTH: 'STEALTH',
  ARCANA: 'ARCANA',
  HISTORY: 'HISTORY',
  INVESTIGATION: 'INVESTIGATION',
  NATURE: 'NATURE',
  RELIGION: 'RELIGION',
  ANIMAL_HANDLING: 'ANIMAL_HANDLING',
  INSIGHT: 'INSIGHT',
  MEDICINE: 'MEDICINE',
  PERCEPTION: 'PERCEPTION',
  SURVIVAL: 'SURVIVAL',
  DECEPTION: 'DECEPTION',
  INTIMIDATION: 'INTIMIDATION',
  PERFORMANCE: 'PERFORMANCE',
  PERSUASION: 'PERSUASION'
};

export type Skills = (typeof Skills)[keyof typeof Skills]


export const BackgroundCategory: {
  ACOLYTE: 'ACOLYTE',
  CHARLATAN: 'CHARLATAN',
  CRIMINAL: 'CRIMINAL',
  ENTERTAINER: 'ENTERTAINER',
  FOLK_HERO: 'FOLK_HERO',
  GUILD_ARTISAN: 'GUILD_ARTISAN',
  GUILD_MERCHANT: 'GUILD_MERCHANT',
  HERMIT: 'HERMIT',
  NOBLE: 'NOBLE',
  OUTLANDER: 'OUTLANDER',
  SAGE: 'SAGE',
  SAILOR: 'SAILOR',
  SOLDIER: 'SOLDIER',
  URCHIN: 'URCHIN',
  GLADIATOR: 'GLADIATOR',
  KNIGHT: 'KNIGHT',
  PIRATE: 'PIRATE',
  SPY: 'SPY',
  ANTHROPOLOGIST: 'ANTHROPOLOGIST',
  ARCHAEOLOGIST: 'ARCHAEOLOGIST',
  CITY_WATCH: 'CITY_WATCH',
  CLAN_CRAFTER: 'CLAN_CRAFTER',
  CLOISTERED_SCHOLAR: 'CLOISTERED_SCHOLAR',
  COURTIER: 'COURTIER',
  FACTION_AGENT: 'FACTION_AGENT',
  FAR_TRAVELER: 'FAR_TRAVELER',
  INHERITOR: 'INHERITOR',
  INVESTIGATOR: 'INVESTIGATOR',
  KNIGHT_OF_THE_ORDER: 'KNIGHT_OF_THE_ORDER',
  MERCENARY_VETERAN: 'MERCENARY_VETERAN',
  URBAN_BOUNTY_HUNTER: 'URBAN_BOUNTY_HUNTER',
  UTHGARDT_TRIBE_MEMBER: 'UTHGARDT_TRIBE_MEMBER',
  WATERDHAVIAN_NOBLE: 'WATERDHAVIAN_NOBLE',
  FISHER: 'FISHER',
  SHIPWRIGHT: 'SHIPWRIGHT',
  SMUGGLER: 'SMUGGLER',
  MARINE: 'MARINE',
  AZORIUS_FUNCTIONARY: 'AZORIUS_FUNCTIONARY',
  BOROS_LEGIONNAIRE: 'BOROS_LEGIONNAIRE',
  DIMIR_OPERATIVE: 'DIMIR_OPERATIVE',
  GOLGARI_AGENT: 'GOLGARI_AGENT',
  GRUUL_ANARCH: 'GRUUL_ANARCH',
  IZZET_ENGINEER: 'IZZET_ENGINEER',
  ORZHOV_REPRESENTATIVE: 'ORZHOV_REPRESENTATIVE',
  RAKDOS_CULTIST: 'RAKDOS_CULTIST',
  SELESNYA_INITIATE: 'SELESNYA_INITIATE',
  SIMIC_SCIENTIST: 'SIMIC_SCIENTIST',
  GRINNER: 'GRINNER',
  VOLSTRUCKER_AGENT: 'VOLSTRUCKER_AGENT',
  ATHLETE: 'ATHLETE',
  LOREHOLD_STUDENT: 'LOREHOLD_STUDENT',
  PRISMARI_STUDENT: 'PRISMARI_STUDENT',
  QUANDRIX_STUDENT: 'QUANDRIX_STUDENT',
  SILVERQUILL_STUDENT: 'SILVERQUILL_STUDENT',
  WITHERBLOOM_STUDENT: 'WITHERBLOOM_STUDENT',
  ASTRAL_DRIFTER: 'ASTRAL_DRIFTER',
  FACELESS: 'FACELESS',
  FAILED_MERCHANT: 'FAILED_MERCHANT',
  FEYLOST: 'FEYLOST',
  GAMBLER: 'GAMBLER',
  HAUNTED_ONE: 'HAUNTED_ONE',
  PLAINTIFF: 'PLAINTIFF',
  RIVAL_INTERN: 'RIVAL_INTERN',
  WILDSPACER: 'WILDSPACER',
  WITCHLIGHT_HAND: 'WITCHLIGHT_HAND',
  KNIGHT_OF_SOLAMNIA: 'KNIGHT_OF_SOLAMNIA',
  MAGE_OF_HIGH_SORCERY: 'MAGE_OF_HIGH_SORCERY',
  HOUSE_AGENT: 'HOUSE_AGENT',
  ARTISAN_2024: 'ARTISAN_2024',
  CHARLATAN_2024: 'CHARLATAN_2024',
  CRIMINAL_2024: 'CRIMINAL_2024',
  ENTERTAINER_2024: 'ENTERTAINER_2024',
  FARMER_2024: 'FARMER_2024',
  GUARD_2024: 'GUARD_2024',
  GUIDE_2024: 'GUIDE_2024',
  HERMIT_2024: 'HERMIT_2024',
  MERCHANT_2024: 'MERCHANT_2024',
  NOBLE_2024: 'NOBLE_2024',
  SAGE_2024: 'SAGE_2024',
  SAILOR_2024: 'SAILOR_2024',
  SCRIBE_2024: 'SCRIBE_2024',
  SOLDIER_2024: 'SOLDIER_2024',
  WAYFARER_2024: 'WAYFARER_2024',
  CUSTOM: 'CUSTOM'
};

export type BackgroundCategory = (typeof BackgroundCategory)[keyof typeof BackgroundCategory]


export const FeatureDisplayType: {
  STANDARD: 'STANDARD',
  RESOURCE: 'RESOURCE',
  ACTION: 'ACTION',
  PASSIVE: 'PASSIVE',
  TOGGLE: 'TOGGLE'
};

export type FeatureDisplayType = (typeof FeatureDisplayType)[keyof typeof FeatureDisplayType]


export const WeaponProperty: {
  FINESSE: 'FINESSE',
  VERSATILE: 'VERSATILE',
  LIGHT: 'LIGHT',
  HEAVY: 'HEAVY',
  REACH: 'REACH',
  TWO_HANDED: 'TWO_HANDED',
  THROWN: 'THROWN',
  AMMUNITION: 'AMMUNITION',
  LOADING: 'LOADING',
  SPECIAL: 'SPECIAL',
  MAGIC_WEAPON: 'MAGIC_WEAPON'
};

export type WeaponProperty = (typeof WeaponProperty)[keyof typeof WeaponProperty]


export const MagicItemType: {
  WEAPON: 'WEAPON',
  ARMOR: 'ARMOR',
  WONDROUS_ITEM: 'WONDROUS_ITEM',
  POTION: 'POTION',
  SCROLL: 'SCROLL',
  RING: 'RING',
  WAND: 'WAND',
  ROD: 'ROD',
  STAFF: 'STAFF'
};

export type MagicItemType = (typeof MagicItemType)[keyof typeof MagicItemType]


export const ItemRarity: {
  COMMON: 'COMMON',
  UNCOMMON: 'UNCOMMON',
  RARE: 'RARE',
  VERY_RARE: 'VERY_RARE',
  LEGENDARY: 'LEGENDARY',
  ARTIFACT: 'ARTIFACT'
};

export type ItemRarity = (typeof ItemRarity)[keyof typeof ItemRarity]


export const FeatCategory: {
  ORIGIN: 'ORIGIN',
  GENERAL: 'GENERAL',
  FIGHTING_STYLE: 'FIGHTING_STYLE',
  EPIC_BOON: 'EPIC_BOON'
};

export type FeatCategory = (typeof FeatCategory)[keyof typeof FeatCategory]


export const ToolCategory: {
  ARTISAN_TOOLS: 'ARTISAN_TOOLS',
  DICE_SET: 'DICE_SET',
  DRAGONCHESS_SET: 'DRAGONCHESS_SET',
  PLAYING_CARD_SET: 'PLAYING_CARD_SET',
  THREE_DRAGON_ANTE_SET: 'THREE_DRAGON_ANTE_SET',
  GAMING_SET: 'GAMING_SET',
  MUSICAL_INSTRUMENT: 'MUSICAL_INSTRUMENT',
  DISGUISE_KIT: 'DISGUISE_KIT',
  FORGERY_KIT: 'FORGERY_KIT',
  HERBALISM_KIT: 'HERBALISM_KIT',
  NAVIGATORS_TOOLS: 'NAVIGATORS_TOOLS',
  POISONERS_KIT: 'POISONERS_KIT',
  THIEVES_TOOLS: 'THIEVES_TOOLS',
  JEWELERS_TOOLS: 'JEWELERS_TOOLS',
  FISHING_TACKLE: 'FISHING_TACKLE',
  CARTOGRAPHERS_TOOLS: 'CARTOGRAPHERS_TOOLS',
  VEHICLES_LAND: 'VEHICLES_LAND',
  VEHICLES_WATER: 'VEHICLES_WATER'
};

export type ToolCategory = (typeof ToolCategory)[keyof typeof ToolCategory]


export const Races: {
  AASIMAR_2024: 'AASIMAR_2024',
  DRAGONBORN_2024: 'DRAGONBORN_2024',
  DWARF_2024: 'DWARF_2024',
  ELF_2024: 'ELF_2024',
  GNOME_2024: 'GNOME_2024',
  GOLIATH_2024: 'GOLIATH_2024',
  HALFLING_2024: 'HALFLING_2024',
  HUMAN_2024: 'HUMAN_2024',
  ORC_2024: 'ORC_2024',
  TIEFLING_2024: 'TIEFLING_2024',
  DRAGONBORN_2014: 'DRAGONBORN_2014',
  DWARF_2014: 'DWARF_2014',
  ELF_2014: 'ELF_2014',
  GNOME_2014: 'GNOME_2014',
  HALF_ELF_2014: 'HALF_ELF_2014',
  HALF_ORC_2014: 'HALF_ORC_2014',
  HALFLING_2014: 'HALFLING_2014',
  HUMAN_2014: 'HUMAN_2014',
  TIEFLING_2014: 'TIEFLING_2014',
  CENTAUR_GGTR: 'CENTAUR_GGTR',
  LOXODON_GGTR: 'LOXODON_GGTR',
  MINOTAUR_GGTR: 'MINOTAUR_GGTR',
  SIMIC_HYBRID_GGTR: 'SIMIC_HYBRID_GGTR',
  VEDALKEN_GGTR: 'VEDALKEN_GGTR',
  VERDAN_AI: 'VERDAN_AI',
  KALASHTAR_AI: 'KALASHTAR_AI',
  WARFORGED_AI: 'WARFORGED_AI',
  LEONIN_MOOT: 'LEONIN_MOOT',
  SATYR_MOOT: 'SATYR_MOOT',
  DHAMPIR_VRGTR: 'DHAMPIR_VRGTR',
  HEXBLOOD_VRGTR: 'HEXBLOOD_VRGTR',
  REBORN_VRGTR: 'REBORN_VRGTR',
  OWLIN_SACOC: 'OWLIN_SACOC',
  AARAKOCRA_MPMM: 'AARAKOCRA_MPMM',
  AASIMAR_MPMM: 'AASIMAR_MPMM',
  BUGBEAR_MPMM: 'BUGBEAR_MPMM',
  CENTAUR_MPMM: 'CENTAUR_MPMM',
  CHANGELING_MPMM: 'CHANGELING_MPMM',
  DEEP_GNOME_MPMM: 'DEEP_GNOME_MPMM',
  DUERGAR_MPMM: 'DUERGAR_MPMM',
  ELADRIN_MPMM: 'ELADRIN_MPMM',
  FAIRY_MPMM: 'FAIRY_MPMM',
  FIRBOLG_MPMM: 'FIRBOLG_MPMM',
  GENASI_AIR_MPMM: 'GENASI_AIR_MPMM',
  GENASI_EARTH_MPMM: 'GENASI_EARTH_MPMM',
  GENASI_FIRE_MPMM: 'GENASI_FIRE_MPMM',
  GENASI_WATER_MPMM: 'GENASI_WATER_MPMM',
  GITHYANKI_MPMM: 'GITHYANKI_MPMM',
  GITHZERAI_MPMM: 'GITHZERAI_MPMM',
  GOBLIN_MPMM: 'GOBLIN_MPMM',
  GOLIATH_MPMM: 'GOLIATH_MPMM',
  HARENGON_MPMM: 'HARENGON_MPMM',
  HOBGOBLIN_MPMM: 'HOBGOBLIN_MPMM',
  KENKU_MPMM: 'KENKU_MPMM',
  KOBOLD_MPMM: 'KOBOLD_MPMM',
  LIZARDFOLK_MPMM: 'LIZARDFOLK_MPMM',
  MINOTAUR_MPMM: 'MINOTAUR_MPMM',
  ORC_MPMM: 'ORC_MPMM',
  SATYR_MPMM: 'SATYR_MPMM',
  SEA_ELF_MPMM: 'SEA_ELF_MPMM',
  SHADAR_KAI_MPMM: 'SHADAR_KAI_MPMM',
  SHIFTER_MPMM: 'SHIFTER_MPMM',
  TABAXI_MPMM: 'TABAXI_MPMM',
  TORTLE_MPMM: 'TORTLE_MPMM',
  TRITON_MPMM: 'TRITON_MPMM',
  YUAN_TI_MPMM: 'YUAN_TI_MPMM',
  ASTRAL_ELF_SPELLJAMMER: 'ASTRAL_ELF_SPELLJAMMER',
  AUTOGNOME_SPELLJAMMER: 'AUTOGNOME_SPELLJAMMER',
  GIFF_SPELLJAMMER: 'GIFF_SPELLJAMMER',
  HADOZEE_SPELLJAMMER: 'HADOZEE_SPELLJAMMER',
  PLASMOID_SPELLJAMMER: 'PLASMOID_SPELLJAMMER',
  THRI_KREEN_SPELLJAMMER: 'THRI_KREEN_SPELLJAMMER',
  KENDER_DRAGONLANCE: 'KENDER_DRAGONLANCE',
  GRUNG: 'GRUNG',
  LOCATHAH: 'LOCATHAH'
};

export type Races = (typeof Races)[keyof typeof Races]


export const Subraces: {
  DWARF_HILL_2014: 'DWARF_HILL_2014',
  DWARF_MOUNTAIN_2014: 'DWARF_MOUNTAIN_2014',
  DWARF_DUERGAR_GRAY_SCAG: 'DWARF_DUERGAR_GRAY_SCAG',
  ELF_HIGH_2014: 'ELF_HIGH_2014',
  ELF_WOOD_2014: 'ELF_WOOD_2014',
  ELF_DARK_DROW_2014: 'ELF_DARK_DROW_2014',
  ELF_ELADRIN_DMG: 'ELF_ELADRIN_DMG',
  ELF_ELADRIN_MPMM: 'ELF_ELADRIN_MPMM',
  ELF_SHADAR_KAI_MPMM: 'ELF_SHADAR_KAI_MPMM',
  ELF_SEA_MTOF: 'ELF_SEA_MTOF',
  ELF_PALLID_EGTW: 'ELF_PALLID_EGTW',
  GNOME_FOREST_2014: 'GNOME_FOREST_2014',
  GNOME_ROCK_2014: 'GNOME_ROCK_2014',
  GNOME_DEEP_SCAG: 'GNOME_DEEP_SCAG',
  HALFLING_LIGHTFOOT_2014: 'HALFLING_LIGHTFOOT_2014',
  HALFLING_STOUT_2014: 'HALFLING_STOUT_2014',
  HALFLING_GHOSTWISE_SCAG: 'HALFLING_GHOSTWISE_SCAG',
  TIEFLING_ASMODEUS: 'TIEFLING_ASMODEUS',
  TIEFLING_BAALZEBUL: 'TIEFLING_BAALZEBUL',
  TIEFLING_DISPATER: 'TIEFLING_DISPATER',
  TIEFLING_FIERNA: 'TIEFLING_FIERNA',
  TIEFLING_GLASYA: 'TIEFLING_GLASYA',
  TIEFLING_LEVISTUS: 'TIEFLING_LEVISTUS',
  TIEFLING_MAMMON: 'TIEFLING_MAMMON',
  TIEFLING_MEPHISTOPHELES: 'TIEFLING_MEPHISTOPHELES',
  TIEFLING_ZARIEL: 'TIEFLING_ZARIEL',
  DRAGONBORN_BLACK: 'DRAGONBORN_BLACK',
  DRAGONBORN_BLUE: 'DRAGONBORN_BLUE',
  DRAGONBORN_BRASS: 'DRAGONBORN_BRASS',
  DRAGONBORN_BRONZE: 'DRAGONBORN_BRONZE',
  DRAGONBORN_COPPER: 'DRAGONBORN_COPPER',
  DRAGONBORN_GOLD: 'DRAGONBORN_GOLD',
  DRAGONBORN_GREEN: 'DRAGONBORN_GREEN',
  DRAGONBORN_RED: 'DRAGONBORN_RED',
  DRAGONBORN_SILVER: 'DRAGONBORN_SILVER',
  DRAGONBORN_WHITE: 'DRAGONBORN_WHITE',
  DRAGONBORN_CHROMATIC: 'DRAGONBORN_CHROMATIC',
  DRAGONBORN_METALLIC: 'DRAGONBORN_METALLIC',
  DRAGONBORN_GEM: 'DRAGONBORN_GEM',
  DRAGONBORN_DRACONBLOOD: 'DRAGONBORN_DRACONBLOOD',
  DRAGONBORN_RAVENITE: 'DRAGONBORN_RAVENITE',
  GENASI_AIR: 'GENASI_AIR',
  GENASI_EARTH: 'GENASI_EARTH',
  GENASI_FIRE: 'GENASI_FIRE',
  GENASI_WATER: 'GENASI_WATER',
  AASIMAR_PROTECTOR: 'AASIMAR_PROTECTOR',
  AASIMAR_SCOURGE: 'AASIMAR_SCOURGE',
  AASIMAR_FALLEN: 'AASIMAR_FALLEN',
  GITH_GITHYANKI: 'GITH_GITHYANKI',
  GITH_GITHZERAI: 'GITH_GITHZERAI',
  SHIFTER_BEASTHIDE: 'SHIFTER_BEASTHIDE',
  SHIFTER_LONGTOOTH: 'SHIFTER_LONGTOOTH',
  SHIFTER_SWIFTSTRIDE: 'SHIFTER_SWIFTSTRIDE',
  SHIFTER_WILDHUNT: 'SHIFTER_WILDHUNT'
};

export type Subraces = (typeof Subraces)[keyof typeof Subraces]


export const Variants: {
  HALF_ELF_VARIANT_HIGH_DESCENT_SCAG: 'HALF_ELF_VARIANT_HIGH_DESCENT_SCAG',
  HALF_ELF_VARIANT_WOOD_DESCENT_SCAG: 'HALF_ELF_VARIANT_WOOD_DESCENT_SCAG',
  HALF_ELF_VARIANT_DROW_DESCENT_SCAG: 'HALF_ELF_VARIANT_DROW_DESCENT_SCAG',
  HALF_ELF_VARIANT_AQUATIC_DESCENT_SCAG: 'HALF_ELF_VARIANT_AQUATIC_DESCENT_SCAG',
  HALF_ELF_VARIANT: 'HALF_ELF_VARIANT',
  TIEFLING_VARIANT_FERAL_SCAG: 'TIEFLING_VARIANT_FERAL_SCAG',
  TIEFLING_VARIANT_DEVILS_TONGUE_SCAG: 'TIEFLING_VARIANT_DEVILS_TONGUE_SCAG',
  TIEFLING_VARIANT_HELLFIRE_SCAG: 'TIEFLING_VARIANT_HELLFIRE_SCAG',
  TIEFLING_VARIANT_WINGED_SCAG: 'TIEFLING_VARIANT_WINGED_SCAG'
};

export type Variants = (typeof Variants)[keyof typeof Variants]


export const DragonbornTypes: {
  BLACK: 'BLACK',
  BLUE: 'BLUE',
  BRASS: 'BRASS',
  BRONZE: 'BRONZE',
  COPPER: 'COPPER',
  GOLD: 'GOLD',
  GREEN: 'GREEN',
  RED: 'RED',
  SILVER: 'SILVER',
  WHITE: 'WHITE',
  AMETHYST: 'AMETHYST',
  CRYSTAL: 'CRYSTAL',
  EMETALD: 'EMETALD',
  SAPPHIRE: 'SAPPHIRE',
  TOPAZ: 'TOPAZ'
};

export type DragonbornTypes = (typeof DragonbornTypes)[keyof typeof DragonbornTypes]


export const AOEShapes: {
  CONE: 'CONE',
  CUBE: 'CUBE',
  CYLINDER: 'CYLINDER',
  EMANATION: 'EMANATION',
  LINE: 'LINE',
  SPHERE: 'SPHERE'
};

export type AOEShapes = (typeof AOEShapes)[keyof typeof AOEShapes]

}

export type Ability = $Enums.Ability

export const Ability: typeof $Enums.Ability

export type SpellcastingType = $Enums.SpellcastingType

export const SpellcastingType: typeof $Enums.SpellcastingType

export type Size = $Enums.Size

export const Size: typeof $Enums.Size

export type SpellSchool = $Enums.SpellSchool

export const SpellSchool: typeof $Enums.SpellSchool

export type ArmorCategory = $Enums.ArmorCategory

export const ArmorCategory: typeof $Enums.ArmorCategory

export type ArmorType = $Enums.ArmorType

export const ArmorType: typeof $Enums.ArmorType

export type SkillProficiencyType = $Enums.SkillProficiencyType

export const SkillProficiencyType: typeof $Enums.SkillProficiencyType

export type RestType = $Enums.RestType

export const RestType: typeof $Enums.RestType

export type Language = $Enums.Language

export const Language: typeof $Enums.Language

export type DamageType = $Enums.DamageType

export const DamageType: typeof $Enums.DamageType

export type EquipmentPackCategory = $Enums.EquipmentPackCategory

export const EquipmentPackCategory: typeof $Enums.EquipmentPackCategory

export type Source = $Enums.Source

export const Source: typeof $Enums.Source

export type WeaponType = $Enums.WeaponType

export const WeaponType: typeof $Enums.WeaponType

export type WeaponCategory = $Enums.WeaponCategory

export const WeaponCategory: typeof $Enums.WeaponCategory

export type Skills = $Enums.Skills

export const Skills: typeof $Enums.Skills

export type BackgroundCategory = $Enums.BackgroundCategory

export const BackgroundCategory: typeof $Enums.BackgroundCategory

export type FeatureDisplayType = $Enums.FeatureDisplayType

export const FeatureDisplayType: typeof $Enums.FeatureDisplayType

export type WeaponProperty = $Enums.WeaponProperty

export const WeaponProperty: typeof $Enums.WeaponProperty

export type MagicItemType = $Enums.MagicItemType

export const MagicItemType: typeof $Enums.MagicItemType

export type ItemRarity = $Enums.ItemRarity

export const ItemRarity: typeof $Enums.ItemRarity

export type FeatCategory = $Enums.FeatCategory

export const FeatCategory: typeof $Enums.FeatCategory

export type ToolCategory = $Enums.ToolCategory

export const ToolCategory: typeof $Enums.ToolCategory

export type Races = $Enums.Races

export const Races: typeof $Enums.Races

export type Subraces = $Enums.Subraces

export const Subraces: typeof $Enums.Subraces

export type Variants = $Enums.Variants

export const Variants: typeof $Enums.Variants

export type DragonbornTypes = $Enums.DragonbornTypes

export const DragonbornTypes: typeof $Enums.DragonbornTypes

export type AOEShapes = $Enums.AOEShapes

export const AOEShapes: typeof $Enums.AOEShapes

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Characters
 * const characters = await prisma.character.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Characters
   * const characters = await prisma.character.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.character`: Exposes CRUD operations for the **Character** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.character.findMany()
    * ```
    */
  get character(): Prisma.CharacterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.characterSpells`: Exposes CRUD operations for the **CharacterSpells** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterSpells
    * const characterSpells = await prisma.characterSpells.findMany()
    * ```
    */
  get characterSpells(): Prisma.CharacterSpellsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creature`: Exposes CRUD operations for the **Creature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Creatures
    * const creatures = await prisma.creature.findMany()
    * ```
    */
  get creature(): Prisma.CreatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spell`: Exposes CRUD operations for the **Spell** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spells
    * const spells = await prisma.spell.findMany()
    * ```
    */
  get spell(): Prisma.SpellDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spellClasses`: Exposes CRUD operations for the **SpellClasses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellClasses
    * const spellClasses = await prisma.spellClasses.findMany()
    * ```
    */
  get spellClasses(): Prisma.SpellClassesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spellRaces`: Exposes CRUD operations for the **SpellRaces** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellRaces
    * const spellRaces = await prisma.spellRaces.findMany()
    * ```
    */
  get spellRaces(): Prisma.SpellRacesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spellbook`: Exposes CRUD operations for the **Spellbook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spellbooks
    * const spellbooks = await prisma.spellbook.findMany()
    * ```
    */
  get spellbook(): Prisma.SpellbookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spellbookSpells`: Exposes CRUD operations for the **SpellbookSpells** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellbookSpells
    * const spellbookSpells = await prisma.spellbookSpells.findMany()
    * ```
    */
  get spellbookSpells(): Prisma.SpellbookSpellsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subclass`: Exposes CRUD operations for the **Subclass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subclasses
    * const subclasses = await prisma.subclass.findMany()
    * ```
    */
  get subclass(): Prisma.SubclassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pers`: Exposes CRUD operations for the **Pers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pers
    * const pers = await prisma.pers.findMany()
    * ```
    */
  get pers(): Prisma.PersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.persMulticlass`: Exposes CRUD operations for the **PersMulticlass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersMulticlasses
    * const persMulticlasses = await prisma.persMulticlass.findMany()
    * ```
    */
  get persMulticlass(): Prisma.PersMulticlassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.persFeature`: Exposes CRUD operations for the **PersFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersFeatures
    * const persFeatures = await prisma.persFeature.findMany()
    * ```
    */
  get persFeature(): Prisma.PersFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feature`: Exposes CRUD operations for the **Feature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Features
    * const features = await prisma.feature.findMany()
    * ```
    */
  get feature(): Prisma.FeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classFeature`: Exposes CRUD operations for the **ClassFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassFeatures
    * const classFeatures = await prisma.classFeature.findMany()
    * ```
    */
  get classFeature(): Prisma.ClassFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subclassFeature`: Exposes CRUD operations for the **SubclassFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubclassFeatures
    * const subclassFeatures = await prisma.subclassFeature.findMany()
    * ```
    */
  get subclassFeature(): Prisma.SubclassFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raceTrait`: Exposes CRUD operations for the **RaceTrait** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaceTraits
    * const raceTraits = await prisma.raceTrait.findMany()
    * ```
    */
  get raceTrait(): Prisma.RaceTraitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subraceTrait`: Exposes CRUD operations for the **SubraceTrait** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubraceTraits
    * const subraceTraits = await prisma.subraceTrait.findMany()
    * ```
    */
  get subraceTrait(): Prisma.SubraceTraitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raceVariantTrait`: Exposes CRUD operations for the **RaceVariantTrait** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaceVariantTraits
    * const raceVariantTraits = await prisma.raceVariantTrait.findMany()
    * ```
    */
  get raceVariantTrait(): Prisma.RaceVariantTraitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raceChoiceOptionTrait`: Exposes CRUD operations for the **RaceChoiceOptionTrait** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaceChoiceOptionTraits
    * const raceChoiceOptionTraits = await prisma.raceChoiceOptionTrait.findMany()
    * ```
    */
  get raceChoiceOptionTrait(): Prisma.RaceChoiceOptionTraitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featFeature`: Exposes CRUD operations for the **FeatFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatFeatures
    * const featFeatures = await prisma.featFeature.findMany()
    * ```
    */
  get featFeature(): Prisma.FeatFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.magicItemFeature`: Exposes CRUD operations for the **MagicItemFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MagicItemFeatures
    * const magicItemFeatures = await prisma.magicItemFeature.findMany()
    * ```
    */
  get magicItemFeature(): Prisma.MagicItemFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.race`: Exposes CRUD operations for the **Race** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Races
    * const races = await prisma.race.findMany()
    * ```
    */
  get race(): Prisma.RaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subrace`: Exposes CRUD operations for the **Subrace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subraces
    * const subraces = await prisma.subrace.findMany()
    * ```
    */
  get subrace(): Prisma.SubraceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raceVariant`: Exposes CRUD operations for the **RaceVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaceVariants
    * const raceVariants = await prisma.raceVariant.findMany()
    * ```
    */
  get raceVariant(): Prisma.RaceVariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raceChoiceOption`: Exposes CRUD operations for the **RaceChoiceOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaceChoiceOptions
    * const raceChoiceOptions = await prisma.raceChoiceOption.findMany()
    * ```
    */
  get raceChoiceOption(): Prisma.RaceChoiceOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.background`: Exposes CRUD operations for the **Background** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Backgrounds
    * const backgrounds = await prisma.background.findMany()
    * ```
    */
  get background(): Prisma.BackgroundDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feat`: Exposes CRUD operations for the **Feat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feats
    * const feats = await prisma.feat.findMany()
    * ```
    */
  get feat(): Prisma.FeatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featAbilityBoost`: Exposes CRUD operations for the **FeatAbilityBoost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatAbilityBoosts
    * const featAbilityBoosts = await prisma.featAbilityBoost.findMany()
    * ```
    */
  get featAbilityBoost(): Prisma.FeatAbilityBoostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.persFeat`: Exposes CRUD operations for the **PersFeat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersFeats
    * const persFeats = await prisma.persFeat.findMany()
    * ```
    */
  get persFeat(): Prisma.PersFeatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.magicItem`: Exposes CRUD operations for the **MagicItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MagicItems
    * const magicItems = await prisma.magicItem.findMany()
    * ```
    */
  get magicItem(): Prisma.MagicItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weapon`: Exposes CRUD operations for the **Weapon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weapons
    * const weapons = await prisma.weapon.findMany()
    * ```
    */
  get weapon(): Prisma.WeaponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.armor`: Exposes CRUD operations for the **Armor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Armors
    * const armors = await prisma.armor.findMany()
    * ```
    */
  get armor(): Prisma.ArmorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.persSkill`: Exposes CRUD operations for the **PersSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersSkills
    * const persSkills = await prisma.persSkill.findMany()
    * ```
    */
  get persSkill(): Prisma.PersSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.persWeapon`: Exposes CRUD operations for the **PersWeapon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersWeapons
    * const persWeapons = await prisma.persWeapon.findMany()
    * ```
    */
  get persWeapon(): Prisma.PersWeaponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.persArmor`: Exposes CRUD operations for the **PersArmor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersArmors
    * const persArmors = await prisma.persArmor.findMany()
    * ```
    */
  get persArmor(): Prisma.PersArmorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.persMagicItem`: Exposes CRUD operations for the **PersMagicItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersMagicItems
    * const persMagicItems = await prisma.persMagicItem.findMany()
    * ```
    */
  get persMagicItem(): Prisma.PersMagicItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipmentPack`: Exposes CRUD operations for the **EquipmentPack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentPacks
    * const equipmentPacks = await prisma.equipmentPack.findMany()
    * ```
    */
  get equipmentPack(): Prisma.EquipmentPackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classStartingEquipmentOption`: Exposes CRUD operations for the **ClassStartingEquipmentOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassStartingEquipmentOptions
    * const classStartingEquipmentOptions = await prisma.classStartingEquipmentOption.findMany()
    * ```
    */
  get classStartingEquipmentOption(): Prisma.ClassStartingEquipmentOptionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.3
   * Query Engine version: bb420e667c1820a8c05a38023385f6cc7ef8e83a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Character: 'Character',
    CharacterSpells: 'CharacterSpells',
    Creature: 'Creature',
    Spell: 'Spell',
    SpellClasses: 'SpellClasses',
    SpellRaces: 'SpellRaces',
    Spellbook: 'Spellbook',
    SpellbookSpells: 'SpellbookSpells',
    User: 'User',
    Class: 'Class',
    Subclass: 'Subclass',
    Pers: 'Pers',
    PersMulticlass: 'PersMulticlass',
    PersFeature: 'PersFeature',
    Feature: 'Feature',
    ClassFeature: 'ClassFeature',
    SubclassFeature: 'SubclassFeature',
    RaceTrait: 'RaceTrait',
    SubraceTrait: 'SubraceTrait',
    RaceVariantTrait: 'RaceVariantTrait',
    RaceChoiceOptionTrait: 'RaceChoiceOptionTrait',
    FeatFeature: 'FeatFeature',
    MagicItemFeature: 'MagicItemFeature',
    Race: 'Race',
    Subrace: 'Subrace',
    RaceVariant: 'RaceVariant',
    RaceChoiceOption: 'RaceChoiceOption',
    Background: 'Background',
    Feat: 'Feat',
    FeatAbilityBoost: 'FeatAbilityBoost',
    PersFeat: 'PersFeat',
    MagicItem: 'MagicItem',
    Weapon: 'Weapon',
    Armor: 'Armor',
    PersSkill: 'PersSkill',
    PersWeapon: 'PersWeapon',
    PersArmor: 'PersArmor',
    PersMagicItem: 'PersMagicItem',
    EquipmentPack: 'EquipmentPack',
    ClassStartingEquipmentOption: 'ClassStartingEquipmentOption'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "character" | "characterSpells" | "creature" | "spell" | "spellClasses" | "spellRaces" | "spellbook" | "spellbookSpells" | "user" | "class" | "subclass" | "pers" | "persMulticlass" | "persFeature" | "feature" | "classFeature" | "subclassFeature" | "raceTrait" | "subraceTrait" | "raceVariantTrait" | "raceChoiceOptionTrait" | "featFeature" | "magicItemFeature" | "race" | "subrace" | "raceVariant" | "raceChoiceOption" | "background" | "feat" | "featAbilityBoost" | "persFeat" | "magicItem" | "weapon" | "armor" | "persSkill" | "persWeapon" | "persArmor" | "persMagicItem" | "equipmentPack" | "classStartingEquipmentOption"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Character: {
        payload: Prisma.$CharacterPayload<ExtArgs>
        fields: Prisma.CharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findFirst: {
            args: Prisma.CharacterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findMany: {
            args: Prisma.CharacterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          create: {
            args: Prisma.CharacterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          createMany: {
            args: Prisma.CharacterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          delete: {
            args: Prisma.CharacterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          update: {
            args: Prisma.CharacterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          deleteMany: {
            args: Prisma.CharacterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          upsert: {
            args: Prisma.CharacterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          aggregate: {
            args: Prisma.CharacterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter>
          }
          groupBy: {
            args: Prisma.CharacterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterCountAggregateOutputType> | number
          }
        }
      }
      CharacterSpells: {
        payload: Prisma.$CharacterSpellsPayload<ExtArgs>
        fields: Prisma.CharacterSpellsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterSpellsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterSpellsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellsPayload>
          }
          findFirst: {
            args: Prisma.CharacterSpellsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterSpellsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellsPayload>
          }
          findMany: {
            args: Prisma.CharacterSpellsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellsPayload>[]
          }
          create: {
            args: Prisma.CharacterSpellsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellsPayload>
          }
          createMany: {
            args: Prisma.CharacterSpellsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterSpellsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellsPayload>[]
          }
          delete: {
            args: Prisma.CharacterSpellsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellsPayload>
          }
          update: {
            args: Prisma.CharacterSpellsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellsPayload>
          }
          deleteMany: {
            args: Prisma.CharacterSpellsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterSpellsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacterSpellsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellsPayload>[]
          }
          upsert: {
            args: Prisma.CharacterSpellsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellsPayload>
          }
          aggregate: {
            args: Prisma.CharacterSpellsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterSpells>
          }
          groupBy: {
            args: Prisma.CharacterSpellsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterSpellsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterSpellsCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterSpellsCountAggregateOutputType> | number
          }
        }
      }
      Creature: {
        payload: Prisma.$CreaturePayload<ExtArgs>
        fields: Prisma.CreatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          findFirst: {
            args: Prisma.CreatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          findMany: {
            args: Prisma.CreatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>[]
          }
          create: {
            args: Prisma.CreatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          createMany: {
            args: Prisma.CreatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>[]
          }
          delete: {
            args: Prisma.CreatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          update: {
            args: Prisma.CreatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          deleteMany: {
            args: Prisma.CreatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>[]
          }
          upsert: {
            args: Prisma.CreatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          aggregate: {
            args: Prisma.CreatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreature>
          }
          groupBy: {
            args: Prisma.CreatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatureCountArgs<ExtArgs>
            result: $Utils.Optional<CreatureCountAggregateOutputType> | number
          }
        }
      }
      Spell: {
        payload: Prisma.$SpellPayload<ExtArgs>
        fields: Prisma.SpellFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          findFirst: {
            args: Prisma.SpellFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          findMany: {
            args: Prisma.SpellFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>[]
          }
          create: {
            args: Prisma.SpellCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          createMany: {
            args: Prisma.SpellCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpellCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>[]
          }
          delete: {
            args: Prisma.SpellDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          update: {
            args: Prisma.SpellUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          deleteMany: {
            args: Prisma.SpellDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpellUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpellUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>[]
          }
          upsert: {
            args: Prisma.SpellUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          aggregate: {
            args: Prisma.SpellAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpell>
          }
          groupBy: {
            args: Prisma.SpellGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpellGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellCountArgs<ExtArgs>
            result: $Utils.Optional<SpellCountAggregateOutputType> | number
          }
        }
      }
      SpellClasses: {
        payload: Prisma.$SpellClassesPayload<ExtArgs>
        fields: Prisma.SpellClassesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellClassesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellClassesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellClassesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellClassesPayload>
          }
          findFirst: {
            args: Prisma.SpellClassesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellClassesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellClassesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellClassesPayload>
          }
          findMany: {
            args: Prisma.SpellClassesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellClassesPayload>[]
          }
          create: {
            args: Prisma.SpellClassesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellClassesPayload>
          }
          createMany: {
            args: Prisma.SpellClassesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpellClassesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellClassesPayload>[]
          }
          delete: {
            args: Prisma.SpellClassesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellClassesPayload>
          }
          update: {
            args: Prisma.SpellClassesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellClassesPayload>
          }
          deleteMany: {
            args: Prisma.SpellClassesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpellClassesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpellClassesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellClassesPayload>[]
          }
          upsert: {
            args: Prisma.SpellClassesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellClassesPayload>
          }
          aggregate: {
            args: Prisma.SpellClassesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpellClasses>
          }
          groupBy: {
            args: Prisma.SpellClassesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpellClassesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellClassesCountArgs<ExtArgs>
            result: $Utils.Optional<SpellClassesCountAggregateOutputType> | number
          }
        }
      }
      SpellRaces: {
        payload: Prisma.$SpellRacesPayload<ExtArgs>
        fields: Prisma.SpellRacesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellRacesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellRacesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellRacesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellRacesPayload>
          }
          findFirst: {
            args: Prisma.SpellRacesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellRacesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellRacesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellRacesPayload>
          }
          findMany: {
            args: Prisma.SpellRacesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellRacesPayload>[]
          }
          create: {
            args: Prisma.SpellRacesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellRacesPayload>
          }
          createMany: {
            args: Prisma.SpellRacesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpellRacesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellRacesPayload>[]
          }
          delete: {
            args: Prisma.SpellRacesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellRacesPayload>
          }
          update: {
            args: Prisma.SpellRacesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellRacesPayload>
          }
          deleteMany: {
            args: Prisma.SpellRacesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpellRacesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpellRacesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellRacesPayload>[]
          }
          upsert: {
            args: Prisma.SpellRacesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellRacesPayload>
          }
          aggregate: {
            args: Prisma.SpellRacesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpellRaces>
          }
          groupBy: {
            args: Prisma.SpellRacesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpellRacesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellRacesCountArgs<ExtArgs>
            result: $Utils.Optional<SpellRacesCountAggregateOutputType> | number
          }
        }
      }
      Spellbook: {
        payload: Prisma.$SpellbookPayload<ExtArgs>
        fields: Prisma.SpellbookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellbookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellbookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookPayload>
          }
          findFirst: {
            args: Prisma.SpellbookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellbookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookPayload>
          }
          findMany: {
            args: Prisma.SpellbookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookPayload>[]
          }
          create: {
            args: Prisma.SpellbookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookPayload>
          }
          createMany: {
            args: Prisma.SpellbookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpellbookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookPayload>[]
          }
          delete: {
            args: Prisma.SpellbookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookPayload>
          }
          update: {
            args: Prisma.SpellbookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookPayload>
          }
          deleteMany: {
            args: Prisma.SpellbookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpellbookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpellbookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookPayload>[]
          }
          upsert: {
            args: Prisma.SpellbookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookPayload>
          }
          aggregate: {
            args: Prisma.SpellbookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpellbook>
          }
          groupBy: {
            args: Prisma.SpellbookGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpellbookGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellbookCountArgs<ExtArgs>
            result: $Utils.Optional<SpellbookCountAggregateOutputType> | number
          }
        }
      }
      SpellbookSpells: {
        payload: Prisma.$SpellbookSpellsPayload<ExtArgs>
        fields: Prisma.SpellbookSpellsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellbookSpellsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookSpellsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellbookSpellsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookSpellsPayload>
          }
          findFirst: {
            args: Prisma.SpellbookSpellsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookSpellsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellbookSpellsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookSpellsPayload>
          }
          findMany: {
            args: Prisma.SpellbookSpellsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookSpellsPayload>[]
          }
          create: {
            args: Prisma.SpellbookSpellsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookSpellsPayload>
          }
          createMany: {
            args: Prisma.SpellbookSpellsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpellbookSpellsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookSpellsPayload>[]
          }
          delete: {
            args: Prisma.SpellbookSpellsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookSpellsPayload>
          }
          update: {
            args: Prisma.SpellbookSpellsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookSpellsPayload>
          }
          deleteMany: {
            args: Prisma.SpellbookSpellsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpellbookSpellsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpellbookSpellsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookSpellsPayload>[]
          }
          upsert: {
            args: Prisma.SpellbookSpellsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpellbookSpellsPayload>
          }
          aggregate: {
            args: Prisma.SpellbookSpellsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpellbookSpells>
          }
          groupBy: {
            args: Prisma.SpellbookSpellsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpellbookSpellsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellbookSpellsCountArgs<ExtArgs>
            result: $Utils.Optional<SpellbookSpellsCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      Subclass: {
        payload: Prisma.$SubclassPayload<ExtArgs>
        fields: Prisma.SubclassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubclassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubclassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassPayload>
          }
          findFirst: {
            args: Prisma.SubclassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubclassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassPayload>
          }
          findMany: {
            args: Prisma.SubclassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassPayload>[]
          }
          create: {
            args: Prisma.SubclassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassPayload>
          }
          createMany: {
            args: Prisma.SubclassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubclassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassPayload>[]
          }
          delete: {
            args: Prisma.SubclassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassPayload>
          }
          update: {
            args: Prisma.SubclassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassPayload>
          }
          deleteMany: {
            args: Prisma.SubclassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubclassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubclassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassPayload>[]
          }
          upsert: {
            args: Prisma.SubclassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassPayload>
          }
          aggregate: {
            args: Prisma.SubclassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubclass>
          }
          groupBy: {
            args: Prisma.SubclassGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubclassGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubclassCountArgs<ExtArgs>
            result: $Utils.Optional<SubclassCountAggregateOutputType> | number
          }
        }
      }
      Pers: {
        payload: Prisma.$PersPayload<ExtArgs>
        fields: Prisma.PersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersPayload>
          }
          findFirst: {
            args: Prisma.PersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersPayload>
          }
          findMany: {
            args: Prisma.PersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersPayload>[]
          }
          create: {
            args: Prisma.PersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersPayload>
          }
          createMany: {
            args: Prisma.PersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersPayload>[]
          }
          delete: {
            args: Prisma.PersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersPayload>
          }
          update: {
            args: Prisma.PersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersPayload>
          }
          deleteMany: {
            args: Prisma.PersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersPayload>[]
          }
          upsert: {
            args: Prisma.PersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersPayload>
          }
          aggregate: {
            args: Prisma.PersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePers>
          }
          groupBy: {
            args: Prisma.PersGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersCountArgs<ExtArgs>
            result: $Utils.Optional<PersCountAggregateOutputType> | number
          }
        }
      }
      PersMulticlass: {
        payload: Prisma.$PersMulticlassPayload<ExtArgs>
        fields: Prisma.PersMulticlassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersMulticlassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMulticlassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersMulticlassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMulticlassPayload>
          }
          findFirst: {
            args: Prisma.PersMulticlassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMulticlassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersMulticlassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMulticlassPayload>
          }
          findMany: {
            args: Prisma.PersMulticlassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMulticlassPayload>[]
          }
          create: {
            args: Prisma.PersMulticlassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMulticlassPayload>
          }
          createMany: {
            args: Prisma.PersMulticlassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersMulticlassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMulticlassPayload>[]
          }
          delete: {
            args: Prisma.PersMulticlassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMulticlassPayload>
          }
          update: {
            args: Prisma.PersMulticlassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMulticlassPayload>
          }
          deleteMany: {
            args: Prisma.PersMulticlassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersMulticlassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersMulticlassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMulticlassPayload>[]
          }
          upsert: {
            args: Prisma.PersMulticlassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMulticlassPayload>
          }
          aggregate: {
            args: Prisma.PersMulticlassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersMulticlass>
          }
          groupBy: {
            args: Prisma.PersMulticlassGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersMulticlassGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersMulticlassCountArgs<ExtArgs>
            result: $Utils.Optional<PersMulticlassCountAggregateOutputType> | number
          }
        }
      }
      PersFeature: {
        payload: Prisma.$PersFeaturePayload<ExtArgs>
        fields: Prisma.PersFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeaturePayload>
          }
          findFirst: {
            args: Prisma.PersFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeaturePayload>
          }
          findMany: {
            args: Prisma.PersFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeaturePayload>[]
          }
          create: {
            args: Prisma.PersFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeaturePayload>
          }
          createMany: {
            args: Prisma.PersFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeaturePayload>[]
          }
          delete: {
            args: Prisma.PersFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeaturePayload>
          }
          update: {
            args: Prisma.PersFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeaturePayload>
          }
          deleteMany: {
            args: Prisma.PersFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeaturePayload>[]
          }
          upsert: {
            args: Prisma.PersFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeaturePayload>
          }
          aggregate: {
            args: Prisma.PersFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersFeature>
          }
          groupBy: {
            args: Prisma.PersFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<PersFeatureCountAggregateOutputType> | number
          }
        }
      }
      Feature: {
        payload: Prisma.$FeaturePayload<ExtArgs>
        fields: Prisma.FeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          findFirst: {
            args: Prisma.FeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          findMany: {
            args: Prisma.FeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          create: {
            args: Prisma.FeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          createMany: {
            args: Prisma.FeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          delete: {
            args: Prisma.FeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          update: {
            args: Prisma.FeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          deleteMany: {
            args: Prisma.FeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          upsert: {
            args: Prisma.FeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          aggregate: {
            args: Prisma.FeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeature>
          }
          groupBy: {
            args: Prisma.FeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureCountAggregateOutputType> | number
          }
        }
      }
      ClassFeature: {
        payload: Prisma.$ClassFeaturePayload<ExtArgs>
        fields: Prisma.ClassFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>
          }
          findFirst: {
            args: Prisma.ClassFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>
          }
          findMany: {
            args: Prisma.ClassFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>[]
          }
          create: {
            args: Prisma.ClassFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>
          }
          createMany: {
            args: Prisma.ClassFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>[]
          }
          delete: {
            args: Prisma.ClassFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>
          }
          update: {
            args: Prisma.ClassFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>
          }
          deleteMany: {
            args: Prisma.ClassFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>[]
          }
          upsert: {
            args: Prisma.ClassFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassFeaturePayload>
          }
          aggregate: {
            args: Prisma.ClassFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassFeature>
          }
          groupBy: {
            args: Prisma.ClassFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<ClassFeatureCountAggregateOutputType> | number
          }
        }
      }
      SubclassFeature: {
        payload: Prisma.$SubclassFeaturePayload<ExtArgs>
        fields: Prisma.SubclassFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubclassFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubclassFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassFeaturePayload>
          }
          findFirst: {
            args: Prisma.SubclassFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubclassFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassFeaturePayload>
          }
          findMany: {
            args: Prisma.SubclassFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassFeaturePayload>[]
          }
          create: {
            args: Prisma.SubclassFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassFeaturePayload>
          }
          createMany: {
            args: Prisma.SubclassFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubclassFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassFeaturePayload>[]
          }
          delete: {
            args: Prisma.SubclassFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassFeaturePayload>
          }
          update: {
            args: Prisma.SubclassFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassFeaturePayload>
          }
          deleteMany: {
            args: Prisma.SubclassFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubclassFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubclassFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassFeaturePayload>[]
          }
          upsert: {
            args: Prisma.SubclassFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubclassFeaturePayload>
          }
          aggregate: {
            args: Prisma.SubclassFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubclassFeature>
          }
          groupBy: {
            args: Prisma.SubclassFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubclassFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubclassFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<SubclassFeatureCountAggregateOutputType> | number
          }
        }
      }
      RaceTrait: {
        payload: Prisma.$RaceTraitPayload<ExtArgs>
        fields: Prisma.RaceTraitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceTraitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceTraitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>
          }
          findFirst: {
            args: Prisma.RaceTraitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceTraitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>
          }
          findMany: {
            args: Prisma.RaceTraitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>[]
          }
          create: {
            args: Prisma.RaceTraitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>
          }
          createMany: {
            args: Prisma.RaceTraitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaceTraitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>[]
          }
          delete: {
            args: Prisma.RaceTraitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>
          }
          update: {
            args: Prisma.RaceTraitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>
          }
          deleteMany: {
            args: Prisma.RaceTraitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceTraitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaceTraitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>[]
          }
          upsert: {
            args: Prisma.RaceTraitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceTraitPayload>
          }
          aggregate: {
            args: Prisma.RaceTraitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaceTrait>
          }
          groupBy: {
            args: Prisma.RaceTraitGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceTraitGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceTraitCountArgs<ExtArgs>
            result: $Utils.Optional<RaceTraitCountAggregateOutputType> | number
          }
        }
      }
      SubraceTrait: {
        payload: Prisma.$SubraceTraitPayload<ExtArgs>
        fields: Prisma.SubraceTraitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubraceTraitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubraceTraitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubraceTraitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubraceTraitPayload>
          }
          findFirst: {
            args: Prisma.SubraceTraitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubraceTraitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubraceTraitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubraceTraitPayload>
          }
          findMany: {
            args: Prisma.SubraceTraitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubraceTraitPayload>[]
          }
          create: {
            args: Prisma.SubraceTraitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubraceTraitPayload>
          }
          createMany: {
            args: Prisma.SubraceTraitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubraceTraitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubraceTraitPayload>[]
          }
          delete: {
            args: Prisma.SubraceTraitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubraceTraitPayload>
          }
          update: {
            args: Prisma.SubraceTraitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubraceTraitPayload>
          }
          deleteMany: {
            args: Prisma.SubraceTraitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubraceTraitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubraceTraitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubraceTraitPayload>[]
          }
          upsert: {
            args: Prisma.SubraceTraitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubraceTraitPayload>
          }
          aggregate: {
            args: Prisma.SubraceTraitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubraceTrait>
          }
          groupBy: {
            args: Prisma.SubraceTraitGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubraceTraitGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubraceTraitCountArgs<ExtArgs>
            result: $Utils.Optional<SubraceTraitCountAggregateOutputType> | number
          }
        }
      }
      RaceVariantTrait: {
        payload: Prisma.$RaceVariantTraitPayload<ExtArgs>
        fields: Prisma.RaceVariantTraitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceVariantTraitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantTraitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceVariantTraitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantTraitPayload>
          }
          findFirst: {
            args: Prisma.RaceVariantTraitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantTraitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceVariantTraitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantTraitPayload>
          }
          findMany: {
            args: Prisma.RaceVariantTraitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantTraitPayload>[]
          }
          create: {
            args: Prisma.RaceVariantTraitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantTraitPayload>
          }
          createMany: {
            args: Prisma.RaceVariantTraitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaceVariantTraitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantTraitPayload>[]
          }
          delete: {
            args: Prisma.RaceVariantTraitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantTraitPayload>
          }
          update: {
            args: Prisma.RaceVariantTraitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantTraitPayload>
          }
          deleteMany: {
            args: Prisma.RaceVariantTraitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceVariantTraitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaceVariantTraitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantTraitPayload>[]
          }
          upsert: {
            args: Prisma.RaceVariantTraitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantTraitPayload>
          }
          aggregate: {
            args: Prisma.RaceVariantTraitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaceVariantTrait>
          }
          groupBy: {
            args: Prisma.RaceVariantTraitGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceVariantTraitGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceVariantTraitCountArgs<ExtArgs>
            result: $Utils.Optional<RaceVariantTraitCountAggregateOutputType> | number
          }
        }
      }
      RaceChoiceOptionTrait: {
        payload: Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>
        fields: Prisma.RaceChoiceOptionTraitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceChoiceOptionTraitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionTraitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceChoiceOptionTraitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionTraitPayload>
          }
          findFirst: {
            args: Prisma.RaceChoiceOptionTraitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionTraitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceChoiceOptionTraitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionTraitPayload>
          }
          findMany: {
            args: Prisma.RaceChoiceOptionTraitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionTraitPayload>[]
          }
          create: {
            args: Prisma.RaceChoiceOptionTraitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionTraitPayload>
          }
          createMany: {
            args: Prisma.RaceChoiceOptionTraitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaceChoiceOptionTraitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionTraitPayload>[]
          }
          delete: {
            args: Prisma.RaceChoiceOptionTraitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionTraitPayload>
          }
          update: {
            args: Prisma.RaceChoiceOptionTraitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionTraitPayload>
          }
          deleteMany: {
            args: Prisma.RaceChoiceOptionTraitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceChoiceOptionTraitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaceChoiceOptionTraitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionTraitPayload>[]
          }
          upsert: {
            args: Prisma.RaceChoiceOptionTraitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionTraitPayload>
          }
          aggregate: {
            args: Prisma.RaceChoiceOptionTraitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaceChoiceOptionTrait>
          }
          groupBy: {
            args: Prisma.RaceChoiceOptionTraitGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceChoiceOptionTraitGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceChoiceOptionTraitCountArgs<ExtArgs>
            result: $Utils.Optional<RaceChoiceOptionTraitCountAggregateOutputType> | number
          }
        }
      }
      FeatFeature: {
        payload: Prisma.$FeatFeaturePayload<ExtArgs>
        fields: Prisma.FeatFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatFeaturePayload>
          }
          findFirst: {
            args: Prisma.FeatFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatFeaturePayload>
          }
          findMany: {
            args: Prisma.FeatFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatFeaturePayload>[]
          }
          create: {
            args: Prisma.FeatFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatFeaturePayload>
          }
          createMany: {
            args: Prisma.FeatFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatFeaturePayload>[]
          }
          delete: {
            args: Prisma.FeatFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatFeaturePayload>
          }
          update: {
            args: Prisma.FeatFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatFeaturePayload>
          }
          deleteMany: {
            args: Prisma.FeatFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatFeaturePayload>[]
          }
          upsert: {
            args: Prisma.FeatFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatFeaturePayload>
          }
          aggregate: {
            args: Prisma.FeatFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatFeature>
          }
          groupBy: {
            args: Prisma.FeatFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<FeatFeatureCountAggregateOutputType> | number
          }
        }
      }
      MagicItemFeature: {
        payload: Prisma.$MagicItemFeaturePayload<ExtArgs>
        fields: Prisma.MagicItemFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MagicItemFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MagicItemFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemFeaturePayload>
          }
          findFirst: {
            args: Prisma.MagicItemFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MagicItemFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemFeaturePayload>
          }
          findMany: {
            args: Prisma.MagicItemFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemFeaturePayload>[]
          }
          create: {
            args: Prisma.MagicItemFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemFeaturePayload>
          }
          createMany: {
            args: Prisma.MagicItemFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MagicItemFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemFeaturePayload>[]
          }
          delete: {
            args: Prisma.MagicItemFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemFeaturePayload>
          }
          update: {
            args: Prisma.MagicItemFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemFeaturePayload>
          }
          deleteMany: {
            args: Prisma.MagicItemFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MagicItemFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MagicItemFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemFeaturePayload>[]
          }
          upsert: {
            args: Prisma.MagicItemFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemFeaturePayload>
          }
          aggregate: {
            args: Prisma.MagicItemFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMagicItemFeature>
          }
          groupBy: {
            args: Prisma.MagicItemFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<MagicItemFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.MagicItemFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<MagicItemFeatureCountAggregateOutputType> | number
          }
        }
      }
      Race: {
        payload: Prisma.$RacePayload<ExtArgs>
        fields: Prisma.RaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          findFirst: {
            args: Prisma.RaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          findMany: {
            args: Prisma.RaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          create: {
            args: Prisma.RaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          createMany: {
            args: Prisma.RaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          delete: {
            args: Prisma.RaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          update: {
            args: Prisma.RaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          deleteMany: {
            args: Prisma.RaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          upsert: {
            args: Prisma.RaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          aggregate: {
            args: Prisma.RaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRace>
          }
          groupBy: {
            args: Prisma.RaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceCountArgs<ExtArgs>
            result: $Utils.Optional<RaceCountAggregateOutputType> | number
          }
        }
      }
      Subrace: {
        payload: Prisma.$SubracePayload<ExtArgs>
        fields: Prisma.SubraceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubraceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubracePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubraceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubracePayload>
          }
          findFirst: {
            args: Prisma.SubraceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubracePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubraceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubracePayload>
          }
          findMany: {
            args: Prisma.SubraceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubracePayload>[]
          }
          create: {
            args: Prisma.SubraceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubracePayload>
          }
          createMany: {
            args: Prisma.SubraceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubraceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubracePayload>[]
          }
          delete: {
            args: Prisma.SubraceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubracePayload>
          }
          update: {
            args: Prisma.SubraceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubracePayload>
          }
          deleteMany: {
            args: Prisma.SubraceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubraceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubraceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubracePayload>[]
          }
          upsert: {
            args: Prisma.SubraceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubracePayload>
          }
          aggregate: {
            args: Prisma.SubraceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubrace>
          }
          groupBy: {
            args: Prisma.SubraceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubraceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubraceCountArgs<ExtArgs>
            result: $Utils.Optional<SubraceCountAggregateOutputType> | number
          }
        }
      }
      RaceVariant: {
        payload: Prisma.$RaceVariantPayload<ExtArgs>
        fields: Prisma.RaceVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantPayload>
          }
          findFirst: {
            args: Prisma.RaceVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantPayload>
          }
          findMany: {
            args: Prisma.RaceVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantPayload>[]
          }
          create: {
            args: Prisma.RaceVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantPayload>
          }
          createMany: {
            args: Prisma.RaceVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaceVariantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantPayload>[]
          }
          delete: {
            args: Prisma.RaceVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantPayload>
          }
          update: {
            args: Prisma.RaceVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantPayload>
          }
          deleteMany: {
            args: Prisma.RaceVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaceVariantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantPayload>[]
          }
          upsert: {
            args: Prisma.RaceVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceVariantPayload>
          }
          aggregate: {
            args: Prisma.RaceVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaceVariant>
          }
          groupBy: {
            args: Prisma.RaceVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceVariantCountArgs<ExtArgs>
            result: $Utils.Optional<RaceVariantCountAggregateOutputType> | number
          }
        }
      }
      RaceChoiceOption: {
        payload: Prisma.$RaceChoiceOptionPayload<ExtArgs>
        fields: Prisma.RaceChoiceOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceChoiceOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceChoiceOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionPayload>
          }
          findFirst: {
            args: Prisma.RaceChoiceOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceChoiceOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionPayload>
          }
          findMany: {
            args: Prisma.RaceChoiceOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionPayload>[]
          }
          create: {
            args: Prisma.RaceChoiceOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionPayload>
          }
          createMany: {
            args: Prisma.RaceChoiceOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaceChoiceOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionPayload>[]
          }
          delete: {
            args: Prisma.RaceChoiceOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionPayload>
          }
          update: {
            args: Prisma.RaceChoiceOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionPayload>
          }
          deleteMany: {
            args: Prisma.RaceChoiceOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceChoiceOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaceChoiceOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionPayload>[]
          }
          upsert: {
            args: Prisma.RaceChoiceOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceChoiceOptionPayload>
          }
          aggregate: {
            args: Prisma.RaceChoiceOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaceChoiceOption>
          }
          groupBy: {
            args: Prisma.RaceChoiceOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceChoiceOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceChoiceOptionCountArgs<ExtArgs>
            result: $Utils.Optional<RaceChoiceOptionCountAggregateOutputType> | number
          }
        }
      }
      Background: {
        payload: Prisma.$BackgroundPayload<ExtArgs>
        fields: Prisma.BackgroundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BackgroundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BackgroundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          findFirst: {
            args: Prisma.BackgroundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BackgroundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          findMany: {
            args: Prisma.BackgroundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>[]
          }
          create: {
            args: Prisma.BackgroundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          createMany: {
            args: Prisma.BackgroundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BackgroundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>[]
          }
          delete: {
            args: Prisma.BackgroundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          update: {
            args: Prisma.BackgroundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          deleteMany: {
            args: Prisma.BackgroundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BackgroundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BackgroundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>[]
          }
          upsert: {
            args: Prisma.BackgroundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          aggregate: {
            args: Prisma.BackgroundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBackground>
          }
          groupBy: {
            args: Prisma.BackgroundGroupByArgs<ExtArgs>
            result: $Utils.Optional<BackgroundGroupByOutputType>[]
          }
          count: {
            args: Prisma.BackgroundCountArgs<ExtArgs>
            result: $Utils.Optional<BackgroundCountAggregateOutputType> | number
          }
        }
      }
      Feat: {
        payload: Prisma.$FeatPayload<ExtArgs>
        fields: Prisma.FeatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>
          }
          findFirst: {
            args: Prisma.FeatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>
          }
          findMany: {
            args: Prisma.FeatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>[]
          }
          create: {
            args: Prisma.FeatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>
          }
          createMany: {
            args: Prisma.FeatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>[]
          }
          delete: {
            args: Prisma.FeatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>
          }
          update: {
            args: Prisma.FeatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>
          }
          deleteMany: {
            args: Prisma.FeatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>[]
          }
          upsert: {
            args: Prisma.FeatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatPayload>
          }
          aggregate: {
            args: Prisma.FeatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeat>
          }
          groupBy: {
            args: Prisma.FeatGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatCountArgs<ExtArgs>
            result: $Utils.Optional<FeatCountAggregateOutputType> | number
          }
        }
      }
      FeatAbilityBoost: {
        payload: Prisma.$FeatAbilityBoostPayload<ExtArgs>
        fields: Prisma.FeatAbilityBoostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatAbilityBoostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatAbilityBoostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatAbilityBoostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatAbilityBoostPayload>
          }
          findFirst: {
            args: Prisma.FeatAbilityBoostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatAbilityBoostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatAbilityBoostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatAbilityBoostPayload>
          }
          findMany: {
            args: Prisma.FeatAbilityBoostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatAbilityBoostPayload>[]
          }
          create: {
            args: Prisma.FeatAbilityBoostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatAbilityBoostPayload>
          }
          createMany: {
            args: Prisma.FeatAbilityBoostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatAbilityBoostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatAbilityBoostPayload>[]
          }
          delete: {
            args: Prisma.FeatAbilityBoostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatAbilityBoostPayload>
          }
          update: {
            args: Prisma.FeatAbilityBoostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatAbilityBoostPayload>
          }
          deleteMany: {
            args: Prisma.FeatAbilityBoostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatAbilityBoostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatAbilityBoostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatAbilityBoostPayload>[]
          }
          upsert: {
            args: Prisma.FeatAbilityBoostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatAbilityBoostPayload>
          }
          aggregate: {
            args: Prisma.FeatAbilityBoostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatAbilityBoost>
          }
          groupBy: {
            args: Prisma.FeatAbilityBoostGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatAbilityBoostGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatAbilityBoostCountArgs<ExtArgs>
            result: $Utils.Optional<FeatAbilityBoostCountAggregateOutputType> | number
          }
        }
      }
      PersFeat: {
        payload: Prisma.$PersFeatPayload<ExtArgs>
        fields: Prisma.PersFeatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersFeatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersFeatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeatPayload>
          }
          findFirst: {
            args: Prisma.PersFeatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersFeatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeatPayload>
          }
          findMany: {
            args: Prisma.PersFeatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeatPayload>[]
          }
          create: {
            args: Prisma.PersFeatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeatPayload>
          }
          createMany: {
            args: Prisma.PersFeatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersFeatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeatPayload>[]
          }
          delete: {
            args: Prisma.PersFeatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeatPayload>
          }
          update: {
            args: Prisma.PersFeatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeatPayload>
          }
          deleteMany: {
            args: Prisma.PersFeatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersFeatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersFeatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeatPayload>[]
          }
          upsert: {
            args: Prisma.PersFeatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersFeatPayload>
          }
          aggregate: {
            args: Prisma.PersFeatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersFeat>
          }
          groupBy: {
            args: Prisma.PersFeatGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersFeatGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersFeatCountArgs<ExtArgs>
            result: $Utils.Optional<PersFeatCountAggregateOutputType> | number
          }
        }
      }
      MagicItem: {
        payload: Prisma.$MagicItemPayload<ExtArgs>
        fields: Prisma.MagicItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MagicItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MagicItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>
          }
          findFirst: {
            args: Prisma.MagicItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MagicItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>
          }
          findMany: {
            args: Prisma.MagicItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>[]
          }
          create: {
            args: Prisma.MagicItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>
          }
          createMany: {
            args: Prisma.MagicItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MagicItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>[]
          }
          delete: {
            args: Prisma.MagicItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>
          }
          update: {
            args: Prisma.MagicItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>
          }
          deleteMany: {
            args: Prisma.MagicItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MagicItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MagicItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>[]
          }
          upsert: {
            args: Prisma.MagicItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>
          }
          aggregate: {
            args: Prisma.MagicItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMagicItem>
          }
          groupBy: {
            args: Prisma.MagicItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MagicItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MagicItemCountArgs<ExtArgs>
            result: $Utils.Optional<MagicItemCountAggregateOutputType> | number
          }
        }
      }
      Weapon: {
        payload: Prisma.$WeaponPayload<ExtArgs>
        fields: Prisma.WeaponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeaponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeaponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          findFirst: {
            args: Prisma.WeaponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeaponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          findMany: {
            args: Prisma.WeaponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>[]
          }
          create: {
            args: Prisma.WeaponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          createMany: {
            args: Prisma.WeaponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeaponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>[]
          }
          delete: {
            args: Prisma.WeaponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          update: {
            args: Prisma.WeaponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          deleteMany: {
            args: Prisma.WeaponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeaponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeaponUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>[]
          }
          upsert: {
            args: Prisma.WeaponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          aggregate: {
            args: Prisma.WeaponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeapon>
          }
          groupBy: {
            args: Prisma.WeaponGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeaponGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeaponCountArgs<ExtArgs>
            result: $Utils.Optional<WeaponCountAggregateOutputType> | number
          }
        }
      }
      Armor: {
        payload: Prisma.$ArmorPayload<ExtArgs>
        fields: Prisma.ArmorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArmorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArmorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>
          }
          findFirst: {
            args: Prisma.ArmorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArmorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>
          }
          findMany: {
            args: Prisma.ArmorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>[]
          }
          create: {
            args: Prisma.ArmorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>
          }
          createMany: {
            args: Prisma.ArmorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArmorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>[]
          }
          delete: {
            args: Prisma.ArmorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>
          }
          update: {
            args: Prisma.ArmorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>
          }
          deleteMany: {
            args: Prisma.ArmorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArmorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArmorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>[]
          }
          upsert: {
            args: Prisma.ArmorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmorPayload>
          }
          aggregate: {
            args: Prisma.ArmorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArmor>
          }
          groupBy: {
            args: Prisma.ArmorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArmorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArmorCountArgs<ExtArgs>
            result: $Utils.Optional<ArmorCountAggregateOutputType> | number
          }
        }
      }
      PersSkill: {
        payload: Prisma.$PersSkillPayload<ExtArgs>
        fields: Prisma.PersSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersSkillPayload>
          }
          findFirst: {
            args: Prisma.PersSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersSkillPayload>
          }
          findMany: {
            args: Prisma.PersSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersSkillPayload>[]
          }
          create: {
            args: Prisma.PersSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersSkillPayload>
          }
          createMany: {
            args: Prisma.PersSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersSkillPayload>[]
          }
          delete: {
            args: Prisma.PersSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersSkillPayload>
          }
          update: {
            args: Prisma.PersSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersSkillPayload>
          }
          deleteMany: {
            args: Prisma.PersSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersSkillPayload>[]
          }
          upsert: {
            args: Prisma.PersSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersSkillPayload>
          }
          aggregate: {
            args: Prisma.PersSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersSkill>
          }
          groupBy: {
            args: Prisma.PersSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersSkillCountArgs<ExtArgs>
            result: $Utils.Optional<PersSkillCountAggregateOutputType> | number
          }
        }
      }
      PersWeapon: {
        payload: Prisma.$PersWeaponPayload<ExtArgs>
        fields: Prisma.PersWeaponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersWeaponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersWeaponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersWeaponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersWeaponPayload>
          }
          findFirst: {
            args: Prisma.PersWeaponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersWeaponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersWeaponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersWeaponPayload>
          }
          findMany: {
            args: Prisma.PersWeaponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersWeaponPayload>[]
          }
          create: {
            args: Prisma.PersWeaponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersWeaponPayload>
          }
          createMany: {
            args: Prisma.PersWeaponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersWeaponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersWeaponPayload>[]
          }
          delete: {
            args: Prisma.PersWeaponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersWeaponPayload>
          }
          update: {
            args: Prisma.PersWeaponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersWeaponPayload>
          }
          deleteMany: {
            args: Prisma.PersWeaponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersWeaponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersWeaponUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersWeaponPayload>[]
          }
          upsert: {
            args: Prisma.PersWeaponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersWeaponPayload>
          }
          aggregate: {
            args: Prisma.PersWeaponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersWeapon>
          }
          groupBy: {
            args: Prisma.PersWeaponGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersWeaponGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersWeaponCountArgs<ExtArgs>
            result: $Utils.Optional<PersWeaponCountAggregateOutputType> | number
          }
        }
      }
      PersArmor: {
        payload: Prisma.$PersArmorPayload<ExtArgs>
        fields: Prisma.PersArmorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersArmorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersArmorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersArmorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersArmorPayload>
          }
          findFirst: {
            args: Prisma.PersArmorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersArmorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersArmorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersArmorPayload>
          }
          findMany: {
            args: Prisma.PersArmorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersArmorPayload>[]
          }
          create: {
            args: Prisma.PersArmorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersArmorPayload>
          }
          createMany: {
            args: Prisma.PersArmorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersArmorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersArmorPayload>[]
          }
          delete: {
            args: Prisma.PersArmorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersArmorPayload>
          }
          update: {
            args: Prisma.PersArmorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersArmorPayload>
          }
          deleteMany: {
            args: Prisma.PersArmorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersArmorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersArmorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersArmorPayload>[]
          }
          upsert: {
            args: Prisma.PersArmorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersArmorPayload>
          }
          aggregate: {
            args: Prisma.PersArmorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersArmor>
          }
          groupBy: {
            args: Prisma.PersArmorGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersArmorGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersArmorCountArgs<ExtArgs>
            result: $Utils.Optional<PersArmorCountAggregateOutputType> | number
          }
        }
      }
      PersMagicItem: {
        payload: Prisma.$PersMagicItemPayload<ExtArgs>
        fields: Prisma.PersMagicItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersMagicItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMagicItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersMagicItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMagicItemPayload>
          }
          findFirst: {
            args: Prisma.PersMagicItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMagicItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersMagicItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMagicItemPayload>
          }
          findMany: {
            args: Prisma.PersMagicItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMagicItemPayload>[]
          }
          create: {
            args: Prisma.PersMagicItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMagicItemPayload>
          }
          createMany: {
            args: Prisma.PersMagicItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersMagicItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMagicItemPayload>[]
          }
          delete: {
            args: Prisma.PersMagicItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMagicItemPayload>
          }
          update: {
            args: Prisma.PersMagicItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMagicItemPayload>
          }
          deleteMany: {
            args: Prisma.PersMagicItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersMagicItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersMagicItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMagicItemPayload>[]
          }
          upsert: {
            args: Prisma.PersMagicItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersMagicItemPayload>
          }
          aggregate: {
            args: Prisma.PersMagicItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersMagicItem>
          }
          groupBy: {
            args: Prisma.PersMagicItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersMagicItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersMagicItemCountArgs<ExtArgs>
            result: $Utils.Optional<PersMagicItemCountAggregateOutputType> | number
          }
        }
      }
      EquipmentPack: {
        payload: Prisma.$EquipmentPackPayload<ExtArgs>
        fields: Prisma.EquipmentPackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentPackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentPackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPackPayload>
          }
          findFirst: {
            args: Prisma.EquipmentPackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentPackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPackPayload>
          }
          findMany: {
            args: Prisma.EquipmentPackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPackPayload>[]
          }
          create: {
            args: Prisma.EquipmentPackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPackPayload>
          }
          createMany: {
            args: Prisma.EquipmentPackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentPackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPackPayload>[]
          }
          delete: {
            args: Prisma.EquipmentPackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPackPayload>
          }
          update: {
            args: Prisma.EquipmentPackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPackPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentPackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentPackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentPackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPackPayload>[]
          }
          upsert: {
            args: Prisma.EquipmentPackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPackPayload>
          }
          aggregate: {
            args: Prisma.EquipmentPackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipmentPack>
          }
          groupBy: {
            args: Prisma.EquipmentPackGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentPackGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentPackCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentPackCountAggregateOutputType> | number
          }
        }
      }
      ClassStartingEquipmentOption: {
        payload: Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>
        fields: Prisma.ClassStartingEquipmentOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassStartingEquipmentOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassStartingEquipmentOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassStartingEquipmentOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassStartingEquipmentOptionPayload>
          }
          findFirst: {
            args: Prisma.ClassStartingEquipmentOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassStartingEquipmentOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassStartingEquipmentOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassStartingEquipmentOptionPayload>
          }
          findMany: {
            args: Prisma.ClassStartingEquipmentOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassStartingEquipmentOptionPayload>[]
          }
          create: {
            args: Prisma.ClassStartingEquipmentOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassStartingEquipmentOptionPayload>
          }
          createMany: {
            args: Prisma.ClassStartingEquipmentOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassStartingEquipmentOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassStartingEquipmentOptionPayload>[]
          }
          delete: {
            args: Prisma.ClassStartingEquipmentOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassStartingEquipmentOptionPayload>
          }
          update: {
            args: Prisma.ClassStartingEquipmentOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassStartingEquipmentOptionPayload>
          }
          deleteMany: {
            args: Prisma.ClassStartingEquipmentOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassStartingEquipmentOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassStartingEquipmentOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassStartingEquipmentOptionPayload>[]
          }
          upsert: {
            args: Prisma.ClassStartingEquipmentOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassStartingEquipmentOptionPayload>
          }
          aggregate: {
            args: Prisma.ClassStartingEquipmentOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassStartingEquipmentOption>
          }
          groupBy: {
            args: Prisma.ClassStartingEquipmentOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassStartingEquipmentOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassStartingEquipmentOptionCountArgs<ExtArgs>
            result: $Utils.Optional<ClassStartingEquipmentOptionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    character?: CharacterOmit
    characterSpells?: CharacterSpellsOmit
    creature?: CreatureOmit
    spell?: SpellOmit
    spellClasses?: SpellClassesOmit
    spellRaces?: SpellRacesOmit
    spellbook?: SpellbookOmit
    spellbookSpells?: SpellbookSpellsOmit
    user?: UserOmit
    class?: ClassOmit
    subclass?: SubclassOmit
    pers?: PersOmit
    persMulticlass?: PersMulticlassOmit
    persFeature?: PersFeatureOmit
    feature?: FeatureOmit
    classFeature?: ClassFeatureOmit
    subclassFeature?: SubclassFeatureOmit
    raceTrait?: RaceTraitOmit
    subraceTrait?: SubraceTraitOmit
    raceVariantTrait?: RaceVariantTraitOmit
    raceChoiceOptionTrait?: RaceChoiceOptionTraitOmit
    featFeature?: FeatFeatureOmit
    magicItemFeature?: MagicItemFeatureOmit
    race?: RaceOmit
    subrace?: SubraceOmit
    raceVariant?: RaceVariantOmit
    raceChoiceOption?: RaceChoiceOptionOmit
    background?: BackgroundOmit
    feat?: FeatOmit
    featAbilityBoost?: FeatAbilityBoostOmit
    persFeat?: PersFeatOmit
    magicItem?: MagicItemOmit
    weapon?: WeaponOmit
    armor?: ArmorOmit
    persSkill?: PersSkillOmit
    persWeapon?: PersWeaponOmit
    persArmor?: PersArmorOmit
    persMagicItem?: PersMagicItemOmit
    equipmentPack?: EquipmentPackOmit
    classStartingEquipmentOption?: ClassStartingEquipmentOptionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CharacterCountOutputType
   */

  export type CharacterCountOutputType = {
    characterSpells: number
  }

  export type CharacterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characterSpells?: boolean | CharacterCountOutputTypeCountCharacterSpellsArgs
  }

  // Custom InputTypes
  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterCountOutputType
     */
    select?: CharacterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountCharacterSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterSpellsWhereInput
  }


  /**
   * Count Type SpellCountOutputType
   */

  export type SpellCountOutputType = {
    characterSpells: number
    spellClasses: number
    spellRaces: number
    spellbookSpells: number
    subclasses: number
    perses: number
    features: number
  }

  export type SpellCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characterSpells?: boolean | SpellCountOutputTypeCountCharacterSpellsArgs
    spellClasses?: boolean | SpellCountOutputTypeCountSpellClassesArgs
    spellRaces?: boolean | SpellCountOutputTypeCountSpellRacesArgs
    spellbookSpells?: boolean | SpellCountOutputTypeCountSpellbookSpellsArgs
    subclasses?: boolean | SpellCountOutputTypeCountSubclassesArgs
    perses?: boolean | SpellCountOutputTypeCountPersesArgs
    features?: boolean | SpellCountOutputTypeCountFeaturesArgs
  }

  // Custom InputTypes
  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellCountOutputType
     */
    select?: SpellCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountCharacterSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterSpellsWhereInput
  }

  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountSpellClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellClassesWhereInput
  }

  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountSpellRacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellRacesWhereInput
  }

  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountSpellbookSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellbookSpellsWhereInput
  }

  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountSubclassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubclassWhereInput
  }

  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountPersesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersWhereInput
  }

  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureWhereInput
  }


  /**
   * Count Type SpellbookCountOutputType
   */

  export type SpellbookCountOutputType = {
    spellbookSpells: number
  }

  export type SpellbookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spellbookSpells?: boolean | SpellbookCountOutputTypeCountSpellbookSpellsArgs
  }

  // Custom InputTypes
  /**
   * SpellbookCountOutputType without action
   */
  export type SpellbookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellbookCountOutputType
     */
    select?: SpellbookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpellbookCountOutputType without action
   */
  export type SpellbookCountOutputTypeCountSpellbookSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellbookSpellsWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    character: number
    spellbook: number
    pers: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | UserCountOutputTypeCountCharacterArgs
    spellbook?: boolean | UserCountOutputTypeCountSpellbookArgs
    pers?: boolean | UserCountOutputTypeCountPersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSpellbookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellbookWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    subclasses: number
    classFeatures: number
    perses: number
    persMulticlasses: number
    startingEquipmentOption: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subclasses?: boolean | ClassCountOutputTypeCountSubclassesArgs
    classFeatures?: boolean | ClassCountOutputTypeCountClassFeaturesArgs
    perses?: boolean | ClassCountOutputTypeCountPersesArgs
    persMulticlasses?: boolean | ClassCountOutputTypeCountPersMulticlassesArgs
    startingEquipmentOption?: boolean | ClassCountOutputTypeCountStartingEquipmentOptionArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountSubclassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubclassWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountClassFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassFeatureWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountPersesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountPersMulticlassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersMulticlassWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountStartingEquipmentOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassStartingEquipmentOptionWhereInput
  }


  /**
   * Count Type SubclassCountOutputType
   */

  export type SubclassCountOutputType = {
    expandedSpells: number
    features: number
    perses: number
    persMulticlasses: number
  }

  export type SubclassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expandedSpells?: boolean | SubclassCountOutputTypeCountExpandedSpellsArgs
    features?: boolean | SubclassCountOutputTypeCountFeaturesArgs
    perses?: boolean | SubclassCountOutputTypeCountPersesArgs
    persMulticlasses?: boolean | SubclassCountOutputTypeCountPersMulticlassesArgs
  }

  // Custom InputTypes
  /**
   * SubclassCountOutputType without action
   */
  export type SubclassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubclassCountOutputType
     */
    select?: SubclassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubclassCountOutputType without action
   */
  export type SubclassCountOutputTypeCountExpandedSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellWhereInput
  }

  /**
   * SubclassCountOutputType without action
   */
  export type SubclassCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubclassFeatureWhereInput
  }

  /**
   * SubclassCountOutputType without action
   */
  export type SubclassCountOutputTypeCountPersesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersWhereInput
  }

  /**
   * SubclassCountOutputType without action
   */
  export type SubclassCountOutputTypeCountPersMulticlassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersMulticlassWhereInput
  }


  /**
   * Count Type PersCountOutputType
   */

  export type PersCountOutputType = {
    skills: number
    multiclasses: number
    features: number
    spells: number
    feats: number
    armors: number
    weapons: number
    magicItems: number
    raceVariants: number
    raceChoiceOptions: number
  }

  export type PersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | PersCountOutputTypeCountSkillsArgs
    multiclasses?: boolean | PersCountOutputTypeCountMulticlassesArgs
    features?: boolean | PersCountOutputTypeCountFeaturesArgs
    spells?: boolean | PersCountOutputTypeCountSpellsArgs
    feats?: boolean | PersCountOutputTypeCountFeatsArgs
    armors?: boolean | PersCountOutputTypeCountArmorsArgs
    weapons?: boolean | PersCountOutputTypeCountWeaponsArgs
    magicItems?: boolean | PersCountOutputTypeCountMagicItemsArgs
    raceVariants?: boolean | PersCountOutputTypeCountRaceVariantsArgs
    raceChoiceOptions?: boolean | PersCountOutputTypeCountRaceChoiceOptionsArgs
  }

  // Custom InputTypes
  /**
   * PersCountOutputType without action
   */
  export type PersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersCountOutputType
     */
    select?: PersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersCountOutputType without action
   */
  export type PersCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersSkillWhereInput
  }

  /**
   * PersCountOutputType without action
   */
  export type PersCountOutputTypeCountMulticlassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersMulticlassWhereInput
  }

  /**
   * PersCountOutputType without action
   */
  export type PersCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersFeatureWhereInput
  }

  /**
   * PersCountOutputType without action
   */
  export type PersCountOutputTypeCountSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellWhereInput
  }

  /**
   * PersCountOutputType without action
   */
  export type PersCountOutputTypeCountFeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersFeatWhereInput
  }

  /**
   * PersCountOutputType without action
   */
  export type PersCountOutputTypeCountArmorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersArmorWhereInput
  }

  /**
   * PersCountOutputType without action
   */
  export type PersCountOutputTypeCountWeaponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersWeaponWhereInput
  }

  /**
   * PersCountOutputType without action
   */
  export type PersCountOutputTypeCountMagicItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersMagicItemWhereInput
  }

  /**
   * PersCountOutputType without action
   */
  export type PersCountOutputTypeCountRaceVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceVariantWhereInput
  }

  /**
   * PersCountOutputType without action
   */
  export type PersCountOutputTypeCountRaceChoiceOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceChoiceOptionWhereInput
  }


  /**
   * Count Type FeatureCountOutputType
   */

  export type FeatureCountOutputType = {
    givesSpells: number
    classFeatures: number
    subclassFeatures: number
    raceTraits: number
    subraceTraits: number
    raceVariantTraits: number
    raceChoiceOptionsTraits: number
    featFeatures: number
    magicItemFeatures: number
    persFeatures: number
  }

  export type FeatureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    givesSpells?: boolean | FeatureCountOutputTypeCountGivesSpellsArgs
    classFeatures?: boolean | FeatureCountOutputTypeCountClassFeaturesArgs
    subclassFeatures?: boolean | FeatureCountOutputTypeCountSubclassFeaturesArgs
    raceTraits?: boolean | FeatureCountOutputTypeCountRaceTraitsArgs
    subraceTraits?: boolean | FeatureCountOutputTypeCountSubraceTraitsArgs
    raceVariantTraits?: boolean | FeatureCountOutputTypeCountRaceVariantTraitsArgs
    raceChoiceOptionsTraits?: boolean | FeatureCountOutputTypeCountRaceChoiceOptionsTraitsArgs
    featFeatures?: boolean | FeatureCountOutputTypeCountFeatFeaturesArgs
    magicItemFeatures?: boolean | FeatureCountOutputTypeCountMagicItemFeaturesArgs
    persFeatures?: boolean | FeatureCountOutputTypeCountPersFeaturesArgs
  }

  // Custom InputTypes
  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureCountOutputType
     */
    select?: FeatureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountGivesSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellWhereInput
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountClassFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassFeatureWhereInput
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountSubclassFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubclassFeatureWhereInput
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountRaceTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceTraitWhereInput
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountSubraceTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubraceTraitWhereInput
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountRaceVariantTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceVariantTraitWhereInput
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountRaceChoiceOptionsTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceChoiceOptionTraitWhereInput
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountFeatFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatFeatureWhereInput
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountMagicItemFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicItemFeatureWhereInput
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountPersFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersFeatureWhereInput
  }


  /**
   * Count Type RaceTraitCountOutputType
   */

  export type RaceTraitCountOutputType = {
    subraces: number
    raceVariants: number
  }

  export type RaceTraitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subraces?: boolean | RaceTraitCountOutputTypeCountSubracesArgs
    raceVariants?: boolean | RaceTraitCountOutputTypeCountRaceVariantsArgs
  }

  // Custom InputTypes
  /**
   * RaceTraitCountOutputType without action
   */
  export type RaceTraitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTraitCountOutputType
     */
    select?: RaceTraitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RaceTraitCountOutputType without action
   */
  export type RaceTraitCountOutputTypeCountSubracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubraceWhereInput
  }

  /**
   * RaceTraitCountOutputType without action
   */
  export type RaceTraitCountOutputTypeCountRaceVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceVariantWhereInput
  }


  /**
   * Count Type RaceCountOutputType
   */

  export type RaceCountOutputType = {
    subraces: number
    perses: number
    raceChoiceOptions: number
    raceVariants: number
    traits: number
  }

  export type RaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subraces?: boolean | RaceCountOutputTypeCountSubracesArgs
    perses?: boolean | RaceCountOutputTypeCountPersesArgs
    raceChoiceOptions?: boolean | RaceCountOutputTypeCountRaceChoiceOptionsArgs
    raceVariants?: boolean | RaceCountOutputTypeCountRaceVariantsArgs
    traits?: boolean | RaceCountOutputTypeCountTraitsArgs
  }

  // Custom InputTypes
  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceCountOutputType
     */
    select?: RaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountSubracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubraceWhereInput
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountPersesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersWhereInput
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountRaceChoiceOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceChoiceOptionWhereInput
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountRaceVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceVariantWhereInput
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceTraitWhereInput
  }


  /**
   * Count Type SubraceCountOutputType
   */

  export type SubraceCountOutputType = {
    replacesTraits: number
    perses: number
    raceChoiceOptions: number
    traits: number
  }

  export type SubraceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replacesTraits?: boolean | SubraceCountOutputTypeCountReplacesTraitsArgs
    perses?: boolean | SubraceCountOutputTypeCountPersesArgs
    raceChoiceOptions?: boolean | SubraceCountOutputTypeCountRaceChoiceOptionsArgs
    traits?: boolean | SubraceCountOutputTypeCountTraitsArgs
  }

  // Custom InputTypes
  /**
   * SubraceCountOutputType without action
   */
  export type SubraceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubraceCountOutputType
     */
    select?: SubraceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubraceCountOutputType without action
   */
  export type SubraceCountOutputTypeCountReplacesTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceTraitWhereInput
  }

  /**
   * SubraceCountOutputType without action
   */
  export type SubraceCountOutputTypeCountPersesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersWhereInput
  }

  /**
   * SubraceCountOutputType without action
   */
  export type SubraceCountOutputTypeCountRaceChoiceOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceChoiceOptionWhereInput
  }

  /**
   * SubraceCountOutputType without action
   */
  export type SubraceCountOutputTypeCountTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubraceTraitWhereInput
  }


  /**
   * Count Type RaceVariantCountOutputType
   */

  export type RaceVariantCountOutputType = {
    replacesTraits: number
    traits: number
    perses: number
  }

  export type RaceVariantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replacesTraits?: boolean | RaceVariantCountOutputTypeCountReplacesTraitsArgs
    traits?: boolean | RaceVariantCountOutputTypeCountTraitsArgs
    perses?: boolean | RaceVariantCountOutputTypeCountPersesArgs
  }

  // Custom InputTypes
  /**
   * RaceVariantCountOutputType without action
   */
  export type RaceVariantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariantCountOutputType
     */
    select?: RaceVariantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RaceVariantCountOutputType without action
   */
  export type RaceVariantCountOutputTypeCountReplacesTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceTraitWhereInput
  }

  /**
   * RaceVariantCountOutputType without action
   */
  export type RaceVariantCountOutputTypeCountTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceVariantTraitWhereInput
  }

  /**
   * RaceVariantCountOutputType without action
   */
  export type RaceVariantCountOutputTypeCountPersesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersWhereInput
  }


  /**
   * Count Type RaceChoiceOptionCountOutputType
   */

  export type RaceChoiceOptionCountOutputType = {
    grantsTraits: number
    perses: number
  }

  export type RaceChoiceOptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grantsTraits?: boolean | RaceChoiceOptionCountOutputTypeCountGrantsTraitsArgs
    perses?: boolean | RaceChoiceOptionCountOutputTypeCountPersesArgs
  }

  // Custom InputTypes
  /**
   * RaceChoiceOptionCountOutputType without action
   */
  export type RaceChoiceOptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOptionCountOutputType
     */
    select?: RaceChoiceOptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RaceChoiceOptionCountOutputType without action
   */
  export type RaceChoiceOptionCountOutputTypeCountGrantsTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceChoiceOptionTraitWhereInput
  }

  /**
   * RaceChoiceOptionCountOutputType without action
   */
  export type RaceChoiceOptionCountOutputTypeCountPersesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersWhereInput
  }


  /**
   * Count Type BackgroundCountOutputType
   */

  export type BackgroundCountOutputType = {
    perses: number
  }

  export type BackgroundCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    perses?: boolean | BackgroundCountOutputTypeCountPersesArgs
  }

  // Custom InputTypes
  /**
   * BackgroundCountOutputType without action
   */
  export type BackgroundCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackgroundCountOutputType
     */
    select?: BackgroundCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BackgroundCountOutputType without action
   */
  export type BackgroundCountOutputTypeCountPersesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersWhereInput
  }


  /**
   * Count Type FeatCountOutputType
   */

  export type FeatCountOutputType = {
    featFeatures: number
    persFeats: number
  }

  export type FeatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    featFeatures?: boolean | FeatCountOutputTypeCountFeatFeaturesArgs
    persFeats?: boolean | FeatCountOutputTypeCountPersFeatsArgs
  }

  // Custom InputTypes
  /**
   * FeatCountOutputType without action
   */
  export type FeatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatCountOutputType
     */
    select?: FeatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeatCountOutputType without action
   */
  export type FeatCountOutputTypeCountFeatFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatFeatureWhereInput
  }

  /**
   * FeatCountOutputType without action
   */
  export type FeatCountOutputTypeCountPersFeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersFeatWhereInput
  }


  /**
   * Count Type MagicItemCountOutputType
   */

  export type MagicItemCountOutputType = {
    features: number
    persMagicItems: number
  }

  export type MagicItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | MagicItemCountOutputTypeCountFeaturesArgs
    persMagicItems?: boolean | MagicItemCountOutputTypeCountPersMagicItemsArgs
  }

  // Custom InputTypes
  /**
   * MagicItemCountOutputType without action
   */
  export type MagicItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemCountOutputType
     */
    select?: MagicItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MagicItemCountOutputType without action
   */
  export type MagicItemCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicItemFeatureWhereInput
  }

  /**
   * MagicItemCountOutputType without action
   */
  export type MagicItemCountOutputTypeCountPersMagicItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersMagicItemWhereInput
  }


  /**
   * Count Type WeaponCountOutputType
   */

  export type WeaponCountOutputType = {
    persWeapons: number
    classStartingEquipmentOption: number
  }

  export type WeaponCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    persWeapons?: boolean | WeaponCountOutputTypeCountPersWeaponsArgs
    classStartingEquipmentOption?: boolean | WeaponCountOutputTypeCountClassStartingEquipmentOptionArgs
  }

  // Custom InputTypes
  /**
   * WeaponCountOutputType without action
   */
  export type WeaponCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponCountOutputType
     */
    select?: WeaponCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeaponCountOutputType without action
   */
  export type WeaponCountOutputTypeCountPersWeaponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersWeaponWhereInput
  }

  /**
   * WeaponCountOutputType without action
   */
  export type WeaponCountOutputTypeCountClassStartingEquipmentOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassStartingEquipmentOptionWhereInput
  }


  /**
   * Count Type ArmorCountOutputType
   */

  export type ArmorCountOutputType = {
    persArmor: number
    classStartingEquipmentOption: number
  }

  export type ArmorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    persArmor?: boolean | ArmorCountOutputTypeCountPersArmorArgs
    classStartingEquipmentOption?: boolean | ArmorCountOutputTypeCountClassStartingEquipmentOptionArgs
  }

  // Custom InputTypes
  /**
   * ArmorCountOutputType without action
   */
  export type ArmorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArmorCountOutputType
     */
    select?: ArmorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArmorCountOutputType without action
   */
  export type ArmorCountOutputTypeCountPersArmorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersArmorWhereInput
  }

  /**
   * ArmorCountOutputType without action
   */
  export type ArmorCountOutputTypeCountClassStartingEquipmentOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassStartingEquipmentOptionWhereInput
  }


  /**
   * Count Type EquipmentPackCountOutputType
   */

  export type EquipmentPackCountOutputType = {
    classStartingEquipmentOptions: number
  }

  export type EquipmentPackCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classStartingEquipmentOptions?: boolean | EquipmentPackCountOutputTypeCountClassStartingEquipmentOptionsArgs
  }

  // Custom InputTypes
  /**
   * EquipmentPackCountOutputType without action
   */
  export type EquipmentPackCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentPackCountOutputType
     */
    select?: EquipmentPackCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentPackCountOutputType without action
   */
  export type EquipmentPackCountOutputTypeCountClassStartingEquipmentOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassStartingEquipmentOptionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Character
   */

  export type AggregateCharacter = {
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  export type CharacterAvgAggregateOutputType = {
    characterId: number | null
    userId: number | null
  }

  export type CharacterSumAggregateOutputType = {
    characterId: number | null
    userId: number | null
  }

  export type CharacterMinAggregateOutputType = {
    characterId: number | null
    name: string | null
    userId: number | null
  }

  export type CharacterMaxAggregateOutputType = {
    characterId: number | null
    name: string | null
    userId: number | null
  }

  export type CharacterCountAggregateOutputType = {
    characterId: number
    name: number
    userId: number
    _all: number
  }


  export type CharacterAvgAggregateInputType = {
    characterId?: true
    userId?: true
  }

  export type CharacterSumAggregateInputType = {
    characterId?: true
    userId?: true
  }

  export type CharacterMinAggregateInputType = {
    characterId?: true
    name?: true
    userId?: true
  }

  export type CharacterMaxAggregateInputType = {
    characterId?: true
    name?: true
    userId?: true
  }

  export type CharacterCountAggregateInputType = {
    characterId?: true
    name?: true
    userId?: true
    _all?: true
  }

  export type CharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Character to aggregate.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characters
    **/
    _count?: true | CharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterMaxAggregateInputType
  }

  export type GetCharacterAggregateType<T extends CharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter[P]>
      : GetScalarType<T[P], AggregateCharacter[P]>
  }




  export type CharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithAggregationInput | CharacterOrderByWithAggregationInput[]
    by: CharacterScalarFieldEnum[] | CharacterScalarFieldEnum
    having?: CharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterCountAggregateInputType | true
    _avg?: CharacterAvgAggregateInputType
    _sum?: CharacterSumAggregateInputType
    _min?: CharacterMinAggregateInputType
    _max?: CharacterMaxAggregateInputType
  }

  export type CharacterGroupByOutputType = {
    characterId: number
    name: string | null
    userId: number | null
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  type GetCharacterGroupByPayload<T extends CharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    characterId?: boolean
    name?: boolean
    userId?: boolean
    user?: boolean | Character$userArgs<ExtArgs>
    characterSpells?: boolean | Character$characterSpellsArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    characterId?: boolean
    name?: boolean
    userId?: boolean
    user?: boolean | Character$userArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    characterId?: boolean
    name?: boolean
    userId?: boolean
    user?: boolean | Character$userArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectScalar = {
    characterId?: boolean
    name?: boolean
    userId?: boolean
  }

  export type CharacterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"characterId" | "name" | "userId", ExtArgs["result"]["character"]>
  export type CharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Character$userArgs<ExtArgs>
    characterSpells?: boolean | Character$characterSpellsArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CharacterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Character$userArgs<ExtArgs>
  }
  export type CharacterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Character$userArgs<ExtArgs>
  }

  export type $CharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Character"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      characterSpells: Prisma.$CharacterSpellsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      characterId: number
      name: string | null
      userId: number | null
    }, ExtArgs["result"]["character"]>
    composites: {}
  }

  type CharacterGetPayload<S extends boolean | null | undefined | CharacterDefaultArgs> = $Result.GetResult<Prisma.$CharacterPayload, S>

  type CharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacterCountAggregateInputType | true
    }

  export interface CharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Character'], meta: { name: 'Character' } }
    /**
     * Find zero or one Character that matches the filter.
     * @param {CharacterFindUniqueArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterFindUniqueArgs>(args: SelectSubset<T, CharacterFindUniqueArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacterFindUniqueOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterFindFirstArgs>(args?: SelectSubset<T, CharacterFindFirstArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.character.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.character.findMany({ take: 10 })
     * 
     * // Only select the `characterId`
     * const characterWithCharacterIdOnly = await prisma.character.findMany({ select: { characterId: true } })
     * 
     */
    findMany<T extends CharacterFindManyArgs>(args?: SelectSubset<T, CharacterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character.
     * @param {CharacterCreateArgs} args - Arguments to create a Character.
     * @example
     * // Create one Character
     * const Character = await prisma.character.create({
     *   data: {
     *     // ... data to create a Character
     *   }
     * })
     * 
     */
    create<T extends CharacterCreateArgs>(args: SelectSubset<T, CharacterCreateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Characters.
     * @param {CharacterCreateManyArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterCreateManyArgs>(args?: SelectSubset<T, CharacterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Characters and returns the data saved in the database.
     * @param {CharacterCreateManyAndReturnArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Characters and only return the `characterId`
     * const characterWithCharacterIdOnly = await prisma.character.createManyAndReturn({
     *   select: { characterId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character.
     * @param {CharacterDeleteArgs} args - Arguments to delete one Character.
     * @example
     * // Delete one Character
     * const Character = await prisma.character.delete({
     *   where: {
     *     // ... filter to delete one Character
     *   }
     * })
     * 
     */
    delete<T extends CharacterDeleteArgs>(args: SelectSubset<T, CharacterDeleteArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character.
     * @param {CharacterUpdateArgs} args - Arguments to update one Character.
     * @example
     * // Update one Character
     * const character = await prisma.character.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterUpdateArgs>(args: SelectSubset<T, CharacterUpdateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Characters.
     * @param {CharacterDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.character.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterDeleteManyArgs>(args?: SelectSubset<T, CharacterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterUpdateManyArgs>(args: SelectSubset<T, CharacterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters and returns the data updated in the database.
     * @param {CharacterUpdateManyAndReturnArgs} args - Arguments to update many Characters.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Characters and only return the `characterId`
     * const characterWithCharacterIdOnly = await prisma.character.updateManyAndReturn({
     *   select: { characterId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacterUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character.
     * @param {CharacterUpsertArgs} args - Arguments to update or create a Character.
     * @example
     * // Update or create a Character
     * const character = await prisma.character.upsert({
     *   create: {
     *     // ... data to create a Character
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character we want to update
     *   }
     * })
     */
    upsert<T extends CharacterUpsertArgs>(args: SelectSubset<T, CharacterUpsertArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.character.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends CharacterCountArgs>(
      args?: Subset<T, CharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterAggregateArgs>(args: Subset<T, CharacterAggregateArgs>): Prisma.PrismaPromise<GetCharacterAggregateType<T>>

    /**
     * Group by Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterGroupByArgs['orderBy'] }
        : { orderBy?: CharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Character model
   */
  readonly fields: CharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Character.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Character$userArgs<ExtArgs> = {}>(args?: Subset<T, Character$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    characterSpells<T extends Character$characterSpellsArgs<ExtArgs> = {}>(args?: Subset<T, Character$characterSpellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSpellsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Character model
   */
  interface CharacterFieldRefs {
    readonly characterId: FieldRef<"Character", 'Int'>
    readonly name: FieldRef<"Character", 'String'>
    readonly userId: FieldRef<"Character", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Character findUnique
   */
  export type CharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findUniqueOrThrow
   */
  export type CharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findFirst
   */
  export type CharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findFirstOrThrow
   */
  export type CharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findMany
   */
  export type CharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character create
   */
  export type CharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a Character.
     */
    data?: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
  }

  /**
   * Character createMany
   */
  export type CharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Character createManyAndReturn
   */
  export type CharacterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Character update
   */
  export type CharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a Character.
     */
    data: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
    /**
     * Choose, which Character to update.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character updateMany
   */
  export type CharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to update.
     */
    limit?: number
  }

  /**
   * Character updateManyAndReturn
   */
  export type CharacterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Character upsert
   */
  export type CharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the Character to update in case it exists.
     */
    where: CharacterWhereUniqueInput
    /**
     * In case the Character found by the `where` argument doesn't exist, create a new Character with this data.
     */
    create: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
    /**
     * In case the Character was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
  }

  /**
   * Character delete
   */
  export type CharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter which Character to delete.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character deleteMany
   */
  export type CharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characters to delete
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to delete.
     */
    limit?: number
  }

  /**
   * Character.user
   */
  export type Character$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Character.characterSpells
   */
  export type Character$characterSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpells
     */
    select?: CharacterSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSpells
     */
    omit?: CharacterSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSpellsInclude<ExtArgs> | null
    where?: CharacterSpellsWhereInput
    orderBy?: CharacterSpellsOrderByWithRelationInput | CharacterSpellsOrderByWithRelationInput[]
    cursor?: CharacterSpellsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterSpellsScalarFieldEnum | CharacterSpellsScalarFieldEnum[]
  }

  /**
   * Character without action
   */
  export type CharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
  }


  /**
   * Model CharacterSpells
   */

  export type AggregateCharacterSpells = {
    _count: CharacterSpellsCountAggregateOutputType | null
    _avg: CharacterSpellsAvgAggregateOutputType | null
    _sum: CharacterSpellsSumAggregateOutputType | null
    _min: CharacterSpellsMinAggregateOutputType | null
    _max: CharacterSpellsMaxAggregateOutputType | null
  }

  export type CharacterSpellsAvgAggregateOutputType = {
    characterSpellId: number | null
    characterId: number | null
    spellId: number | null
  }

  export type CharacterSpellsSumAggregateOutputType = {
    characterSpellId: number | null
    characterId: number | null
    spellId: number | null
  }

  export type CharacterSpellsMinAggregateOutputType = {
    characterSpellId: number | null
    characterId: number | null
    spellId: number | null
  }

  export type CharacterSpellsMaxAggregateOutputType = {
    characterSpellId: number | null
    characterId: number | null
    spellId: number | null
  }

  export type CharacterSpellsCountAggregateOutputType = {
    characterSpellId: number
    characterId: number
    spellId: number
    _all: number
  }


  export type CharacterSpellsAvgAggregateInputType = {
    characterSpellId?: true
    characterId?: true
    spellId?: true
  }

  export type CharacterSpellsSumAggregateInputType = {
    characterSpellId?: true
    characterId?: true
    spellId?: true
  }

  export type CharacterSpellsMinAggregateInputType = {
    characterSpellId?: true
    characterId?: true
    spellId?: true
  }

  export type CharacterSpellsMaxAggregateInputType = {
    characterSpellId?: true
    characterId?: true
    spellId?: true
  }

  export type CharacterSpellsCountAggregateInputType = {
    characterSpellId?: true
    characterId?: true
    spellId?: true
    _all?: true
  }

  export type CharacterSpellsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterSpells to aggregate.
     */
    where?: CharacterSpellsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSpells to fetch.
     */
    orderBy?: CharacterSpellsOrderByWithRelationInput | CharacterSpellsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterSpellsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterSpells
    **/
    _count?: true | CharacterSpellsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterSpellsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSpellsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterSpellsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterSpellsMaxAggregateInputType
  }

  export type GetCharacterSpellsAggregateType<T extends CharacterSpellsAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterSpells]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterSpells[P]>
      : GetScalarType<T[P], AggregateCharacterSpells[P]>
  }




  export type CharacterSpellsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterSpellsWhereInput
    orderBy?: CharacterSpellsOrderByWithAggregationInput | CharacterSpellsOrderByWithAggregationInput[]
    by: CharacterSpellsScalarFieldEnum[] | CharacterSpellsScalarFieldEnum
    having?: CharacterSpellsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterSpellsCountAggregateInputType | true
    _avg?: CharacterSpellsAvgAggregateInputType
    _sum?: CharacterSpellsSumAggregateInputType
    _min?: CharacterSpellsMinAggregateInputType
    _max?: CharacterSpellsMaxAggregateInputType
  }

  export type CharacterSpellsGroupByOutputType = {
    characterSpellId: number
    characterId: number | null
    spellId: number | null
    _count: CharacterSpellsCountAggregateOutputType | null
    _avg: CharacterSpellsAvgAggregateOutputType | null
    _sum: CharacterSpellsSumAggregateOutputType | null
    _min: CharacterSpellsMinAggregateOutputType | null
    _max: CharacterSpellsMaxAggregateOutputType | null
  }

  type GetCharacterSpellsGroupByPayload<T extends CharacterSpellsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterSpellsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterSpellsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterSpellsGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterSpellsGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSpellsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    characterSpellId?: boolean
    characterId?: boolean
    spellId?: boolean
    character?: boolean | CharacterSpells$characterArgs<ExtArgs>
    spell?: boolean | CharacterSpells$spellArgs<ExtArgs>
  }, ExtArgs["result"]["characterSpells"]>

  export type CharacterSpellsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    characterSpellId?: boolean
    characterId?: boolean
    spellId?: boolean
    character?: boolean | CharacterSpells$characterArgs<ExtArgs>
    spell?: boolean | CharacterSpells$spellArgs<ExtArgs>
  }, ExtArgs["result"]["characterSpells"]>

  export type CharacterSpellsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    characterSpellId?: boolean
    characterId?: boolean
    spellId?: boolean
    character?: boolean | CharacterSpells$characterArgs<ExtArgs>
    spell?: boolean | CharacterSpells$spellArgs<ExtArgs>
  }, ExtArgs["result"]["characterSpells"]>

  export type CharacterSpellsSelectScalar = {
    characterSpellId?: boolean
    characterId?: boolean
    spellId?: boolean
  }

  export type CharacterSpellsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"characterSpellId" | "characterId" | "spellId", ExtArgs["result"]["characterSpells"]>
  export type CharacterSpellsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterSpells$characterArgs<ExtArgs>
    spell?: boolean | CharacterSpells$spellArgs<ExtArgs>
  }
  export type CharacterSpellsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterSpells$characterArgs<ExtArgs>
    spell?: boolean | CharacterSpells$spellArgs<ExtArgs>
  }
  export type CharacterSpellsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterSpells$characterArgs<ExtArgs>
    spell?: boolean | CharacterSpells$spellArgs<ExtArgs>
  }

  export type $CharacterSpellsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterSpells"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs> | null
      spell: Prisma.$SpellPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      characterSpellId: number
      characterId: number | null
      spellId: number | null
    }, ExtArgs["result"]["characterSpells"]>
    composites: {}
  }

  type CharacterSpellsGetPayload<S extends boolean | null | undefined | CharacterSpellsDefaultArgs> = $Result.GetResult<Prisma.$CharacterSpellsPayload, S>

  type CharacterSpellsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacterSpellsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacterSpellsCountAggregateInputType | true
    }

  export interface CharacterSpellsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterSpells'], meta: { name: 'CharacterSpells' } }
    /**
     * Find zero or one CharacterSpells that matches the filter.
     * @param {CharacterSpellsFindUniqueArgs} args - Arguments to find a CharacterSpells
     * @example
     * // Get one CharacterSpells
     * const characterSpells = await prisma.characterSpells.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterSpellsFindUniqueArgs>(args: SelectSubset<T, CharacterSpellsFindUniqueArgs<ExtArgs>>): Prisma__CharacterSpellsClient<$Result.GetResult<Prisma.$CharacterSpellsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CharacterSpells that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacterSpellsFindUniqueOrThrowArgs} args - Arguments to find a CharacterSpells
     * @example
     * // Get one CharacterSpells
     * const characterSpells = await prisma.characterSpells.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterSpellsFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterSpellsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterSpellsClient<$Result.GetResult<Prisma.$CharacterSpellsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterSpells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSpellsFindFirstArgs} args - Arguments to find a CharacterSpells
     * @example
     * // Get one CharacterSpells
     * const characterSpells = await prisma.characterSpells.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterSpellsFindFirstArgs>(args?: SelectSubset<T, CharacterSpellsFindFirstArgs<ExtArgs>>): Prisma__CharacterSpellsClient<$Result.GetResult<Prisma.$CharacterSpellsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterSpells that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSpellsFindFirstOrThrowArgs} args - Arguments to find a CharacterSpells
     * @example
     * // Get one CharacterSpells
     * const characterSpells = await prisma.characterSpells.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterSpellsFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterSpellsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterSpellsClient<$Result.GetResult<Prisma.$CharacterSpellsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CharacterSpells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSpellsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterSpells
     * const characterSpells = await prisma.characterSpells.findMany()
     * 
     * // Get first 10 CharacterSpells
     * const characterSpells = await prisma.characterSpells.findMany({ take: 10 })
     * 
     * // Only select the `characterSpellId`
     * const characterSpellsWithCharacterSpellIdOnly = await prisma.characterSpells.findMany({ select: { characterSpellId: true } })
     * 
     */
    findMany<T extends CharacterSpellsFindManyArgs>(args?: SelectSubset<T, CharacterSpellsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSpellsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CharacterSpells.
     * @param {CharacterSpellsCreateArgs} args - Arguments to create a CharacterSpells.
     * @example
     * // Create one CharacterSpells
     * const CharacterSpells = await prisma.characterSpells.create({
     *   data: {
     *     // ... data to create a CharacterSpells
     *   }
     * })
     * 
     */
    create<T extends CharacterSpellsCreateArgs>(args: SelectSubset<T, CharacterSpellsCreateArgs<ExtArgs>>): Prisma__CharacterSpellsClient<$Result.GetResult<Prisma.$CharacterSpellsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CharacterSpells.
     * @param {CharacterSpellsCreateManyArgs} args - Arguments to create many CharacterSpells.
     * @example
     * // Create many CharacterSpells
     * const characterSpells = await prisma.characterSpells.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterSpellsCreateManyArgs>(args?: SelectSubset<T, CharacterSpellsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacterSpells and returns the data saved in the database.
     * @param {CharacterSpellsCreateManyAndReturnArgs} args - Arguments to create many CharacterSpells.
     * @example
     * // Create many CharacterSpells
     * const characterSpells = await prisma.characterSpells.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacterSpells and only return the `characterSpellId`
     * const characterSpellsWithCharacterSpellIdOnly = await prisma.characterSpells.createManyAndReturn({
     *   select: { characterSpellId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterSpellsCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterSpellsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSpellsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CharacterSpells.
     * @param {CharacterSpellsDeleteArgs} args - Arguments to delete one CharacterSpells.
     * @example
     * // Delete one CharacterSpells
     * const CharacterSpells = await prisma.characterSpells.delete({
     *   where: {
     *     // ... filter to delete one CharacterSpells
     *   }
     * })
     * 
     */
    delete<T extends CharacterSpellsDeleteArgs>(args: SelectSubset<T, CharacterSpellsDeleteArgs<ExtArgs>>): Prisma__CharacterSpellsClient<$Result.GetResult<Prisma.$CharacterSpellsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CharacterSpells.
     * @param {CharacterSpellsUpdateArgs} args - Arguments to update one CharacterSpells.
     * @example
     * // Update one CharacterSpells
     * const characterSpells = await prisma.characterSpells.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterSpellsUpdateArgs>(args: SelectSubset<T, CharacterSpellsUpdateArgs<ExtArgs>>): Prisma__CharacterSpellsClient<$Result.GetResult<Prisma.$CharacterSpellsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CharacterSpells.
     * @param {CharacterSpellsDeleteManyArgs} args - Arguments to filter CharacterSpells to delete.
     * @example
     * // Delete a few CharacterSpells
     * const { count } = await prisma.characterSpells.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterSpellsDeleteManyArgs>(args?: SelectSubset<T, CharacterSpellsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSpellsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterSpells
     * const characterSpells = await prisma.characterSpells.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterSpellsUpdateManyArgs>(args: SelectSubset<T, CharacterSpellsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterSpells and returns the data updated in the database.
     * @param {CharacterSpellsUpdateManyAndReturnArgs} args - Arguments to update many CharacterSpells.
     * @example
     * // Update many CharacterSpells
     * const characterSpells = await prisma.characterSpells.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CharacterSpells and only return the `characterSpellId`
     * const characterSpellsWithCharacterSpellIdOnly = await prisma.characterSpells.updateManyAndReturn({
     *   select: { characterSpellId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacterSpellsUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacterSpellsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSpellsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CharacterSpells.
     * @param {CharacterSpellsUpsertArgs} args - Arguments to update or create a CharacterSpells.
     * @example
     * // Update or create a CharacterSpells
     * const characterSpells = await prisma.characterSpells.upsert({
     *   create: {
     *     // ... data to create a CharacterSpells
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterSpells we want to update
     *   }
     * })
     */
    upsert<T extends CharacterSpellsUpsertArgs>(args: SelectSubset<T, CharacterSpellsUpsertArgs<ExtArgs>>): Prisma__CharacterSpellsClient<$Result.GetResult<Prisma.$CharacterSpellsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CharacterSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSpellsCountArgs} args - Arguments to filter CharacterSpells to count.
     * @example
     * // Count the number of CharacterSpells
     * const count = await prisma.characterSpells.count({
     *   where: {
     *     // ... the filter for the CharacterSpells we want to count
     *   }
     * })
    **/
    count<T extends CharacterSpellsCountArgs>(
      args?: Subset<T, CharacterSpellsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterSpellsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSpellsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterSpellsAggregateArgs>(args: Subset<T, CharacterSpellsAggregateArgs>): Prisma.PrismaPromise<GetCharacterSpellsAggregateType<T>>

    /**
     * Group by CharacterSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSpellsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterSpellsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterSpellsGroupByArgs['orderBy'] }
        : { orderBy?: CharacterSpellsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterSpellsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterSpellsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterSpells model
   */
  readonly fields: CharacterSpellsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterSpells.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterSpellsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends CharacterSpells$characterArgs<ExtArgs> = {}>(args?: Subset<T, CharacterSpells$characterArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    spell<T extends CharacterSpells$spellArgs<ExtArgs> = {}>(args?: Subset<T, CharacterSpells$spellArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacterSpells model
   */
  interface CharacterSpellsFieldRefs {
    readonly characterSpellId: FieldRef<"CharacterSpells", 'Int'>
    readonly characterId: FieldRef<"CharacterSpells", 'Int'>
    readonly spellId: FieldRef<"CharacterSpells", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CharacterSpells findUnique
   */
  export type CharacterSpellsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpells
     */
    select?: CharacterSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSpells
     */
    omit?: CharacterSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSpellsInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSpells to fetch.
     */
    where: CharacterSpellsWhereUniqueInput
  }

  /**
   * CharacterSpells findUniqueOrThrow
   */
  export type CharacterSpellsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpells
     */
    select?: CharacterSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSpells
     */
    omit?: CharacterSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSpellsInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSpells to fetch.
     */
    where: CharacterSpellsWhereUniqueInput
  }

  /**
   * CharacterSpells findFirst
   */
  export type CharacterSpellsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpells
     */
    select?: CharacterSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSpells
     */
    omit?: CharacterSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSpellsInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSpells to fetch.
     */
    where?: CharacterSpellsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSpells to fetch.
     */
    orderBy?: CharacterSpellsOrderByWithRelationInput | CharacterSpellsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterSpells.
     */
    cursor?: CharacterSpellsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterSpells.
     */
    distinct?: CharacterSpellsScalarFieldEnum | CharacterSpellsScalarFieldEnum[]
  }

  /**
   * CharacterSpells findFirstOrThrow
   */
  export type CharacterSpellsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpells
     */
    select?: CharacterSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSpells
     */
    omit?: CharacterSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSpellsInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSpells to fetch.
     */
    where?: CharacterSpellsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSpells to fetch.
     */
    orderBy?: CharacterSpellsOrderByWithRelationInput | CharacterSpellsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterSpells.
     */
    cursor?: CharacterSpellsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterSpells.
     */
    distinct?: CharacterSpellsScalarFieldEnum | CharacterSpellsScalarFieldEnum[]
  }

  /**
   * CharacterSpells findMany
   */
  export type CharacterSpellsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpells
     */
    select?: CharacterSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSpells
     */
    omit?: CharacterSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSpellsInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSpells to fetch.
     */
    where?: CharacterSpellsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSpells to fetch.
     */
    orderBy?: CharacterSpellsOrderByWithRelationInput | CharacterSpellsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterSpells.
     */
    cursor?: CharacterSpellsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSpells.
     */
    skip?: number
    distinct?: CharacterSpellsScalarFieldEnum | CharacterSpellsScalarFieldEnum[]
  }

  /**
   * CharacterSpells create
   */
  export type CharacterSpellsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpells
     */
    select?: CharacterSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSpells
     */
    omit?: CharacterSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSpellsInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterSpells.
     */
    data?: XOR<CharacterSpellsCreateInput, CharacterSpellsUncheckedCreateInput>
  }

  /**
   * CharacterSpells createMany
   */
  export type CharacterSpellsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterSpells.
     */
    data: CharacterSpellsCreateManyInput | CharacterSpellsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacterSpells createManyAndReturn
   */
  export type CharacterSpellsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpells
     */
    select?: CharacterSpellsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSpells
     */
    omit?: CharacterSpellsOmit<ExtArgs> | null
    /**
     * The data used to create many CharacterSpells.
     */
    data: CharacterSpellsCreateManyInput | CharacterSpellsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSpellsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterSpells update
   */
  export type CharacterSpellsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpells
     */
    select?: CharacterSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSpells
     */
    omit?: CharacterSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSpellsInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterSpells.
     */
    data: XOR<CharacterSpellsUpdateInput, CharacterSpellsUncheckedUpdateInput>
    /**
     * Choose, which CharacterSpells to update.
     */
    where: CharacterSpellsWhereUniqueInput
  }

  /**
   * CharacterSpells updateMany
   */
  export type CharacterSpellsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterSpells.
     */
    data: XOR<CharacterSpellsUpdateManyMutationInput, CharacterSpellsUncheckedUpdateManyInput>
    /**
     * Filter which CharacterSpells to update
     */
    where?: CharacterSpellsWhereInput
    /**
     * Limit how many CharacterSpells to update.
     */
    limit?: number
  }

  /**
   * CharacterSpells updateManyAndReturn
   */
  export type CharacterSpellsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpells
     */
    select?: CharacterSpellsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSpells
     */
    omit?: CharacterSpellsOmit<ExtArgs> | null
    /**
     * The data used to update CharacterSpells.
     */
    data: XOR<CharacterSpellsUpdateManyMutationInput, CharacterSpellsUncheckedUpdateManyInput>
    /**
     * Filter which CharacterSpells to update
     */
    where?: CharacterSpellsWhereInput
    /**
     * Limit how many CharacterSpells to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSpellsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterSpells upsert
   */
  export type CharacterSpellsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpells
     */
    select?: CharacterSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSpells
     */
    omit?: CharacterSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSpellsInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterSpells to update in case it exists.
     */
    where: CharacterSpellsWhereUniqueInput
    /**
     * In case the CharacterSpells found by the `where` argument doesn't exist, create a new CharacterSpells with this data.
     */
    create: XOR<CharacterSpellsCreateInput, CharacterSpellsUncheckedCreateInput>
    /**
     * In case the CharacterSpells was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterSpellsUpdateInput, CharacterSpellsUncheckedUpdateInput>
  }

  /**
   * CharacterSpells delete
   */
  export type CharacterSpellsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpells
     */
    select?: CharacterSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSpells
     */
    omit?: CharacterSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSpellsInclude<ExtArgs> | null
    /**
     * Filter which CharacterSpells to delete.
     */
    where: CharacterSpellsWhereUniqueInput
  }

  /**
   * CharacterSpells deleteMany
   */
  export type CharacterSpellsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterSpells to delete
     */
    where?: CharacterSpellsWhereInput
    /**
     * Limit how many CharacterSpells to delete.
     */
    limit?: number
  }

  /**
   * CharacterSpells.character
   */
  export type CharacterSpells$characterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
  }

  /**
   * CharacterSpells.spell
   */
  export type CharacterSpells$spellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    where?: SpellWhereInput
  }

  /**
   * CharacterSpells without action
   */
  export type CharacterSpellsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpells
     */
    select?: CharacterSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSpells
     */
    omit?: CharacterSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSpellsInclude<ExtArgs> | null
  }


  /**
   * Model Creature
   */

  export type AggregateCreature = {
    _count: CreatureCountAggregateOutputType | null
    _avg: CreatureAvgAggregateOutputType | null
    _sum: CreatureSumAggregateOutputType | null
    _min: CreatureMinAggregateOutputType | null
    _max: CreatureMaxAggregateOutputType | null
  }

  export type CreatureAvgAggregateOutputType = {
    creatureId: number | null
  }

  export type CreatureSumAggregateOutputType = {
    creatureId: number | null
  }

  export type CreatureMinAggregateOutputType = {
    creatureId: number | null
    name: string | null
    nameEng: string | null
    size: string | null
    type: string | null
    alignment: string | null
    source: $Enums.Source | null
    ac: string | null
    hp: string | null
    speed: string | null
    strength: string | null
    dexterity: string | null
    constitution: string | null
    intelligence: string | null
    wisdom: string | null
    charisma: string | null
    skills: string | null
    senses: string | null
    languages: string | null
    challenge: string | null
    damageImmunity: string | null
    damageResistance: string | null
    conditionImmunity: string | null
    savingThrows: string | null
    specialAbilities: string | null
    actions: string | null
    reactions: string | null
    legendaryActions: string | null
    proficiencyBonus: string | null
    description: string | null
    lairActions: string | null
    lairInfo: string | null
    regionEffects: string | null
    xp: string | null
  }

  export type CreatureMaxAggregateOutputType = {
    creatureId: number | null
    name: string | null
    nameEng: string | null
    size: string | null
    type: string | null
    alignment: string | null
    source: $Enums.Source | null
    ac: string | null
    hp: string | null
    speed: string | null
    strength: string | null
    dexterity: string | null
    constitution: string | null
    intelligence: string | null
    wisdom: string | null
    charisma: string | null
    skills: string | null
    senses: string | null
    languages: string | null
    challenge: string | null
    damageImmunity: string | null
    damageResistance: string | null
    conditionImmunity: string | null
    savingThrows: string | null
    specialAbilities: string | null
    actions: string | null
    reactions: string | null
    legendaryActions: string | null
    proficiencyBonus: string | null
    description: string | null
    lairActions: string | null
    lairInfo: string | null
    regionEffects: string | null
    xp: string | null
  }

  export type CreatureCountAggregateOutputType = {
    creatureId: number
    name: number
    nameEng: number
    size: number
    type: number
    alignment: number
    source: number
    ac: number
    hp: number
    speed: number
    strength: number
    dexterity: number
    constitution: number
    intelligence: number
    wisdom: number
    charisma: number
    skills: number
    senses: number
    languages: number
    challenge: number
    damageImmunity: number
    damageResistance: number
    conditionImmunity: number
    savingThrows: number
    specialAbilities: number
    actions: number
    reactions: number
    legendaryActions: number
    proficiencyBonus: number
    description: number
    lairActions: number
    lairInfo: number
    regionEffects: number
    xp: number
    _all: number
  }


  export type CreatureAvgAggregateInputType = {
    creatureId?: true
  }

  export type CreatureSumAggregateInputType = {
    creatureId?: true
  }

  export type CreatureMinAggregateInputType = {
    creatureId?: true
    name?: true
    nameEng?: true
    size?: true
    type?: true
    alignment?: true
    source?: true
    ac?: true
    hp?: true
    speed?: true
    strength?: true
    dexterity?: true
    constitution?: true
    intelligence?: true
    wisdom?: true
    charisma?: true
    skills?: true
    senses?: true
    languages?: true
    challenge?: true
    damageImmunity?: true
    damageResistance?: true
    conditionImmunity?: true
    savingThrows?: true
    specialAbilities?: true
    actions?: true
    reactions?: true
    legendaryActions?: true
    proficiencyBonus?: true
    description?: true
    lairActions?: true
    lairInfo?: true
    regionEffects?: true
    xp?: true
  }

  export type CreatureMaxAggregateInputType = {
    creatureId?: true
    name?: true
    nameEng?: true
    size?: true
    type?: true
    alignment?: true
    source?: true
    ac?: true
    hp?: true
    speed?: true
    strength?: true
    dexterity?: true
    constitution?: true
    intelligence?: true
    wisdom?: true
    charisma?: true
    skills?: true
    senses?: true
    languages?: true
    challenge?: true
    damageImmunity?: true
    damageResistance?: true
    conditionImmunity?: true
    savingThrows?: true
    specialAbilities?: true
    actions?: true
    reactions?: true
    legendaryActions?: true
    proficiencyBonus?: true
    description?: true
    lairActions?: true
    lairInfo?: true
    regionEffects?: true
    xp?: true
  }

  export type CreatureCountAggregateInputType = {
    creatureId?: true
    name?: true
    nameEng?: true
    size?: true
    type?: true
    alignment?: true
    source?: true
    ac?: true
    hp?: true
    speed?: true
    strength?: true
    dexterity?: true
    constitution?: true
    intelligence?: true
    wisdom?: true
    charisma?: true
    skills?: true
    senses?: true
    languages?: true
    challenge?: true
    damageImmunity?: true
    damageResistance?: true
    conditionImmunity?: true
    savingThrows?: true
    specialAbilities?: true
    actions?: true
    reactions?: true
    legendaryActions?: true
    proficiencyBonus?: true
    description?: true
    lairActions?: true
    lairInfo?: true
    regionEffects?: true
    xp?: true
    _all?: true
  }

  export type CreatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creature to aggregate.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Creatures
    **/
    _count?: true | CreatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatureMaxAggregateInputType
  }

  export type GetCreatureAggregateType<T extends CreatureAggregateArgs> = {
        [P in keyof T & keyof AggregateCreature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreature[P]>
      : GetScalarType<T[P], AggregateCreature[P]>
  }




  export type CreatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithAggregationInput | CreatureOrderByWithAggregationInput[]
    by: CreatureScalarFieldEnum[] | CreatureScalarFieldEnum
    having?: CreatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatureCountAggregateInputType | true
    _avg?: CreatureAvgAggregateInputType
    _sum?: CreatureSumAggregateInputType
    _min?: CreatureMinAggregateInputType
    _max?: CreatureMaxAggregateInputType
  }

  export type CreatureGroupByOutputType = {
    creatureId: number
    name: string | null
    nameEng: string | null
    size: string | null
    type: string | null
    alignment: string | null
    source: $Enums.Source
    ac: string | null
    hp: string | null
    speed: string | null
    strength: string | null
    dexterity: string | null
    constitution: string | null
    intelligence: string | null
    wisdom: string | null
    charisma: string | null
    skills: string | null
    senses: string | null
    languages: string | null
    challenge: string | null
    damageImmunity: string | null
    damageResistance: string | null
    conditionImmunity: string | null
    savingThrows: string | null
    specialAbilities: string | null
    actions: string | null
    reactions: string | null
    legendaryActions: string | null
    proficiencyBonus: string | null
    description: string | null
    lairActions: string | null
    lairInfo: string | null
    regionEffects: string | null
    xp: string | null
    _count: CreatureCountAggregateOutputType | null
    _avg: CreatureAvgAggregateOutputType | null
    _sum: CreatureSumAggregateOutputType | null
    _min: CreatureMinAggregateOutputType | null
    _max: CreatureMaxAggregateOutputType | null
  }

  type GetCreatureGroupByPayload<T extends CreatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatureGroupByOutputType[P]>
            : GetScalarType<T[P], CreatureGroupByOutputType[P]>
        }
      >
    >


  export type CreatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    creatureId?: boolean
    name?: boolean
    nameEng?: boolean
    size?: boolean
    type?: boolean
    alignment?: boolean
    source?: boolean
    ac?: boolean
    hp?: boolean
    speed?: boolean
    strength?: boolean
    dexterity?: boolean
    constitution?: boolean
    intelligence?: boolean
    wisdom?: boolean
    charisma?: boolean
    skills?: boolean
    senses?: boolean
    languages?: boolean
    challenge?: boolean
    damageImmunity?: boolean
    damageResistance?: boolean
    conditionImmunity?: boolean
    savingThrows?: boolean
    specialAbilities?: boolean
    actions?: boolean
    reactions?: boolean
    legendaryActions?: boolean
    proficiencyBonus?: boolean
    description?: boolean
    lairActions?: boolean
    lairInfo?: boolean
    regionEffects?: boolean
    xp?: boolean
  }, ExtArgs["result"]["creature"]>

  export type CreatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    creatureId?: boolean
    name?: boolean
    nameEng?: boolean
    size?: boolean
    type?: boolean
    alignment?: boolean
    source?: boolean
    ac?: boolean
    hp?: boolean
    speed?: boolean
    strength?: boolean
    dexterity?: boolean
    constitution?: boolean
    intelligence?: boolean
    wisdom?: boolean
    charisma?: boolean
    skills?: boolean
    senses?: boolean
    languages?: boolean
    challenge?: boolean
    damageImmunity?: boolean
    damageResistance?: boolean
    conditionImmunity?: boolean
    savingThrows?: boolean
    specialAbilities?: boolean
    actions?: boolean
    reactions?: boolean
    legendaryActions?: boolean
    proficiencyBonus?: boolean
    description?: boolean
    lairActions?: boolean
    lairInfo?: boolean
    regionEffects?: boolean
    xp?: boolean
  }, ExtArgs["result"]["creature"]>

  export type CreatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    creatureId?: boolean
    name?: boolean
    nameEng?: boolean
    size?: boolean
    type?: boolean
    alignment?: boolean
    source?: boolean
    ac?: boolean
    hp?: boolean
    speed?: boolean
    strength?: boolean
    dexterity?: boolean
    constitution?: boolean
    intelligence?: boolean
    wisdom?: boolean
    charisma?: boolean
    skills?: boolean
    senses?: boolean
    languages?: boolean
    challenge?: boolean
    damageImmunity?: boolean
    damageResistance?: boolean
    conditionImmunity?: boolean
    savingThrows?: boolean
    specialAbilities?: boolean
    actions?: boolean
    reactions?: boolean
    legendaryActions?: boolean
    proficiencyBonus?: boolean
    description?: boolean
    lairActions?: boolean
    lairInfo?: boolean
    regionEffects?: boolean
    xp?: boolean
  }, ExtArgs["result"]["creature"]>

  export type CreatureSelectScalar = {
    creatureId?: boolean
    name?: boolean
    nameEng?: boolean
    size?: boolean
    type?: boolean
    alignment?: boolean
    source?: boolean
    ac?: boolean
    hp?: boolean
    speed?: boolean
    strength?: boolean
    dexterity?: boolean
    constitution?: boolean
    intelligence?: boolean
    wisdom?: boolean
    charisma?: boolean
    skills?: boolean
    senses?: boolean
    languages?: boolean
    challenge?: boolean
    damageImmunity?: boolean
    damageResistance?: boolean
    conditionImmunity?: boolean
    savingThrows?: boolean
    specialAbilities?: boolean
    actions?: boolean
    reactions?: boolean
    legendaryActions?: boolean
    proficiencyBonus?: boolean
    description?: boolean
    lairActions?: boolean
    lairInfo?: boolean
    regionEffects?: boolean
    xp?: boolean
  }

  export type CreatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"creatureId" | "name" | "nameEng" | "size" | "type" | "alignment" | "source" | "ac" | "hp" | "speed" | "strength" | "dexterity" | "constitution" | "intelligence" | "wisdom" | "charisma" | "skills" | "senses" | "languages" | "challenge" | "damageImmunity" | "damageResistance" | "conditionImmunity" | "savingThrows" | "specialAbilities" | "actions" | "reactions" | "legendaryActions" | "proficiencyBonus" | "description" | "lairActions" | "lairInfo" | "regionEffects" | "xp", ExtArgs["result"]["creature"]>

  export type $CreaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Creature"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      creatureId: number
      name: string | null
      nameEng: string | null
      size: string | null
      type: string | null
      alignment: string | null
      source: $Enums.Source
      ac: string | null
      hp: string | null
      speed: string | null
      strength: string | null
      dexterity: string | null
      constitution: string | null
      intelligence: string | null
      wisdom: string | null
      charisma: string | null
      skills: string | null
      senses: string | null
      languages: string | null
      challenge: string | null
      damageImmunity: string | null
      damageResistance: string | null
      conditionImmunity: string | null
      savingThrows: string | null
      specialAbilities: string | null
      actions: string | null
      reactions: string | null
      legendaryActions: string | null
      proficiencyBonus: string | null
      description: string | null
      lairActions: string | null
      lairInfo: string | null
      regionEffects: string | null
      xp: string | null
    }, ExtArgs["result"]["creature"]>
    composites: {}
  }

  type CreatureGetPayload<S extends boolean | null | undefined | CreatureDefaultArgs> = $Result.GetResult<Prisma.$CreaturePayload, S>

  type CreatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreatureCountAggregateInputType | true
    }

  export interface CreatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Creature'], meta: { name: 'Creature' } }
    /**
     * Find zero or one Creature that matches the filter.
     * @param {CreatureFindUniqueArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatureFindUniqueArgs>(args: SelectSubset<T, CreatureFindUniqueArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Creature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreatureFindUniqueOrThrowArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatureFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Creature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureFindFirstArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatureFindFirstArgs>(args?: SelectSubset<T, CreatureFindFirstArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Creature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureFindFirstOrThrowArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatureFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Creatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Creatures
     * const creatures = await prisma.creature.findMany()
     * 
     * // Get first 10 Creatures
     * const creatures = await prisma.creature.findMany({ take: 10 })
     * 
     * // Only select the `creatureId`
     * const creatureWithCreatureIdOnly = await prisma.creature.findMany({ select: { creatureId: true } })
     * 
     */
    findMany<T extends CreatureFindManyArgs>(args?: SelectSubset<T, CreatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Creature.
     * @param {CreatureCreateArgs} args - Arguments to create a Creature.
     * @example
     * // Create one Creature
     * const Creature = await prisma.creature.create({
     *   data: {
     *     // ... data to create a Creature
     *   }
     * })
     * 
     */
    create<T extends CreatureCreateArgs>(args: SelectSubset<T, CreatureCreateArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Creatures.
     * @param {CreatureCreateManyArgs} args - Arguments to create many Creatures.
     * @example
     * // Create many Creatures
     * const creature = await prisma.creature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatureCreateManyArgs>(args?: SelectSubset<T, CreatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Creatures and returns the data saved in the database.
     * @param {CreatureCreateManyAndReturnArgs} args - Arguments to create many Creatures.
     * @example
     * // Create many Creatures
     * const creature = await prisma.creature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Creatures and only return the `creatureId`
     * const creatureWithCreatureIdOnly = await prisma.creature.createManyAndReturn({
     *   select: { creatureId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatureCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Creature.
     * @param {CreatureDeleteArgs} args - Arguments to delete one Creature.
     * @example
     * // Delete one Creature
     * const Creature = await prisma.creature.delete({
     *   where: {
     *     // ... filter to delete one Creature
     *   }
     * })
     * 
     */
    delete<T extends CreatureDeleteArgs>(args: SelectSubset<T, CreatureDeleteArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Creature.
     * @param {CreatureUpdateArgs} args - Arguments to update one Creature.
     * @example
     * // Update one Creature
     * const creature = await prisma.creature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatureUpdateArgs>(args: SelectSubset<T, CreatureUpdateArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Creatures.
     * @param {CreatureDeleteManyArgs} args - Arguments to filter Creatures to delete.
     * @example
     * // Delete a few Creatures
     * const { count } = await prisma.creature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatureDeleteManyArgs>(args?: SelectSubset<T, CreatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Creatures
     * const creature = await prisma.creature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatureUpdateManyArgs>(args: SelectSubset<T, CreatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creatures and returns the data updated in the database.
     * @param {CreatureUpdateManyAndReturnArgs} args - Arguments to update many Creatures.
     * @example
     * // Update many Creatures
     * const creature = await prisma.creature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Creatures and only return the `creatureId`
     * const creatureWithCreatureIdOnly = await prisma.creature.updateManyAndReturn({
     *   select: { creatureId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreatureUpdateManyAndReturnArgs>(args: SelectSubset<T, CreatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Creature.
     * @param {CreatureUpsertArgs} args - Arguments to update or create a Creature.
     * @example
     * // Update or create a Creature
     * const creature = await prisma.creature.upsert({
     *   create: {
     *     // ... data to create a Creature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Creature we want to update
     *   }
     * })
     */
    upsert<T extends CreatureUpsertArgs>(args: SelectSubset<T, CreatureUpsertArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Creatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureCountArgs} args - Arguments to filter Creatures to count.
     * @example
     * // Count the number of Creatures
     * const count = await prisma.creature.count({
     *   where: {
     *     // ... the filter for the Creatures we want to count
     *   }
     * })
    **/
    count<T extends CreatureCountArgs>(
      args?: Subset<T, CreatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Creature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatureAggregateArgs>(args: Subset<T, CreatureAggregateArgs>): Prisma.PrismaPromise<GetCreatureAggregateType<T>>

    /**
     * Group by Creature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatureGroupByArgs['orderBy'] }
        : { orderBy?: CreatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Creature model
   */
  readonly fields: CreatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Creature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Creature model
   */
  interface CreatureFieldRefs {
    readonly creatureId: FieldRef<"Creature", 'Int'>
    readonly name: FieldRef<"Creature", 'String'>
    readonly nameEng: FieldRef<"Creature", 'String'>
    readonly size: FieldRef<"Creature", 'String'>
    readonly type: FieldRef<"Creature", 'String'>
    readonly alignment: FieldRef<"Creature", 'String'>
    readonly source: FieldRef<"Creature", 'Source'>
    readonly ac: FieldRef<"Creature", 'String'>
    readonly hp: FieldRef<"Creature", 'String'>
    readonly speed: FieldRef<"Creature", 'String'>
    readonly strength: FieldRef<"Creature", 'String'>
    readonly dexterity: FieldRef<"Creature", 'String'>
    readonly constitution: FieldRef<"Creature", 'String'>
    readonly intelligence: FieldRef<"Creature", 'String'>
    readonly wisdom: FieldRef<"Creature", 'String'>
    readonly charisma: FieldRef<"Creature", 'String'>
    readonly skills: FieldRef<"Creature", 'String'>
    readonly senses: FieldRef<"Creature", 'String'>
    readonly languages: FieldRef<"Creature", 'String'>
    readonly challenge: FieldRef<"Creature", 'String'>
    readonly damageImmunity: FieldRef<"Creature", 'String'>
    readonly damageResistance: FieldRef<"Creature", 'String'>
    readonly conditionImmunity: FieldRef<"Creature", 'String'>
    readonly savingThrows: FieldRef<"Creature", 'String'>
    readonly specialAbilities: FieldRef<"Creature", 'String'>
    readonly actions: FieldRef<"Creature", 'String'>
    readonly reactions: FieldRef<"Creature", 'String'>
    readonly legendaryActions: FieldRef<"Creature", 'String'>
    readonly proficiencyBonus: FieldRef<"Creature", 'String'>
    readonly description: FieldRef<"Creature", 'String'>
    readonly lairActions: FieldRef<"Creature", 'String'>
    readonly lairInfo: FieldRef<"Creature", 'String'>
    readonly regionEffects: FieldRef<"Creature", 'String'>
    readonly xp: FieldRef<"Creature", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Creature findUnique
   */
  export type CreatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature findUniqueOrThrow
   */
  export type CreatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature findFirst
   */
  export type CreatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creatures.
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creatures.
     */
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Creature findFirstOrThrow
   */
  export type CreatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creatures.
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creatures.
     */
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Creature findMany
   */
  export type CreatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Filter, which Creatures to fetch.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Creatures.
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Creature create
   */
  export type CreatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * The data needed to create a Creature.
     */
    data?: XOR<CreatureCreateInput, CreatureUncheckedCreateInput>
  }

  /**
   * Creature createMany
   */
  export type CreatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Creatures.
     */
    data: CreatureCreateManyInput | CreatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Creature createManyAndReturn
   */
  export type CreatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * The data used to create many Creatures.
     */
    data: CreatureCreateManyInput | CreatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Creature update
   */
  export type CreatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * The data needed to update a Creature.
     */
    data: XOR<CreatureUpdateInput, CreatureUncheckedUpdateInput>
    /**
     * Choose, which Creature to update.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature updateMany
   */
  export type CreatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Creatures.
     */
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyInput>
    /**
     * Filter which Creatures to update
     */
    where?: CreatureWhereInput
    /**
     * Limit how many Creatures to update.
     */
    limit?: number
  }

  /**
   * Creature updateManyAndReturn
   */
  export type CreatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * The data used to update Creatures.
     */
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyInput>
    /**
     * Filter which Creatures to update
     */
    where?: CreatureWhereInput
    /**
     * Limit how many Creatures to update.
     */
    limit?: number
  }

  /**
   * Creature upsert
   */
  export type CreatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * The filter to search for the Creature to update in case it exists.
     */
    where: CreatureWhereUniqueInput
    /**
     * In case the Creature found by the `where` argument doesn't exist, create a new Creature with this data.
     */
    create: XOR<CreatureCreateInput, CreatureUncheckedCreateInput>
    /**
     * In case the Creature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatureUpdateInput, CreatureUncheckedUpdateInput>
  }

  /**
   * Creature delete
   */
  export type CreatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Filter which Creature to delete.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature deleteMany
   */
  export type CreatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creatures to delete
     */
    where?: CreatureWhereInput
    /**
     * Limit how many Creatures to delete.
     */
    limit?: number
  }

  /**
   * Creature without action
   */
  export type CreatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
  }


  /**
   * Model Spell
   */

  export type AggregateSpell = {
    _count: SpellCountAggregateOutputType | null
    _avg: SpellAvgAggregateOutputType | null
    _sum: SpellSumAggregateOutputType | null
    _min: SpellMinAggregateOutputType | null
    _max: SpellMaxAggregateOutputType | null
  }

  export type SpellAvgAggregateOutputType = {
    spellId: number | null
    level: number | null
  }

  export type SpellSumAggregateOutputType = {
    spellId: number | null
    level: number | null
  }

  export type SpellMinAggregateOutputType = {
    spellId: number | null
    name: string | null
    level: number | null
    school: string | null
    castingTime: string | null
    range: string | null
    components: string | null
    duration: string | null
    description: string | null
    hasRitual: string | null
    hasConcentration: string | null
    source: $Enums.Source | null
  }

  export type SpellMaxAggregateOutputType = {
    spellId: number | null
    name: string | null
    level: number | null
    school: string | null
    castingTime: string | null
    range: string | null
    components: string | null
    duration: string | null
    description: string | null
    hasRitual: string | null
    hasConcentration: string | null
    source: $Enums.Source | null
  }

  export type SpellCountAggregateOutputType = {
    spellId: number
    name: number
    level: number
    school: number
    castingTime: number
    range: number
    components: number
    duration: number
    description: number
    hasRitual: number
    hasConcentration: number
    source: number
    _all: number
  }


  export type SpellAvgAggregateInputType = {
    spellId?: true
    level?: true
  }

  export type SpellSumAggregateInputType = {
    spellId?: true
    level?: true
  }

  export type SpellMinAggregateInputType = {
    spellId?: true
    name?: true
    level?: true
    school?: true
    castingTime?: true
    range?: true
    components?: true
    duration?: true
    description?: true
    hasRitual?: true
    hasConcentration?: true
    source?: true
  }

  export type SpellMaxAggregateInputType = {
    spellId?: true
    name?: true
    level?: true
    school?: true
    castingTime?: true
    range?: true
    components?: true
    duration?: true
    description?: true
    hasRitual?: true
    hasConcentration?: true
    source?: true
  }

  export type SpellCountAggregateInputType = {
    spellId?: true
    name?: true
    level?: true
    school?: true
    castingTime?: true
    range?: true
    components?: true
    duration?: true
    description?: true
    hasRitual?: true
    hasConcentration?: true
    source?: true
    _all?: true
  }

  export type SpellAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spell to aggregate.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Spells
    **/
    _count?: true | SpellCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellMaxAggregateInputType
  }

  export type GetSpellAggregateType<T extends SpellAggregateArgs> = {
        [P in keyof T & keyof AggregateSpell]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpell[P]>
      : GetScalarType<T[P], AggregateSpell[P]>
  }




  export type SpellGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellWhereInput
    orderBy?: SpellOrderByWithAggregationInput | SpellOrderByWithAggregationInput[]
    by: SpellScalarFieldEnum[] | SpellScalarFieldEnum
    having?: SpellScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellCountAggregateInputType | true
    _avg?: SpellAvgAggregateInputType
    _sum?: SpellSumAggregateInputType
    _min?: SpellMinAggregateInputType
    _max?: SpellMaxAggregateInputType
  }

  export type SpellGroupByOutputType = {
    spellId: number
    name: string
    level: number
    school: string | null
    castingTime: string
    range: string
    components: string | null
    duration: string
    description: string
    hasRitual: string | null
    hasConcentration: string | null
    source: $Enums.Source
    _count: SpellCountAggregateOutputType | null
    _avg: SpellAvgAggregateOutputType | null
    _sum: SpellSumAggregateOutputType | null
    _min: SpellMinAggregateOutputType | null
    _max: SpellMaxAggregateOutputType | null
  }

  type GetSpellGroupByPayload<T extends SpellGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellGroupByOutputType[P]>
            : GetScalarType<T[P], SpellGroupByOutputType[P]>
        }
      >
    >


  export type SpellSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    spellId?: boolean
    name?: boolean
    level?: boolean
    school?: boolean
    castingTime?: boolean
    range?: boolean
    components?: boolean
    duration?: boolean
    description?: boolean
    hasRitual?: boolean
    hasConcentration?: boolean
    source?: boolean
    characterSpells?: boolean | Spell$characterSpellsArgs<ExtArgs>
    spellClasses?: boolean | Spell$spellClassesArgs<ExtArgs>
    spellRaces?: boolean | Spell$spellRacesArgs<ExtArgs>
    spellbookSpells?: boolean | Spell$spellbookSpellsArgs<ExtArgs>
    subclasses?: boolean | Spell$subclassesArgs<ExtArgs>
    perses?: boolean | Spell$persesArgs<ExtArgs>
    features?: boolean | Spell$featuresArgs<ExtArgs>
    _count?: boolean | SpellCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spell"]>

  export type SpellSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    spellId?: boolean
    name?: boolean
    level?: boolean
    school?: boolean
    castingTime?: boolean
    range?: boolean
    components?: boolean
    duration?: boolean
    description?: boolean
    hasRitual?: boolean
    hasConcentration?: boolean
    source?: boolean
  }, ExtArgs["result"]["spell"]>

  export type SpellSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    spellId?: boolean
    name?: boolean
    level?: boolean
    school?: boolean
    castingTime?: boolean
    range?: boolean
    components?: boolean
    duration?: boolean
    description?: boolean
    hasRitual?: boolean
    hasConcentration?: boolean
    source?: boolean
  }, ExtArgs["result"]["spell"]>

  export type SpellSelectScalar = {
    spellId?: boolean
    name?: boolean
    level?: boolean
    school?: boolean
    castingTime?: boolean
    range?: boolean
    components?: boolean
    duration?: boolean
    description?: boolean
    hasRitual?: boolean
    hasConcentration?: boolean
    source?: boolean
  }

  export type SpellOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"spellId" | "name" | "level" | "school" | "castingTime" | "range" | "components" | "duration" | "description" | "hasRitual" | "hasConcentration" | "source", ExtArgs["result"]["spell"]>
  export type SpellInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characterSpells?: boolean | Spell$characterSpellsArgs<ExtArgs>
    spellClasses?: boolean | Spell$spellClassesArgs<ExtArgs>
    spellRaces?: boolean | Spell$spellRacesArgs<ExtArgs>
    spellbookSpells?: boolean | Spell$spellbookSpellsArgs<ExtArgs>
    subclasses?: boolean | Spell$subclassesArgs<ExtArgs>
    perses?: boolean | Spell$persesArgs<ExtArgs>
    features?: boolean | Spell$featuresArgs<ExtArgs>
    _count?: boolean | SpellCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpellIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SpellIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SpellPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Spell"
    objects: {
      characterSpells: Prisma.$CharacterSpellsPayload<ExtArgs>[]
      spellClasses: Prisma.$SpellClassesPayload<ExtArgs>[]
      spellRaces: Prisma.$SpellRacesPayload<ExtArgs>[]
      spellbookSpells: Prisma.$SpellbookSpellsPayload<ExtArgs>[]
      subclasses: Prisma.$SubclassPayload<ExtArgs>[]
      perses: Prisma.$PersPayload<ExtArgs>[]
      features: Prisma.$FeaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      spellId: number
      name: string
      level: number
      school: string | null
      castingTime: string
      range: string
      components: string | null
      duration: string
      description: string
      hasRitual: string | null
      hasConcentration: string | null
      source: $Enums.Source
    }, ExtArgs["result"]["spell"]>
    composites: {}
  }

  type SpellGetPayload<S extends boolean | null | undefined | SpellDefaultArgs> = $Result.GetResult<Prisma.$SpellPayload, S>

  type SpellCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpellFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpellCountAggregateInputType | true
    }

  export interface SpellDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Spell'], meta: { name: 'Spell' } }
    /**
     * Find zero or one Spell that matches the filter.
     * @param {SpellFindUniqueArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpellFindUniqueArgs>(args: SelectSubset<T, SpellFindUniqueArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Spell that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpellFindUniqueOrThrowArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpellFindUniqueOrThrowArgs>(args: SelectSubset<T, SpellFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Spell that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellFindFirstArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpellFindFirstArgs>(args?: SelectSubset<T, SpellFindFirstArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Spell that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellFindFirstOrThrowArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpellFindFirstOrThrowArgs>(args?: SelectSubset<T, SpellFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Spells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spells
     * const spells = await prisma.spell.findMany()
     * 
     * // Get first 10 Spells
     * const spells = await prisma.spell.findMany({ take: 10 })
     * 
     * // Only select the `spellId`
     * const spellWithSpellIdOnly = await prisma.spell.findMany({ select: { spellId: true } })
     * 
     */
    findMany<T extends SpellFindManyArgs>(args?: SelectSubset<T, SpellFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Spell.
     * @param {SpellCreateArgs} args - Arguments to create a Spell.
     * @example
     * // Create one Spell
     * const Spell = await prisma.spell.create({
     *   data: {
     *     // ... data to create a Spell
     *   }
     * })
     * 
     */
    create<T extends SpellCreateArgs>(args: SelectSubset<T, SpellCreateArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Spells.
     * @param {SpellCreateManyArgs} args - Arguments to create many Spells.
     * @example
     * // Create many Spells
     * const spell = await prisma.spell.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpellCreateManyArgs>(args?: SelectSubset<T, SpellCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Spells and returns the data saved in the database.
     * @param {SpellCreateManyAndReturnArgs} args - Arguments to create many Spells.
     * @example
     * // Create many Spells
     * const spell = await prisma.spell.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Spells and only return the `spellId`
     * const spellWithSpellIdOnly = await prisma.spell.createManyAndReturn({
     *   select: { spellId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpellCreateManyAndReturnArgs>(args?: SelectSubset<T, SpellCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Spell.
     * @param {SpellDeleteArgs} args - Arguments to delete one Spell.
     * @example
     * // Delete one Spell
     * const Spell = await prisma.spell.delete({
     *   where: {
     *     // ... filter to delete one Spell
     *   }
     * })
     * 
     */
    delete<T extends SpellDeleteArgs>(args: SelectSubset<T, SpellDeleteArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Spell.
     * @param {SpellUpdateArgs} args - Arguments to update one Spell.
     * @example
     * // Update one Spell
     * const spell = await prisma.spell.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpellUpdateArgs>(args: SelectSubset<T, SpellUpdateArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Spells.
     * @param {SpellDeleteManyArgs} args - Arguments to filter Spells to delete.
     * @example
     * // Delete a few Spells
     * const { count } = await prisma.spell.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpellDeleteManyArgs>(args?: SelectSubset<T, SpellDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spells
     * const spell = await prisma.spell.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpellUpdateManyArgs>(args: SelectSubset<T, SpellUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spells and returns the data updated in the database.
     * @param {SpellUpdateManyAndReturnArgs} args - Arguments to update many Spells.
     * @example
     * // Update many Spells
     * const spell = await prisma.spell.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Spells and only return the `spellId`
     * const spellWithSpellIdOnly = await prisma.spell.updateManyAndReturn({
     *   select: { spellId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpellUpdateManyAndReturnArgs>(args: SelectSubset<T, SpellUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Spell.
     * @param {SpellUpsertArgs} args - Arguments to update or create a Spell.
     * @example
     * // Update or create a Spell
     * const spell = await prisma.spell.upsert({
     *   create: {
     *     // ... data to create a Spell
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Spell we want to update
     *   }
     * })
     */
    upsert<T extends SpellUpsertArgs>(args: SelectSubset<T, SpellUpsertArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Spells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellCountArgs} args - Arguments to filter Spells to count.
     * @example
     * // Count the number of Spells
     * const count = await prisma.spell.count({
     *   where: {
     *     // ... the filter for the Spells we want to count
     *   }
     * })
    **/
    count<T extends SpellCountArgs>(
      args?: Subset<T, SpellCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Spell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellAggregateArgs>(args: Subset<T, SpellAggregateArgs>): Prisma.PrismaPromise<GetSpellAggregateType<T>>

    /**
     * Group by Spell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellGroupByArgs['orderBy'] }
        : { orderBy?: SpellGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Spell model
   */
  readonly fields: SpellFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Spell.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characterSpells<T extends Spell$characterSpellsArgs<ExtArgs> = {}>(args?: Subset<T, Spell$characterSpellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSpellsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spellClasses<T extends Spell$spellClassesArgs<ExtArgs> = {}>(args?: Subset<T, Spell$spellClassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellClassesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spellRaces<T extends Spell$spellRacesArgs<ExtArgs> = {}>(args?: Subset<T, Spell$spellRacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellRacesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spellbookSpells<T extends Spell$spellbookSpellsArgs<ExtArgs> = {}>(args?: Subset<T, Spell$spellbookSpellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellbookSpellsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subclasses<T extends Spell$subclassesArgs<ExtArgs> = {}>(args?: Subset<T, Spell$subclassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    perses<T extends Spell$persesArgs<ExtArgs> = {}>(args?: Subset<T, Spell$persesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    features<T extends Spell$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Spell$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Spell model
   */
  interface SpellFieldRefs {
    readonly spellId: FieldRef<"Spell", 'Int'>
    readonly name: FieldRef<"Spell", 'String'>
    readonly level: FieldRef<"Spell", 'Int'>
    readonly school: FieldRef<"Spell", 'String'>
    readonly castingTime: FieldRef<"Spell", 'String'>
    readonly range: FieldRef<"Spell", 'String'>
    readonly components: FieldRef<"Spell", 'String'>
    readonly duration: FieldRef<"Spell", 'String'>
    readonly description: FieldRef<"Spell", 'String'>
    readonly hasRitual: FieldRef<"Spell", 'String'>
    readonly hasConcentration: FieldRef<"Spell", 'String'>
    readonly source: FieldRef<"Spell", 'Source'>
  }
    

  // Custom InputTypes
  /**
   * Spell findUnique
   */
  export type SpellFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where: SpellWhereUniqueInput
  }

  /**
   * Spell findUniqueOrThrow
   */
  export type SpellFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where: SpellWhereUniqueInput
  }

  /**
   * Spell findFirst
   */
  export type SpellFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spells.
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spells.
     */
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }

  /**
   * Spell findFirstOrThrow
   */
  export type SpellFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spells.
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spells.
     */
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }

  /**
   * Spell findMany
   */
  export type SpellFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spells to fetch.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Spells.
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }

  /**
   * Spell create
   */
  export type SpellCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * The data needed to create a Spell.
     */
    data: XOR<SpellCreateInput, SpellUncheckedCreateInput>
  }

  /**
   * Spell createMany
   */
  export type SpellCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Spells.
     */
    data: SpellCreateManyInput | SpellCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Spell createManyAndReturn
   */
  export type SpellCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * The data used to create many Spells.
     */
    data: SpellCreateManyInput | SpellCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Spell update
   */
  export type SpellUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * The data needed to update a Spell.
     */
    data: XOR<SpellUpdateInput, SpellUncheckedUpdateInput>
    /**
     * Choose, which Spell to update.
     */
    where: SpellWhereUniqueInput
  }

  /**
   * Spell updateMany
   */
  export type SpellUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Spells.
     */
    data: XOR<SpellUpdateManyMutationInput, SpellUncheckedUpdateManyInput>
    /**
     * Filter which Spells to update
     */
    where?: SpellWhereInput
    /**
     * Limit how many Spells to update.
     */
    limit?: number
  }

  /**
   * Spell updateManyAndReturn
   */
  export type SpellUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * The data used to update Spells.
     */
    data: XOR<SpellUpdateManyMutationInput, SpellUncheckedUpdateManyInput>
    /**
     * Filter which Spells to update
     */
    where?: SpellWhereInput
    /**
     * Limit how many Spells to update.
     */
    limit?: number
  }

  /**
   * Spell upsert
   */
  export type SpellUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * The filter to search for the Spell to update in case it exists.
     */
    where: SpellWhereUniqueInput
    /**
     * In case the Spell found by the `where` argument doesn't exist, create a new Spell with this data.
     */
    create: XOR<SpellCreateInput, SpellUncheckedCreateInput>
    /**
     * In case the Spell was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellUpdateInput, SpellUncheckedUpdateInput>
  }

  /**
   * Spell delete
   */
  export type SpellDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter which Spell to delete.
     */
    where: SpellWhereUniqueInput
  }

  /**
   * Spell deleteMany
   */
  export type SpellDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spells to delete
     */
    where?: SpellWhereInput
    /**
     * Limit how many Spells to delete.
     */
    limit?: number
  }

  /**
   * Spell.characterSpells
   */
  export type Spell$characterSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpells
     */
    select?: CharacterSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSpells
     */
    omit?: CharacterSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSpellsInclude<ExtArgs> | null
    where?: CharacterSpellsWhereInput
    orderBy?: CharacterSpellsOrderByWithRelationInput | CharacterSpellsOrderByWithRelationInput[]
    cursor?: CharacterSpellsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterSpellsScalarFieldEnum | CharacterSpellsScalarFieldEnum[]
  }

  /**
   * Spell.spellClasses
   */
  export type Spell$spellClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClasses
     */
    select?: SpellClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellClasses
     */
    omit?: SpellClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellClassesInclude<ExtArgs> | null
    where?: SpellClassesWhereInput
    orderBy?: SpellClassesOrderByWithRelationInput | SpellClassesOrderByWithRelationInput[]
    cursor?: SpellClassesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellClassesScalarFieldEnum | SpellClassesScalarFieldEnum[]
  }

  /**
   * Spell.spellRaces
   */
  export type Spell$spellRacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRaces
     */
    select?: SpellRacesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellRaces
     */
    omit?: SpellRacesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellRacesInclude<ExtArgs> | null
    where?: SpellRacesWhereInput
    orderBy?: SpellRacesOrderByWithRelationInput | SpellRacesOrderByWithRelationInput[]
    cursor?: SpellRacesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellRacesScalarFieldEnum | SpellRacesScalarFieldEnum[]
  }

  /**
   * Spell.spellbookSpells
   */
  export type Spell$spellbookSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellbookSpells
     */
    select?: SpellbookSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellbookSpells
     */
    omit?: SpellbookSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookSpellsInclude<ExtArgs> | null
    where?: SpellbookSpellsWhereInput
    orderBy?: SpellbookSpellsOrderByWithRelationInput | SpellbookSpellsOrderByWithRelationInput[]
    cursor?: SpellbookSpellsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellbookSpellsScalarFieldEnum | SpellbookSpellsScalarFieldEnum[]
  }

  /**
   * Spell.subclasses
   */
  export type Spell$subclassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassInclude<ExtArgs> | null
    where?: SubclassWhereInput
    orderBy?: SubclassOrderByWithRelationInput | SubclassOrderByWithRelationInput[]
    cursor?: SubclassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubclassScalarFieldEnum | SubclassScalarFieldEnum[]
  }

  /**
   * Spell.perses
   */
  export type Spell$persesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    where?: PersWhereInput
    orderBy?: PersOrderByWithRelationInput | PersOrderByWithRelationInput[]
    cursor?: PersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersScalarFieldEnum | PersScalarFieldEnum[]
  }

  /**
   * Spell.features
   */
  export type Spell$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    where?: FeatureWhereInput
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    cursor?: FeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Spell without action
   */
  export type SpellDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
  }


  /**
   * Model SpellClasses
   */

  export type AggregateSpellClasses = {
    _count: SpellClassesCountAggregateOutputType | null
    _avg: SpellClassesAvgAggregateOutputType | null
    _sum: SpellClassesSumAggregateOutputType | null
    _min: SpellClassesMinAggregateOutputType | null
    _max: SpellClassesMaxAggregateOutputType | null
  }

  export type SpellClassesAvgAggregateOutputType = {
    classId: number | null
    spellId: number | null
  }

  export type SpellClassesSumAggregateOutputType = {
    classId: number | null
    spellId: number | null
  }

  export type SpellClassesMinAggregateOutputType = {
    classId: number | null
    spellId: number | null
    className: string | null
  }

  export type SpellClassesMaxAggregateOutputType = {
    classId: number | null
    spellId: number | null
    className: string | null
  }

  export type SpellClassesCountAggregateOutputType = {
    classId: number
    spellId: number
    className: number
    _all: number
  }


  export type SpellClassesAvgAggregateInputType = {
    classId?: true
    spellId?: true
  }

  export type SpellClassesSumAggregateInputType = {
    classId?: true
    spellId?: true
  }

  export type SpellClassesMinAggregateInputType = {
    classId?: true
    spellId?: true
    className?: true
  }

  export type SpellClassesMaxAggregateInputType = {
    classId?: true
    spellId?: true
    className?: true
  }

  export type SpellClassesCountAggregateInputType = {
    classId?: true
    spellId?: true
    className?: true
    _all?: true
  }

  export type SpellClassesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellClasses to aggregate.
     */
    where?: SpellClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellClasses to fetch.
     */
    orderBy?: SpellClassesOrderByWithRelationInput | SpellClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellClasses
    **/
    _count?: true | SpellClassesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellClassesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellClassesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellClassesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellClassesMaxAggregateInputType
  }

  export type GetSpellClassesAggregateType<T extends SpellClassesAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellClasses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellClasses[P]>
      : GetScalarType<T[P], AggregateSpellClasses[P]>
  }




  export type SpellClassesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellClassesWhereInput
    orderBy?: SpellClassesOrderByWithAggregationInput | SpellClassesOrderByWithAggregationInput[]
    by: SpellClassesScalarFieldEnum[] | SpellClassesScalarFieldEnum
    having?: SpellClassesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellClassesCountAggregateInputType | true
    _avg?: SpellClassesAvgAggregateInputType
    _sum?: SpellClassesSumAggregateInputType
    _min?: SpellClassesMinAggregateInputType
    _max?: SpellClassesMaxAggregateInputType
  }

  export type SpellClassesGroupByOutputType = {
    classId: number
    spellId: number
    className: string
    _count: SpellClassesCountAggregateOutputType | null
    _avg: SpellClassesAvgAggregateOutputType | null
    _sum: SpellClassesSumAggregateOutputType | null
    _min: SpellClassesMinAggregateOutputType | null
    _max: SpellClassesMaxAggregateOutputType | null
  }

  type GetSpellClassesGroupByPayload<T extends SpellClassesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellClassesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellClassesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellClassesGroupByOutputType[P]>
            : GetScalarType<T[P], SpellClassesGroupByOutputType[P]>
        }
      >
    >


  export type SpellClassesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classId?: boolean
    spellId?: boolean
    className?: boolean
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellClasses"]>

  export type SpellClassesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classId?: boolean
    spellId?: boolean
    className?: boolean
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellClasses"]>

  export type SpellClassesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classId?: boolean
    spellId?: boolean
    className?: boolean
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellClasses"]>

  export type SpellClassesSelectScalar = {
    classId?: boolean
    spellId?: boolean
    className?: boolean
  }

  export type SpellClassesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"classId" | "spellId" | "className", ExtArgs["result"]["spellClasses"]>
  export type SpellClassesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }
  export type SpellClassesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }
  export type SpellClassesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }

  export type $SpellClassesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellClasses"
    objects: {
      spell: Prisma.$SpellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      classId: number
      spellId: number
      className: string
    }, ExtArgs["result"]["spellClasses"]>
    composites: {}
  }

  type SpellClassesGetPayload<S extends boolean | null | undefined | SpellClassesDefaultArgs> = $Result.GetResult<Prisma.$SpellClassesPayload, S>

  type SpellClassesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpellClassesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpellClassesCountAggregateInputType | true
    }

  export interface SpellClassesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellClasses'], meta: { name: 'SpellClasses' } }
    /**
     * Find zero or one SpellClasses that matches the filter.
     * @param {SpellClassesFindUniqueArgs} args - Arguments to find a SpellClasses
     * @example
     * // Get one SpellClasses
     * const spellClasses = await prisma.spellClasses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpellClassesFindUniqueArgs>(args: SelectSubset<T, SpellClassesFindUniqueArgs<ExtArgs>>): Prisma__SpellClassesClient<$Result.GetResult<Prisma.$SpellClassesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpellClasses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpellClassesFindUniqueOrThrowArgs} args - Arguments to find a SpellClasses
     * @example
     * // Get one SpellClasses
     * const spellClasses = await prisma.spellClasses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpellClassesFindUniqueOrThrowArgs>(args: SelectSubset<T, SpellClassesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpellClassesClient<$Result.GetResult<Prisma.$SpellClassesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellClassesFindFirstArgs} args - Arguments to find a SpellClasses
     * @example
     * // Get one SpellClasses
     * const spellClasses = await prisma.spellClasses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpellClassesFindFirstArgs>(args?: SelectSubset<T, SpellClassesFindFirstArgs<ExtArgs>>): Prisma__SpellClassesClient<$Result.GetResult<Prisma.$SpellClassesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellClasses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellClassesFindFirstOrThrowArgs} args - Arguments to find a SpellClasses
     * @example
     * // Get one SpellClasses
     * const spellClasses = await prisma.spellClasses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpellClassesFindFirstOrThrowArgs>(args?: SelectSubset<T, SpellClassesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpellClassesClient<$Result.GetResult<Prisma.$SpellClassesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpellClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellClassesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellClasses
     * const spellClasses = await prisma.spellClasses.findMany()
     * 
     * // Get first 10 SpellClasses
     * const spellClasses = await prisma.spellClasses.findMany({ take: 10 })
     * 
     * // Only select the `classId`
     * const spellClassesWithClassIdOnly = await prisma.spellClasses.findMany({ select: { classId: true } })
     * 
     */
    findMany<T extends SpellClassesFindManyArgs>(args?: SelectSubset<T, SpellClassesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellClassesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpellClasses.
     * @param {SpellClassesCreateArgs} args - Arguments to create a SpellClasses.
     * @example
     * // Create one SpellClasses
     * const SpellClasses = await prisma.spellClasses.create({
     *   data: {
     *     // ... data to create a SpellClasses
     *   }
     * })
     * 
     */
    create<T extends SpellClassesCreateArgs>(args: SelectSubset<T, SpellClassesCreateArgs<ExtArgs>>): Prisma__SpellClassesClient<$Result.GetResult<Prisma.$SpellClassesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpellClasses.
     * @param {SpellClassesCreateManyArgs} args - Arguments to create many SpellClasses.
     * @example
     * // Create many SpellClasses
     * const spellClasses = await prisma.spellClasses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpellClassesCreateManyArgs>(args?: SelectSubset<T, SpellClassesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpellClasses and returns the data saved in the database.
     * @param {SpellClassesCreateManyAndReturnArgs} args - Arguments to create many SpellClasses.
     * @example
     * // Create many SpellClasses
     * const spellClasses = await prisma.spellClasses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpellClasses and only return the `classId`
     * const spellClassesWithClassIdOnly = await prisma.spellClasses.createManyAndReturn({
     *   select: { classId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpellClassesCreateManyAndReturnArgs>(args?: SelectSubset<T, SpellClassesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellClassesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpellClasses.
     * @param {SpellClassesDeleteArgs} args - Arguments to delete one SpellClasses.
     * @example
     * // Delete one SpellClasses
     * const SpellClasses = await prisma.spellClasses.delete({
     *   where: {
     *     // ... filter to delete one SpellClasses
     *   }
     * })
     * 
     */
    delete<T extends SpellClassesDeleteArgs>(args: SelectSubset<T, SpellClassesDeleteArgs<ExtArgs>>): Prisma__SpellClassesClient<$Result.GetResult<Prisma.$SpellClassesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpellClasses.
     * @param {SpellClassesUpdateArgs} args - Arguments to update one SpellClasses.
     * @example
     * // Update one SpellClasses
     * const spellClasses = await prisma.spellClasses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpellClassesUpdateArgs>(args: SelectSubset<T, SpellClassesUpdateArgs<ExtArgs>>): Prisma__SpellClassesClient<$Result.GetResult<Prisma.$SpellClassesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpellClasses.
     * @param {SpellClassesDeleteManyArgs} args - Arguments to filter SpellClasses to delete.
     * @example
     * // Delete a few SpellClasses
     * const { count } = await prisma.spellClasses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpellClassesDeleteManyArgs>(args?: SelectSubset<T, SpellClassesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellClassesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellClasses
     * const spellClasses = await prisma.spellClasses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpellClassesUpdateManyArgs>(args: SelectSubset<T, SpellClassesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellClasses and returns the data updated in the database.
     * @param {SpellClassesUpdateManyAndReturnArgs} args - Arguments to update many SpellClasses.
     * @example
     * // Update many SpellClasses
     * const spellClasses = await prisma.spellClasses.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpellClasses and only return the `classId`
     * const spellClassesWithClassIdOnly = await prisma.spellClasses.updateManyAndReturn({
     *   select: { classId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpellClassesUpdateManyAndReturnArgs>(args: SelectSubset<T, SpellClassesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellClassesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpellClasses.
     * @param {SpellClassesUpsertArgs} args - Arguments to update or create a SpellClasses.
     * @example
     * // Update or create a SpellClasses
     * const spellClasses = await prisma.spellClasses.upsert({
     *   create: {
     *     // ... data to create a SpellClasses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellClasses we want to update
     *   }
     * })
     */
    upsert<T extends SpellClassesUpsertArgs>(args: SelectSubset<T, SpellClassesUpsertArgs<ExtArgs>>): Prisma__SpellClassesClient<$Result.GetResult<Prisma.$SpellClassesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpellClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellClassesCountArgs} args - Arguments to filter SpellClasses to count.
     * @example
     * // Count the number of SpellClasses
     * const count = await prisma.spellClasses.count({
     *   where: {
     *     // ... the filter for the SpellClasses we want to count
     *   }
     * })
    **/
    count<T extends SpellClassesCountArgs>(
      args?: Subset<T, SpellClassesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellClassesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellClassesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellClassesAggregateArgs>(args: Subset<T, SpellClassesAggregateArgs>): Prisma.PrismaPromise<GetSpellClassesAggregateType<T>>

    /**
     * Group by SpellClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellClassesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellClassesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellClassesGroupByArgs['orderBy'] }
        : { orderBy?: SpellClassesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellClassesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellClassesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellClasses model
   */
  readonly fields: SpellClassesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellClasses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellClassesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpellClasses model
   */
  interface SpellClassesFieldRefs {
    readonly classId: FieldRef<"SpellClasses", 'Int'>
    readonly spellId: FieldRef<"SpellClasses", 'Int'>
    readonly className: FieldRef<"SpellClasses", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SpellClasses findUnique
   */
  export type SpellClassesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClasses
     */
    select?: SpellClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellClasses
     */
    omit?: SpellClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellClassesInclude<ExtArgs> | null
    /**
     * Filter, which SpellClasses to fetch.
     */
    where: SpellClassesWhereUniqueInput
  }

  /**
   * SpellClasses findUniqueOrThrow
   */
  export type SpellClassesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClasses
     */
    select?: SpellClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellClasses
     */
    omit?: SpellClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellClassesInclude<ExtArgs> | null
    /**
     * Filter, which SpellClasses to fetch.
     */
    where: SpellClassesWhereUniqueInput
  }

  /**
   * SpellClasses findFirst
   */
  export type SpellClassesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClasses
     */
    select?: SpellClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellClasses
     */
    omit?: SpellClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellClassesInclude<ExtArgs> | null
    /**
     * Filter, which SpellClasses to fetch.
     */
    where?: SpellClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellClasses to fetch.
     */
    orderBy?: SpellClassesOrderByWithRelationInput | SpellClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellClasses.
     */
    cursor?: SpellClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellClasses.
     */
    distinct?: SpellClassesScalarFieldEnum | SpellClassesScalarFieldEnum[]
  }

  /**
   * SpellClasses findFirstOrThrow
   */
  export type SpellClassesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClasses
     */
    select?: SpellClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellClasses
     */
    omit?: SpellClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellClassesInclude<ExtArgs> | null
    /**
     * Filter, which SpellClasses to fetch.
     */
    where?: SpellClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellClasses to fetch.
     */
    orderBy?: SpellClassesOrderByWithRelationInput | SpellClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellClasses.
     */
    cursor?: SpellClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellClasses.
     */
    distinct?: SpellClassesScalarFieldEnum | SpellClassesScalarFieldEnum[]
  }

  /**
   * SpellClasses findMany
   */
  export type SpellClassesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClasses
     */
    select?: SpellClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellClasses
     */
    omit?: SpellClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellClassesInclude<ExtArgs> | null
    /**
     * Filter, which SpellClasses to fetch.
     */
    where?: SpellClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellClasses to fetch.
     */
    orderBy?: SpellClassesOrderByWithRelationInput | SpellClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellClasses.
     */
    cursor?: SpellClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellClasses.
     */
    skip?: number
    distinct?: SpellClassesScalarFieldEnum | SpellClassesScalarFieldEnum[]
  }

  /**
   * SpellClasses create
   */
  export type SpellClassesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClasses
     */
    select?: SpellClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellClasses
     */
    omit?: SpellClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellClassesInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellClasses.
     */
    data: XOR<SpellClassesCreateInput, SpellClassesUncheckedCreateInput>
  }

  /**
   * SpellClasses createMany
   */
  export type SpellClassesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellClasses.
     */
    data: SpellClassesCreateManyInput | SpellClassesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpellClasses createManyAndReturn
   */
  export type SpellClassesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClasses
     */
    select?: SpellClassesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpellClasses
     */
    omit?: SpellClassesOmit<ExtArgs> | null
    /**
     * The data used to create many SpellClasses.
     */
    data: SpellClassesCreateManyInput | SpellClassesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellClassesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpellClasses update
   */
  export type SpellClassesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClasses
     */
    select?: SpellClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellClasses
     */
    omit?: SpellClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellClassesInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellClasses.
     */
    data: XOR<SpellClassesUpdateInput, SpellClassesUncheckedUpdateInput>
    /**
     * Choose, which SpellClasses to update.
     */
    where: SpellClassesWhereUniqueInput
  }

  /**
   * SpellClasses updateMany
   */
  export type SpellClassesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellClasses.
     */
    data: XOR<SpellClassesUpdateManyMutationInput, SpellClassesUncheckedUpdateManyInput>
    /**
     * Filter which SpellClasses to update
     */
    where?: SpellClassesWhereInput
    /**
     * Limit how many SpellClasses to update.
     */
    limit?: number
  }

  /**
   * SpellClasses updateManyAndReturn
   */
  export type SpellClassesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClasses
     */
    select?: SpellClassesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpellClasses
     */
    omit?: SpellClassesOmit<ExtArgs> | null
    /**
     * The data used to update SpellClasses.
     */
    data: XOR<SpellClassesUpdateManyMutationInput, SpellClassesUncheckedUpdateManyInput>
    /**
     * Filter which SpellClasses to update
     */
    where?: SpellClassesWhereInput
    /**
     * Limit how many SpellClasses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellClassesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpellClasses upsert
   */
  export type SpellClassesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClasses
     */
    select?: SpellClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellClasses
     */
    omit?: SpellClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellClassesInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellClasses to update in case it exists.
     */
    where: SpellClassesWhereUniqueInput
    /**
     * In case the SpellClasses found by the `where` argument doesn't exist, create a new SpellClasses with this data.
     */
    create: XOR<SpellClassesCreateInput, SpellClassesUncheckedCreateInput>
    /**
     * In case the SpellClasses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellClassesUpdateInput, SpellClassesUncheckedUpdateInput>
  }

  /**
   * SpellClasses delete
   */
  export type SpellClassesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClasses
     */
    select?: SpellClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellClasses
     */
    omit?: SpellClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellClassesInclude<ExtArgs> | null
    /**
     * Filter which SpellClasses to delete.
     */
    where: SpellClassesWhereUniqueInput
  }

  /**
   * SpellClasses deleteMany
   */
  export type SpellClassesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellClasses to delete
     */
    where?: SpellClassesWhereInput
    /**
     * Limit how many SpellClasses to delete.
     */
    limit?: number
  }

  /**
   * SpellClasses without action
   */
  export type SpellClassesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClasses
     */
    select?: SpellClassesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellClasses
     */
    omit?: SpellClassesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellClassesInclude<ExtArgs> | null
  }


  /**
   * Model SpellRaces
   */

  export type AggregateSpellRaces = {
    _count: SpellRacesCountAggregateOutputType | null
    _avg: SpellRacesAvgAggregateOutputType | null
    _sum: SpellRacesSumAggregateOutputType | null
    _min: SpellRacesMinAggregateOutputType | null
    _max: SpellRacesMaxAggregateOutputType | null
  }

  export type SpellRacesAvgAggregateOutputType = {
    spellId: number | null
    raceId: number | null
  }

  export type SpellRacesSumAggregateOutputType = {
    spellId: number | null
    raceId: number | null
  }

  export type SpellRacesMinAggregateOutputType = {
    spellId: number | null
    raceId: number | null
    raceName: string | null
  }

  export type SpellRacesMaxAggregateOutputType = {
    spellId: number | null
    raceId: number | null
    raceName: string | null
  }

  export type SpellRacesCountAggregateOutputType = {
    spellId: number
    raceId: number
    raceName: number
    _all: number
  }


  export type SpellRacesAvgAggregateInputType = {
    spellId?: true
    raceId?: true
  }

  export type SpellRacesSumAggregateInputType = {
    spellId?: true
    raceId?: true
  }

  export type SpellRacesMinAggregateInputType = {
    spellId?: true
    raceId?: true
    raceName?: true
  }

  export type SpellRacesMaxAggregateInputType = {
    spellId?: true
    raceId?: true
    raceName?: true
  }

  export type SpellRacesCountAggregateInputType = {
    spellId?: true
    raceId?: true
    raceName?: true
    _all?: true
  }

  export type SpellRacesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellRaces to aggregate.
     */
    where?: SpellRacesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellRaces to fetch.
     */
    orderBy?: SpellRacesOrderByWithRelationInput | SpellRacesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellRacesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellRaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellRaces
    **/
    _count?: true | SpellRacesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellRacesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellRacesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellRacesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellRacesMaxAggregateInputType
  }

  export type GetSpellRacesAggregateType<T extends SpellRacesAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellRaces]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellRaces[P]>
      : GetScalarType<T[P], AggregateSpellRaces[P]>
  }




  export type SpellRacesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellRacesWhereInput
    orderBy?: SpellRacesOrderByWithAggregationInput | SpellRacesOrderByWithAggregationInput[]
    by: SpellRacesScalarFieldEnum[] | SpellRacesScalarFieldEnum
    having?: SpellRacesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellRacesCountAggregateInputType | true
    _avg?: SpellRacesAvgAggregateInputType
    _sum?: SpellRacesSumAggregateInputType
    _min?: SpellRacesMinAggregateInputType
    _max?: SpellRacesMaxAggregateInputType
  }

  export type SpellRacesGroupByOutputType = {
    spellId: number | null
    raceId: number
    raceName: string | null
    _count: SpellRacesCountAggregateOutputType | null
    _avg: SpellRacesAvgAggregateOutputType | null
    _sum: SpellRacesSumAggregateOutputType | null
    _min: SpellRacesMinAggregateOutputType | null
    _max: SpellRacesMaxAggregateOutputType | null
  }

  type GetSpellRacesGroupByPayload<T extends SpellRacesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellRacesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellRacesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellRacesGroupByOutputType[P]>
            : GetScalarType<T[P], SpellRacesGroupByOutputType[P]>
        }
      >
    >


  export type SpellRacesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    spellId?: boolean
    raceId?: boolean
    raceName?: boolean
    spell?: boolean | SpellRaces$spellArgs<ExtArgs>
  }, ExtArgs["result"]["spellRaces"]>

  export type SpellRacesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    spellId?: boolean
    raceId?: boolean
    raceName?: boolean
    spell?: boolean | SpellRaces$spellArgs<ExtArgs>
  }, ExtArgs["result"]["spellRaces"]>

  export type SpellRacesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    spellId?: boolean
    raceId?: boolean
    raceName?: boolean
    spell?: boolean | SpellRaces$spellArgs<ExtArgs>
  }, ExtArgs["result"]["spellRaces"]>

  export type SpellRacesSelectScalar = {
    spellId?: boolean
    raceId?: boolean
    raceName?: boolean
  }

  export type SpellRacesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"spellId" | "raceId" | "raceName", ExtArgs["result"]["spellRaces"]>
  export type SpellRacesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellRaces$spellArgs<ExtArgs>
  }
  export type SpellRacesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellRaces$spellArgs<ExtArgs>
  }
  export type SpellRacesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellRaces$spellArgs<ExtArgs>
  }

  export type $SpellRacesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellRaces"
    objects: {
      spell: Prisma.$SpellPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      spellId: number | null
      raceId: number
      raceName: string | null
    }, ExtArgs["result"]["spellRaces"]>
    composites: {}
  }

  type SpellRacesGetPayload<S extends boolean | null | undefined | SpellRacesDefaultArgs> = $Result.GetResult<Prisma.$SpellRacesPayload, S>

  type SpellRacesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpellRacesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpellRacesCountAggregateInputType | true
    }

  export interface SpellRacesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellRaces'], meta: { name: 'SpellRaces' } }
    /**
     * Find zero or one SpellRaces that matches the filter.
     * @param {SpellRacesFindUniqueArgs} args - Arguments to find a SpellRaces
     * @example
     * // Get one SpellRaces
     * const spellRaces = await prisma.spellRaces.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpellRacesFindUniqueArgs>(args: SelectSubset<T, SpellRacesFindUniqueArgs<ExtArgs>>): Prisma__SpellRacesClient<$Result.GetResult<Prisma.$SpellRacesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpellRaces that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpellRacesFindUniqueOrThrowArgs} args - Arguments to find a SpellRaces
     * @example
     * // Get one SpellRaces
     * const spellRaces = await prisma.spellRaces.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpellRacesFindUniqueOrThrowArgs>(args: SelectSubset<T, SpellRacesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpellRacesClient<$Result.GetResult<Prisma.$SpellRacesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellRaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellRacesFindFirstArgs} args - Arguments to find a SpellRaces
     * @example
     * // Get one SpellRaces
     * const spellRaces = await prisma.spellRaces.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpellRacesFindFirstArgs>(args?: SelectSubset<T, SpellRacesFindFirstArgs<ExtArgs>>): Prisma__SpellRacesClient<$Result.GetResult<Prisma.$SpellRacesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellRaces that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellRacesFindFirstOrThrowArgs} args - Arguments to find a SpellRaces
     * @example
     * // Get one SpellRaces
     * const spellRaces = await prisma.spellRaces.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpellRacesFindFirstOrThrowArgs>(args?: SelectSubset<T, SpellRacesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpellRacesClient<$Result.GetResult<Prisma.$SpellRacesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpellRaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellRacesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellRaces
     * const spellRaces = await prisma.spellRaces.findMany()
     * 
     * // Get first 10 SpellRaces
     * const spellRaces = await prisma.spellRaces.findMany({ take: 10 })
     * 
     * // Only select the `spellId`
     * const spellRacesWithSpellIdOnly = await prisma.spellRaces.findMany({ select: { spellId: true } })
     * 
     */
    findMany<T extends SpellRacesFindManyArgs>(args?: SelectSubset<T, SpellRacesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellRacesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpellRaces.
     * @param {SpellRacesCreateArgs} args - Arguments to create a SpellRaces.
     * @example
     * // Create one SpellRaces
     * const SpellRaces = await prisma.spellRaces.create({
     *   data: {
     *     // ... data to create a SpellRaces
     *   }
     * })
     * 
     */
    create<T extends SpellRacesCreateArgs>(args: SelectSubset<T, SpellRacesCreateArgs<ExtArgs>>): Prisma__SpellRacesClient<$Result.GetResult<Prisma.$SpellRacesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpellRaces.
     * @param {SpellRacesCreateManyArgs} args - Arguments to create many SpellRaces.
     * @example
     * // Create many SpellRaces
     * const spellRaces = await prisma.spellRaces.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpellRacesCreateManyArgs>(args?: SelectSubset<T, SpellRacesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpellRaces and returns the data saved in the database.
     * @param {SpellRacesCreateManyAndReturnArgs} args - Arguments to create many SpellRaces.
     * @example
     * // Create many SpellRaces
     * const spellRaces = await prisma.spellRaces.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpellRaces and only return the `spellId`
     * const spellRacesWithSpellIdOnly = await prisma.spellRaces.createManyAndReturn({
     *   select: { spellId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpellRacesCreateManyAndReturnArgs>(args?: SelectSubset<T, SpellRacesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellRacesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpellRaces.
     * @param {SpellRacesDeleteArgs} args - Arguments to delete one SpellRaces.
     * @example
     * // Delete one SpellRaces
     * const SpellRaces = await prisma.spellRaces.delete({
     *   where: {
     *     // ... filter to delete one SpellRaces
     *   }
     * })
     * 
     */
    delete<T extends SpellRacesDeleteArgs>(args: SelectSubset<T, SpellRacesDeleteArgs<ExtArgs>>): Prisma__SpellRacesClient<$Result.GetResult<Prisma.$SpellRacesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpellRaces.
     * @param {SpellRacesUpdateArgs} args - Arguments to update one SpellRaces.
     * @example
     * // Update one SpellRaces
     * const spellRaces = await prisma.spellRaces.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpellRacesUpdateArgs>(args: SelectSubset<T, SpellRacesUpdateArgs<ExtArgs>>): Prisma__SpellRacesClient<$Result.GetResult<Prisma.$SpellRacesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpellRaces.
     * @param {SpellRacesDeleteManyArgs} args - Arguments to filter SpellRaces to delete.
     * @example
     * // Delete a few SpellRaces
     * const { count } = await prisma.spellRaces.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpellRacesDeleteManyArgs>(args?: SelectSubset<T, SpellRacesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellRacesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellRaces
     * const spellRaces = await prisma.spellRaces.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpellRacesUpdateManyArgs>(args: SelectSubset<T, SpellRacesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellRaces and returns the data updated in the database.
     * @param {SpellRacesUpdateManyAndReturnArgs} args - Arguments to update many SpellRaces.
     * @example
     * // Update many SpellRaces
     * const spellRaces = await prisma.spellRaces.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpellRaces and only return the `spellId`
     * const spellRacesWithSpellIdOnly = await prisma.spellRaces.updateManyAndReturn({
     *   select: { spellId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpellRacesUpdateManyAndReturnArgs>(args: SelectSubset<T, SpellRacesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellRacesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpellRaces.
     * @param {SpellRacesUpsertArgs} args - Arguments to update or create a SpellRaces.
     * @example
     * // Update or create a SpellRaces
     * const spellRaces = await prisma.spellRaces.upsert({
     *   create: {
     *     // ... data to create a SpellRaces
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellRaces we want to update
     *   }
     * })
     */
    upsert<T extends SpellRacesUpsertArgs>(args: SelectSubset<T, SpellRacesUpsertArgs<ExtArgs>>): Prisma__SpellRacesClient<$Result.GetResult<Prisma.$SpellRacesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpellRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellRacesCountArgs} args - Arguments to filter SpellRaces to count.
     * @example
     * // Count the number of SpellRaces
     * const count = await prisma.spellRaces.count({
     *   where: {
     *     // ... the filter for the SpellRaces we want to count
     *   }
     * })
    **/
    count<T extends SpellRacesCountArgs>(
      args?: Subset<T, SpellRacesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellRacesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellRacesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellRacesAggregateArgs>(args: Subset<T, SpellRacesAggregateArgs>): Prisma.PrismaPromise<GetSpellRacesAggregateType<T>>

    /**
     * Group by SpellRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellRacesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellRacesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellRacesGroupByArgs['orderBy'] }
        : { orderBy?: SpellRacesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellRacesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellRacesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellRaces model
   */
  readonly fields: SpellRacesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellRaces.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellRacesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    spell<T extends SpellRaces$spellArgs<ExtArgs> = {}>(args?: Subset<T, SpellRaces$spellArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpellRaces model
   */
  interface SpellRacesFieldRefs {
    readonly spellId: FieldRef<"SpellRaces", 'Int'>
    readonly raceId: FieldRef<"SpellRaces", 'Int'>
    readonly raceName: FieldRef<"SpellRaces", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SpellRaces findUnique
   */
  export type SpellRacesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRaces
     */
    select?: SpellRacesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellRaces
     */
    omit?: SpellRacesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellRacesInclude<ExtArgs> | null
    /**
     * Filter, which SpellRaces to fetch.
     */
    where: SpellRacesWhereUniqueInput
  }

  /**
   * SpellRaces findUniqueOrThrow
   */
  export type SpellRacesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRaces
     */
    select?: SpellRacesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellRaces
     */
    omit?: SpellRacesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellRacesInclude<ExtArgs> | null
    /**
     * Filter, which SpellRaces to fetch.
     */
    where: SpellRacesWhereUniqueInput
  }

  /**
   * SpellRaces findFirst
   */
  export type SpellRacesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRaces
     */
    select?: SpellRacesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellRaces
     */
    omit?: SpellRacesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellRacesInclude<ExtArgs> | null
    /**
     * Filter, which SpellRaces to fetch.
     */
    where?: SpellRacesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellRaces to fetch.
     */
    orderBy?: SpellRacesOrderByWithRelationInput | SpellRacesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellRaces.
     */
    cursor?: SpellRacesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellRaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellRaces.
     */
    distinct?: SpellRacesScalarFieldEnum | SpellRacesScalarFieldEnum[]
  }

  /**
   * SpellRaces findFirstOrThrow
   */
  export type SpellRacesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRaces
     */
    select?: SpellRacesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellRaces
     */
    omit?: SpellRacesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellRacesInclude<ExtArgs> | null
    /**
     * Filter, which SpellRaces to fetch.
     */
    where?: SpellRacesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellRaces to fetch.
     */
    orderBy?: SpellRacesOrderByWithRelationInput | SpellRacesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellRaces.
     */
    cursor?: SpellRacesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellRaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellRaces.
     */
    distinct?: SpellRacesScalarFieldEnum | SpellRacesScalarFieldEnum[]
  }

  /**
   * SpellRaces findMany
   */
  export type SpellRacesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRaces
     */
    select?: SpellRacesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellRaces
     */
    omit?: SpellRacesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellRacesInclude<ExtArgs> | null
    /**
     * Filter, which SpellRaces to fetch.
     */
    where?: SpellRacesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellRaces to fetch.
     */
    orderBy?: SpellRacesOrderByWithRelationInput | SpellRacesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellRaces.
     */
    cursor?: SpellRacesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellRaces.
     */
    skip?: number
    distinct?: SpellRacesScalarFieldEnum | SpellRacesScalarFieldEnum[]
  }

  /**
   * SpellRaces create
   */
  export type SpellRacesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRaces
     */
    select?: SpellRacesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellRaces
     */
    omit?: SpellRacesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellRacesInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellRaces.
     */
    data?: XOR<SpellRacesCreateInput, SpellRacesUncheckedCreateInput>
  }

  /**
   * SpellRaces createMany
   */
  export type SpellRacesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellRaces.
     */
    data: SpellRacesCreateManyInput | SpellRacesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpellRaces createManyAndReturn
   */
  export type SpellRacesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRaces
     */
    select?: SpellRacesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpellRaces
     */
    omit?: SpellRacesOmit<ExtArgs> | null
    /**
     * The data used to create many SpellRaces.
     */
    data: SpellRacesCreateManyInput | SpellRacesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellRacesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpellRaces update
   */
  export type SpellRacesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRaces
     */
    select?: SpellRacesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellRaces
     */
    omit?: SpellRacesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellRacesInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellRaces.
     */
    data: XOR<SpellRacesUpdateInput, SpellRacesUncheckedUpdateInput>
    /**
     * Choose, which SpellRaces to update.
     */
    where: SpellRacesWhereUniqueInput
  }

  /**
   * SpellRaces updateMany
   */
  export type SpellRacesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellRaces.
     */
    data: XOR<SpellRacesUpdateManyMutationInput, SpellRacesUncheckedUpdateManyInput>
    /**
     * Filter which SpellRaces to update
     */
    where?: SpellRacesWhereInput
    /**
     * Limit how many SpellRaces to update.
     */
    limit?: number
  }

  /**
   * SpellRaces updateManyAndReturn
   */
  export type SpellRacesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRaces
     */
    select?: SpellRacesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpellRaces
     */
    omit?: SpellRacesOmit<ExtArgs> | null
    /**
     * The data used to update SpellRaces.
     */
    data: XOR<SpellRacesUpdateManyMutationInput, SpellRacesUncheckedUpdateManyInput>
    /**
     * Filter which SpellRaces to update
     */
    where?: SpellRacesWhereInput
    /**
     * Limit how many SpellRaces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellRacesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpellRaces upsert
   */
  export type SpellRacesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRaces
     */
    select?: SpellRacesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellRaces
     */
    omit?: SpellRacesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellRacesInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellRaces to update in case it exists.
     */
    where: SpellRacesWhereUniqueInput
    /**
     * In case the SpellRaces found by the `where` argument doesn't exist, create a new SpellRaces with this data.
     */
    create: XOR<SpellRacesCreateInput, SpellRacesUncheckedCreateInput>
    /**
     * In case the SpellRaces was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellRacesUpdateInput, SpellRacesUncheckedUpdateInput>
  }

  /**
   * SpellRaces delete
   */
  export type SpellRacesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRaces
     */
    select?: SpellRacesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellRaces
     */
    omit?: SpellRacesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellRacesInclude<ExtArgs> | null
    /**
     * Filter which SpellRaces to delete.
     */
    where: SpellRacesWhereUniqueInput
  }

  /**
   * SpellRaces deleteMany
   */
  export type SpellRacesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellRaces to delete
     */
    where?: SpellRacesWhereInput
    /**
     * Limit how many SpellRaces to delete.
     */
    limit?: number
  }

  /**
   * SpellRaces.spell
   */
  export type SpellRaces$spellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    where?: SpellWhereInput
  }

  /**
   * SpellRaces without action
   */
  export type SpellRacesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRaces
     */
    select?: SpellRacesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellRaces
     */
    omit?: SpellRacesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellRacesInclude<ExtArgs> | null
  }


  /**
   * Model Spellbook
   */

  export type AggregateSpellbook = {
    _count: SpellbookCountAggregateOutputType | null
    _avg: SpellbookAvgAggregateOutputType | null
    _sum: SpellbookSumAggregateOutputType | null
    _min: SpellbookMinAggregateOutputType | null
    _max: SpellbookMaxAggregateOutputType | null
  }

  export type SpellbookAvgAggregateOutputType = {
    spellbookId: number | null
    userId: number | null
  }

  export type SpellbookSumAggregateOutputType = {
    spellbookId: number | null
    userId: number | null
  }

  export type SpellbookMinAggregateOutputType = {
    spellbookId: number | null
    userId: number | null
  }

  export type SpellbookMaxAggregateOutputType = {
    spellbookId: number | null
    userId: number | null
  }

  export type SpellbookCountAggregateOutputType = {
    spellbookId: number
    userId: number
    _all: number
  }


  export type SpellbookAvgAggregateInputType = {
    spellbookId?: true
    userId?: true
  }

  export type SpellbookSumAggregateInputType = {
    spellbookId?: true
    userId?: true
  }

  export type SpellbookMinAggregateInputType = {
    spellbookId?: true
    userId?: true
  }

  export type SpellbookMaxAggregateInputType = {
    spellbookId?: true
    userId?: true
  }

  export type SpellbookCountAggregateInputType = {
    spellbookId?: true
    userId?: true
    _all?: true
  }

  export type SpellbookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spellbook to aggregate.
     */
    where?: SpellbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spellbooks to fetch.
     */
    orderBy?: SpellbookOrderByWithRelationInput | SpellbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spellbooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spellbooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Spellbooks
    **/
    _count?: true | SpellbookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellbookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellbookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellbookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellbookMaxAggregateInputType
  }

  export type GetSpellbookAggregateType<T extends SpellbookAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellbook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellbook[P]>
      : GetScalarType<T[P], AggregateSpellbook[P]>
  }




  export type SpellbookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellbookWhereInput
    orderBy?: SpellbookOrderByWithAggregationInput | SpellbookOrderByWithAggregationInput[]
    by: SpellbookScalarFieldEnum[] | SpellbookScalarFieldEnum
    having?: SpellbookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellbookCountAggregateInputType | true
    _avg?: SpellbookAvgAggregateInputType
    _sum?: SpellbookSumAggregateInputType
    _min?: SpellbookMinAggregateInputType
    _max?: SpellbookMaxAggregateInputType
  }

  export type SpellbookGroupByOutputType = {
    spellbookId: number
    userId: number | null
    _count: SpellbookCountAggregateOutputType | null
    _avg: SpellbookAvgAggregateOutputType | null
    _sum: SpellbookSumAggregateOutputType | null
    _min: SpellbookMinAggregateOutputType | null
    _max: SpellbookMaxAggregateOutputType | null
  }

  type GetSpellbookGroupByPayload<T extends SpellbookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellbookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellbookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellbookGroupByOutputType[P]>
            : GetScalarType<T[P], SpellbookGroupByOutputType[P]>
        }
      >
    >


  export type SpellbookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    spellbookId?: boolean
    userId?: boolean
    user?: boolean | Spellbook$userArgs<ExtArgs>
    spellbookSpells?: boolean | Spellbook$spellbookSpellsArgs<ExtArgs>
    _count?: boolean | SpellbookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellbook"]>

  export type SpellbookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    spellbookId?: boolean
    userId?: boolean
    user?: boolean | Spellbook$userArgs<ExtArgs>
  }, ExtArgs["result"]["spellbook"]>

  export type SpellbookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    spellbookId?: boolean
    userId?: boolean
    user?: boolean | Spellbook$userArgs<ExtArgs>
  }, ExtArgs["result"]["spellbook"]>

  export type SpellbookSelectScalar = {
    spellbookId?: boolean
    userId?: boolean
  }

  export type SpellbookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"spellbookId" | "userId", ExtArgs["result"]["spellbook"]>
  export type SpellbookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Spellbook$userArgs<ExtArgs>
    spellbookSpells?: boolean | Spellbook$spellbookSpellsArgs<ExtArgs>
    _count?: boolean | SpellbookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpellbookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Spellbook$userArgs<ExtArgs>
  }
  export type SpellbookIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Spellbook$userArgs<ExtArgs>
  }

  export type $SpellbookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Spellbook"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      spellbookSpells: Prisma.$SpellbookSpellsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      spellbookId: number
      userId: number | null
    }, ExtArgs["result"]["spellbook"]>
    composites: {}
  }

  type SpellbookGetPayload<S extends boolean | null | undefined | SpellbookDefaultArgs> = $Result.GetResult<Prisma.$SpellbookPayload, S>

  type SpellbookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpellbookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpellbookCountAggregateInputType | true
    }

  export interface SpellbookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Spellbook'], meta: { name: 'Spellbook' } }
    /**
     * Find zero or one Spellbook that matches the filter.
     * @param {SpellbookFindUniqueArgs} args - Arguments to find a Spellbook
     * @example
     * // Get one Spellbook
     * const spellbook = await prisma.spellbook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpellbookFindUniqueArgs>(args: SelectSubset<T, SpellbookFindUniqueArgs<ExtArgs>>): Prisma__SpellbookClient<$Result.GetResult<Prisma.$SpellbookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Spellbook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpellbookFindUniqueOrThrowArgs} args - Arguments to find a Spellbook
     * @example
     * // Get one Spellbook
     * const spellbook = await prisma.spellbook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpellbookFindUniqueOrThrowArgs>(args: SelectSubset<T, SpellbookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpellbookClient<$Result.GetResult<Prisma.$SpellbookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Spellbook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellbookFindFirstArgs} args - Arguments to find a Spellbook
     * @example
     * // Get one Spellbook
     * const spellbook = await prisma.spellbook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpellbookFindFirstArgs>(args?: SelectSubset<T, SpellbookFindFirstArgs<ExtArgs>>): Prisma__SpellbookClient<$Result.GetResult<Prisma.$SpellbookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Spellbook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellbookFindFirstOrThrowArgs} args - Arguments to find a Spellbook
     * @example
     * // Get one Spellbook
     * const spellbook = await prisma.spellbook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpellbookFindFirstOrThrowArgs>(args?: SelectSubset<T, SpellbookFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpellbookClient<$Result.GetResult<Prisma.$SpellbookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Spellbooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellbookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spellbooks
     * const spellbooks = await prisma.spellbook.findMany()
     * 
     * // Get first 10 Spellbooks
     * const spellbooks = await prisma.spellbook.findMany({ take: 10 })
     * 
     * // Only select the `spellbookId`
     * const spellbookWithSpellbookIdOnly = await prisma.spellbook.findMany({ select: { spellbookId: true } })
     * 
     */
    findMany<T extends SpellbookFindManyArgs>(args?: SelectSubset<T, SpellbookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellbookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Spellbook.
     * @param {SpellbookCreateArgs} args - Arguments to create a Spellbook.
     * @example
     * // Create one Spellbook
     * const Spellbook = await prisma.spellbook.create({
     *   data: {
     *     // ... data to create a Spellbook
     *   }
     * })
     * 
     */
    create<T extends SpellbookCreateArgs>(args: SelectSubset<T, SpellbookCreateArgs<ExtArgs>>): Prisma__SpellbookClient<$Result.GetResult<Prisma.$SpellbookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Spellbooks.
     * @param {SpellbookCreateManyArgs} args - Arguments to create many Spellbooks.
     * @example
     * // Create many Spellbooks
     * const spellbook = await prisma.spellbook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpellbookCreateManyArgs>(args?: SelectSubset<T, SpellbookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Spellbooks and returns the data saved in the database.
     * @param {SpellbookCreateManyAndReturnArgs} args - Arguments to create many Spellbooks.
     * @example
     * // Create many Spellbooks
     * const spellbook = await prisma.spellbook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Spellbooks and only return the `spellbookId`
     * const spellbookWithSpellbookIdOnly = await prisma.spellbook.createManyAndReturn({
     *   select: { spellbookId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpellbookCreateManyAndReturnArgs>(args?: SelectSubset<T, SpellbookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellbookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Spellbook.
     * @param {SpellbookDeleteArgs} args - Arguments to delete one Spellbook.
     * @example
     * // Delete one Spellbook
     * const Spellbook = await prisma.spellbook.delete({
     *   where: {
     *     // ... filter to delete one Spellbook
     *   }
     * })
     * 
     */
    delete<T extends SpellbookDeleteArgs>(args: SelectSubset<T, SpellbookDeleteArgs<ExtArgs>>): Prisma__SpellbookClient<$Result.GetResult<Prisma.$SpellbookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Spellbook.
     * @param {SpellbookUpdateArgs} args - Arguments to update one Spellbook.
     * @example
     * // Update one Spellbook
     * const spellbook = await prisma.spellbook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpellbookUpdateArgs>(args: SelectSubset<T, SpellbookUpdateArgs<ExtArgs>>): Prisma__SpellbookClient<$Result.GetResult<Prisma.$SpellbookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Spellbooks.
     * @param {SpellbookDeleteManyArgs} args - Arguments to filter Spellbooks to delete.
     * @example
     * // Delete a few Spellbooks
     * const { count } = await prisma.spellbook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpellbookDeleteManyArgs>(args?: SelectSubset<T, SpellbookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spellbooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellbookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spellbooks
     * const spellbook = await prisma.spellbook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpellbookUpdateManyArgs>(args: SelectSubset<T, SpellbookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spellbooks and returns the data updated in the database.
     * @param {SpellbookUpdateManyAndReturnArgs} args - Arguments to update many Spellbooks.
     * @example
     * // Update many Spellbooks
     * const spellbook = await prisma.spellbook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Spellbooks and only return the `spellbookId`
     * const spellbookWithSpellbookIdOnly = await prisma.spellbook.updateManyAndReturn({
     *   select: { spellbookId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpellbookUpdateManyAndReturnArgs>(args: SelectSubset<T, SpellbookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellbookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Spellbook.
     * @param {SpellbookUpsertArgs} args - Arguments to update or create a Spellbook.
     * @example
     * // Update or create a Spellbook
     * const spellbook = await prisma.spellbook.upsert({
     *   create: {
     *     // ... data to create a Spellbook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Spellbook we want to update
     *   }
     * })
     */
    upsert<T extends SpellbookUpsertArgs>(args: SelectSubset<T, SpellbookUpsertArgs<ExtArgs>>): Prisma__SpellbookClient<$Result.GetResult<Prisma.$SpellbookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Spellbooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellbookCountArgs} args - Arguments to filter Spellbooks to count.
     * @example
     * // Count the number of Spellbooks
     * const count = await prisma.spellbook.count({
     *   where: {
     *     // ... the filter for the Spellbooks we want to count
     *   }
     * })
    **/
    count<T extends SpellbookCountArgs>(
      args?: Subset<T, SpellbookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellbookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Spellbook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellbookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellbookAggregateArgs>(args: Subset<T, SpellbookAggregateArgs>): Prisma.PrismaPromise<GetSpellbookAggregateType<T>>

    /**
     * Group by Spellbook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellbookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellbookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellbookGroupByArgs['orderBy'] }
        : { orderBy?: SpellbookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellbookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellbookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Spellbook model
   */
  readonly fields: SpellbookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Spellbook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellbookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Spellbook$userArgs<ExtArgs> = {}>(args?: Subset<T, Spellbook$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    spellbookSpells<T extends Spellbook$spellbookSpellsArgs<ExtArgs> = {}>(args?: Subset<T, Spellbook$spellbookSpellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellbookSpellsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Spellbook model
   */
  interface SpellbookFieldRefs {
    readonly spellbookId: FieldRef<"Spellbook", 'Int'>
    readonly userId: FieldRef<"Spellbook", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Spellbook findUnique
   */
  export type SpellbookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spellbook
     */
    select?: SpellbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spellbook
     */
    omit?: SpellbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookInclude<ExtArgs> | null
    /**
     * Filter, which Spellbook to fetch.
     */
    where: SpellbookWhereUniqueInput
  }

  /**
   * Spellbook findUniqueOrThrow
   */
  export type SpellbookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spellbook
     */
    select?: SpellbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spellbook
     */
    omit?: SpellbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookInclude<ExtArgs> | null
    /**
     * Filter, which Spellbook to fetch.
     */
    where: SpellbookWhereUniqueInput
  }

  /**
   * Spellbook findFirst
   */
  export type SpellbookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spellbook
     */
    select?: SpellbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spellbook
     */
    omit?: SpellbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookInclude<ExtArgs> | null
    /**
     * Filter, which Spellbook to fetch.
     */
    where?: SpellbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spellbooks to fetch.
     */
    orderBy?: SpellbookOrderByWithRelationInput | SpellbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spellbooks.
     */
    cursor?: SpellbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spellbooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spellbooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spellbooks.
     */
    distinct?: SpellbookScalarFieldEnum | SpellbookScalarFieldEnum[]
  }

  /**
   * Spellbook findFirstOrThrow
   */
  export type SpellbookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spellbook
     */
    select?: SpellbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spellbook
     */
    omit?: SpellbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookInclude<ExtArgs> | null
    /**
     * Filter, which Spellbook to fetch.
     */
    where?: SpellbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spellbooks to fetch.
     */
    orderBy?: SpellbookOrderByWithRelationInput | SpellbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spellbooks.
     */
    cursor?: SpellbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spellbooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spellbooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spellbooks.
     */
    distinct?: SpellbookScalarFieldEnum | SpellbookScalarFieldEnum[]
  }

  /**
   * Spellbook findMany
   */
  export type SpellbookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spellbook
     */
    select?: SpellbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spellbook
     */
    omit?: SpellbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookInclude<ExtArgs> | null
    /**
     * Filter, which Spellbooks to fetch.
     */
    where?: SpellbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spellbooks to fetch.
     */
    orderBy?: SpellbookOrderByWithRelationInput | SpellbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Spellbooks.
     */
    cursor?: SpellbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spellbooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spellbooks.
     */
    skip?: number
    distinct?: SpellbookScalarFieldEnum | SpellbookScalarFieldEnum[]
  }

  /**
   * Spellbook create
   */
  export type SpellbookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spellbook
     */
    select?: SpellbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spellbook
     */
    omit?: SpellbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookInclude<ExtArgs> | null
    /**
     * The data needed to create a Spellbook.
     */
    data?: XOR<SpellbookCreateInput, SpellbookUncheckedCreateInput>
  }

  /**
   * Spellbook createMany
   */
  export type SpellbookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Spellbooks.
     */
    data: SpellbookCreateManyInput | SpellbookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Spellbook createManyAndReturn
   */
  export type SpellbookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spellbook
     */
    select?: SpellbookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Spellbook
     */
    omit?: SpellbookOmit<ExtArgs> | null
    /**
     * The data used to create many Spellbooks.
     */
    data: SpellbookCreateManyInput | SpellbookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Spellbook update
   */
  export type SpellbookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spellbook
     */
    select?: SpellbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spellbook
     */
    omit?: SpellbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookInclude<ExtArgs> | null
    /**
     * The data needed to update a Spellbook.
     */
    data: XOR<SpellbookUpdateInput, SpellbookUncheckedUpdateInput>
    /**
     * Choose, which Spellbook to update.
     */
    where: SpellbookWhereUniqueInput
  }

  /**
   * Spellbook updateMany
   */
  export type SpellbookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Spellbooks.
     */
    data: XOR<SpellbookUpdateManyMutationInput, SpellbookUncheckedUpdateManyInput>
    /**
     * Filter which Spellbooks to update
     */
    where?: SpellbookWhereInput
    /**
     * Limit how many Spellbooks to update.
     */
    limit?: number
  }

  /**
   * Spellbook updateManyAndReturn
   */
  export type SpellbookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spellbook
     */
    select?: SpellbookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Spellbook
     */
    omit?: SpellbookOmit<ExtArgs> | null
    /**
     * The data used to update Spellbooks.
     */
    data: XOR<SpellbookUpdateManyMutationInput, SpellbookUncheckedUpdateManyInput>
    /**
     * Filter which Spellbooks to update
     */
    where?: SpellbookWhereInput
    /**
     * Limit how many Spellbooks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Spellbook upsert
   */
  export type SpellbookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spellbook
     */
    select?: SpellbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spellbook
     */
    omit?: SpellbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookInclude<ExtArgs> | null
    /**
     * The filter to search for the Spellbook to update in case it exists.
     */
    where: SpellbookWhereUniqueInput
    /**
     * In case the Spellbook found by the `where` argument doesn't exist, create a new Spellbook with this data.
     */
    create: XOR<SpellbookCreateInput, SpellbookUncheckedCreateInput>
    /**
     * In case the Spellbook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellbookUpdateInput, SpellbookUncheckedUpdateInput>
  }

  /**
   * Spellbook delete
   */
  export type SpellbookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spellbook
     */
    select?: SpellbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spellbook
     */
    omit?: SpellbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookInclude<ExtArgs> | null
    /**
     * Filter which Spellbook to delete.
     */
    where: SpellbookWhereUniqueInput
  }

  /**
   * Spellbook deleteMany
   */
  export type SpellbookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spellbooks to delete
     */
    where?: SpellbookWhereInput
    /**
     * Limit how many Spellbooks to delete.
     */
    limit?: number
  }

  /**
   * Spellbook.user
   */
  export type Spellbook$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Spellbook.spellbookSpells
   */
  export type Spellbook$spellbookSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellbookSpells
     */
    select?: SpellbookSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellbookSpells
     */
    omit?: SpellbookSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookSpellsInclude<ExtArgs> | null
    where?: SpellbookSpellsWhereInput
    orderBy?: SpellbookSpellsOrderByWithRelationInput | SpellbookSpellsOrderByWithRelationInput[]
    cursor?: SpellbookSpellsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellbookSpellsScalarFieldEnum | SpellbookSpellsScalarFieldEnum[]
  }

  /**
   * Spellbook without action
   */
  export type SpellbookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spellbook
     */
    select?: SpellbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spellbook
     */
    omit?: SpellbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookInclude<ExtArgs> | null
  }


  /**
   * Model SpellbookSpells
   */

  export type AggregateSpellbookSpells = {
    _count: SpellbookSpellsCountAggregateOutputType | null
    _avg: SpellbookSpellsAvgAggregateOutputType | null
    _sum: SpellbookSpellsSumAggregateOutputType | null
    _min: SpellbookSpellsMinAggregateOutputType | null
    _max: SpellbookSpellsMaxAggregateOutputType | null
  }

  export type SpellbookSpellsAvgAggregateOutputType = {
    spellbookSpellId: number | null
    spellId: number | null
    spellbookId: number | null
  }

  export type SpellbookSpellsSumAggregateOutputType = {
    spellbookSpellId: number | null
    spellId: number | null
    spellbookId: number | null
  }

  export type SpellbookSpellsMinAggregateOutputType = {
    spellbookSpellId: number | null
    spellId: number | null
    spellbookId: number | null
  }

  export type SpellbookSpellsMaxAggregateOutputType = {
    spellbookSpellId: number | null
    spellId: number | null
    spellbookId: number | null
  }

  export type SpellbookSpellsCountAggregateOutputType = {
    spellbookSpellId: number
    spellId: number
    spellbookId: number
    _all: number
  }


  export type SpellbookSpellsAvgAggregateInputType = {
    spellbookSpellId?: true
    spellId?: true
    spellbookId?: true
  }

  export type SpellbookSpellsSumAggregateInputType = {
    spellbookSpellId?: true
    spellId?: true
    spellbookId?: true
  }

  export type SpellbookSpellsMinAggregateInputType = {
    spellbookSpellId?: true
    spellId?: true
    spellbookId?: true
  }

  export type SpellbookSpellsMaxAggregateInputType = {
    spellbookSpellId?: true
    spellId?: true
    spellbookId?: true
  }

  export type SpellbookSpellsCountAggregateInputType = {
    spellbookSpellId?: true
    spellId?: true
    spellbookId?: true
    _all?: true
  }

  export type SpellbookSpellsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellbookSpells to aggregate.
     */
    where?: SpellbookSpellsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellbookSpells to fetch.
     */
    orderBy?: SpellbookSpellsOrderByWithRelationInput | SpellbookSpellsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellbookSpellsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellbookSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellbookSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellbookSpells
    **/
    _count?: true | SpellbookSpellsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellbookSpellsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellbookSpellsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellbookSpellsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellbookSpellsMaxAggregateInputType
  }

  export type GetSpellbookSpellsAggregateType<T extends SpellbookSpellsAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellbookSpells]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellbookSpells[P]>
      : GetScalarType<T[P], AggregateSpellbookSpells[P]>
  }




  export type SpellbookSpellsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellbookSpellsWhereInput
    orderBy?: SpellbookSpellsOrderByWithAggregationInput | SpellbookSpellsOrderByWithAggregationInput[]
    by: SpellbookSpellsScalarFieldEnum[] | SpellbookSpellsScalarFieldEnum
    having?: SpellbookSpellsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellbookSpellsCountAggregateInputType | true
    _avg?: SpellbookSpellsAvgAggregateInputType
    _sum?: SpellbookSpellsSumAggregateInputType
    _min?: SpellbookSpellsMinAggregateInputType
    _max?: SpellbookSpellsMaxAggregateInputType
  }

  export type SpellbookSpellsGroupByOutputType = {
    spellbookSpellId: number
    spellId: number | null
    spellbookId: number | null
    _count: SpellbookSpellsCountAggregateOutputType | null
    _avg: SpellbookSpellsAvgAggregateOutputType | null
    _sum: SpellbookSpellsSumAggregateOutputType | null
    _min: SpellbookSpellsMinAggregateOutputType | null
    _max: SpellbookSpellsMaxAggregateOutputType | null
  }

  type GetSpellbookSpellsGroupByPayload<T extends SpellbookSpellsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellbookSpellsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellbookSpellsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellbookSpellsGroupByOutputType[P]>
            : GetScalarType<T[P], SpellbookSpellsGroupByOutputType[P]>
        }
      >
    >


  export type SpellbookSpellsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    spellbookSpellId?: boolean
    spellId?: boolean
    spellbookId?: boolean
    spell?: boolean | SpellbookSpells$spellArgs<ExtArgs>
    spellbook?: boolean | SpellbookSpells$spellbookArgs<ExtArgs>
  }, ExtArgs["result"]["spellbookSpells"]>

  export type SpellbookSpellsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    spellbookSpellId?: boolean
    spellId?: boolean
    spellbookId?: boolean
    spell?: boolean | SpellbookSpells$spellArgs<ExtArgs>
    spellbook?: boolean | SpellbookSpells$spellbookArgs<ExtArgs>
  }, ExtArgs["result"]["spellbookSpells"]>

  export type SpellbookSpellsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    spellbookSpellId?: boolean
    spellId?: boolean
    spellbookId?: boolean
    spell?: boolean | SpellbookSpells$spellArgs<ExtArgs>
    spellbook?: boolean | SpellbookSpells$spellbookArgs<ExtArgs>
  }, ExtArgs["result"]["spellbookSpells"]>

  export type SpellbookSpellsSelectScalar = {
    spellbookSpellId?: boolean
    spellId?: boolean
    spellbookId?: boolean
  }

  export type SpellbookSpellsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"spellbookSpellId" | "spellId" | "spellbookId", ExtArgs["result"]["spellbookSpells"]>
  export type SpellbookSpellsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellbookSpells$spellArgs<ExtArgs>
    spellbook?: boolean | SpellbookSpells$spellbookArgs<ExtArgs>
  }
  export type SpellbookSpellsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellbookSpells$spellArgs<ExtArgs>
    spellbook?: boolean | SpellbookSpells$spellbookArgs<ExtArgs>
  }
  export type SpellbookSpellsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellbookSpells$spellArgs<ExtArgs>
    spellbook?: boolean | SpellbookSpells$spellbookArgs<ExtArgs>
  }

  export type $SpellbookSpellsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellbookSpells"
    objects: {
      spell: Prisma.$SpellPayload<ExtArgs> | null
      spellbook: Prisma.$SpellbookPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      spellbookSpellId: number
      spellId: number | null
      spellbookId: number | null
    }, ExtArgs["result"]["spellbookSpells"]>
    composites: {}
  }

  type SpellbookSpellsGetPayload<S extends boolean | null | undefined | SpellbookSpellsDefaultArgs> = $Result.GetResult<Prisma.$SpellbookSpellsPayload, S>

  type SpellbookSpellsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpellbookSpellsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpellbookSpellsCountAggregateInputType | true
    }

  export interface SpellbookSpellsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellbookSpells'], meta: { name: 'SpellbookSpells' } }
    /**
     * Find zero or one SpellbookSpells that matches the filter.
     * @param {SpellbookSpellsFindUniqueArgs} args - Arguments to find a SpellbookSpells
     * @example
     * // Get one SpellbookSpells
     * const spellbookSpells = await prisma.spellbookSpells.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpellbookSpellsFindUniqueArgs>(args: SelectSubset<T, SpellbookSpellsFindUniqueArgs<ExtArgs>>): Prisma__SpellbookSpellsClient<$Result.GetResult<Prisma.$SpellbookSpellsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpellbookSpells that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpellbookSpellsFindUniqueOrThrowArgs} args - Arguments to find a SpellbookSpells
     * @example
     * // Get one SpellbookSpells
     * const spellbookSpells = await prisma.spellbookSpells.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpellbookSpellsFindUniqueOrThrowArgs>(args: SelectSubset<T, SpellbookSpellsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpellbookSpellsClient<$Result.GetResult<Prisma.$SpellbookSpellsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellbookSpells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellbookSpellsFindFirstArgs} args - Arguments to find a SpellbookSpells
     * @example
     * // Get one SpellbookSpells
     * const spellbookSpells = await prisma.spellbookSpells.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpellbookSpellsFindFirstArgs>(args?: SelectSubset<T, SpellbookSpellsFindFirstArgs<ExtArgs>>): Prisma__SpellbookSpellsClient<$Result.GetResult<Prisma.$SpellbookSpellsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpellbookSpells that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellbookSpellsFindFirstOrThrowArgs} args - Arguments to find a SpellbookSpells
     * @example
     * // Get one SpellbookSpells
     * const spellbookSpells = await prisma.spellbookSpells.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpellbookSpellsFindFirstOrThrowArgs>(args?: SelectSubset<T, SpellbookSpellsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpellbookSpellsClient<$Result.GetResult<Prisma.$SpellbookSpellsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpellbookSpells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellbookSpellsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellbookSpells
     * const spellbookSpells = await prisma.spellbookSpells.findMany()
     * 
     * // Get first 10 SpellbookSpells
     * const spellbookSpells = await prisma.spellbookSpells.findMany({ take: 10 })
     * 
     * // Only select the `spellbookSpellId`
     * const spellbookSpellsWithSpellbookSpellIdOnly = await prisma.spellbookSpells.findMany({ select: { spellbookSpellId: true } })
     * 
     */
    findMany<T extends SpellbookSpellsFindManyArgs>(args?: SelectSubset<T, SpellbookSpellsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellbookSpellsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpellbookSpells.
     * @param {SpellbookSpellsCreateArgs} args - Arguments to create a SpellbookSpells.
     * @example
     * // Create one SpellbookSpells
     * const SpellbookSpells = await prisma.spellbookSpells.create({
     *   data: {
     *     // ... data to create a SpellbookSpells
     *   }
     * })
     * 
     */
    create<T extends SpellbookSpellsCreateArgs>(args: SelectSubset<T, SpellbookSpellsCreateArgs<ExtArgs>>): Prisma__SpellbookSpellsClient<$Result.GetResult<Prisma.$SpellbookSpellsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpellbookSpells.
     * @param {SpellbookSpellsCreateManyArgs} args - Arguments to create many SpellbookSpells.
     * @example
     * // Create many SpellbookSpells
     * const spellbookSpells = await prisma.spellbookSpells.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpellbookSpellsCreateManyArgs>(args?: SelectSubset<T, SpellbookSpellsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpellbookSpells and returns the data saved in the database.
     * @param {SpellbookSpellsCreateManyAndReturnArgs} args - Arguments to create many SpellbookSpells.
     * @example
     * // Create many SpellbookSpells
     * const spellbookSpells = await prisma.spellbookSpells.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpellbookSpells and only return the `spellbookSpellId`
     * const spellbookSpellsWithSpellbookSpellIdOnly = await prisma.spellbookSpells.createManyAndReturn({
     *   select: { spellbookSpellId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpellbookSpellsCreateManyAndReturnArgs>(args?: SelectSubset<T, SpellbookSpellsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellbookSpellsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpellbookSpells.
     * @param {SpellbookSpellsDeleteArgs} args - Arguments to delete one SpellbookSpells.
     * @example
     * // Delete one SpellbookSpells
     * const SpellbookSpells = await prisma.spellbookSpells.delete({
     *   where: {
     *     // ... filter to delete one SpellbookSpells
     *   }
     * })
     * 
     */
    delete<T extends SpellbookSpellsDeleteArgs>(args: SelectSubset<T, SpellbookSpellsDeleteArgs<ExtArgs>>): Prisma__SpellbookSpellsClient<$Result.GetResult<Prisma.$SpellbookSpellsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpellbookSpells.
     * @param {SpellbookSpellsUpdateArgs} args - Arguments to update one SpellbookSpells.
     * @example
     * // Update one SpellbookSpells
     * const spellbookSpells = await prisma.spellbookSpells.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpellbookSpellsUpdateArgs>(args: SelectSubset<T, SpellbookSpellsUpdateArgs<ExtArgs>>): Prisma__SpellbookSpellsClient<$Result.GetResult<Prisma.$SpellbookSpellsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpellbookSpells.
     * @param {SpellbookSpellsDeleteManyArgs} args - Arguments to filter SpellbookSpells to delete.
     * @example
     * // Delete a few SpellbookSpells
     * const { count } = await prisma.spellbookSpells.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpellbookSpellsDeleteManyArgs>(args?: SelectSubset<T, SpellbookSpellsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellbookSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellbookSpellsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellbookSpells
     * const spellbookSpells = await prisma.spellbookSpells.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpellbookSpellsUpdateManyArgs>(args: SelectSubset<T, SpellbookSpellsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellbookSpells and returns the data updated in the database.
     * @param {SpellbookSpellsUpdateManyAndReturnArgs} args - Arguments to update many SpellbookSpells.
     * @example
     * // Update many SpellbookSpells
     * const spellbookSpells = await prisma.spellbookSpells.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpellbookSpells and only return the `spellbookSpellId`
     * const spellbookSpellsWithSpellbookSpellIdOnly = await prisma.spellbookSpells.updateManyAndReturn({
     *   select: { spellbookSpellId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpellbookSpellsUpdateManyAndReturnArgs>(args: SelectSubset<T, SpellbookSpellsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellbookSpellsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpellbookSpells.
     * @param {SpellbookSpellsUpsertArgs} args - Arguments to update or create a SpellbookSpells.
     * @example
     * // Update or create a SpellbookSpells
     * const spellbookSpells = await prisma.spellbookSpells.upsert({
     *   create: {
     *     // ... data to create a SpellbookSpells
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellbookSpells we want to update
     *   }
     * })
     */
    upsert<T extends SpellbookSpellsUpsertArgs>(args: SelectSubset<T, SpellbookSpellsUpsertArgs<ExtArgs>>): Prisma__SpellbookSpellsClient<$Result.GetResult<Prisma.$SpellbookSpellsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpellbookSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellbookSpellsCountArgs} args - Arguments to filter SpellbookSpells to count.
     * @example
     * // Count the number of SpellbookSpells
     * const count = await prisma.spellbookSpells.count({
     *   where: {
     *     // ... the filter for the SpellbookSpells we want to count
     *   }
     * })
    **/
    count<T extends SpellbookSpellsCountArgs>(
      args?: Subset<T, SpellbookSpellsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellbookSpellsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellbookSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellbookSpellsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellbookSpellsAggregateArgs>(args: Subset<T, SpellbookSpellsAggregateArgs>): Prisma.PrismaPromise<GetSpellbookSpellsAggregateType<T>>

    /**
     * Group by SpellbookSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellbookSpellsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellbookSpellsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellbookSpellsGroupByArgs['orderBy'] }
        : { orderBy?: SpellbookSpellsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellbookSpellsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellbookSpellsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellbookSpells model
   */
  readonly fields: SpellbookSpellsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellbookSpells.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellbookSpellsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    spell<T extends SpellbookSpells$spellArgs<ExtArgs> = {}>(args?: Subset<T, SpellbookSpells$spellArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    spellbook<T extends SpellbookSpells$spellbookArgs<ExtArgs> = {}>(args?: Subset<T, SpellbookSpells$spellbookArgs<ExtArgs>>): Prisma__SpellbookClient<$Result.GetResult<Prisma.$SpellbookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpellbookSpells model
   */
  interface SpellbookSpellsFieldRefs {
    readonly spellbookSpellId: FieldRef<"SpellbookSpells", 'Int'>
    readonly spellId: FieldRef<"SpellbookSpells", 'Int'>
    readonly spellbookId: FieldRef<"SpellbookSpells", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SpellbookSpells findUnique
   */
  export type SpellbookSpellsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellbookSpells
     */
    select?: SpellbookSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellbookSpells
     */
    omit?: SpellbookSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookSpellsInclude<ExtArgs> | null
    /**
     * Filter, which SpellbookSpells to fetch.
     */
    where: SpellbookSpellsWhereUniqueInput
  }

  /**
   * SpellbookSpells findUniqueOrThrow
   */
  export type SpellbookSpellsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellbookSpells
     */
    select?: SpellbookSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellbookSpells
     */
    omit?: SpellbookSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookSpellsInclude<ExtArgs> | null
    /**
     * Filter, which SpellbookSpells to fetch.
     */
    where: SpellbookSpellsWhereUniqueInput
  }

  /**
   * SpellbookSpells findFirst
   */
  export type SpellbookSpellsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellbookSpells
     */
    select?: SpellbookSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellbookSpells
     */
    omit?: SpellbookSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookSpellsInclude<ExtArgs> | null
    /**
     * Filter, which SpellbookSpells to fetch.
     */
    where?: SpellbookSpellsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellbookSpells to fetch.
     */
    orderBy?: SpellbookSpellsOrderByWithRelationInput | SpellbookSpellsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellbookSpells.
     */
    cursor?: SpellbookSpellsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellbookSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellbookSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellbookSpells.
     */
    distinct?: SpellbookSpellsScalarFieldEnum | SpellbookSpellsScalarFieldEnum[]
  }

  /**
   * SpellbookSpells findFirstOrThrow
   */
  export type SpellbookSpellsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellbookSpells
     */
    select?: SpellbookSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellbookSpells
     */
    omit?: SpellbookSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookSpellsInclude<ExtArgs> | null
    /**
     * Filter, which SpellbookSpells to fetch.
     */
    where?: SpellbookSpellsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellbookSpells to fetch.
     */
    orderBy?: SpellbookSpellsOrderByWithRelationInput | SpellbookSpellsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellbookSpells.
     */
    cursor?: SpellbookSpellsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellbookSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellbookSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellbookSpells.
     */
    distinct?: SpellbookSpellsScalarFieldEnum | SpellbookSpellsScalarFieldEnum[]
  }

  /**
   * SpellbookSpells findMany
   */
  export type SpellbookSpellsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellbookSpells
     */
    select?: SpellbookSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellbookSpells
     */
    omit?: SpellbookSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookSpellsInclude<ExtArgs> | null
    /**
     * Filter, which SpellbookSpells to fetch.
     */
    where?: SpellbookSpellsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellbookSpells to fetch.
     */
    orderBy?: SpellbookSpellsOrderByWithRelationInput | SpellbookSpellsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellbookSpells.
     */
    cursor?: SpellbookSpellsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellbookSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellbookSpells.
     */
    skip?: number
    distinct?: SpellbookSpellsScalarFieldEnum | SpellbookSpellsScalarFieldEnum[]
  }

  /**
   * SpellbookSpells create
   */
  export type SpellbookSpellsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellbookSpells
     */
    select?: SpellbookSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellbookSpells
     */
    omit?: SpellbookSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookSpellsInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellbookSpells.
     */
    data?: XOR<SpellbookSpellsCreateInput, SpellbookSpellsUncheckedCreateInput>
  }

  /**
   * SpellbookSpells createMany
   */
  export type SpellbookSpellsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellbookSpells.
     */
    data: SpellbookSpellsCreateManyInput | SpellbookSpellsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpellbookSpells createManyAndReturn
   */
  export type SpellbookSpellsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellbookSpells
     */
    select?: SpellbookSpellsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpellbookSpells
     */
    omit?: SpellbookSpellsOmit<ExtArgs> | null
    /**
     * The data used to create many SpellbookSpells.
     */
    data: SpellbookSpellsCreateManyInput | SpellbookSpellsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookSpellsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpellbookSpells update
   */
  export type SpellbookSpellsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellbookSpells
     */
    select?: SpellbookSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellbookSpells
     */
    omit?: SpellbookSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookSpellsInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellbookSpells.
     */
    data: XOR<SpellbookSpellsUpdateInput, SpellbookSpellsUncheckedUpdateInput>
    /**
     * Choose, which SpellbookSpells to update.
     */
    where: SpellbookSpellsWhereUniqueInput
  }

  /**
   * SpellbookSpells updateMany
   */
  export type SpellbookSpellsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellbookSpells.
     */
    data: XOR<SpellbookSpellsUpdateManyMutationInput, SpellbookSpellsUncheckedUpdateManyInput>
    /**
     * Filter which SpellbookSpells to update
     */
    where?: SpellbookSpellsWhereInput
    /**
     * Limit how many SpellbookSpells to update.
     */
    limit?: number
  }

  /**
   * SpellbookSpells updateManyAndReturn
   */
  export type SpellbookSpellsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellbookSpells
     */
    select?: SpellbookSpellsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpellbookSpells
     */
    omit?: SpellbookSpellsOmit<ExtArgs> | null
    /**
     * The data used to update SpellbookSpells.
     */
    data: XOR<SpellbookSpellsUpdateManyMutationInput, SpellbookSpellsUncheckedUpdateManyInput>
    /**
     * Filter which SpellbookSpells to update
     */
    where?: SpellbookSpellsWhereInput
    /**
     * Limit how many SpellbookSpells to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookSpellsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpellbookSpells upsert
   */
  export type SpellbookSpellsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellbookSpells
     */
    select?: SpellbookSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellbookSpells
     */
    omit?: SpellbookSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookSpellsInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellbookSpells to update in case it exists.
     */
    where: SpellbookSpellsWhereUniqueInput
    /**
     * In case the SpellbookSpells found by the `where` argument doesn't exist, create a new SpellbookSpells with this data.
     */
    create: XOR<SpellbookSpellsCreateInput, SpellbookSpellsUncheckedCreateInput>
    /**
     * In case the SpellbookSpells was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellbookSpellsUpdateInput, SpellbookSpellsUncheckedUpdateInput>
  }

  /**
   * SpellbookSpells delete
   */
  export type SpellbookSpellsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellbookSpells
     */
    select?: SpellbookSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellbookSpells
     */
    omit?: SpellbookSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookSpellsInclude<ExtArgs> | null
    /**
     * Filter which SpellbookSpells to delete.
     */
    where: SpellbookSpellsWhereUniqueInput
  }

  /**
   * SpellbookSpells deleteMany
   */
  export type SpellbookSpellsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellbookSpells to delete
     */
    where?: SpellbookSpellsWhereInput
    /**
     * Limit how many SpellbookSpells to delete.
     */
    limit?: number
  }

  /**
   * SpellbookSpells.spell
   */
  export type SpellbookSpells$spellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    where?: SpellWhereInput
  }

  /**
   * SpellbookSpells.spellbook
   */
  export type SpellbookSpells$spellbookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spellbook
     */
    select?: SpellbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spellbook
     */
    omit?: SpellbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookInclude<ExtArgs> | null
    where?: SpellbookWhereInput
  }

  /**
   * SpellbookSpells without action
   */
  export type SpellbookSpellsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellbookSpells
     */
    select?: SpellbookSpellsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpellbookSpells
     */
    omit?: SpellbookSpellsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookSpellsInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    userId: number | null
  }

  export type UserSumAggregateOutputType = {
    userId: number | null
  }

  export type UserMinAggregateOutputType = {
    userId: number | null
    login: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    userId: number | null
    login: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    userId: number
    login: number
    password: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    userId?: true
  }

  export type UserSumAggregateInputType = {
    userId?: true
  }

  export type UserMinAggregateInputType = {
    userId?: true
    login?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    userId?: true
    login?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    userId?: true
    login?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    userId: number
    login: string
    password: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    login?: boolean
    password?: boolean
    character?: boolean | User$characterArgs<ExtArgs>
    spellbook?: boolean | User$spellbookArgs<ExtArgs>
    pers?: boolean | User$persArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    login?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    login?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    userId?: boolean
    login?: boolean
    password?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "login" | "password", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | User$characterArgs<ExtArgs>
    spellbook?: boolean | User$spellbookArgs<ExtArgs>
    pers?: boolean | User$persArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>[]
      spellbook: Prisma.$SpellbookPayload<ExtArgs>[]
      pers: Prisma.$PersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      login: string
      password: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userWithUserIdOnly = await prisma.user.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `userId`
     * const userWithUserIdOnly = await prisma.user.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `userId`
     * const userWithUserIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends User$characterArgs<ExtArgs> = {}>(args?: Subset<T, User$characterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spellbook<T extends User$spellbookArgs<ExtArgs> = {}>(args?: Subset<T, User$spellbookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellbookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pers<T extends User$persArgs<ExtArgs> = {}>(args?: Subset<T, User$persArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly userId: FieldRef<"User", 'Int'>
    readonly login: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.character
   */
  export type User$characterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * User.spellbook
   */
  export type User$spellbookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spellbook
     */
    select?: SpellbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spellbook
     */
    omit?: SpellbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellbookInclude<ExtArgs> | null
    where?: SpellbookWhereInput
    orderBy?: SpellbookOrderByWithRelationInput | SpellbookOrderByWithRelationInput[]
    cursor?: SpellbookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellbookScalarFieldEnum | SpellbookScalarFieldEnum[]
  }

  /**
   * User.pers
   */
  export type User$persArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    where?: PersWhereInput
    orderBy?: PersOrderByWithRelationInput | PersOrderByWithRelationInput[]
    cursor?: PersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersScalarFieldEnum | PersScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassAvgAggregateOutputType = {
    classId: number | null
    hitDie: number | null
    abilityScoreUpLevels: number | null
    subclassLevel: number | null
    multiclassStrReq: number | null
    multiclassDexReq: number | null
    multiclassConReq: number | null
    multiclassIntReq: number | null
    multiclassWisReq: number | null
    multiclassChaReq: number | null
    languagesToChooseCount: number | null
  }

  export type ClassSumAggregateOutputType = {
    classId: number | null
    hitDie: number | null
    abilityScoreUpLevels: number[]
    subclassLevel: number | null
    multiclassStrReq: number | null
    multiclassDexReq: number | null
    multiclassConReq: number | null
    multiclassIntReq: number | null
    multiclassWisReq: number | null
    multiclassChaReq: number | null
    languagesToChooseCount: number | null
  }

  export type ClassMinAggregateOutputType = {
    classId: number | null
    name: string | null
    hitDie: number | null
    primaryCastingStat: $Enums.Ability | null
    spellcastingType: $Enums.SpellcastingType | null
    subclassLevel: number | null
    multiclassStrReq: number | null
    multiclassDexReq: number | null
    multiclassConReq: number | null
    multiclassIntReq: number | null
    multiclassWisReq: number | null
    multiclassChaReq: number | null
    languagesToChooseCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    classId: number | null
    name: string | null
    hitDie: number | null
    primaryCastingStat: $Enums.Ability | null
    spellcastingType: $Enums.SpellcastingType | null
    subclassLevel: number | null
    multiclassStrReq: number | null
    multiclassDexReq: number | null
    multiclassConReq: number | null
    multiclassIntReq: number | null
    multiclassWisReq: number | null
    multiclassChaReq: number | null
    languagesToChooseCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    classId: number
    name: number
    hitDie: number
    primaryCastingStat: number
    spellcastingType: number
    abilityScoreUpLevels: number
    subclassLevel: number
    multiclassStrReq: number
    multiclassDexReq: number
    multiclassConReq: number
    multiclassIntReq: number
    multiclassWisReq: number
    multiclassChaReq: number
    armorProficiencies: number
    weaponProficiencies: number
    savingThrows: number
    skillProficiencies: number
    toolProficiencies: number
    languagesToChooseCount: number
    languages: number
    specialSpellSlotProgression: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassAvgAggregateInputType = {
    classId?: true
    hitDie?: true
    abilityScoreUpLevels?: true
    subclassLevel?: true
    multiclassStrReq?: true
    multiclassDexReq?: true
    multiclassConReq?: true
    multiclassIntReq?: true
    multiclassWisReq?: true
    multiclassChaReq?: true
    languagesToChooseCount?: true
  }

  export type ClassSumAggregateInputType = {
    classId?: true
    hitDie?: true
    abilityScoreUpLevels?: true
    subclassLevel?: true
    multiclassStrReq?: true
    multiclassDexReq?: true
    multiclassConReq?: true
    multiclassIntReq?: true
    multiclassWisReq?: true
    multiclassChaReq?: true
    languagesToChooseCount?: true
  }

  export type ClassMinAggregateInputType = {
    classId?: true
    name?: true
    hitDie?: true
    primaryCastingStat?: true
    spellcastingType?: true
    subclassLevel?: true
    multiclassStrReq?: true
    multiclassDexReq?: true
    multiclassConReq?: true
    multiclassIntReq?: true
    multiclassWisReq?: true
    multiclassChaReq?: true
    languagesToChooseCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassMaxAggregateInputType = {
    classId?: true
    name?: true
    hitDie?: true
    primaryCastingStat?: true
    spellcastingType?: true
    subclassLevel?: true
    multiclassStrReq?: true
    multiclassDexReq?: true
    multiclassConReq?: true
    multiclassIntReq?: true
    multiclassWisReq?: true
    multiclassChaReq?: true
    languagesToChooseCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassCountAggregateInputType = {
    classId?: true
    name?: true
    hitDie?: true
    primaryCastingStat?: true
    spellcastingType?: true
    abilityScoreUpLevels?: true
    subclassLevel?: true
    multiclassStrReq?: true
    multiclassDexReq?: true
    multiclassConReq?: true
    multiclassIntReq?: true
    multiclassWisReq?: true
    multiclassChaReq?: true
    armorProficiencies?: true
    weaponProficiencies?: true
    savingThrows?: true
    skillProficiencies?: true
    toolProficiencies?: true
    languagesToChooseCount?: true
    languages?: true
    specialSpellSlotProgression?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _avg?: ClassAvgAggregateInputType
    _sum?: ClassSumAggregateInputType
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    classId: number
    name: string
    hitDie: number
    primaryCastingStat: $Enums.Ability | null
    spellcastingType: $Enums.SpellcastingType
    abilityScoreUpLevels: number[]
    subclassLevel: number
    multiclassStrReq: number
    multiclassDexReq: number
    multiclassConReq: number
    multiclassIntReq: number
    multiclassWisReq: number
    multiclassChaReq: number
    armorProficiencies: $Enums.ArmorType[]
    weaponProficiencies: $Enums.WeaponType[]
    savingThrows: $Enums.Ability[]
    skillProficiencies: $Enums.Ability[]
    toolProficiencies: $Enums.ToolCategory[]
    languagesToChooseCount: number
    languages: $Enums.Language[]
    specialSpellSlotProgression: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classId?: boolean
    name?: boolean
    hitDie?: boolean
    primaryCastingStat?: boolean
    spellcastingType?: boolean
    abilityScoreUpLevels?: boolean
    subclassLevel?: boolean
    multiclassStrReq?: boolean
    multiclassDexReq?: boolean
    multiclassConReq?: boolean
    multiclassIntReq?: boolean
    multiclassWisReq?: boolean
    multiclassChaReq?: boolean
    armorProficiencies?: boolean
    weaponProficiencies?: boolean
    savingThrows?: boolean
    skillProficiencies?: boolean
    toolProficiencies?: boolean
    languagesToChooseCount?: boolean
    languages?: boolean
    specialSpellSlotProgression?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subclasses?: boolean | Class$subclassesArgs<ExtArgs>
    classFeatures?: boolean | Class$classFeaturesArgs<ExtArgs>
    perses?: boolean | Class$persesArgs<ExtArgs>
    persMulticlasses?: boolean | Class$persMulticlassesArgs<ExtArgs>
    startingEquipmentOption?: boolean | Class$startingEquipmentOptionArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classId?: boolean
    name?: boolean
    hitDie?: boolean
    primaryCastingStat?: boolean
    spellcastingType?: boolean
    abilityScoreUpLevels?: boolean
    subclassLevel?: boolean
    multiclassStrReq?: boolean
    multiclassDexReq?: boolean
    multiclassConReq?: boolean
    multiclassIntReq?: boolean
    multiclassWisReq?: boolean
    multiclassChaReq?: boolean
    armorProficiencies?: boolean
    weaponProficiencies?: boolean
    savingThrows?: boolean
    skillProficiencies?: boolean
    toolProficiencies?: boolean
    languagesToChooseCount?: boolean
    languages?: boolean
    specialSpellSlotProgression?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["class"]>

  export type ClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classId?: boolean
    name?: boolean
    hitDie?: boolean
    primaryCastingStat?: boolean
    spellcastingType?: boolean
    abilityScoreUpLevels?: boolean
    subclassLevel?: boolean
    multiclassStrReq?: boolean
    multiclassDexReq?: boolean
    multiclassConReq?: boolean
    multiclassIntReq?: boolean
    multiclassWisReq?: boolean
    multiclassChaReq?: boolean
    armorProficiencies?: boolean
    weaponProficiencies?: boolean
    savingThrows?: boolean
    skillProficiencies?: boolean
    toolProficiencies?: boolean
    languagesToChooseCount?: boolean
    languages?: boolean
    specialSpellSlotProgression?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    classId?: boolean
    name?: boolean
    hitDie?: boolean
    primaryCastingStat?: boolean
    spellcastingType?: boolean
    abilityScoreUpLevels?: boolean
    subclassLevel?: boolean
    multiclassStrReq?: boolean
    multiclassDexReq?: boolean
    multiclassConReq?: boolean
    multiclassIntReq?: boolean
    multiclassWisReq?: boolean
    multiclassChaReq?: boolean
    armorProficiencies?: boolean
    weaponProficiencies?: boolean
    savingThrows?: boolean
    skillProficiencies?: boolean
    toolProficiencies?: boolean
    languagesToChooseCount?: boolean
    languages?: boolean
    specialSpellSlotProgression?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"classId" | "name" | "hitDie" | "primaryCastingStat" | "spellcastingType" | "abilityScoreUpLevels" | "subclassLevel" | "multiclassStrReq" | "multiclassDexReq" | "multiclassConReq" | "multiclassIntReq" | "multiclassWisReq" | "multiclassChaReq" | "armorProficiencies" | "weaponProficiencies" | "savingThrows" | "skillProficiencies" | "toolProficiencies" | "languagesToChooseCount" | "languages" | "specialSpellSlotProgression" | "createdAt" | "updatedAt", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subclasses?: boolean | Class$subclassesArgs<ExtArgs>
    classFeatures?: boolean | Class$classFeaturesArgs<ExtArgs>
    perses?: boolean | Class$persesArgs<ExtArgs>
    persMulticlasses?: boolean | Class$persMulticlassesArgs<ExtArgs>
    startingEquipmentOption?: boolean | Class$startingEquipmentOptionArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      subclasses: Prisma.$SubclassPayload<ExtArgs>[]
      classFeatures: Prisma.$ClassFeaturePayload<ExtArgs>[]
      perses: Prisma.$PersPayload<ExtArgs>[]
      persMulticlasses: Prisma.$PersMulticlassPayload<ExtArgs>[]
      startingEquipmentOption: Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      classId: number
      name: string
      hitDie: number
      primaryCastingStat: $Enums.Ability | null
      spellcastingType: $Enums.SpellcastingType
      abilityScoreUpLevels: number[]
      subclassLevel: number
      multiclassStrReq: number
      multiclassDexReq: number
      multiclassConReq: number
      multiclassIntReq: number
      multiclassWisReq: number
      multiclassChaReq: number
      armorProficiencies: $Enums.ArmorType[]
      weaponProficiencies: $Enums.WeaponType[]
      savingThrows: $Enums.Ability[]
      skillProficiencies: $Enums.Ability[]
      toolProficiencies: $Enums.ToolCategory[]
      languagesToChooseCount: number
      languages: $Enums.Language[]
      specialSpellSlotProgression: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `classId`
     * const classWithClassIdOnly = await prisma.class.findMany({ select: { classId: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `classId`
     * const classWithClassIdOnly = await prisma.class.createManyAndReturn({
     *   select: { classId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `classId`
     * const classWithClassIdOnly = await prisma.class.updateManyAndReturn({
     *   select: { classId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subclasses<T extends Class$subclassesArgs<ExtArgs> = {}>(args?: Subset<T, Class$subclassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classFeatures<T extends Class$classFeaturesArgs<ExtArgs> = {}>(args?: Subset<T, Class$classFeaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    perses<T extends Class$persesArgs<ExtArgs> = {}>(args?: Subset<T, Class$persesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    persMulticlasses<T extends Class$persMulticlassesArgs<ExtArgs> = {}>(args?: Subset<T, Class$persMulticlassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersMulticlassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    startingEquipmentOption<T extends Class$startingEquipmentOptionArgs<ExtArgs> = {}>(args?: Subset<T, Class$startingEquipmentOptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly classId: FieldRef<"Class", 'Int'>
    readonly name: FieldRef<"Class", 'String'>
    readonly hitDie: FieldRef<"Class", 'Int'>
    readonly primaryCastingStat: FieldRef<"Class", 'Ability'>
    readonly spellcastingType: FieldRef<"Class", 'SpellcastingType'>
    readonly abilityScoreUpLevels: FieldRef<"Class", 'Int[]'>
    readonly subclassLevel: FieldRef<"Class", 'Int'>
    readonly multiclassStrReq: FieldRef<"Class", 'Int'>
    readonly multiclassDexReq: FieldRef<"Class", 'Int'>
    readonly multiclassConReq: FieldRef<"Class", 'Int'>
    readonly multiclassIntReq: FieldRef<"Class", 'Int'>
    readonly multiclassWisReq: FieldRef<"Class", 'Int'>
    readonly multiclassChaReq: FieldRef<"Class", 'Int'>
    readonly armorProficiencies: FieldRef<"Class", 'ArmorType[]'>
    readonly weaponProficiencies: FieldRef<"Class", 'WeaponType[]'>
    readonly savingThrows: FieldRef<"Class", 'Ability[]'>
    readonly skillProficiencies: FieldRef<"Class", 'Ability[]'>
    readonly toolProficiencies: FieldRef<"Class", 'ToolCategory[]'>
    readonly languagesToChooseCount: FieldRef<"Class", 'Int'>
    readonly languages: FieldRef<"Class", 'Language[]'>
    readonly specialSpellSlotProgression: FieldRef<"Class", 'Json'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class updateManyAndReturn
   */
  export type ClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class.subclasses
   */
  export type Class$subclassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassInclude<ExtArgs> | null
    where?: SubclassWhereInput
    orderBy?: SubclassOrderByWithRelationInput | SubclassOrderByWithRelationInput[]
    cursor?: SubclassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubclassScalarFieldEnum | SubclassScalarFieldEnum[]
  }

  /**
   * Class.classFeatures
   */
  export type Class$classFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    where?: ClassFeatureWhereInput
    orderBy?: ClassFeatureOrderByWithRelationInput | ClassFeatureOrderByWithRelationInput[]
    cursor?: ClassFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassFeatureScalarFieldEnum | ClassFeatureScalarFieldEnum[]
  }

  /**
   * Class.perses
   */
  export type Class$persesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    where?: PersWhereInput
    orderBy?: PersOrderByWithRelationInput | PersOrderByWithRelationInput[]
    cursor?: PersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersScalarFieldEnum | PersScalarFieldEnum[]
  }

  /**
   * Class.persMulticlasses
   */
  export type Class$persMulticlassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMulticlass
     */
    select?: PersMulticlassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMulticlass
     */
    omit?: PersMulticlassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMulticlassInclude<ExtArgs> | null
    where?: PersMulticlassWhereInput
    orderBy?: PersMulticlassOrderByWithRelationInput | PersMulticlassOrderByWithRelationInput[]
    cursor?: PersMulticlassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersMulticlassScalarFieldEnum | PersMulticlassScalarFieldEnum[]
  }

  /**
   * Class.startingEquipmentOption
   */
  export type Class$startingEquipmentOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionInclude<ExtArgs> | null
    where?: ClassStartingEquipmentOptionWhereInput
    orderBy?: ClassStartingEquipmentOptionOrderByWithRelationInput | ClassStartingEquipmentOptionOrderByWithRelationInput[]
    cursor?: ClassStartingEquipmentOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassStartingEquipmentOptionScalarFieldEnum | ClassStartingEquipmentOptionScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model Subclass
   */

  export type AggregateSubclass = {
    _count: SubclassCountAggregateOutputType | null
    _avg: SubclassAvgAggregateOutputType | null
    _sum: SubclassSumAggregateOutputType | null
    _min: SubclassMinAggregateOutputType | null
    _max: SubclassMaxAggregateOutputType | null
  }

  export type SubclassAvgAggregateOutputType = {
    subclassId: number | null
    classId: number | null
    languagesToChooseCount: number | null
  }

  export type SubclassSumAggregateOutputType = {
    subclassId: number | null
    classId: number | null
    languagesToChooseCount: number | null
  }

  export type SubclassMinAggregateOutputType = {
    subclassId: number | null
    classId: number | null
    name: string | null
    description: string | null
    grantsSpells: boolean | null
    languagesToChooseCount: number | null
  }

  export type SubclassMaxAggregateOutputType = {
    subclassId: number | null
    classId: number | null
    name: string | null
    description: string | null
    grantsSpells: boolean | null
    languagesToChooseCount: number | null
  }

  export type SubclassCountAggregateOutputType = {
    subclassId: number
    classId: number
    name: number
    description: number
    grantsSpells: number
    languagesToChooseCount: number
    languages: number
    toolProficiencies: number
    _all: number
  }


  export type SubclassAvgAggregateInputType = {
    subclassId?: true
    classId?: true
    languagesToChooseCount?: true
  }

  export type SubclassSumAggregateInputType = {
    subclassId?: true
    classId?: true
    languagesToChooseCount?: true
  }

  export type SubclassMinAggregateInputType = {
    subclassId?: true
    classId?: true
    name?: true
    description?: true
    grantsSpells?: true
    languagesToChooseCount?: true
  }

  export type SubclassMaxAggregateInputType = {
    subclassId?: true
    classId?: true
    name?: true
    description?: true
    grantsSpells?: true
    languagesToChooseCount?: true
  }

  export type SubclassCountAggregateInputType = {
    subclassId?: true
    classId?: true
    name?: true
    description?: true
    grantsSpells?: true
    languagesToChooseCount?: true
    languages?: true
    toolProficiencies?: true
    _all?: true
  }

  export type SubclassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subclass to aggregate.
     */
    where?: SubclassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subclasses to fetch.
     */
    orderBy?: SubclassOrderByWithRelationInput | SubclassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubclassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subclasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subclasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subclasses
    **/
    _count?: true | SubclassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubclassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubclassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubclassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubclassMaxAggregateInputType
  }

  export type GetSubclassAggregateType<T extends SubclassAggregateArgs> = {
        [P in keyof T & keyof AggregateSubclass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubclass[P]>
      : GetScalarType<T[P], AggregateSubclass[P]>
  }




  export type SubclassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubclassWhereInput
    orderBy?: SubclassOrderByWithAggregationInput | SubclassOrderByWithAggregationInput[]
    by: SubclassScalarFieldEnum[] | SubclassScalarFieldEnum
    having?: SubclassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubclassCountAggregateInputType | true
    _avg?: SubclassAvgAggregateInputType
    _sum?: SubclassSumAggregateInputType
    _min?: SubclassMinAggregateInputType
    _max?: SubclassMaxAggregateInputType
  }

  export type SubclassGroupByOutputType = {
    subclassId: number
    classId: number
    name: string
    description: string | null
    grantsSpells: boolean
    languagesToChooseCount: number
    languages: $Enums.Language[]
    toolProficiencies: $Enums.ToolCategory[]
    _count: SubclassCountAggregateOutputType | null
    _avg: SubclassAvgAggregateOutputType | null
    _sum: SubclassSumAggregateOutputType | null
    _min: SubclassMinAggregateOutputType | null
    _max: SubclassMaxAggregateOutputType | null
  }

  type GetSubclassGroupByPayload<T extends SubclassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubclassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubclassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubclassGroupByOutputType[P]>
            : GetScalarType<T[P], SubclassGroupByOutputType[P]>
        }
      >
    >


  export type SubclassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subclassId?: boolean
    classId?: boolean
    name?: boolean
    description?: boolean
    grantsSpells?: boolean
    languagesToChooseCount?: boolean
    languages?: boolean
    toolProficiencies?: boolean
    expandedSpells?: boolean | Subclass$expandedSpellsArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    features?: boolean | Subclass$featuresArgs<ExtArgs>
    perses?: boolean | Subclass$persesArgs<ExtArgs>
    persMulticlasses?: boolean | Subclass$persMulticlassesArgs<ExtArgs>
    _count?: boolean | SubclassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subclass"]>

  export type SubclassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subclassId?: boolean
    classId?: boolean
    name?: boolean
    description?: boolean
    grantsSpells?: boolean
    languagesToChooseCount?: boolean
    languages?: boolean
    toolProficiencies?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subclass"]>

  export type SubclassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subclassId?: boolean
    classId?: boolean
    name?: boolean
    description?: boolean
    grantsSpells?: boolean
    languagesToChooseCount?: boolean
    languages?: boolean
    toolProficiencies?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subclass"]>

  export type SubclassSelectScalar = {
    subclassId?: boolean
    classId?: boolean
    name?: boolean
    description?: boolean
    grantsSpells?: boolean
    languagesToChooseCount?: boolean
    languages?: boolean
    toolProficiencies?: boolean
  }

  export type SubclassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"subclassId" | "classId" | "name" | "description" | "grantsSpells" | "languagesToChooseCount" | "languages" | "toolProficiencies", ExtArgs["result"]["subclass"]>
  export type SubclassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expandedSpells?: boolean | Subclass$expandedSpellsArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    features?: boolean | Subclass$featuresArgs<ExtArgs>
    perses?: boolean | Subclass$persesArgs<ExtArgs>
    persMulticlasses?: boolean | Subclass$persMulticlassesArgs<ExtArgs>
    _count?: boolean | SubclassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubclassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type SubclassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $SubclassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subclass"
    objects: {
      expandedSpells: Prisma.$SpellPayload<ExtArgs>[]
      class: Prisma.$ClassPayload<ExtArgs>
      features: Prisma.$SubclassFeaturePayload<ExtArgs>[]
      perses: Prisma.$PersPayload<ExtArgs>[]
      persMulticlasses: Prisma.$PersMulticlassPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      subclassId: number
      classId: number
      name: string
      description: string | null
      grantsSpells: boolean
      languagesToChooseCount: number
      languages: $Enums.Language[]
      toolProficiencies: $Enums.ToolCategory[]
    }, ExtArgs["result"]["subclass"]>
    composites: {}
  }

  type SubclassGetPayload<S extends boolean | null | undefined | SubclassDefaultArgs> = $Result.GetResult<Prisma.$SubclassPayload, S>

  type SubclassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubclassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubclassCountAggregateInputType | true
    }

  export interface SubclassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subclass'], meta: { name: 'Subclass' } }
    /**
     * Find zero or one Subclass that matches the filter.
     * @param {SubclassFindUniqueArgs} args - Arguments to find a Subclass
     * @example
     * // Get one Subclass
     * const subclass = await prisma.subclass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubclassFindUniqueArgs>(args: SelectSubset<T, SubclassFindUniqueArgs<ExtArgs>>): Prisma__SubclassClient<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subclass that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubclassFindUniqueOrThrowArgs} args - Arguments to find a Subclass
     * @example
     * // Get one Subclass
     * const subclass = await prisma.subclass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubclassFindUniqueOrThrowArgs>(args: SelectSubset<T, SubclassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubclassClient<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subclass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubclassFindFirstArgs} args - Arguments to find a Subclass
     * @example
     * // Get one Subclass
     * const subclass = await prisma.subclass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubclassFindFirstArgs>(args?: SelectSubset<T, SubclassFindFirstArgs<ExtArgs>>): Prisma__SubclassClient<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subclass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubclassFindFirstOrThrowArgs} args - Arguments to find a Subclass
     * @example
     * // Get one Subclass
     * const subclass = await prisma.subclass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubclassFindFirstOrThrowArgs>(args?: SelectSubset<T, SubclassFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubclassClient<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subclasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubclassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subclasses
     * const subclasses = await prisma.subclass.findMany()
     * 
     * // Get first 10 Subclasses
     * const subclasses = await prisma.subclass.findMany({ take: 10 })
     * 
     * // Only select the `subclassId`
     * const subclassWithSubclassIdOnly = await prisma.subclass.findMany({ select: { subclassId: true } })
     * 
     */
    findMany<T extends SubclassFindManyArgs>(args?: SelectSubset<T, SubclassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subclass.
     * @param {SubclassCreateArgs} args - Arguments to create a Subclass.
     * @example
     * // Create one Subclass
     * const Subclass = await prisma.subclass.create({
     *   data: {
     *     // ... data to create a Subclass
     *   }
     * })
     * 
     */
    create<T extends SubclassCreateArgs>(args: SelectSubset<T, SubclassCreateArgs<ExtArgs>>): Prisma__SubclassClient<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subclasses.
     * @param {SubclassCreateManyArgs} args - Arguments to create many Subclasses.
     * @example
     * // Create many Subclasses
     * const subclass = await prisma.subclass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubclassCreateManyArgs>(args?: SelectSubset<T, SubclassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subclasses and returns the data saved in the database.
     * @param {SubclassCreateManyAndReturnArgs} args - Arguments to create many Subclasses.
     * @example
     * // Create many Subclasses
     * const subclass = await prisma.subclass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subclasses and only return the `subclassId`
     * const subclassWithSubclassIdOnly = await prisma.subclass.createManyAndReturn({
     *   select: { subclassId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubclassCreateManyAndReturnArgs>(args?: SelectSubset<T, SubclassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subclass.
     * @param {SubclassDeleteArgs} args - Arguments to delete one Subclass.
     * @example
     * // Delete one Subclass
     * const Subclass = await prisma.subclass.delete({
     *   where: {
     *     // ... filter to delete one Subclass
     *   }
     * })
     * 
     */
    delete<T extends SubclassDeleteArgs>(args: SelectSubset<T, SubclassDeleteArgs<ExtArgs>>): Prisma__SubclassClient<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subclass.
     * @param {SubclassUpdateArgs} args - Arguments to update one Subclass.
     * @example
     * // Update one Subclass
     * const subclass = await prisma.subclass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubclassUpdateArgs>(args: SelectSubset<T, SubclassUpdateArgs<ExtArgs>>): Prisma__SubclassClient<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subclasses.
     * @param {SubclassDeleteManyArgs} args - Arguments to filter Subclasses to delete.
     * @example
     * // Delete a few Subclasses
     * const { count } = await prisma.subclass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubclassDeleteManyArgs>(args?: SelectSubset<T, SubclassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subclasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubclassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subclasses
     * const subclass = await prisma.subclass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubclassUpdateManyArgs>(args: SelectSubset<T, SubclassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subclasses and returns the data updated in the database.
     * @param {SubclassUpdateManyAndReturnArgs} args - Arguments to update many Subclasses.
     * @example
     * // Update many Subclasses
     * const subclass = await prisma.subclass.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subclasses and only return the `subclassId`
     * const subclassWithSubclassIdOnly = await prisma.subclass.updateManyAndReturn({
     *   select: { subclassId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubclassUpdateManyAndReturnArgs>(args: SelectSubset<T, SubclassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subclass.
     * @param {SubclassUpsertArgs} args - Arguments to update or create a Subclass.
     * @example
     * // Update or create a Subclass
     * const subclass = await prisma.subclass.upsert({
     *   create: {
     *     // ... data to create a Subclass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subclass we want to update
     *   }
     * })
     */
    upsert<T extends SubclassUpsertArgs>(args: SelectSubset<T, SubclassUpsertArgs<ExtArgs>>): Prisma__SubclassClient<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subclasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubclassCountArgs} args - Arguments to filter Subclasses to count.
     * @example
     * // Count the number of Subclasses
     * const count = await prisma.subclass.count({
     *   where: {
     *     // ... the filter for the Subclasses we want to count
     *   }
     * })
    **/
    count<T extends SubclassCountArgs>(
      args?: Subset<T, SubclassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubclassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subclass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubclassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubclassAggregateArgs>(args: Subset<T, SubclassAggregateArgs>): Prisma.PrismaPromise<GetSubclassAggregateType<T>>

    /**
     * Group by Subclass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubclassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubclassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubclassGroupByArgs['orderBy'] }
        : { orderBy?: SubclassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubclassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubclassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subclass model
   */
  readonly fields: SubclassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subclass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubclassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expandedSpells<T extends Subclass$expandedSpellsArgs<ExtArgs> = {}>(args?: Subset<T, Subclass$expandedSpellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    features<T extends Subclass$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Subclass$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubclassFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    perses<T extends Subclass$persesArgs<ExtArgs> = {}>(args?: Subset<T, Subclass$persesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    persMulticlasses<T extends Subclass$persMulticlassesArgs<ExtArgs> = {}>(args?: Subset<T, Subclass$persMulticlassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersMulticlassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subclass model
   */
  interface SubclassFieldRefs {
    readonly subclassId: FieldRef<"Subclass", 'Int'>
    readonly classId: FieldRef<"Subclass", 'Int'>
    readonly name: FieldRef<"Subclass", 'String'>
    readonly description: FieldRef<"Subclass", 'String'>
    readonly grantsSpells: FieldRef<"Subclass", 'Boolean'>
    readonly languagesToChooseCount: FieldRef<"Subclass", 'Int'>
    readonly languages: FieldRef<"Subclass", 'Language[]'>
    readonly toolProficiencies: FieldRef<"Subclass", 'ToolCategory[]'>
  }
    

  // Custom InputTypes
  /**
   * Subclass findUnique
   */
  export type SubclassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassInclude<ExtArgs> | null
    /**
     * Filter, which Subclass to fetch.
     */
    where: SubclassWhereUniqueInput
  }

  /**
   * Subclass findUniqueOrThrow
   */
  export type SubclassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassInclude<ExtArgs> | null
    /**
     * Filter, which Subclass to fetch.
     */
    where: SubclassWhereUniqueInput
  }

  /**
   * Subclass findFirst
   */
  export type SubclassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassInclude<ExtArgs> | null
    /**
     * Filter, which Subclass to fetch.
     */
    where?: SubclassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subclasses to fetch.
     */
    orderBy?: SubclassOrderByWithRelationInput | SubclassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subclasses.
     */
    cursor?: SubclassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subclasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subclasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subclasses.
     */
    distinct?: SubclassScalarFieldEnum | SubclassScalarFieldEnum[]
  }

  /**
   * Subclass findFirstOrThrow
   */
  export type SubclassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassInclude<ExtArgs> | null
    /**
     * Filter, which Subclass to fetch.
     */
    where?: SubclassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subclasses to fetch.
     */
    orderBy?: SubclassOrderByWithRelationInput | SubclassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subclasses.
     */
    cursor?: SubclassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subclasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subclasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subclasses.
     */
    distinct?: SubclassScalarFieldEnum | SubclassScalarFieldEnum[]
  }

  /**
   * Subclass findMany
   */
  export type SubclassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassInclude<ExtArgs> | null
    /**
     * Filter, which Subclasses to fetch.
     */
    where?: SubclassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subclasses to fetch.
     */
    orderBy?: SubclassOrderByWithRelationInput | SubclassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subclasses.
     */
    cursor?: SubclassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subclasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subclasses.
     */
    skip?: number
    distinct?: SubclassScalarFieldEnum | SubclassScalarFieldEnum[]
  }

  /**
   * Subclass create
   */
  export type SubclassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassInclude<ExtArgs> | null
    /**
     * The data needed to create a Subclass.
     */
    data: XOR<SubclassCreateInput, SubclassUncheckedCreateInput>
  }

  /**
   * Subclass createMany
   */
  export type SubclassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subclasses.
     */
    data: SubclassCreateManyInput | SubclassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subclass createManyAndReturn
   */
  export type SubclassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * The data used to create many Subclasses.
     */
    data: SubclassCreateManyInput | SubclassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subclass update
   */
  export type SubclassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassInclude<ExtArgs> | null
    /**
     * The data needed to update a Subclass.
     */
    data: XOR<SubclassUpdateInput, SubclassUncheckedUpdateInput>
    /**
     * Choose, which Subclass to update.
     */
    where: SubclassWhereUniqueInput
  }

  /**
   * Subclass updateMany
   */
  export type SubclassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subclasses.
     */
    data: XOR<SubclassUpdateManyMutationInput, SubclassUncheckedUpdateManyInput>
    /**
     * Filter which Subclasses to update
     */
    where?: SubclassWhereInput
    /**
     * Limit how many Subclasses to update.
     */
    limit?: number
  }

  /**
   * Subclass updateManyAndReturn
   */
  export type SubclassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * The data used to update Subclasses.
     */
    data: XOR<SubclassUpdateManyMutationInput, SubclassUncheckedUpdateManyInput>
    /**
     * Filter which Subclasses to update
     */
    where?: SubclassWhereInput
    /**
     * Limit how many Subclasses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subclass upsert
   */
  export type SubclassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassInclude<ExtArgs> | null
    /**
     * The filter to search for the Subclass to update in case it exists.
     */
    where: SubclassWhereUniqueInput
    /**
     * In case the Subclass found by the `where` argument doesn't exist, create a new Subclass with this data.
     */
    create: XOR<SubclassCreateInput, SubclassUncheckedCreateInput>
    /**
     * In case the Subclass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubclassUpdateInput, SubclassUncheckedUpdateInput>
  }

  /**
   * Subclass delete
   */
  export type SubclassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassInclude<ExtArgs> | null
    /**
     * Filter which Subclass to delete.
     */
    where: SubclassWhereUniqueInput
  }

  /**
   * Subclass deleteMany
   */
  export type SubclassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subclasses to delete
     */
    where?: SubclassWhereInput
    /**
     * Limit how many Subclasses to delete.
     */
    limit?: number
  }

  /**
   * Subclass.expandedSpells
   */
  export type Subclass$expandedSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    where?: SpellWhereInput
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    cursor?: SpellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }

  /**
   * Subclass.features
   */
  export type Subclass$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubclassFeature
     */
    select?: SubclassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubclassFeature
     */
    omit?: SubclassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassFeatureInclude<ExtArgs> | null
    where?: SubclassFeatureWhereInput
    orderBy?: SubclassFeatureOrderByWithRelationInput | SubclassFeatureOrderByWithRelationInput[]
    cursor?: SubclassFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubclassFeatureScalarFieldEnum | SubclassFeatureScalarFieldEnum[]
  }

  /**
   * Subclass.perses
   */
  export type Subclass$persesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    where?: PersWhereInput
    orderBy?: PersOrderByWithRelationInput | PersOrderByWithRelationInput[]
    cursor?: PersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersScalarFieldEnum | PersScalarFieldEnum[]
  }

  /**
   * Subclass.persMulticlasses
   */
  export type Subclass$persMulticlassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMulticlass
     */
    select?: PersMulticlassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMulticlass
     */
    omit?: PersMulticlassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMulticlassInclude<ExtArgs> | null
    where?: PersMulticlassWhereInput
    orderBy?: PersMulticlassOrderByWithRelationInput | PersMulticlassOrderByWithRelationInput[]
    cursor?: PersMulticlassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersMulticlassScalarFieldEnum | PersMulticlassScalarFieldEnum[]
  }

  /**
   * Subclass without action
   */
  export type SubclassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassInclude<ExtArgs> | null
  }


  /**
   * Model Pers
   */

  export type AggregatePers = {
    _count: PersCountAggregateOutputType | null
    _avg: PersAvgAggregateOutputType | null
    _sum: PersSumAggregateOutputType | null
    _min: PersMinAggregateOutputType | null
    _max: PersMaxAggregateOutputType | null
  }

  export type PersAvgAggregateOutputType = {
    persId: number | null
    userId: number | null
    level: number | null
    currentSpellSlots: number | null
    classId: number | null
    subclassId: number | null
    backgroundId: number | null
    raceId: number | null
    subraceId: number | null
    currentHp: number | null
    maxHp: number | null
    tempHp: number | null
    xp: number | null
    str: number | null
    dex: number | null
    con: number | null
    int: number | null
    wis: number | null
    cha: number | null
    cp: number | null
    sp: number | null
    ep: number | null
    gp: number | null
    pp: number | null
  }

  export type PersSumAggregateOutputType = {
    persId: number | null
    userId: number | null
    level: number | null
    currentSpellSlots: number[]
    classId: number | null
    subclassId: number | null
    backgroundId: number | null
    raceId: number | null
    subraceId: number | null
    currentHp: number | null
    maxHp: number | null
    tempHp: number | null
    xp: number | null
    str: number | null
    dex: number | null
    con: number | null
    int: number | null
    wis: number | null
    cha: number | null
    cp: number | null
    sp: number | null
    ep: number | null
    gp: number | null
    pp: number | null
  }

  export type PersMinAggregateOutputType = {
    persId: number | null
    userId: number | null
    name: string | null
    level: number | null
    classId: number | null
    subclassId: number | null
    backgroundId: number | null
    raceId: number | null
    subraceId: number | null
    currentHp: number | null
    maxHp: number | null
    tempHp: number | null
    raceCustom: string | null
    classCustom: string | null
    alignment: string | null
    xp: number | null
    customBackground: string | null
    customFeatures: string | null
    customLanguagesKnown: string | null
    customEquipment: string | null
    personalityTraits: string | null
    ideals: string | null
    bonds: string | null
    flaws: string | null
    backstory: string | null
    notes: string | null
    str: number | null
    dex: number | null
    con: number | null
    int: number | null
    wis: number | null
    cha: number | null
    cp: number | null
    sp: number | null
    ep: number | null
    gp: number | null
    pp: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersMaxAggregateOutputType = {
    persId: number | null
    userId: number | null
    name: string | null
    level: number | null
    classId: number | null
    subclassId: number | null
    backgroundId: number | null
    raceId: number | null
    subraceId: number | null
    currentHp: number | null
    maxHp: number | null
    tempHp: number | null
    raceCustom: string | null
    classCustom: string | null
    alignment: string | null
    xp: number | null
    customBackground: string | null
    customFeatures: string | null
    customLanguagesKnown: string | null
    customEquipment: string | null
    personalityTraits: string | null
    ideals: string | null
    bonds: string | null
    flaws: string | null
    backstory: string | null
    notes: string | null
    str: number | null
    dex: number | null
    con: number | null
    int: number | null
    wis: number | null
    cha: number | null
    cp: number | null
    sp: number | null
    ep: number | null
    gp: number | null
    pp: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersCountAggregateOutputType = {
    persId: number
    userId: number
    name: number
    level: number
    currentSpellSlots: number
    classId: number
    subclassId: number
    backgroundId: number
    raceId: number
    subraceId: number
    currentHp: number
    maxHp: number
    tempHp: number
    raceCustom: number
    classCustom: number
    alignment: number
    xp: number
    customBackground: number
    customFeatures: number
    customLanguagesKnown: number
    customEquipment: number
    personalityTraits: number
    ideals: number
    bonds: number
    flaws: number
    backstory: number
    notes: number
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp: number
    sp: number
    ep: number
    gp: number
    pp: number
    additionalSaveProficiencies: number
    miscSaveBonuses: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PersAvgAggregateInputType = {
    persId?: true
    userId?: true
    level?: true
    currentSpellSlots?: true
    classId?: true
    subclassId?: true
    backgroundId?: true
    raceId?: true
    subraceId?: true
    currentHp?: true
    maxHp?: true
    tempHp?: true
    xp?: true
    str?: true
    dex?: true
    con?: true
    int?: true
    wis?: true
    cha?: true
    cp?: true
    sp?: true
    ep?: true
    gp?: true
    pp?: true
  }

  export type PersSumAggregateInputType = {
    persId?: true
    userId?: true
    level?: true
    currentSpellSlots?: true
    classId?: true
    subclassId?: true
    backgroundId?: true
    raceId?: true
    subraceId?: true
    currentHp?: true
    maxHp?: true
    tempHp?: true
    xp?: true
    str?: true
    dex?: true
    con?: true
    int?: true
    wis?: true
    cha?: true
    cp?: true
    sp?: true
    ep?: true
    gp?: true
    pp?: true
  }

  export type PersMinAggregateInputType = {
    persId?: true
    userId?: true
    name?: true
    level?: true
    classId?: true
    subclassId?: true
    backgroundId?: true
    raceId?: true
    subraceId?: true
    currentHp?: true
    maxHp?: true
    tempHp?: true
    raceCustom?: true
    classCustom?: true
    alignment?: true
    xp?: true
    customBackground?: true
    customFeatures?: true
    customLanguagesKnown?: true
    customEquipment?: true
    personalityTraits?: true
    ideals?: true
    bonds?: true
    flaws?: true
    backstory?: true
    notes?: true
    str?: true
    dex?: true
    con?: true
    int?: true
    wis?: true
    cha?: true
    cp?: true
    sp?: true
    ep?: true
    gp?: true
    pp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersMaxAggregateInputType = {
    persId?: true
    userId?: true
    name?: true
    level?: true
    classId?: true
    subclassId?: true
    backgroundId?: true
    raceId?: true
    subraceId?: true
    currentHp?: true
    maxHp?: true
    tempHp?: true
    raceCustom?: true
    classCustom?: true
    alignment?: true
    xp?: true
    customBackground?: true
    customFeatures?: true
    customLanguagesKnown?: true
    customEquipment?: true
    personalityTraits?: true
    ideals?: true
    bonds?: true
    flaws?: true
    backstory?: true
    notes?: true
    str?: true
    dex?: true
    con?: true
    int?: true
    wis?: true
    cha?: true
    cp?: true
    sp?: true
    ep?: true
    gp?: true
    pp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersCountAggregateInputType = {
    persId?: true
    userId?: true
    name?: true
    level?: true
    currentSpellSlots?: true
    classId?: true
    subclassId?: true
    backgroundId?: true
    raceId?: true
    subraceId?: true
    currentHp?: true
    maxHp?: true
    tempHp?: true
    raceCustom?: true
    classCustom?: true
    alignment?: true
    xp?: true
    customBackground?: true
    customFeatures?: true
    customLanguagesKnown?: true
    customEquipment?: true
    personalityTraits?: true
    ideals?: true
    bonds?: true
    flaws?: true
    backstory?: true
    notes?: true
    str?: true
    dex?: true
    con?: true
    int?: true
    wis?: true
    cha?: true
    cp?: true
    sp?: true
    ep?: true
    gp?: true
    pp?: true
    additionalSaveProficiencies?: true
    miscSaveBonuses?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pers to aggregate.
     */
    where?: PersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pers to fetch.
     */
    orderBy?: PersOrderByWithRelationInput | PersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pers
    **/
    _count?: true | PersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersMaxAggregateInputType
  }

  export type GetPersAggregateType<T extends PersAggregateArgs> = {
        [P in keyof T & keyof AggregatePers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePers[P]>
      : GetScalarType<T[P], AggregatePers[P]>
  }




  export type PersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersWhereInput
    orderBy?: PersOrderByWithAggregationInput | PersOrderByWithAggregationInput[]
    by: PersScalarFieldEnum[] | PersScalarFieldEnum
    having?: PersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersCountAggregateInputType | true
    _avg?: PersAvgAggregateInputType
    _sum?: PersSumAggregateInputType
    _min?: PersMinAggregateInputType
    _max?: PersMaxAggregateInputType
  }

  export type PersGroupByOutputType = {
    persId: number
    userId: number
    name: string
    level: number
    currentSpellSlots: number[]
    classId: number
    subclassId: number | null
    backgroundId: number
    raceId: number
    subraceId: number | null
    currentHp: number
    maxHp: number
    tempHp: number
    raceCustom: string
    classCustom: string
    alignment: string
    xp: number
    customBackground: string
    customFeatures: string
    customLanguagesKnown: string
    customEquipment: string
    personalityTraits: string
    ideals: string
    bonds: string
    flaws: string
    backstory: string
    notes: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp: number
    sp: number
    ep: number
    gp: number
    pp: number
    additionalSaveProficiencies: $Enums.Ability[]
    miscSaveBonuses: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PersCountAggregateOutputType | null
    _avg: PersAvgAggregateOutputType | null
    _sum: PersSumAggregateOutputType | null
    _min: PersMinAggregateOutputType | null
    _max: PersMaxAggregateOutputType | null
  }

  type GetPersGroupByPayload<T extends PersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersGroupByOutputType[P]>
            : GetScalarType<T[P], PersGroupByOutputType[P]>
        }
      >
    >


  export type PersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persId?: boolean
    userId?: boolean
    name?: boolean
    level?: boolean
    currentSpellSlots?: boolean
    classId?: boolean
    subclassId?: boolean
    backgroundId?: boolean
    raceId?: boolean
    subraceId?: boolean
    currentHp?: boolean
    maxHp?: boolean
    tempHp?: boolean
    raceCustom?: boolean
    classCustom?: boolean
    alignment?: boolean
    xp?: boolean
    customBackground?: boolean
    customFeatures?: boolean
    customLanguagesKnown?: boolean
    customEquipment?: boolean
    personalityTraits?: boolean
    ideals?: boolean
    bonds?: boolean
    flaws?: boolean
    backstory?: boolean
    notes?: boolean
    str?: boolean
    dex?: boolean
    con?: boolean
    int?: boolean
    wis?: boolean
    cha?: boolean
    cp?: boolean
    sp?: boolean
    ep?: boolean
    gp?: boolean
    pp?: boolean
    additionalSaveProficiencies?: boolean
    miscSaveBonuses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subclass?: boolean | Pers$subclassArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    subrace?: boolean | Pers$subraceArgs<ExtArgs>
    background?: boolean | BackgroundDefaultArgs<ExtArgs>
    skills?: boolean | Pers$skillsArgs<ExtArgs>
    multiclasses?: boolean | Pers$multiclassesArgs<ExtArgs>
    features?: boolean | Pers$featuresArgs<ExtArgs>
    spells?: boolean | Pers$spellsArgs<ExtArgs>
    feats?: boolean | Pers$featsArgs<ExtArgs>
    armors?: boolean | Pers$armorsArgs<ExtArgs>
    weapons?: boolean | Pers$weaponsArgs<ExtArgs>
    magicItems?: boolean | Pers$magicItemsArgs<ExtArgs>
    raceVariants?: boolean | Pers$raceVariantsArgs<ExtArgs>
    raceChoiceOptions?: boolean | Pers$raceChoiceOptionsArgs<ExtArgs>
    _count?: boolean | PersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pers"]>

  export type PersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persId?: boolean
    userId?: boolean
    name?: boolean
    level?: boolean
    currentSpellSlots?: boolean
    classId?: boolean
    subclassId?: boolean
    backgroundId?: boolean
    raceId?: boolean
    subraceId?: boolean
    currentHp?: boolean
    maxHp?: boolean
    tempHp?: boolean
    raceCustom?: boolean
    classCustom?: boolean
    alignment?: boolean
    xp?: boolean
    customBackground?: boolean
    customFeatures?: boolean
    customLanguagesKnown?: boolean
    customEquipment?: boolean
    personalityTraits?: boolean
    ideals?: boolean
    bonds?: boolean
    flaws?: boolean
    backstory?: boolean
    notes?: boolean
    str?: boolean
    dex?: boolean
    con?: boolean
    int?: boolean
    wis?: boolean
    cha?: boolean
    cp?: boolean
    sp?: boolean
    ep?: boolean
    gp?: boolean
    pp?: boolean
    additionalSaveProficiencies?: boolean
    miscSaveBonuses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subclass?: boolean | Pers$subclassArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    subrace?: boolean | Pers$subraceArgs<ExtArgs>
    background?: boolean | BackgroundDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pers"]>

  export type PersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persId?: boolean
    userId?: boolean
    name?: boolean
    level?: boolean
    currentSpellSlots?: boolean
    classId?: boolean
    subclassId?: boolean
    backgroundId?: boolean
    raceId?: boolean
    subraceId?: boolean
    currentHp?: boolean
    maxHp?: boolean
    tempHp?: boolean
    raceCustom?: boolean
    classCustom?: boolean
    alignment?: boolean
    xp?: boolean
    customBackground?: boolean
    customFeatures?: boolean
    customLanguagesKnown?: boolean
    customEquipment?: boolean
    personalityTraits?: boolean
    ideals?: boolean
    bonds?: boolean
    flaws?: boolean
    backstory?: boolean
    notes?: boolean
    str?: boolean
    dex?: boolean
    con?: boolean
    int?: boolean
    wis?: boolean
    cha?: boolean
    cp?: boolean
    sp?: boolean
    ep?: boolean
    gp?: boolean
    pp?: boolean
    additionalSaveProficiencies?: boolean
    miscSaveBonuses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subclass?: boolean | Pers$subclassArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    subrace?: boolean | Pers$subraceArgs<ExtArgs>
    background?: boolean | BackgroundDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pers"]>

  export type PersSelectScalar = {
    persId?: boolean
    userId?: boolean
    name?: boolean
    level?: boolean
    currentSpellSlots?: boolean
    classId?: boolean
    subclassId?: boolean
    backgroundId?: boolean
    raceId?: boolean
    subraceId?: boolean
    currentHp?: boolean
    maxHp?: boolean
    tempHp?: boolean
    raceCustom?: boolean
    classCustom?: boolean
    alignment?: boolean
    xp?: boolean
    customBackground?: boolean
    customFeatures?: boolean
    customLanguagesKnown?: boolean
    customEquipment?: boolean
    personalityTraits?: boolean
    ideals?: boolean
    bonds?: boolean
    flaws?: boolean
    backstory?: boolean
    notes?: boolean
    str?: boolean
    dex?: boolean
    con?: boolean
    int?: boolean
    wis?: boolean
    cha?: boolean
    cp?: boolean
    sp?: boolean
    ep?: boolean
    gp?: boolean
    pp?: boolean
    additionalSaveProficiencies?: boolean
    miscSaveBonuses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"persId" | "userId" | "name" | "level" | "currentSpellSlots" | "classId" | "subclassId" | "backgroundId" | "raceId" | "subraceId" | "currentHp" | "maxHp" | "tempHp" | "raceCustom" | "classCustom" | "alignment" | "xp" | "customBackground" | "customFeatures" | "customLanguagesKnown" | "customEquipment" | "personalityTraits" | "ideals" | "bonds" | "flaws" | "backstory" | "notes" | "str" | "dex" | "con" | "int" | "wis" | "cha" | "cp" | "sp" | "ep" | "gp" | "pp" | "additionalSaveProficiencies" | "miscSaveBonuses" | "createdAt" | "updatedAt", ExtArgs["result"]["pers"]>
  export type PersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subclass?: boolean | Pers$subclassArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    subrace?: boolean | Pers$subraceArgs<ExtArgs>
    background?: boolean | BackgroundDefaultArgs<ExtArgs>
    skills?: boolean | Pers$skillsArgs<ExtArgs>
    multiclasses?: boolean | Pers$multiclassesArgs<ExtArgs>
    features?: boolean | Pers$featuresArgs<ExtArgs>
    spells?: boolean | Pers$spellsArgs<ExtArgs>
    feats?: boolean | Pers$featsArgs<ExtArgs>
    armors?: boolean | Pers$armorsArgs<ExtArgs>
    weapons?: boolean | Pers$weaponsArgs<ExtArgs>
    magicItems?: boolean | Pers$magicItemsArgs<ExtArgs>
    raceVariants?: boolean | Pers$raceVariantsArgs<ExtArgs>
    raceChoiceOptions?: boolean | Pers$raceChoiceOptionsArgs<ExtArgs>
    _count?: boolean | PersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subclass?: boolean | Pers$subclassArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    subrace?: boolean | Pers$subraceArgs<ExtArgs>
    background?: boolean | BackgroundDefaultArgs<ExtArgs>
  }
  export type PersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subclass?: boolean | Pers$subclassArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    subrace?: boolean | Pers$subraceArgs<ExtArgs>
    background?: boolean | BackgroundDefaultArgs<ExtArgs>
  }

  export type $PersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pers"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      subclass: Prisma.$SubclassPayload<ExtArgs> | null
      race: Prisma.$RacePayload<ExtArgs>
      subrace: Prisma.$SubracePayload<ExtArgs> | null
      background: Prisma.$BackgroundPayload<ExtArgs>
      skills: Prisma.$PersSkillPayload<ExtArgs>[]
      multiclasses: Prisma.$PersMulticlassPayload<ExtArgs>[]
      features: Prisma.$PersFeaturePayload<ExtArgs>[]
      spells: Prisma.$SpellPayload<ExtArgs>[]
      feats: Prisma.$PersFeatPayload<ExtArgs>[]
      armors: Prisma.$PersArmorPayload<ExtArgs>[]
      weapons: Prisma.$PersWeaponPayload<ExtArgs>[]
      magicItems: Prisma.$PersMagicItemPayload<ExtArgs>[]
      raceVariants: Prisma.$RaceVariantPayload<ExtArgs>[]
      raceChoiceOptions: Prisma.$RaceChoiceOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      persId: number
      userId: number
      name: string
      level: number
      currentSpellSlots: number[]
      classId: number
      subclassId: number | null
      backgroundId: number
      raceId: number
      subraceId: number | null
      currentHp: number
      maxHp: number
      tempHp: number
      raceCustom: string
      classCustom: string
      alignment: string
      xp: number
      customBackground: string
      customFeatures: string
      customLanguagesKnown: string
      customEquipment: string
      personalityTraits: string
      ideals: string
      bonds: string
      flaws: string
      backstory: string
      notes: string
      str: number
      dex: number
      con: number
      int: number
      wis: number
      cha: number
      cp: number
      sp: number
      ep: number
      gp: number
      pp: number
      additionalSaveProficiencies: $Enums.Ability[]
      miscSaveBonuses: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pers"]>
    composites: {}
  }

  type PersGetPayload<S extends boolean | null | undefined | PersDefaultArgs> = $Result.GetResult<Prisma.$PersPayload, S>

  type PersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersCountAggregateInputType | true
    }

  export interface PersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pers'], meta: { name: 'Pers' } }
    /**
     * Find zero or one Pers that matches the filter.
     * @param {PersFindUniqueArgs} args - Arguments to find a Pers
     * @example
     * // Get one Pers
     * const pers = await prisma.pers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersFindUniqueArgs>(args: SelectSubset<T, PersFindUniqueArgs<ExtArgs>>): Prisma__PersClient<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersFindUniqueOrThrowArgs} args - Arguments to find a Pers
     * @example
     * // Get one Pers
     * const pers = await prisma.pers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersFindUniqueOrThrowArgs>(args: SelectSubset<T, PersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersClient<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFindFirstArgs} args - Arguments to find a Pers
     * @example
     * // Get one Pers
     * const pers = await prisma.pers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersFindFirstArgs>(args?: SelectSubset<T, PersFindFirstArgs<ExtArgs>>): Prisma__PersClient<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFindFirstOrThrowArgs} args - Arguments to find a Pers
     * @example
     * // Get one Pers
     * const pers = await prisma.pers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersFindFirstOrThrowArgs>(args?: SelectSubset<T, PersFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersClient<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pers
     * const pers = await prisma.pers.findMany()
     * 
     * // Get first 10 Pers
     * const pers = await prisma.pers.findMany({ take: 10 })
     * 
     * // Only select the `persId`
     * const persWithPersIdOnly = await prisma.pers.findMany({ select: { persId: true } })
     * 
     */
    findMany<T extends PersFindManyArgs>(args?: SelectSubset<T, PersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pers.
     * @param {PersCreateArgs} args - Arguments to create a Pers.
     * @example
     * // Create one Pers
     * const Pers = await prisma.pers.create({
     *   data: {
     *     // ... data to create a Pers
     *   }
     * })
     * 
     */
    create<T extends PersCreateArgs>(args: SelectSubset<T, PersCreateArgs<ExtArgs>>): Prisma__PersClient<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pers.
     * @param {PersCreateManyArgs} args - Arguments to create many Pers.
     * @example
     * // Create many Pers
     * const pers = await prisma.pers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersCreateManyArgs>(args?: SelectSubset<T, PersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pers and returns the data saved in the database.
     * @param {PersCreateManyAndReturnArgs} args - Arguments to create many Pers.
     * @example
     * // Create many Pers
     * const pers = await prisma.pers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pers and only return the `persId`
     * const persWithPersIdOnly = await prisma.pers.createManyAndReturn({
     *   select: { persId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersCreateManyAndReturnArgs>(args?: SelectSubset<T, PersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pers.
     * @param {PersDeleteArgs} args - Arguments to delete one Pers.
     * @example
     * // Delete one Pers
     * const Pers = await prisma.pers.delete({
     *   where: {
     *     // ... filter to delete one Pers
     *   }
     * })
     * 
     */
    delete<T extends PersDeleteArgs>(args: SelectSubset<T, PersDeleteArgs<ExtArgs>>): Prisma__PersClient<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pers.
     * @param {PersUpdateArgs} args - Arguments to update one Pers.
     * @example
     * // Update one Pers
     * const pers = await prisma.pers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersUpdateArgs>(args: SelectSubset<T, PersUpdateArgs<ExtArgs>>): Prisma__PersClient<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pers.
     * @param {PersDeleteManyArgs} args - Arguments to filter Pers to delete.
     * @example
     * // Delete a few Pers
     * const { count } = await prisma.pers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersDeleteManyArgs>(args?: SelectSubset<T, PersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pers
     * const pers = await prisma.pers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersUpdateManyArgs>(args: SelectSubset<T, PersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pers and returns the data updated in the database.
     * @param {PersUpdateManyAndReturnArgs} args - Arguments to update many Pers.
     * @example
     * // Update many Pers
     * const pers = await prisma.pers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pers and only return the `persId`
     * const persWithPersIdOnly = await prisma.pers.updateManyAndReturn({
     *   select: { persId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersUpdateManyAndReturnArgs>(args: SelectSubset<T, PersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pers.
     * @param {PersUpsertArgs} args - Arguments to update or create a Pers.
     * @example
     * // Update or create a Pers
     * const pers = await prisma.pers.upsert({
     *   create: {
     *     // ... data to create a Pers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pers we want to update
     *   }
     * })
     */
    upsert<T extends PersUpsertArgs>(args: SelectSubset<T, PersUpsertArgs<ExtArgs>>): Prisma__PersClient<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersCountArgs} args - Arguments to filter Pers to count.
     * @example
     * // Count the number of Pers
     * const count = await prisma.pers.count({
     *   where: {
     *     // ... the filter for the Pers we want to count
     *   }
     * })
    **/
    count<T extends PersCountArgs>(
      args?: Subset<T, PersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersAggregateArgs>(args: Subset<T, PersAggregateArgs>): Prisma.PrismaPromise<GetPersAggregateType<T>>

    /**
     * Group by Pers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersGroupByArgs['orderBy'] }
        : { orderBy?: PersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pers model
   */
  readonly fields: PersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subclass<T extends Pers$subclassArgs<ExtArgs> = {}>(args?: Subset<T, Pers$subclassArgs<ExtArgs>>): Prisma__SubclassClient<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    race<T extends RaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceDefaultArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subrace<T extends Pers$subraceArgs<ExtArgs> = {}>(args?: Subset<T, Pers$subraceArgs<ExtArgs>>): Prisma__SubraceClient<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    background<T extends BackgroundDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BackgroundDefaultArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skills<T extends Pers$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Pers$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    multiclasses<T extends Pers$multiclassesArgs<ExtArgs> = {}>(args?: Subset<T, Pers$multiclassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersMulticlassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    features<T extends Pers$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Pers$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spells<T extends Pers$spellsArgs<ExtArgs> = {}>(args?: Subset<T, Pers$spellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feats<T extends Pers$featsArgs<ExtArgs> = {}>(args?: Subset<T, Pers$featsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersFeatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    armors<T extends Pers$armorsArgs<ExtArgs> = {}>(args?: Subset<T, Pers$armorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersArmorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    weapons<T extends Pers$weaponsArgs<ExtArgs> = {}>(args?: Subset<T, Pers$weaponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersWeaponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    magicItems<T extends Pers$magicItemsArgs<ExtArgs> = {}>(args?: Subset<T, Pers$magicItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersMagicItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    raceVariants<T extends Pers$raceVariantsArgs<ExtArgs> = {}>(args?: Subset<T, Pers$raceVariantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    raceChoiceOptions<T extends Pers$raceChoiceOptionsArgs<ExtArgs> = {}>(args?: Subset<T, Pers$raceChoiceOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceChoiceOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pers model
   */
  interface PersFieldRefs {
    readonly persId: FieldRef<"Pers", 'Int'>
    readonly userId: FieldRef<"Pers", 'Int'>
    readonly name: FieldRef<"Pers", 'String'>
    readonly level: FieldRef<"Pers", 'Int'>
    readonly currentSpellSlots: FieldRef<"Pers", 'Int[]'>
    readonly classId: FieldRef<"Pers", 'Int'>
    readonly subclassId: FieldRef<"Pers", 'Int'>
    readonly backgroundId: FieldRef<"Pers", 'Int'>
    readonly raceId: FieldRef<"Pers", 'Int'>
    readonly subraceId: FieldRef<"Pers", 'Int'>
    readonly currentHp: FieldRef<"Pers", 'Int'>
    readonly maxHp: FieldRef<"Pers", 'Int'>
    readonly tempHp: FieldRef<"Pers", 'Int'>
    readonly raceCustom: FieldRef<"Pers", 'String'>
    readonly classCustom: FieldRef<"Pers", 'String'>
    readonly alignment: FieldRef<"Pers", 'String'>
    readonly xp: FieldRef<"Pers", 'Int'>
    readonly customBackground: FieldRef<"Pers", 'String'>
    readonly customFeatures: FieldRef<"Pers", 'String'>
    readonly customLanguagesKnown: FieldRef<"Pers", 'String'>
    readonly customEquipment: FieldRef<"Pers", 'String'>
    readonly personalityTraits: FieldRef<"Pers", 'String'>
    readonly ideals: FieldRef<"Pers", 'String'>
    readonly bonds: FieldRef<"Pers", 'String'>
    readonly flaws: FieldRef<"Pers", 'String'>
    readonly backstory: FieldRef<"Pers", 'String'>
    readonly notes: FieldRef<"Pers", 'String'>
    readonly str: FieldRef<"Pers", 'Int'>
    readonly dex: FieldRef<"Pers", 'Int'>
    readonly con: FieldRef<"Pers", 'Int'>
    readonly int: FieldRef<"Pers", 'Int'>
    readonly wis: FieldRef<"Pers", 'Int'>
    readonly cha: FieldRef<"Pers", 'Int'>
    readonly cp: FieldRef<"Pers", 'Int'>
    readonly sp: FieldRef<"Pers", 'Int'>
    readonly ep: FieldRef<"Pers", 'Int'>
    readonly gp: FieldRef<"Pers", 'Int'>
    readonly pp: FieldRef<"Pers", 'Int'>
    readonly additionalSaveProficiencies: FieldRef<"Pers", 'Ability[]'>
    readonly miscSaveBonuses: FieldRef<"Pers", 'Json'>
    readonly createdAt: FieldRef<"Pers", 'DateTime'>
    readonly updatedAt: FieldRef<"Pers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pers findUnique
   */
  export type PersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    /**
     * Filter, which Pers to fetch.
     */
    where: PersWhereUniqueInput
  }

  /**
   * Pers findUniqueOrThrow
   */
  export type PersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    /**
     * Filter, which Pers to fetch.
     */
    where: PersWhereUniqueInput
  }

  /**
   * Pers findFirst
   */
  export type PersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    /**
     * Filter, which Pers to fetch.
     */
    where?: PersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pers to fetch.
     */
    orderBy?: PersOrderByWithRelationInput | PersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pers.
     */
    cursor?: PersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pers.
     */
    distinct?: PersScalarFieldEnum | PersScalarFieldEnum[]
  }

  /**
   * Pers findFirstOrThrow
   */
  export type PersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    /**
     * Filter, which Pers to fetch.
     */
    where?: PersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pers to fetch.
     */
    orderBy?: PersOrderByWithRelationInput | PersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pers.
     */
    cursor?: PersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pers.
     */
    distinct?: PersScalarFieldEnum | PersScalarFieldEnum[]
  }

  /**
   * Pers findMany
   */
  export type PersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    /**
     * Filter, which Pers to fetch.
     */
    where?: PersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pers to fetch.
     */
    orderBy?: PersOrderByWithRelationInput | PersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pers.
     */
    cursor?: PersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pers.
     */
    skip?: number
    distinct?: PersScalarFieldEnum | PersScalarFieldEnum[]
  }

  /**
   * Pers create
   */
  export type PersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    /**
     * The data needed to create a Pers.
     */
    data: XOR<PersCreateInput, PersUncheckedCreateInput>
  }

  /**
   * Pers createMany
   */
  export type PersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pers.
     */
    data: PersCreateManyInput | PersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pers createManyAndReturn
   */
  export type PersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * The data used to create many Pers.
     */
    data: PersCreateManyInput | PersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pers update
   */
  export type PersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    /**
     * The data needed to update a Pers.
     */
    data: XOR<PersUpdateInput, PersUncheckedUpdateInput>
    /**
     * Choose, which Pers to update.
     */
    where: PersWhereUniqueInput
  }

  /**
   * Pers updateMany
   */
  export type PersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pers.
     */
    data: XOR<PersUpdateManyMutationInput, PersUncheckedUpdateManyInput>
    /**
     * Filter which Pers to update
     */
    where?: PersWhereInput
    /**
     * Limit how many Pers to update.
     */
    limit?: number
  }

  /**
   * Pers updateManyAndReturn
   */
  export type PersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * The data used to update Pers.
     */
    data: XOR<PersUpdateManyMutationInput, PersUncheckedUpdateManyInput>
    /**
     * Filter which Pers to update
     */
    where?: PersWhereInput
    /**
     * Limit how many Pers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pers upsert
   */
  export type PersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    /**
     * The filter to search for the Pers to update in case it exists.
     */
    where: PersWhereUniqueInput
    /**
     * In case the Pers found by the `where` argument doesn't exist, create a new Pers with this data.
     */
    create: XOR<PersCreateInput, PersUncheckedCreateInput>
    /**
     * In case the Pers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersUpdateInput, PersUncheckedUpdateInput>
  }

  /**
   * Pers delete
   */
  export type PersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    /**
     * Filter which Pers to delete.
     */
    where: PersWhereUniqueInput
  }

  /**
   * Pers deleteMany
   */
  export type PersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pers to delete
     */
    where?: PersWhereInput
    /**
     * Limit how many Pers to delete.
     */
    limit?: number
  }

  /**
   * Pers.subclass
   */
  export type Pers$subclassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassInclude<ExtArgs> | null
    where?: SubclassWhereInput
  }

  /**
   * Pers.subrace
   */
  export type Pers$subraceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceInclude<ExtArgs> | null
    where?: SubraceWhereInput
  }

  /**
   * Pers.skills
   */
  export type Pers$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersSkill
     */
    select?: PersSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersSkill
     */
    omit?: PersSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersSkillInclude<ExtArgs> | null
    where?: PersSkillWhereInput
    orderBy?: PersSkillOrderByWithRelationInput | PersSkillOrderByWithRelationInput[]
    cursor?: PersSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersSkillScalarFieldEnum | PersSkillScalarFieldEnum[]
  }

  /**
   * Pers.multiclasses
   */
  export type Pers$multiclassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMulticlass
     */
    select?: PersMulticlassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMulticlass
     */
    omit?: PersMulticlassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMulticlassInclude<ExtArgs> | null
    where?: PersMulticlassWhereInput
    orderBy?: PersMulticlassOrderByWithRelationInput | PersMulticlassOrderByWithRelationInput[]
    cursor?: PersMulticlassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersMulticlassScalarFieldEnum | PersMulticlassScalarFieldEnum[]
  }

  /**
   * Pers.features
   */
  export type Pers$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeature
     */
    select?: PersFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeature
     */
    omit?: PersFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatureInclude<ExtArgs> | null
    where?: PersFeatureWhereInput
    orderBy?: PersFeatureOrderByWithRelationInput | PersFeatureOrderByWithRelationInput[]
    cursor?: PersFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersFeatureScalarFieldEnum | PersFeatureScalarFieldEnum[]
  }

  /**
   * Pers.spells
   */
  export type Pers$spellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    where?: SpellWhereInput
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    cursor?: SpellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }

  /**
   * Pers.feats
   */
  export type Pers$featsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeat
     */
    select?: PersFeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeat
     */
    omit?: PersFeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatInclude<ExtArgs> | null
    where?: PersFeatWhereInput
    orderBy?: PersFeatOrderByWithRelationInput | PersFeatOrderByWithRelationInput[]
    cursor?: PersFeatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersFeatScalarFieldEnum | PersFeatScalarFieldEnum[]
  }

  /**
   * Pers.armors
   */
  export type Pers$armorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersArmor
     */
    select?: PersArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersArmor
     */
    omit?: PersArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersArmorInclude<ExtArgs> | null
    where?: PersArmorWhereInput
    orderBy?: PersArmorOrderByWithRelationInput | PersArmorOrderByWithRelationInput[]
    cursor?: PersArmorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersArmorScalarFieldEnum | PersArmorScalarFieldEnum[]
  }

  /**
   * Pers.weapons
   */
  export type Pers$weaponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersWeapon
     */
    select?: PersWeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersWeapon
     */
    omit?: PersWeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersWeaponInclude<ExtArgs> | null
    where?: PersWeaponWhereInput
    orderBy?: PersWeaponOrderByWithRelationInput | PersWeaponOrderByWithRelationInput[]
    cursor?: PersWeaponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersWeaponScalarFieldEnum | PersWeaponScalarFieldEnum[]
  }

  /**
   * Pers.magicItems
   */
  export type Pers$magicItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMagicItem
     */
    select?: PersMagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMagicItem
     */
    omit?: PersMagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMagicItemInclude<ExtArgs> | null
    where?: PersMagicItemWhereInput
    orderBy?: PersMagicItemOrderByWithRelationInput | PersMagicItemOrderByWithRelationInput[]
    cursor?: PersMagicItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersMagicItemScalarFieldEnum | PersMagicItemScalarFieldEnum[]
  }

  /**
   * Pers.raceVariants
   */
  export type Pers$raceVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariant
     */
    select?: RaceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariant
     */
    omit?: RaceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantInclude<ExtArgs> | null
    where?: RaceVariantWhereInput
    orderBy?: RaceVariantOrderByWithRelationInput | RaceVariantOrderByWithRelationInput[]
    cursor?: RaceVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceVariantScalarFieldEnum | RaceVariantScalarFieldEnum[]
  }

  /**
   * Pers.raceChoiceOptions
   */
  export type Pers$raceChoiceOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOption
     */
    select?: RaceChoiceOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOption
     */
    omit?: RaceChoiceOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionInclude<ExtArgs> | null
    where?: RaceChoiceOptionWhereInput
    orderBy?: RaceChoiceOptionOrderByWithRelationInput | RaceChoiceOptionOrderByWithRelationInput[]
    cursor?: RaceChoiceOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceChoiceOptionScalarFieldEnum | RaceChoiceOptionScalarFieldEnum[]
  }

  /**
   * Pers without action
   */
  export type PersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
  }


  /**
   * Model PersMulticlass
   */

  export type AggregatePersMulticlass = {
    _count: PersMulticlassCountAggregateOutputType | null
    _avg: PersMulticlassAvgAggregateOutputType | null
    _sum: PersMulticlassSumAggregateOutputType | null
    _min: PersMulticlassMinAggregateOutputType | null
    _max: PersMulticlassMaxAggregateOutputType | null
  }

  export type PersMulticlassAvgAggregateOutputType = {
    persMulticlassId: number | null
    persId: number | null
    classId: number | null
    subclassId: number | null
    classLevel: number | null
  }

  export type PersMulticlassSumAggregateOutputType = {
    persMulticlassId: number | null
    persId: number | null
    classId: number | null
    subclassId: number | null
    classLevel: number | null
  }

  export type PersMulticlassMinAggregateOutputType = {
    persMulticlassId: number | null
    persId: number | null
    classId: number | null
    subclassId: number | null
    classLevel: number | null
  }

  export type PersMulticlassMaxAggregateOutputType = {
    persMulticlassId: number | null
    persId: number | null
    classId: number | null
    subclassId: number | null
    classLevel: number | null
  }

  export type PersMulticlassCountAggregateOutputType = {
    persMulticlassId: number
    persId: number
    classId: number
    subclassId: number
    classLevel: number
    _all: number
  }


  export type PersMulticlassAvgAggregateInputType = {
    persMulticlassId?: true
    persId?: true
    classId?: true
    subclassId?: true
    classLevel?: true
  }

  export type PersMulticlassSumAggregateInputType = {
    persMulticlassId?: true
    persId?: true
    classId?: true
    subclassId?: true
    classLevel?: true
  }

  export type PersMulticlassMinAggregateInputType = {
    persMulticlassId?: true
    persId?: true
    classId?: true
    subclassId?: true
    classLevel?: true
  }

  export type PersMulticlassMaxAggregateInputType = {
    persMulticlassId?: true
    persId?: true
    classId?: true
    subclassId?: true
    classLevel?: true
  }

  export type PersMulticlassCountAggregateInputType = {
    persMulticlassId?: true
    persId?: true
    classId?: true
    subclassId?: true
    classLevel?: true
    _all?: true
  }

  export type PersMulticlassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersMulticlass to aggregate.
     */
    where?: PersMulticlassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersMulticlasses to fetch.
     */
    orderBy?: PersMulticlassOrderByWithRelationInput | PersMulticlassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersMulticlassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersMulticlasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersMulticlasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersMulticlasses
    **/
    _count?: true | PersMulticlassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersMulticlassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersMulticlassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersMulticlassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersMulticlassMaxAggregateInputType
  }

  export type GetPersMulticlassAggregateType<T extends PersMulticlassAggregateArgs> = {
        [P in keyof T & keyof AggregatePersMulticlass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersMulticlass[P]>
      : GetScalarType<T[P], AggregatePersMulticlass[P]>
  }




  export type PersMulticlassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersMulticlassWhereInput
    orderBy?: PersMulticlassOrderByWithAggregationInput | PersMulticlassOrderByWithAggregationInput[]
    by: PersMulticlassScalarFieldEnum[] | PersMulticlassScalarFieldEnum
    having?: PersMulticlassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersMulticlassCountAggregateInputType | true
    _avg?: PersMulticlassAvgAggregateInputType
    _sum?: PersMulticlassSumAggregateInputType
    _min?: PersMulticlassMinAggregateInputType
    _max?: PersMulticlassMaxAggregateInputType
  }

  export type PersMulticlassGroupByOutputType = {
    persMulticlassId: number
    persId: number
    classId: number
    subclassId: number | null
    classLevel: number
    _count: PersMulticlassCountAggregateOutputType | null
    _avg: PersMulticlassAvgAggregateOutputType | null
    _sum: PersMulticlassSumAggregateOutputType | null
    _min: PersMulticlassMinAggregateOutputType | null
    _max: PersMulticlassMaxAggregateOutputType | null
  }

  type GetPersMulticlassGroupByPayload<T extends PersMulticlassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersMulticlassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersMulticlassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersMulticlassGroupByOutputType[P]>
            : GetScalarType<T[P], PersMulticlassGroupByOutputType[P]>
        }
      >
    >


  export type PersMulticlassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persMulticlassId?: boolean
    persId?: boolean
    classId?: boolean
    subclassId?: boolean
    classLevel?: boolean
    pers?: boolean | PersDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subclass?: boolean | PersMulticlass$subclassArgs<ExtArgs>
  }, ExtArgs["result"]["persMulticlass"]>

  export type PersMulticlassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persMulticlassId?: boolean
    persId?: boolean
    classId?: boolean
    subclassId?: boolean
    classLevel?: boolean
    pers?: boolean | PersDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subclass?: boolean | PersMulticlass$subclassArgs<ExtArgs>
  }, ExtArgs["result"]["persMulticlass"]>

  export type PersMulticlassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persMulticlassId?: boolean
    persId?: boolean
    classId?: boolean
    subclassId?: boolean
    classLevel?: boolean
    pers?: boolean | PersDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subclass?: boolean | PersMulticlass$subclassArgs<ExtArgs>
  }, ExtArgs["result"]["persMulticlass"]>

  export type PersMulticlassSelectScalar = {
    persMulticlassId?: boolean
    persId?: boolean
    classId?: boolean
    subclassId?: boolean
    classLevel?: boolean
  }

  export type PersMulticlassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"persMulticlassId" | "persId" | "classId" | "subclassId" | "classLevel", ExtArgs["result"]["persMulticlass"]>
  export type PersMulticlassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pers?: boolean | PersDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subclass?: boolean | PersMulticlass$subclassArgs<ExtArgs>
  }
  export type PersMulticlassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pers?: boolean | PersDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subclass?: boolean | PersMulticlass$subclassArgs<ExtArgs>
  }
  export type PersMulticlassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pers?: boolean | PersDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subclass?: boolean | PersMulticlass$subclassArgs<ExtArgs>
  }

  export type $PersMulticlassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersMulticlass"
    objects: {
      pers: Prisma.$PersPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      subclass: Prisma.$SubclassPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      persMulticlassId: number
      persId: number
      classId: number
      subclassId: number | null
      classLevel: number
    }, ExtArgs["result"]["persMulticlass"]>
    composites: {}
  }

  type PersMulticlassGetPayload<S extends boolean | null | undefined | PersMulticlassDefaultArgs> = $Result.GetResult<Prisma.$PersMulticlassPayload, S>

  type PersMulticlassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersMulticlassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersMulticlassCountAggregateInputType | true
    }

  export interface PersMulticlassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersMulticlass'], meta: { name: 'PersMulticlass' } }
    /**
     * Find zero or one PersMulticlass that matches the filter.
     * @param {PersMulticlassFindUniqueArgs} args - Arguments to find a PersMulticlass
     * @example
     * // Get one PersMulticlass
     * const persMulticlass = await prisma.persMulticlass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersMulticlassFindUniqueArgs>(args: SelectSubset<T, PersMulticlassFindUniqueArgs<ExtArgs>>): Prisma__PersMulticlassClient<$Result.GetResult<Prisma.$PersMulticlassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersMulticlass that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersMulticlassFindUniqueOrThrowArgs} args - Arguments to find a PersMulticlass
     * @example
     * // Get one PersMulticlass
     * const persMulticlass = await prisma.persMulticlass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersMulticlassFindUniqueOrThrowArgs>(args: SelectSubset<T, PersMulticlassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersMulticlassClient<$Result.GetResult<Prisma.$PersMulticlassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersMulticlass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersMulticlassFindFirstArgs} args - Arguments to find a PersMulticlass
     * @example
     * // Get one PersMulticlass
     * const persMulticlass = await prisma.persMulticlass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersMulticlassFindFirstArgs>(args?: SelectSubset<T, PersMulticlassFindFirstArgs<ExtArgs>>): Prisma__PersMulticlassClient<$Result.GetResult<Prisma.$PersMulticlassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersMulticlass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersMulticlassFindFirstOrThrowArgs} args - Arguments to find a PersMulticlass
     * @example
     * // Get one PersMulticlass
     * const persMulticlass = await prisma.persMulticlass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersMulticlassFindFirstOrThrowArgs>(args?: SelectSubset<T, PersMulticlassFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersMulticlassClient<$Result.GetResult<Prisma.$PersMulticlassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersMulticlasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersMulticlassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersMulticlasses
     * const persMulticlasses = await prisma.persMulticlass.findMany()
     * 
     * // Get first 10 PersMulticlasses
     * const persMulticlasses = await prisma.persMulticlass.findMany({ take: 10 })
     * 
     * // Only select the `persMulticlassId`
     * const persMulticlassWithPersMulticlassIdOnly = await prisma.persMulticlass.findMany({ select: { persMulticlassId: true } })
     * 
     */
    findMany<T extends PersMulticlassFindManyArgs>(args?: SelectSubset<T, PersMulticlassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersMulticlassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersMulticlass.
     * @param {PersMulticlassCreateArgs} args - Arguments to create a PersMulticlass.
     * @example
     * // Create one PersMulticlass
     * const PersMulticlass = await prisma.persMulticlass.create({
     *   data: {
     *     // ... data to create a PersMulticlass
     *   }
     * })
     * 
     */
    create<T extends PersMulticlassCreateArgs>(args: SelectSubset<T, PersMulticlassCreateArgs<ExtArgs>>): Prisma__PersMulticlassClient<$Result.GetResult<Prisma.$PersMulticlassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersMulticlasses.
     * @param {PersMulticlassCreateManyArgs} args - Arguments to create many PersMulticlasses.
     * @example
     * // Create many PersMulticlasses
     * const persMulticlass = await prisma.persMulticlass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersMulticlassCreateManyArgs>(args?: SelectSubset<T, PersMulticlassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersMulticlasses and returns the data saved in the database.
     * @param {PersMulticlassCreateManyAndReturnArgs} args - Arguments to create many PersMulticlasses.
     * @example
     * // Create many PersMulticlasses
     * const persMulticlass = await prisma.persMulticlass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersMulticlasses and only return the `persMulticlassId`
     * const persMulticlassWithPersMulticlassIdOnly = await prisma.persMulticlass.createManyAndReturn({
     *   select: { persMulticlassId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersMulticlassCreateManyAndReturnArgs>(args?: SelectSubset<T, PersMulticlassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersMulticlassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersMulticlass.
     * @param {PersMulticlassDeleteArgs} args - Arguments to delete one PersMulticlass.
     * @example
     * // Delete one PersMulticlass
     * const PersMulticlass = await prisma.persMulticlass.delete({
     *   where: {
     *     // ... filter to delete one PersMulticlass
     *   }
     * })
     * 
     */
    delete<T extends PersMulticlassDeleteArgs>(args: SelectSubset<T, PersMulticlassDeleteArgs<ExtArgs>>): Prisma__PersMulticlassClient<$Result.GetResult<Prisma.$PersMulticlassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersMulticlass.
     * @param {PersMulticlassUpdateArgs} args - Arguments to update one PersMulticlass.
     * @example
     * // Update one PersMulticlass
     * const persMulticlass = await prisma.persMulticlass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersMulticlassUpdateArgs>(args: SelectSubset<T, PersMulticlassUpdateArgs<ExtArgs>>): Prisma__PersMulticlassClient<$Result.GetResult<Prisma.$PersMulticlassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersMulticlasses.
     * @param {PersMulticlassDeleteManyArgs} args - Arguments to filter PersMulticlasses to delete.
     * @example
     * // Delete a few PersMulticlasses
     * const { count } = await prisma.persMulticlass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersMulticlassDeleteManyArgs>(args?: SelectSubset<T, PersMulticlassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersMulticlasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersMulticlassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersMulticlasses
     * const persMulticlass = await prisma.persMulticlass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersMulticlassUpdateManyArgs>(args: SelectSubset<T, PersMulticlassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersMulticlasses and returns the data updated in the database.
     * @param {PersMulticlassUpdateManyAndReturnArgs} args - Arguments to update many PersMulticlasses.
     * @example
     * // Update many PersMulticlasses
     * const persMulticlass = await prisma.persMulticlass.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersMulticlasses and only return the `persMulticlassId`
     * const persMulticlassWithPersMulticlassIdOnly = await prisma.persMulticlass.updateManyAndReturn({
     *   select: { persMulticlassId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersMulticlassUpdateManyAndReturnArgs>(args: SelectSubset<T, PersMulticlassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersMulticlassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersMulticlass.
     * @param {PersMulticlassUpsertArgs} args - Arguments to update or create a PersMulticlass.
     * @example
     * // Update or create a PersMulticlass
     * const persMulticlass = await prisma.persMulticlass.upsert({
     *   create: {
     *     // ... data to create a PersMulticlass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersMulticlass we want to update
     *   }
     * })
     */
    upsert<T extends PersMulticlassUpsertArgs>(args: SelectSubset<T, PersMulticlassUpsertArgs<ExtArgs>>): Prisma__PersMulticlassClient<$Result.GetResult<Prisma.$PersMulticlassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersMulticlasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersMulticlassCountArgs} args - Arguments to filter PersMulticlasses to count.
     * @example
     * // Count the number of PersMulticlasses
     * const count = await prisma.persMulticlass.count({
     *   where: {
     *     // ... the filter for the PersMulticlasses we want to count
     *   }
     * })
    **/
    count<T extends PersMulticlassCountArgs>(
      args?: Subset<T, PersMulticlassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersMulticlassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersMulticlass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersMulticlassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersMulticlassAggregateArgs>(args: Subset<T, PersMulticlassAggregateArgs>): Prisma.PrismaPromise<GetPersMulticlassAggregateType<T>>

    /**
     * Group by PersMulticlass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersMulticlassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersMulticlassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersMulticlassGroupByArgs['orderBy'] }
        : { orderBy?: PersMulticlassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersMulticlassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersMulticlassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersMulticlass model
   */
  readonly fields: PersMulticlassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersMulticlass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersMulticlassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pers<T extends PersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersDefaultArgs<ExtArgs>>): Prisma__PersClient<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subclass<T extends PersMulticlass$subclassArgs<ExtArgs> = {}>(args?: Subset<T, PersMulticlass$subclassArgs<ExtArgs>>): Prisma__SubclassClient<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersMulticlass model
   */
  interface PersMulticlassFieldRefs {
    readonly persMulticlassId: FieldRef<"PersMulticlass", 'Int'>
    readonly persId: FieldRef<"PersMulticlass", 'Int'>
    readonly classId: FieldRef<"PersMulticlass", 'Int'>
    readonly subclassId: FieldRef<"PersMulticlass", 'Int'>
    readonly classLevel: FieldRef<"PersMulticlass", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PersMulticlass findUnique
   */
  export type PersMulticlassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMulticlass
     */
    select?: PersMulticlassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMulticlass
     */
    omit?: PersMulticlassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMulticlassInclude<ExtArgs> | null
    /**
     * Filter, which PersMulticlass to fetch.
     */
    where: PersMulticlassWhereUniqueInput
  }

  /**
   * PersMulticlass findUniqueOrThrow
   */
  export type PersMulticlassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMulticlass
     */
    select?: PersMulticlassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMulticlass
     */
    omit?: PersMulticlassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMulticlassInclude<ExtArgs> | null
    /**
     * Filter, which PersMulticlass to fetch.
     */
    where: PersMulticlassWhereUniqueInput
  }

  /**
   * PersMulticlass findFirst
   */
  export type PersMulticlassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMulticlass
     */
    select?: PersMulticlassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMulticlass
     */
    omit?: PersMulticlassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMulticlassInclude<ExtArgs> | null
    /**
     * Filter, which PersMulticlass to fetch.
     */
    where?: PersMulticlassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersMulticlasses to fetch.
     */
    orderBy?: PersMulticlassOrderByWithRelationInput | PersMulticlassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersMulticlasses.
     */
    cursor?: PersMulticlassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersMulticlasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersMulticlasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersMulticlasses.
     */
    distinct?: PersMulticlassScalarFieldEnum | PersMulticlassScalarFieldEnum[]
  }

  /**
   * PersMulticlass findFirstOrThrow
   */
  export type PersMulticlassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMulticlass
     */
    select?: PersMulticlassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMulticlass
     */
    omit?: PersMulticlassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMulticlassInclude<ExtArgs> | null
    /**
     * Filter, which PersMulticlass to fetch.
     */
    where?: PersMulticlassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersMulticlasses to fetch.
     */
    orderBy?: PersMulticlassOrderByWithRelationInput | PersMulticlassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersMulticlasses.
     */
    cursor?: PersMulticlassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersMulticlasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersMulticlasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersMulticlasses.
     */
    distinct?: PersMulticlassScalarFieldEnum | PersMulticlassScalarFieldEnum[]
  }

  /**
   * PersMulticlass findMany
   */
  export type PersMulticlassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMulticlass
     */
    select?: PersMulticlassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMulticlass
     */
    omit?: PersMulticlassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMulticlassInclude<ExtArgs> | null
    /**
     * Filter, which PersMulticlasses to fetch.
     */
    where?: PersMulticlassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersMulticlasses to fetch.
     */
    orderBy?: PersMulticlassOrderByWithRelationInput | PersMulticlassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersMulticlasses.
     */
    cursor?: PersMulticlassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersMulticlasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersMulticlasses.
     */
    skip?: number
    distinct?: PersMulticlassScalarFieldEnum | PersMulticlassScalarFieldEnum[]
  }

  /**
   * PersMulticlass create
   */
  export type PersMulticlassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMulticlass
     */
    select?: PersMulticlassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMulticlass
     */
    omit?: PersMulticlassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMulticlassInclude<ExtArgs> | null
    /**
     * The data needed to create a PersMulticlass.
     */
    data: XOR<PersMulticlassCreateInput, PersMulticlassUncheckedCreateInput>
  }

  /**
   * PersMulticlass createMany
   */
  export type PersMulticlassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersMulticlasses.
     */
    data: PersMulticlassCreateManyInput | PersMulticlassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersMulticlass createManyAndReturn
   */
  export type PersMulticlassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMulticlass
     */
    select?: PersMulticlassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersMulticlass
     */
    omit?: PersMulticlassOmit<ExtArgs> | null
    /**
     * The data used to create many PersMulticlasses.
     */
    data: PersMulticlassCreateManyInput | PersMulticlassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMulticlassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersMulticlass update
   */
  export type PersMulticlassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMulticlass
     */
    select?: PersMulticlassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMulticlass
     */
    omit?: PersMulticlassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMulticlassInclude<ExtArgs> | null
    /**
     * The data needed to update a PersMulticlass.
     */
    data: XOR<PersMulticlassUpdateInput, PersMulticlassUncheckedUpdateInput>
    /**
     * Choose, which PersMulticlass to update.
     */
    where: PersMulticlassWhereUniqueInput
  }

  /**
   * PersMulticlass updateMany
   */
  export type PersMulticlassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersMulticlasses.
     */
    data: XOR<PersMulticlassUpdateManyMutationInput, PersMulticlassUncheckedUpdateManyInput>
    /**
     * Filter which PersMulticlasses to update
     */
    where?: PersMulticlassWhereInput
    /**
     * Limit how many PersMulticlasses to update.
     */
    limit?: number
  }

  /**
   * PersMulticlass updateManyAndReturn
   */
  export type PersMulticlassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMulticlass
     */
    select?: PersMulticlassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersMulticlass
     */
    omit?: PersMulticlassOmit<ExtArgs> | null
    /**
     * The data used to update PersMulticlasses.
     */
    data: XOR<PersMulticlassUpdateManyMutationInput, PersMulticlassUncheckedUpdateManyInput>
    /**
     * Filter which PersMulticlasses to update
     */
    where?: PersMulticlassWhereInput
    /**
     * Limit how many PersMulticlasses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMulticlassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersMulticlass upsert
   */
  export type PersMulticlassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMulticlass
     */
    select?: PersMulticlassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMulticlass
     */
    omit?: PersMulticlassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMulticlassInclude<ExtArgs> | null
    /**
     * The filter to search for the PersMulticlass to update in case it exists.
     */
    where: PersMulticlassWhereUniqueInput
    /**
     * In case the PersMulticlass found by the `where` argument doesn't exist, create a new PersMulticlass with this data.
     */
    create: XOR<PersMulticlassCreateInput, PersMulticlassUncheckedCreateInput>
    /**
     * In case the PersMulticlass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersMulticlassUpdateInput, PersMulticlassUncheckedUpdateInput>
  }

  /**
   * PersMulticlass delete
   */
  export type PersMulticlassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMulticlass
     */
    select?: PersMulticlassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMulticlass
     */
    omit?: PersMulticlassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMulticlassInclude<ExtArgs> | null
    /**
     * Filter which PersMulticlass to delete.
     */
    where: PersMulticlassWhereUniqueInput
  }

  /**
   * PersMulticlass deleteMany
   */
  export type PersMulticlassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersMulticlasses to delete
     */
    where?: PersMulticlassWhereInput
    /**
     * Limit how many PersMulticlasses to delete.
     */
    limit?: number
  }

  /**
   * PersMulticlass.subclass
   */
  export type PersMulticlass$subclassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subclass
     */
    select?: SubclassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subclass
     */
    omit?: SubclassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassInclude<ExtArgs> | null
    where?: SubclassWhereInput
  }

  /**
   * PersMulticlass without action
   */
  export type PersMulticlassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMulticlass
     */
    select?: PersMulticlassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMulticlass
     */
    omit?: PersMulticlassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMulticlassInclude<ExtArgs> | null
  }


  /**
   * Model PersFeature
   */

  export type AggregatePersFeature = {
    _count: PersFeatureCountAggregateOutputType | null
    _avg: PersFeatureAvgAggregateOutputType | null
    _sum: PersFeatureSumAggregateOutputType | null
    _min: PersFeatureMinAggregateOutputType | null
    _max: PersFeatureMaxAggregateOutputType | null
  }

  export type PersFeatureAvgAggregateOutputType = {
    persFeatureId: number | null
    persId: number | null
    featureId: number | null
    usesRemaining: number | null
  }

  export type PersFeatureSumAggregateOutputType = {
    persFeatureId: number | null
    persId: number | null
    featureId: number | null
    usesRemaining: number | null
  }

  export type PersFeatureMinAggregateOutputType = {
    persFeatureId: number | null
    persId: number | null
    featureId: number | null
    usesRemaining: number | null
  }

  export type PersFeatureMaxAggregateOutputType = {
    persFeatureId: number | null
    persId: number | null
    featureId: number | null
    usesRemaining: number | null
  }

  export type PersFeatureCountAggregateOutputType = {
    persFeatureId: number
    persId: number
    featureId: number
    usesRemaining: number
    _all: number
  }


  export type PersFeatureAvgAggregateInputType = {
    persFeatureId?: true
    persId?: true
    featureId?: true
    usesRemaining?: true
  }

  export type PersFeatureSumAggregateInputType = {
    persFeatureId?: true
    persId?: true
    featureId?: true
    usesRemaining?: true
  }

  export type PersFeatureMinAggregateInputType = {
    persFeatureId?: true
    persId?: true
    featureId?: true
    usesRemaining?: true
  }

  export type PersFeatureMaxAggregateInputType = {
    persFeatureId?: true
    persId?: true
    featureId?: true
    usesRemaining?: true
  }

  export type PersFeatureCountAggregateInputType = {
    persFeatureId?: true
    persId?: true
    featureId?: true
    usesRemaining?: true
    _all?: true
  }

  export type PersFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersFeature to aggregate.
     */
    where?: PersFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersFeatures to fetch.
     */
    orderBy?: PersFeatureOrderByWithRelationInput | PersFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersFeatures
    **/
    _count?: true | PersFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersFeatureMaxAggregateInputType
  }

  export type GetPersFeatureAggregateType<T extends PersFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregatePersFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersFeature[P]>
      : GetScalarType<T[P], AggregatePersFeature[P]>
  }




  export type PersFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersFeatureWhereInput
    orderBy?: PersFeatureOrderByWithAggregationInput | PersFeatureOrderByWithAggregationInput[]
    by: PersFeatureScalarFieldEnum[] | PersFeatureScalarFieldEnum
    having?: PersFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersFeatureCountAggregateInputType | true
    _avg?: PersFeatureAvgAggregateInputType
    _sum?: PersFeatureSumAggregateInputType
    _min?: PersFeatureMinAggregateInputType
    _max?: PersFeatureMaxAggregateInputType
  }

  export type PersFeatureGroupByOutputType = {
    persFeatureId: number
    persId: number
    featureId: number
    usesRemaining: number | null
    _count: PersFeatureCountAggregateOutputType | null
    _avg: PersFeatureAvgAggregateOutputType | null
    _sum: PersFeatureSumAggregateOutputType | null
    _min: PersFeatureMinAggregateOutputType | null
    _max: PersFeatureMaxAggregateOutputType | null
  }

  type GetPersFeatureGroupByPayload<T extends PersFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], PersFeatureGroupByOutputType[P]>
        }
      >
    >


  export type PersFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persFeatureId?: boolean
    persId?: boolean
    featureId?: boolean
    usesRemaining?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persFeature"]>

  export type PersFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persFeatureId?: boolean
    persId?: boolean
    featureId?: boolean
    usesRemaining?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persFeature"]>

  export type PersFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persFeatureId?: boolean
    persId?: boolean
    featureId?: boolean
    usesRemaining?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persFeature"]>

  export type PersFeatureSelectScalar = {
    persFeatureId?: boolean
    persId?: boolean
    featureId?: boolean
    usesRemaining?: boolean
  }

  export type PersFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"persFeatureId" | "persId" | "featureId" | "usesRemaining", ExtArgs["result"]["persFeature"]>
  export type PersFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }
  export type PersFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }
  export type PersFeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }

  export type $PersFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersFeature"
    objects: {
      feature: Prisma.$FeaturePayload<ExtArgs>
      pers: Prisma.$PersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      persFeatureId: number
      persId: number
      featureId: number
      usesRemaining: number | null
    }, ExtArgs["result"]["persFeature"]>
    composites: {}
  }

  type PersFeatureGetPayload<S extends boolean | null | undefined | PersFeatureDefaultArgs> = $Result.GetResult<Prisma.$PersFeaturePayload, S>

  type PersFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersFeatureCountAggregateInputType | true
    }

  export interface PersFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersFeature'], meta: { name: 'PersFeature' } }
    /**
     * Find zero or one PersFeature that matches the filter.
     * @param {PersFeatureFindUniqueArgs} args - Arguments to find a PersFeature
     * @example
     * // Get one PersFeature
     * const persFeature = await prisma.persFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersFeatureFindUniqueArgs>(args: SelectSubset<T, PersFeatureFindUniqueArgs<ExtArgs>>): Prisma__PersFeatureClient<$Result.GetResult<Prisma.$PersFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersFeatureFindUniqueOrThrowArgs} args - Arguments to find a PersFeature
     * @example
     * // Get one PersFeature
     * const persFeature = await prisma.persFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, PersFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersFeatureClient<$Result.GetResult<Prisma.$PersFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFeatureFindFirstArgs} args - Arguments to find a PersFeature
     * @example
     * // Get one PersFeature
     * const persFeature = await prisma.persFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersFeatureFindFirstArgs>(args?: SelectSubset<T, PersFeatureFindFirstArgs<ExtArgs>>): Prisma__PersFeatureClient<$Result.GetResult<Prisma.$PersFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFeatureFindFirstOrThrowArgs} args - Arguments to find a PersFeature
     * @example
     * // Get one PersFeature
     * const persFeature = await prisma.persFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, PersFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersFeatureClient<$Result.GetResult<Prisma.$PersFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersFeatures
     * const persFeatures = await prisma.persFeature.findMany()
     * 
     * // Get first 10 PersFeatures
     * const persFeatures = await prisma.persFeature.findMany({ take: 10 })
     * 
     * // Only select the `persFeatureId`
     * const persFeatureWithPersFeatureIdOnly = await prisma.persFeature.findMany({ select: { persFeatureId: true } })
     * 
     */
    findMany<T extends PersFeatureFindManyArgs>(args?: SelectSubset<T, PersFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersFeature.
     * @param {PersFeatureCreateArgs} args - Arguments to create a PersFeature.
     * @example
     * // Create one PersFeature
     * const PersFeature = await prisma.persFeature.create({
     *   data: {
     *     // ... data to create a PersFeature
     *   }
     * })
     * 
     */
    create<T extends PersFeatureCreateArgs>(args: SelectSubset<T, PersFeatureCreateArgs<ExtArgs>>): Prisma__PersFeatureClient<$Result.GetResult<Prisma.$PersFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersFeatures.
     * @param {PersFeatureCreateManyArgs} args - Arguments to create many PersFeatures.
     * @example
     * // Create many PersFeatures
     * const persFeature = await prisma.persFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersFeatureCreateManyArgs>(args?: SelectSubset<T, PersFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersFeatures and returns the data saved in the database.
     * @param {PersFeatureCreateManyAndReturnArgs} args - Arguments to create many PersFeatures.
     * @example
     * // Create many PersFeatures
     * const persFeature = await prisma.persFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersFeatures and only return the `persFeatureId`
     * const persFeatureWithPersFeatureIdOnly = await prisma.persFeature.createManyAndReturn({
     *   select: { persFeatureId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, PersFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersFeature.
     * @param {PersFeatureDeleteArgs} args - Arguments to delete one PersFeature.
     * @example
     * // Delete one PersFeature
     * const PersFeature = await prisma.persFeature.delete({
     *   where: {
     *     // ... filter to delete one PersFeature
     *   }
     * })
     * 
     */
    delete<T extends PersFeatureDeleteArgs>(args: SelectSubset<T, PersFeatureDeleteArgs<ExtArgs>>): Prisma__PersFeatureClient<$Result.GetResult<Prisma.$PersFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersFeature.
     * @param {PersFeatureUpdateArgs} args - Arguments to update one PersFeature.
     * @example
     * // Update one PersFeature
     * const persFeature = await prisma.persFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersFeatureUpdateArgs>(args: SelectSubset<T, PersFeatureUpdateArgs<ExtArgs>>): Prisma__PersFeatureClient<$Result.GetResult<Prisma.$PersFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersFeatures.
     * @param {PersFeatureDeleteManyArgs} args - Arguments to filter PersFeatures to delete.
     * @example
     * // Delete a few PersFeatures
     * const { count } = await prisma.persFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersFeatureDeleteManyArgs>(args?: SelectSubset<T, PersFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersFeatures
     * const persFeature = await prisma.persFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersFeatureUpdateManyArgs>(args: SelectSubset<T, PersFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersFeatures and returns the data updated in the database.
     * @param {PersFeatureUpdateManyAndReturnArgs} args - Arguments to update many PersFeatures.
     * @example
     * // Update many PersFeatures
     * const persFeature = await prisma.persFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersFeatures and only return the `persFeatureId`
     * const persFeatureWithPersFeatureIdOnly = await prisma.persFeature.updateManyAndReturn({
     *   select: { persFeatureId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, PersFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersFeature.
     * @param {PersFeatureUpsertArgs} args - Arguments to update or create a PersFeature.
     * @example
     * // Update or create a PersFeature
     * const persFeature = await prisma.persFeature.upsert({
     *   create: {
     *     // ... data to create a PersFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersFeature we want to update
     *   }
     * })
     */
    upsert<T extends PersFeatureUpsertArgs>(args: SelectSubset<T, PersFeatureUpsertArgs<ExtArgs>>): Prisma__PersFeatureClient<$Result.GetResult<Prisma.$PersFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFeatureCountArgs} args - Arguments to filter PersFeatures to count.
     * @example
     * // Count the number of PersFeatures
     * const count = await prisma.persFeature.count({
     *   where: {
     *     // ... the filter for the PersFeatures we want to count
     *   }
     * })
    **/
    count<T extends PersFeatureCountArgs>(
      args?: Subset<T, PersFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersFeatureAggregateArgs>(args: Subset<T, PersFeatureAggregateArgs>): Prisma.PrismaPromise<GetPersFeatureAggregateType<T>>

    /**
     * Group by PersFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersFeatureGroupByArgs['orderBy'] }
        : { orderBy?: PersFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersFeature model
   */
  readonly fields: PersFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feature<T extends FeatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureDefaultArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pers<T extends PersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersDefaultArgs<ExtArgs>>): Prisma__PersClient<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersFeature model
   */
  interface PersFeatureFieldRefs {
    readonly persFeatureId: FieldRef<"PersFeature", 'Int'>
    readonly persId: FieldRef<"PersFeature", 'Int'>
    readonly featureId: FieldRef<"PersFeature", 'Int'>
    readonly usesRemaining: FieldRef<"PersFeature", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PersFeature findUnique
   */
  export type PersFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeature
     */
    select?: PersFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeature
     */
    omit?: PersFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PersFeature to fetch.
     */
    where: PersFeatureWhereUniqueInput
  }

  /**
   * PersFeature findUniqueOrThrow
   */
  export type PersFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeature
     */
    select?: PersFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeature
     */
    omit?: PersFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PersFeature to fetch.
     */
    where: PersFeatureWhereUniqueInput
  }

  /**
   * PersFeature findFirst
   */
  export type PersFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeature
     */
    select?: PersFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeature
     */
    omit?: PersFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PersFeature to fetch.
     */
    where?: PersFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersFeatures to fetch.
     */
    orderBy?: PersFeatureOrderByWithRelationInput | PersFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersFeatures.
     */
    cursor?: PersFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersFeatures.
     */
    distinct?: PersFeatureScalarFieldEnum | PersFeatureScalarFieldEnum[]
  }

  /**
   * PersFeature findFirstOrThrow
   */
  export type PersFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeature
     */
    select?: PersFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeature
     */
    omit?: PersFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PersFeature to fetch.
     */
    where?: PersFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersFeatures to fetch.
     */
    orderBy?: PersFeatureOrderByWithRelationInput | PersFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersFeatures.
     */
    cursor?: PersFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersFeatures.
     */
    distinct?: PersFeatureScalarFieldEnum | PersFeatureScalarFieldEnum[]
  }

  /**
   * PersFeature findMany
   */
  export type PersFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeature
     */
    select?: PersFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeature
     */
    omit?: PersFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PersFeatures to fetch.
     */
    where?: PersFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersFeatures to fetch.
     */
    orderBy?: PersFeatureOrderByWithRelationInput | PersFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersFeatures.
     */
    cursor?: PersFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersFeatures.
     */
    skip?: number
    distinct?: PersFeatureScalarFieldEnum | PersFeatureScalarFieldEnum[]
  }

  /**
   * PersFeature create
   */
  export type PersFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeature
     */
    select?: PersFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeature
     */
    omit?: PersFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a PersFeature.
     */
    data: XOR<PersFeatureCreateInput, PersFeatureUncheckedCreateInput>
  }

  /**
   * PersFeature createMany
   */
  export type PersFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersFeatures.
     */
    data: PersFeatureCreateManyInput | PersFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersFeature createManyAndReturn
   */
  export type PersFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeature
     */
    select?: PersFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeature
     */
    omit?: PersFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many PersFeatures.
     */
    data: PersFeatureCreateManyInput | PersFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersFeature update
   */
  export type PersFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeature
     */
    select?: PersFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeature
     */
    omit?: PersFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a PersFeature.
     */
    data: XOR<PersFeatureUpdateInput, PersFeatureUncheckedUpdateInput>
    /**
     * Choose, which PersFeature to update.
     */
    where: PersFeatureWhereUniqueInput
  }

  /**
   * PersFeature updateMany
   */
  export type PersFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersFeatures.
     */
    data: XOR<PersFeatureUpdateManyMutationInput, PersFeatureUncheckedUpdateManyInput>
    /**
     * Filter which PersFeatures to update
     */
    where?: PersFeatureWhereInput
    /**
     * Limit how many PersFeatures to update.
     */
    limit?: number
  }

  /**
   * PersFeature updateManyAndReturn
   */
  export type PersFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeature
     */
    select?: PersFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeature
     */
    omit?: PersFeatureOmit<ExtArgs> | null
    /**
     * The data used to update PersFeatures.
     */
    data: XOR<PersFeatureUpdateManyMutationInput, PersFeatureUncheckedUpdateManyInput>
    /**
     * Filter which PersFeatures to update
     */
    where?: PersFeatureWhereInput
    /**
     * Limit how many PersFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersFeature upsert
   */
  export type PersFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeature
     */
    select?: PersFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeature
     */
    omit?: PersFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the PersFeature to update in case it exists.
     */
    where: PersFeatureWhereUniqueInput
    /**
     * In case the PersFeature found by the `where` argument doesn't exist, create a new PersFeature with this data.
     */
    create: XOR<PersFeatureCreateInput, PersFeatureUncheckedCreateInput>
    /**
     * In case the PersFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersFeatureUpdateInput, PersFeatureUncheckedUpdateInput>
  }

  /**
   * PersFeature delete
   */
  export type PersFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeature
     */
    select?: PersFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeature
     */
    omit?: PersFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatureInclude<ExtArgs> | null
    /**
     * Filter which PersFeature to delete.
     */
    where: PersFeatureWhereUniqueInput
  }

  /**
   * PersFeature deleteMany
   */
  export type PersFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersFeatures to delete
     */
    where?: PersFeatureWhereInput
    /**
     * Limit how many PersFeatures to delete.
     */
    limit?: number
  }

  /**
   * PersFeature without action
   */
  export type PersFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeature
     */
    select?: PersFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeature
     */
    omit?: PersFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatureInclude<ExtArgs> | null
  }


  /**
   * Model Feature
   */

  export type AggregateFeature = {
    _count: FeatureCountAggregateOutputType | null
    _avg: FeatureAvgAggregateOutputType | null
    _sum: FeatureSumAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  export type FeatureAvgAggregateOutputType = {
    featureId: number | null
    usesCount: number | null
  }

  export type FeatureSumAggregateOutputType = {
    featureId: number | null
    usesCount: number | null
  }

  export type FeatureMinAggregateOutputType = {
    featureId: number | null
    name: string | null
    description: string | null
    shortDescription: string | null
    limitedUsesPer: $Enums.RestType | null
    usesCount: number | null
    displayType: $Enums.FeatureDisplayType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureMaxAggregateOutputType = {
    featureId: number | null
    name: string | null
    description: string | null
    shortDescription: string | null
    limitedUsesPer: $Enums.RestType | null
    usesCount: number | null
    displayType: $Enums.FeatureDisplayType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureCountAggregateOutputType = {
    featureId: number
    name: number
    description: number
    shortDescription: number
    modifiesStats: number
    limitedUsesPer: number
    usesCount: number
    displayType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeatureAvgAggregateInputType = {
    featureId?: true
    usesCount?: true
  }

  export type FeatureSumAggregateInputType = {
    featureId?: true
    usesCount?: true
  }

  export type FeatureMinAggregateInputType = {
    featureId?: true
    name?: true
    description?: true
    shortDescription?: true
    limitedUsesPer?: true
    usesCount?: true
    displayType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureMaxAggregateInputType = {
    featureId?: true
    name?: true
    description?: true
    shortDescription?: true
    limitedUsesPer?: true
    usesCount?: true
    displayType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureCountAggregateInputType = {
    featureId?: true
    name?: true
    description?: true
    shortDescription?: true
    modifiesStats?: true
    limitedUsesPer?: true
    usesCount?: true
    displayType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feature to aggregate.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Features
    **/
    _count?: true | FeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureMaxAggregateInputType
  }

  export type GetFeatureAggregateType<T extends FeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeature[P]>
      : GetScalarType<T[P], AggregateFeature[P]>
  }




  export type FeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureWhereInput
    orderBy?: FeatureOrderByWithAggregationInput | FeatureOrderByWithAggregationInput[]
    by: FeatureScalarFieldEnum[] | FeatureScalarFieldEnum
    having?: FeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureCountAggregateInputType | true
    _avg?: FeatureAvgAggregateInputType
    _sum?: FeatureSumAggregateInputType
    _min?: FeatureMinAggregateInputType
    _max?: FeatureMaxAggregateInputType
  }

  export type FeatureGroupByOutputType = {
    featureId: number
    name: string
    description: string
    shortDescription: string | null
    modifiesStats: JsonValue | null
    limitedUsesPer: $Enums.RestType | null
    usesCount: number | null
    displayType: $Enums.FeatureDisplayType
    createdAt: Date
    updatedAt: Date
    _count: FeatureCountAggregateOutputType | null
    _avg: FeatureAvgAggregateOutputType | null
    _sum: FeatureSumAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  type GetFeatureGroupByPayload<T extends FeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureGroupByOutputType[P]>
        }
      >
    >


  export type FeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    featureId?: boolean
    name?: boolean
    description?: boolean
    shortDescription?: boolean
    modifiesStats?: boolean
    limitedUsesPer?: boolean
    usesCount?: boolean
    displayType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    givesSpells?: boolean | Feature$givesSpellsArgs<ExtArgs>
    classFeatures?: boolean | Feature$classFeaturesArgs<ExtArgs>
    subclassFeatures?: boolean | Feature$subclassFeaturesArgs<ExtArgs>
    raceTraits?: boolean | Feature$raceTraitsArgs<ExtArgs>
    subraceTraits?: boolean | Feature$subraceTraitsArgs<ExtArgs>
    raceVariantTraits?: boolean | Feature$raceVariantTraitsArgs<ExtArgs>
    raceChoiceOptionsTraits?: boolean | Feature$raceChoiceOptionsTraitsArgs<ExtArgs>
    featFeatures?: boolean | Feature$featFeaturesArgs<ExtArgs>
    magicItemFeatures?: boolean | Feature$magicItemFeaturesArgs<ExtArgs>
    persFeatures?: boolean | Feature$persFeaturesArgs<ExtArgs>
    _count?: boolean | FeatureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    featureId?: boolean
    name?: boolean
    description?: boolean
    shortDescription?: boolean
    modifiesStats?: boolean
    limitedUsesPer?: boolean
    usesCount?: boolean
    displayType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    featureId?: boolean
    name?: boolean
    description?: boolean
    shortDescription?: boolean
    modifiesStats?: boolean
    limitedUsesPer?: boolean
    usesCount?: boolean
    displayType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectScalar = {
    featureId?: boolean
    name?: boolean
    description?: boolean
    shortDescription?: boolean
    modifiesStats?: boolean
    limitedUsesPer?: boolean
    usesCount?: boolean
    displayType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"featureId" | "name" | "description" | "shortDescription" | "modifiesStats" | "limitedUsesPer" | "usesCount" | "displayType" | "createdAt" | "updatedAt", ExtArgs["result"]["feature"]>
  export type FeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    givesSpells?: boolean | Feature$givesSpellsArgs<ExtArgs>
    classFeatures?: boolean | Feature$classFeaturesArgs<ExtArgs>
    subclassFeatures?: boolean | Feature$subclassFeaturesArgs<ExtArgs>
    raceTraits?: boolean | Feature$raceTraitsArgs<ExtArgs>
    subraceTraits?: boolean | Feature$subraceTraitsArgs<ExtArgs>
    raceVariantTraits?: boolean | Feature$raceVariantTraitsArgs<ExtArgs>
    raceChoiceOptionsTraits?: boolean | Feature$raceChoiceOptionsTraitsArgs<ExtArgs>
    featFeatures?: boolean | Feature$featFeaturesArgs<ExtArgs>
    magicItemFeatures?: boolean | Feature$magicItemFeaturesArgs<ExtArgs>
    persFeatures?: boolean | Feature$persFeaturesArgs<ExtArgs>
    _count?: boolean | FeatureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feature"
    objects: {
      givesSpells: Prisma.$SpellPayload<ExtArgs>[]
      classFeatures: Prisma.$ClassFeaturePayload<ExtArgs>[]
      subclassFeatures: Prisma.$SubclassFeaturePayload<ExtArgs>[]
      raceTraits: Prisma.$RaceTraitPayload<ExtArgs>[]
      subraceTraits: Prisma.$SubraceTraitPayload<ExtArgs>[]
      raceVariantTraits: Prisma.$RaceVariantTraitPayload<ExtArgs>[]
      raceChoiceOptionsTraits: Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>[]
      featFeatures: Prisma.$FeatFeaturePayload<ExtArgs>[]
      magicItemFeatures: Prisma.$MagicItemFeaturePayload<ExtArgs>[]
      persFeatures: Prisma.$PersFeaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      featureId: number
      name: string
      description: string
      shortDescription: string | null
      modifiesStats: Prisma.JsonValue | null
      limitedUsesPer: $Enums.RestType | null
      usesCount: number | null
      displayType: $Enums.FeatureDisplayType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feature"]>
    composites: {}
  }

  type FeatureGetPayload<S extends boolean | null | undefined | FeatureDefaultArgs> = $Result.GetResult<Prisma.$FeaturePayload, S>

  type FeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatureCountAggregateInputType | true
    }

  export interface FeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feature'], meta: { name: 'Feature' } }
    /**
     * Find zero or one Feature that matches the filter.
     * @param {FeatureFindUniqueArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureFindUniqueArgs>(args: SelectSubset<T, FeatureFindUniqueArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatureFindUniqueOrThrowArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindFirstArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureFindFirstArgs>(args?: SelectSubset<T, FeatureFindFirstArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindFirstOrThrowArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Features
     * const features = await prisma.feature.findMany()
     * 
     * // Get first 10 Features
     * const features = await prisma.feature.findMany({ take: 10 })
     * 
     * // Only select the `featureId`
     * const featureWithFeatureIdOnly = await prisma.feature.findMany({ select: { featureId: true } })
     * 
     */
    findMany<T extends FeatureFindManyArgs>(args?: SelectSubset<T, FeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feature.
     * @param {FeatureCreateArgs} args - Arguments to create a Feature.
     * @example
     * // Create one Feature
     * const Feature = await prisma.feature.create({
     *   data: {
     *     // ... data to create a Feature
     *   }
     * })
     * 
     */
    create<T extends FeatureCreateArgs>(args: SelectSubset<T, FeatureCreateArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Features.
     * @param {FeatureCreateManyArgs} args - Arguments to create many Features.
     * @example
     * // Create many Features
     * const feature = await prisma.feature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureCreateManyArgs>(args?: SelectSubset<T, FeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Features and returns the data saved in the database.
     * @param {FeatureCreateManyAndReturnArgs} args - Arguments to create many Features.
     * @example
     * // Create many Features
     * const feature = await prisma.feature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Features and only return the `featureId`
     * const featureWithFeatureIdOnly = await prisma.feature.createManyAndReturn({
     *   select: { featureId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feature.
     * @param {FeatureDeleteArgs} args - Arguments to delete one Feature.
     * @example
     * // Delete one Feature
     * const Feature = await prisma.feature.delete({
     *   where: {
     *     // ... filter to delete one Feature
     *   }
     * })
     * 
     */
    delete<T extends FeatureDeleteArgs>(args: SelectSubset<T, FeatureDeleteArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feature.
     * @param {FeatureUpdateArgs} args - Arguments to update one Feature.
     * @example
     * // Update one Feature
     * const feature = await prisma.feature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureUpdateArgs>(args: SelectSubset<T, FeatureUpdateArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Features.
     * @param {FeatureDeleteManyArgs} args - Arguments to filter Features to delete.
     * @example
     * // Delete a few Features
     * const { count } = await prisma.feature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureDeleteManyArgs>(args?: SelectSubset<T, FeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Features
     * const feature = await prisma.feature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureUpdateManyArgs>(args: SelectSubset<T, FeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features and returns the data updated in the database.
     * @param {FeatureUpdateManyAndReturnArgs} args - Arguments to update many Features.
     * @example
     * // Update many Features
     * const feature = await prisma.feature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Features and only return the `featureId`
     * const featureWithFeatureIdOnly = await prisma.feature.updateManyAndReturn({
     *   select: { featureId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feature.
     * @param {FeatureUpsertArgs} args - Arguments to update or create a Feature.
     * @example
     * // Update or create a Feature
     * const feature = await prisma.feature.upsert({
     *   create: {
     *     // ... data to create a Feature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feature we want to update
     *   }
     * })
     */
    upsert<T extends FeatureUpsertArgs>(args: SelectSubset<T, FeatureUpsertArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureCountArgs} args - Arguments to filter Features to count.
     * @example
     * // Count the number of Features
     * const count = await prisma.feature.count({
     *   where: {
     *     // ... the filter for the Features we want to count
     *   }
     * })
    **/
    count<T extends FeatureCountArgs>(
      args?: Subset<T, FeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureAggregateArgs>(args: Subset<T, FeatureAggregateArgs>): Prisma.PrismaPromise<GetFeatureAggregateType<T>>

    /**
     * Group by Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureGroupByArgs['orderBy'] }
        : { orderBy?: FeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feature model
   */
  readonly fields: FeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    givesSpells<T extends Feature$givesSpellsArgs<ExtArgs> = {}>(args?: Subset<T, Feature$givesSpellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classFeatures<T extends Feature$classFeaturesArgs<ExtArgs> = {}>(args?: Subset<T, Feature$classFeaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subclassFeatures<T extends Feature$subclassFeaturesArgs<ExtArgs> = {}>(args?: Subset<T, Feature$subclassFeaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubclassFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    raceTraits<T extends Feature$raceTraitsArgs<ExtArgs> = {}>(args?: Subset<T, Feature$raceTraitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subraceTraits<T extends Feature$subraceTraitsArgs<ExtArgs> = {}>(args?: Subset<T, Feature$subraceTraitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubraceTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    raceVariantTraits<T extends Feature$raceVariantTraitsArgs<ExtArgs> = {}>(args?: Subset<T, Feature$raceVariantTraitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceVariantTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    raceChoiceOptionsTraits<T extends Feature$raceChoiceOptionsTraitsArgs<ExtArgs> = {}>(args?: Subset<T, Feature$raceChoiceOptionsTraitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    featFeatures<T extends Feature$featFeaturesArgs<ExtArgs> = {}>(args?: Subset<T, Feature$featFeaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    magicItemFeatures<T extends Feature$magicItemFeaturesArgs<ExtArgs> = {}>(args?: Subset<T, Feature$magicItemFeaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    persFeatures<T extends Feature$persFeaturesArgs<ExtArgs> = {}>(args?: Subset<T, Feature$persFeaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feature model
   */
  interface FeatureFieldRefs {
    readonly featureId: FieldRef<"Feature", 'Int'>
    readonly name: FieldRef<"Feature", 'String'>
    readonly description: FieldRef<"Feature", 'String'>
    readonly shortDescription: FieldRef<"Feature", 'String'>
    readonly modifiesStats: FieldRef<"Feature", 'Json'>
    readonly limitedUsesPer: FieldRef<"Feature", 'RestType'>
    readonly usesCount: FieldRef<"Feature", 'Int'>
    readonly displayType: FieldRef<"Feature", 'FeatureDisplayType'>
    readonly createdAt: FieldRef<"Feature", 'DateTime'>
    readonly updatedAt: FieldRef<"Feature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feature findUnique
   */
  export type FeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature findUniqueOrThrow
   */
  export type FeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature findFirst
   */
  export type FeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     */
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature findFirstOrThrow
   */
  export type FeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     */
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature findMany
   */
  export type FeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Features to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature create
   */
  export type FeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a Feature.
     */
    data: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
  }

  /**
   * Feature createMany
   */
  export type FeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Features.
     */
    data: FeatureCreateManyInput | FeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feature createManyAndReturn
   */
  export type FeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * The data used to create many Features.
     */
    data: FeatureCreateManyInput | FeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feature update
   */
  export type FeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a Feature.
     */
    data: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
    /**
     * Choose, which Feature to update.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature updateMany
   */
  export type FeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Features.
     */
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyInput>
    /**
     * Filter which Features to update
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to update.
     */
    limit?: number
  }

  /**
   * Feature updateManyAndReturn
   */
  export type FeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * The data used to update Features.
     */
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyInput>
    /**
     * Filter which Features to update
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to update.
     */
    limit?: number
  }

  /**
   * Feature upsert
   */
  export type FeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the Feature to update in case it exists.
     */
    where: FeatureWhereUniqueInput
    /**
     * In case the Feature found by the `where` argument doesn't exist, create a new Feature with this data.
     */
    create: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
    /**
     * In case the Feature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
  }

  /**
   * Feature delete
   */
  export type FeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter which Feature to delete.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature deleteMany
   */
  export type FeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Features to delete
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to delete.
     */
    limit?: number
  }

  /**
   * Feature.givesSpells
   */
  export type Feature$givesSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spell
     */
    omit?: SpellOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpellInclude<ExtArgs> | null
    where?: SpellWhereInput
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    cursor?: SpellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }

  /**
   * Feature.classFeatures
   */
  export type Feature$classFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    where?: ClassFeatureWhereInput
    orderBy?: ClassFeatureOrderByWithRelationInput | ClassFeatureOrderByWithRelationInput[]
    cursor?: ClassFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassFeatureScalarFieldEnum | ClassFeatureScalarFieldEnum[]
  }

  /**
   * Feature.subclassFeatures
   */
  export type Feature$subclassFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubclassFeature
     */
    select?: SubclassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubclassFeature
     */
    omit?: SubclassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassFeatureInclude<ExtArgs> | null
    where?: SubclassFeatureWhereInput
    orderBy?: SubclassFeatureOrderByWithRelationInput | SubclassFeatureOrderByWithRelationInput[]
    cursor?: SubclassFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubclassFeatureScalarFieldEnum | SubclassFeatureScalarFieldEnum[]
  }

  /**
   * Feature.raceTraits
   */
  export type Feature$raceTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    where?: RaceTraitWhereInput
    orderBy?: RaceTraitOrderByWithRelationInput | RaceTraitOrderByWithRelationInput[]
    cursor?: RaceTraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceTraitScalarFieldEnum | RaceTraitScalarFieldEnum[]
  }

  /**
   * Feature.subraceTraits
   */
  export type Feature$subraceTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubraceTrait
     */
    select?: SubraceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubraceTrait
     */
    omit?: SubraceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceTraitInclude<ExtArgs> | null
    where?: SubraceTraitWhereInput
    orderBy?: SubraceTraitOrderByWithRelationInput | SubraceTraitOrderByWithRelationInput[]
    cursor?: SubraceTraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubraceTraitScalarFieldEnum | SubraceTraitScalarFieldEnum[]
  }

  /**
   * Feature.raceVariantTraits
   */
  export type Feature$raceVariantTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariantTrait
     */
    select?: RaceVariantTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariantTrait
     */
    omit?: RaceVariantTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantTraitInclude<ExtArgs> | null
    where?: RaceVariantTraitWhereInput
    orderBy?: RaceVariantTraitOrderByWithRelationInput | RaceVariantTraitOrderByWithRelationInput[]
    cursor?: RaceVariantTraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceVariantTraitScalarFieldEnum | RaceVariantTraitScalarFieldEnum[]
  }

  /**
   * Feature.raceChoiceOptionsTraits
   */
  export type Feature$raceChoiceOptionsTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOptionTrait
     */
    select?: RaceChoiceOptionTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOptionTrait
     */
    omit?: RaceChoiceOptionTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionTraitInclude<ExtArgs> | null
    where?: RaceChoiceOptionTraitWhereInput
    orderBy?: RaceChoiceOptionTraitOrderByWithRelationInput | RaceChoiceOptionTraitOrderByWithRelationInput[]
    cursor?: RaceChoiceOptionTraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceChoiceOptionTraitScalarFieldEnum | RaceChoiceOptionTraitScalarFieldEnum[]
  }

  /**
   * Feature.featFeatures
   */
  export type Feature$featFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatFeature
     */
    select?: FeatFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatFeature
     */
    omit?: FeatFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatFeatureInclude<ExtArgs> | null
    where?: FeatFeatureWhereInput
    orderBy?: FeatFeatureOrderByWithRelationInput | FeatFeatureOrderByWithRelationInput[]
    cursor?: FeatFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeatFeatureScalarFieldEnum | FeatFeatureScalarFieldEnum[]
  }

  /**
   * Feature.magicItemFeatures
   */
  export type Feature$magicItemFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemFeature
     */
    select?: MagicItemFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemFeature
     */
    omit?: MagicItemFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemFeatureInclude<ExtArgs> | null
    where?: MagicItemFeatureWhereInput
    orderBy?: MagicItemFeatureOrderByWithRelationInput | MagicItemFeatureOrderByWithRelationInput[]
    cursor?: MagicItemFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MagicItemFeatureScalarFieldEnum | MagicItemFeatureScalarFieldEnum[]
  }

  /**
   * Feature.persFeatures
   */
  export type Feature$persFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeature
     */
    select?: PersFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeature
     */
    omit?: PersFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatureInclude<ExtArgs> | null
    where?: PersFeatureWhereInput
    orderBy?: PersFeatureOrderByWithRelationInput | PersFeatureOrderByWithRelationInput[]
    cursor?: PersFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersFeatureScalarFieldEnum | PersFeatureScalarFieldEnum[]
  }

  /**
   * Feature without action
   */
  export type FeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
  }


  /**
   * Model ClassFeature
   */

  export type AggregateClassFeature = {
    _count: ClassFeatureCountAggregateOutputType | null
    _avg: ClassFeatureAvgAggregateOutputType | null
    _sum: ClassFeatureSumAggregateOutputType | null
    _min: ClassFeatureMinAggregateOutputType | null
    _max: ClassFeatureMaxAggregateOutputType | null
  }

  export type ClassFeatureAvgAggregateOutputType = {
    classFeatureId: number | null
    classId: number | null
    featureId: number | null
    levelGranted: number | null
  }

  export type ClassFeatureSumAggregateOutputType = {
    classFeatureId: number | null
    classId: number | null
    featureId: number | null
    levelGranted: number | null
  }

  export type ClassFeatureMinAggregateOutputType = {
    classFeatureId: number | null
    classId: number | null
    featureId: number | null
    levelGranted: number | null
    grantsSpellSlots: boolean | null
  }

  export type ClassFeatureMaxAggregateOutputType = {
    classFeatureId: number | null
    classId: number | null
    featureId: number | null
    levelGranted: number | null
    grantsSpellSlots: boolean | null
  }

  export type ClassFeatureCountAggregateOutputType = {
    classFeatureId: number
    classId: number
    featureId: number
    levelGranted: number
    grantsSpellSlots: number
    _all: number
  }


  export type ClassFeatureAvgAggregateInputType = {
    classFeatureId?: true
    classId?: true
    featureId?: true
    levelGranted?: true
  }

  export type ClassFeatureSumAggregateInputType = {
    classFeatureId?: true
    classId?: true
    featureId?: true
    levelGranted?: true
  }

  export type ClassFeatureMinAggregateInputType = {
    classFeatureId?: true
    classId?: true
    featureId?: true
    levelGranted?: true
    grantsSpellSlots?: true
  }

  export type ClassFeatureMaxAggregateInputType = {
    classFeatureId?: true
    classId?: true
    featureId?: true
    levelGranted?: true
    grantsSpellSlots?: true
  }

  export type ClassFeatureCountAggregateInputType = {
    classFeatureId?: true
    classId?: true
    featureId?: true
    levelGranted?: true
    grantsSpellSlots?: true
    _all?: true
  }

  export type ClassFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassFeature to aggregate.
     */
    where?: ClassFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassFeatures to fetch.
     */
    orderBy?: ClassFeatureOrderByWithRelationInput | ClassFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassFeatures
    **/
    _count?: true | ClassFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassFeatureMaxAggregateInputType
  }

  export type GetClassFeatureAggregateType<T extends ClassFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateClassFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassFeature[P]>
      : GetScalarType<T[P], AggregateClassFeature[P]>
  }




  export type ClassFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassFeatureWhereInput
    orderBy?: ClassFeatureOrderByWithAggregationInput | ClassFeatureOrderByWithAggregationInput[]
    by: ClassFeatureScalarFieldEnum[] | ClassFeatureScalarFieldEnum
    having?: ClassFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassFeatureCountAggregateInputType | true
    _avg?: ClassFeatureAvgAggregateInputType
    _sum?: ClassFeatureSumAggregateInputType
    _min?: ClassFeatureMinAggregateInputType
    _max?: ClassFeatureMaxAggregateInputType
  }

  export type ClassFeatureGroupByOutputType = {
    classFeatureId: number
    classId: number
    featureId: number
    levelGranted: number
    grantsSpellSlots: boolean
    _count: ClassFeatureCountAggregateOutputType | null
    _avg: ClassFeatureAvgAggregateOutputType | null
    _sum: ClassFeatureSumAggregateOutputType | null
    _min: ClassFeatureMinAggregateOutputType | null
    _max: ClassFeatureMaxAggregateOutputType | null
  }

  type GetClassFeatureGroupByPayload<T extends ClassFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], ClassFeatureGroupByOutputType[P]>
        }
      >
    >


  export type ClassFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classFeatureId?: boolean
    classId?: boolean
    featureId?: boolean
    levelGranted?: boolean
    grantsSpellSlots?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classFeature"]>

  export type ClassFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classFeatureId?: boolean
    classId?: boolean
    featureId?: boolean
    levelGranted?: boolean
    grantsSpellSlots?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classFeature"]>

  export type ClassFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classFeatureId?: boolean
    classId?: boolean
    featureId?: boolean
    levelGranted?: boolean
    grantsSpellSlots?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classFeature"]>

  export type ClassFeatureSelectScalar = {
    classFeatureId?: boolean
    classId?: boolean
    featureId?: boolean
    levelGranted?: boolean
    grantsSpellSlots?: boolean
  }

  export type ClassFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"classFeatureId" | "classId" | "featureId" | "levelGranted" | "grantsSpellSlots", ExtArgs["result"]["classFeature"]>
  export type ClassFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type ClassFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type ClassFeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $ClassFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassFeature"
    objects: {
      feature: Prisma.$FeaturePayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      classFeatureId: number
      classId: number
      featureId: number
      levelGranted: number
      grantsSpellSlots: boolean
    }, ExtArgs["result"]["classFeature"]>
    composites: {}
  }

  type ClassFeatureGetPayload<S extends boolean | null | undefined | ClassFeatureDefaultArgs> = $Result.GetResult<Prisma.$ClassFeaturePayload, S>

  type ClassFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassFeatureCountAggregateInputType | true
    }

  export interface ClassFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassFeature'], meta: { name: 'ClassFeature' } }
    /**
     * Find zero or one ClassFeature that matches the filter.
     * @param {ClassFeatureFindUniqueArgs} args - Arguments to find a ClassFeature
     * @example
     * // Get one ClassFeature
     * const classFeature = await prisma.classFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFeatureFindUniqueArgs>(args: SelectSubset<T, ClassFeatureFindUniqueArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFeatureFindUniqueOrThrowArgs} args - Arguments to find a ClassFeature
     * @example
     * // Get one ClassFeature
     * const classFeature = await prisma.classFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFeatureFindFirstArgs} args - Arguments to find a ClassFeature
     * @example
     * // Get one ClassFeature
     * const classFeature = await prisma.classFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFeatureFindFirstArgs>(args?: SelectSubset<T, ClassFeatureFindFirstArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFeatureFindFirstOrThrowArgs} args - Arguments to find a ClassFeature
     * @example
     * // Get one ClassFeature
     * const classFeature = await prisma.classFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassFeatures
     * const classFeatures = await prisma.classFeature.findMany()
     * 
     * // Get first 10 ClassFeatures
     * const classFeatures = await prisma.classFeature.findMany({ take: 10 })
     * 
     * // Only select the `classFeatureId`
     * const classFeatureWithClassFeatureIdOnly = await prisma.classFeature.findMany({ select: { classFeatureId: true } })
     * 
     */
    findMany<T extends ClassFeatureFindManyArgs>(args?: SelectSubset<T, ClassFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassFeature.
     * @param {ClassFeatureCreateArgs} args - Arguments to create a ClassFeature.
     * @example
     * // Create one ClassFeature
     * const ClassFeature = await prisma.classFeature.create({
     *   data: {
     *     // ... data to create a ClassFeature
     *   }
     * })
     * 
     */
    create<T extends ClassFeatureCreateArgs>(args: SelectSubset<T, ClassFeatureCreateArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassFeatures.
     * @param {ClassFeatureCreateManyArgs} args - Arguments to create many ClassFeatures.
     * @example
     * // Create many ClassFeatures
     * const classFeature = await prisma.classFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassFeatureCreateManyArgs>(args?: SelectSubset<T, ClassFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassFeatures and returns the data saved in the database.
     * @param {ClassFeatureCreateManyAndReturnArgs} args - Arguments to create many ClassFeatures.
     * @example
     * // Create many ClassFeatures
     * const classFeature = await prisma.classFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassFeatures and only return the `classFeatureId`
     * const classFeatureWithClassFeatureIdOnly = await prisma.classFeature.createManyAndReturn({
     *   select: { classFeatureId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClassFeature.
     * @param {ClassFeatureDeleteArgs} args - Arguments to delete one ClassFeature.
     * @example
     * // Delete one ClassFeature
     * const ClassFeature = await prisma.classFeature.delete({
     *   where: {
     *     // ... filter to delete one ClassFeature
     *   }
     * })
     * 
     */
    delete<T extends ClassFeatureDeleteArgs>(args: SelectSubset<T, ClassFeatureDeleteArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassFeature.
     * @param {ClassFeatureUpdateArgs} args - Arguments to update one ClassFeature.
     * @example
     * // Update one ClassFeature
     * const classFeature = await prisma.classFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassFeatureUpdateArgs>(args: SelectSubset<T, ClassFeatureUpdateArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassFeatures.
     * @param {ClassFeatureDeleteManyArgs} args - Arguments to filter ClassFeatures to delete.
     * @example
     * // Delete a few ClassFeatures
     * const { count } = await prisma.classFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassFeatureDeleteManyArgs>(args?: SelectSubset<T, ClassFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassFeatures
     * const classFeature = await prisma.classFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassFeatureUpdateManyArgs>(args: SelectSubset<T, ClassFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassFeatures and returns the data updated in the database.
     * @param {ClassFeatureUpdateManyAndReturnArgs} args - Arguments to update many ClassFeatures.
     * @example
     * // Update many ClassFeatures
     * const classFeature = await prisma.classFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClassFeatures and only return the `classFeatureId`
     * const classFeatureWithClassFeatureIdOnly = await prisma.classFeature.updateManyAndReturn({
     *   select: { classFeatureId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClassFeature.
     * @param {ClassFeatureUpsertArgs} args - Arguments to update or create a ClassFeature.
     * @example
     * // Update or create a ClassFeature
     * const classFeature = await prisma.classFeature.upsert({
     *   create: {
     *     // ... data to create a ClassFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassFeature we want to update
     *   }
     * })
     */
    upsert<T extends ClassFeatureUpsertArgs>(args: SelectSubset<T, ClassFeatureUpsertArgs<ExtArgs>>): Prisma__ClassFeatureClient<$Result.GetResult<Prisma.$ClassFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFeatureCountArgs} args - Arguments to filter ClassFeatures to count.
     * @example
     * // Count the number of ClassFeatures
     * const count = await prisma.classFeature.count({
     *   where: {
     *     // ... the filter for the ClassFeatures we want to count
     *   }
     * })
    **/
    count<T extends ClassFeatureCountArgs>(
      args?: Subset<T, ClassFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassFeatureAggregateArgs>(args: Subset<T, ClassFeatureAggregateArgs>): Prisma.PrismaPromise<GetClassFeatureAggregateType<T>>

    /**
     * Group by ClassFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassFeatureGroupByArgs['orderBy'] }
        : { orderBy?: ClassFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassFeature model
   */
  readonly fields: ClassFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feature<T extends FeatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureDefaultArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassFeature model
   */
  interface ClassFeatureFieldRefs {
    readonly classFeatureId: FieldRef<"ClassFeature", 'Int'>
    readonly classId: FieldRef<"ClassFeature", 'Int'>
    readonly featureId: FieldRef<"ClassFeature", 'Int'>
    readonly levelGranted: FieldRef<"ClassFeature", 'Int'>
    readonly grantsSpellSlots: FieldRef<"ClassFeature", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ClassFeature findUnique
   */
  export type ClassFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * Filter, which ClassFeature to fetch.
     */
    where: ClassFeatureWhereUniqueInput
  }

  /**
   * ClassFeature findUniqueOrThrow
   */
  export type ClassFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * Filter, which ClassFeature to fetch.
     */
    where: ClassFeatureWhereUniqueInput
  }

  /**
   * ClassFeature findFirst
   */
  export type ClassFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * Filter, which ClassFeature to fetch.
     */
    where?: ClassFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassFeatures to fetch.
     */
    orderBy?: ClassFeatureOrderByWithRelationInput | ClassFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassFeatures.
     */
    cursor?: ClassFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassFeatures.
     */
    distinct?: ClassFeatureScalarFieldEnum | ClassFeatureScalarFieldEnum[]
  }

  /**
   * ClassFeature findFirstOrThrow
   */
  export type ClassFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * Filter, which ClassFeature to fetch.
     */
    where?: ClassFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassFeatures to fetch.
     */
    orderBy?: ClassFeatureOrderByWithRelationInput | ClassFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassFeatures.
     */
    cursor?: ClassFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassFeatures.
     */
    distinct?: ClassFeatureScalarFieldEnum | ClassFeatureScalarFieldEnum[]
  }

  /**
   * ClassFeature findMany
   */
  export type ClassFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * Filter, which ClassFeatures to fetch.
     */
    where?: ClassFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassFeatures to fetch.
     */
    orderBy?: ClassFeatureOrderByWithRelationInput | ClassFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassFeatures.
     */
    cursor?: ClassFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassFeatures.
     */
    skip?: number
    distinct?: ClassFeatureScalarFieldEnum | ClassFeatureScalarFieldEnum[]
  }

  /**
   * ClassFeature create
   */
  export type ClassFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassFeature.
     */
    data: XOR<ClassFeatureCreateInput, ClassFeatureUncheckedCreateInput>
  }

  /**
   * ClassFeature createMany
   */
  export type ClassFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassFeatures.
     */
    data: ClassFeatureCreateManyInput | ClassFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassFeature createManyAndReturn
   */
  export type ClassFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many ClassFeatures.
     */
    data: ClassFeatureCreateManyInput | ClassFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassFeature update
   */
  export type ClassFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassFeature.
     */
    data: XOR<ClassFeatureUpdateInput, ClassFeatureUncheckedUpdateInput>
    /**
     * Choose, which ClassFeature to update.
     */
    where: ClassFeatureWhereUniqueInput
  }

  /**
   * ClassFeature updateMany
   */
  export type ClassFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassFeatures.
     */
    data: XOR<ClassFeatureUpdateManyMutationInput, ClassFeatureUncheckedUpdateManyInput>
    /**
     * Filter which ClassFeatures to update
     */
    where?: ClassFeatureWhereInput
    /**
     * Limit how many ClassFeatures to update.
     */
    limit?: number
  }

  /**
   * ClassFeature updateManyAndReturn
   */
  export type ClassFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * The data used to update ClassFeatures.
     */
    data: XOR<ClassFeatureUpdateManyMutationInput, ClassFeatureUncheckedUpdateManyInput>
    /**
     * Filter which ClassFeatures to update
     */
    where?: ClassFeatureWhereInput
    /**
     * Limit how many ClassFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassFeature upsert
   */
  export type ClassFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassFeature to update in case it exists.
     */
    where: ClassFeatureWhereUniqueInput
    /**
     * In case the ClassFeature found by the `where` argument doesn't exist, create a new ClassFeature with this data.
     */
    create: XOR<ClassFeatureCreateInput, ClassFeatureUncheckedCreateInput>
    /**
     * In case the ClassFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassFeatureUpdateInput, ClassFeatureUncheckedUpdateInput>
  }

  /**
   * ClassFeature delete
   */
  export type ClassFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
    /**
     * Filter which ClassFeature to delete.
     */
    where: ClassFeatureWhereUniqueInput
  }

  /**
   * ClassFeature deleteMany
   */
  export type ClassFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassFeatures to delete
     */
    where?: ClassFeatureWhereInput
    /**
     * Limit how many ClassFeatures to delete.
     */
    limit?: number
  }

  /**
   * ClassFeature without action
   */
  export type ClassFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassFeature
     */
    select?: ClassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassFeature
     */
    omit?: ClassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassFeatureInclude<ExtArgs> | null
  }


  /**
   * Model SubclassFeature
   */

  export type AggregateSubclassFeature = {
    _count: SubclassFeatureCountAggregateOutputType | null
    _avg: SubclassFeatureAvgAggregateOutputType | null
    _sum: SubclassFeatureSumAggregateOutputType | null
    _min: SubclassFeatureMinAggregateOutputType | null
    _max: SubclassFeatureMaxAggregateOutputType | null
  }

  export type SubclassFeatureAvgAggregateOutputType = {
    subclassFeatureId: number | null
    subclassId: number | null
    featureId: number | null
    levelGranted: number | null
  }

  export type SubclassFeatureSumAggregateOutputType = {
    subclassFeatureId: number | null
    subclassId: number | null
    featureId: number | null
    levelGranted: number | null
  }

  export type SubclassFeatureMinAggregateOutputType = {
    subclassFeatureId: number | null
    subclassId: number | null
    featureId: number | null
    levelGranted: number | null
    grantsSpellSlots: boolean | null
  }

  export type SubclassFeatureMaxAggregateOutputType = {
    subclassFeatureId: number | null
    subclassId: number | null
    featureId: number | null
    levelGranted: number | null
    grantsSpellSlots: boolean | null
  }

  export type SubclassFeatureCountAggregateOutputType = {
    subclassFeatureId: number
    subclassId: number
    featureId: number
    levelGranted: number
    grantsSpellSlots: number
    _all: number
  }


  export type SubclassFeatureAvgAggregateInputType = {
    subclassFeatureId?: true
    subclassId?: true
    featureId?: true
    levelGranted?: true
  }

  export type SubclassFeatureSumAggregateInputType = {
    subclassFeatureId?: true
    subclassId?: true
    featureId?: true
    levelGranted?: true
  }

  export type SubclassFeatureMinAggregateInputType = {
    subclassFeatureId?: true
    subclassId?: true
    featureId?: true
    levelGranted?: true
    grantsSpellSlots?: true
  }

  export type SubclassFeatureMaxAggregateInputType = {
    subclassFeatureId?: true
    subclassId?: true
    featureId?: true
    levelGranted?: true
    grantsSpellSlots?: true
  }

  export type SubclassFeatureCountAggregateInputType = {
    subclassFeatureId?: true
    subclassId?: true
    featureId?: true
    levelGranted?: true
    grantsSpellSlots?: true
    _all?: true
  }

  export type SubclassFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubclassFeature to aggregate.
     */
    where?: SubclassFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubclassFeatures to fetch.
     */
    orderBy?: SubclassFeatureOrderByWithRelationInput | SubclassFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubclassFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubclassFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubclassFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubclassFeatures
    **/
    _count?: true | SubclassFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubclassFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubclassFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubclassFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubclassFeatureMaxAggregateInputType
  }

  export type GetSubclassFeatureAggregateType<T extends SubclassFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateSubclassFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubclassFeature[P]>
      : GetScalarType<T[P], AggregateSubclassFeature[P]>
  }




  export type SubclassFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubclassFeatureWhereInput
    orderBy?: SubclassFeatureOrderByWithAggregationInput | SubclassFeatureOrderByWithAggregationInput[]
    by: SubclassFeatureScalarFieldEnum[] | SubclassFeatureScalarFieldEnum
    having?: SubclassFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubclassFeatureCountAggregateInputType | true
    _avg?: SubclassFeatureAvgAggregateInputType
    _sum?: SubclassFeatureSumAggregateInputType
    _min?: SubclassFeatureMinAggregateInputType
    _max?: SubclassFeatureMaxAggregateInputType
  }

  export type SubclassFeatureGroupByOutputType = {
    subclassFeatureId: number
    subclassId: number
    featureId: number
    levelGranted: number
    grantsSpellSlots: boolean
    _count: SubclassFeatureCountAggregateOutputType | null
    _avg: SubclassFeatureAvgAggregateOutputType | null
    _sum: SubclassFeatureSumAggregateOutputType | null
    _min: SubclassFeatureMinAggregateOutputType | null
    _max: SubclassFeatureMaxAggregateOutputType | null
  }

  type GetSubclassFeatureGroupByPayload<T extends SubclassFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubclassFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubclassFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubclassFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], SubclassFeatureGroupByOutputType[P]>
        }
      >
    >


  export type SubclassFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subclassFeatureId?: boolean
    subclassId?: boolean
    featureId?: boolean
    levelGranted?: boolean
    grantsSpellSlots?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    subclass?: boolean | SubclassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subclassFeature"]>

  export type SubclassFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subclassFeatureId?: boolean
    subclassId?: boolean
    featureId?: boolean
    levelGranted?: boolean
    grantsSpellSlots?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    subclass?: boolean | SubclassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subclassFeature"]>

  export type SubclassFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subclassFeatureId?: boolean
    subclassId?: boolean
    featureId?: boolean
    levelGranted?: boolean
    grantsSpellSlots?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    subclass?: boolean | SubclassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subclassFeature"]>

  export type SubclassFeatureSelectScalar = {
    subclassFeatureId?: boolean
    subclassId?: boolean
    featureId?: boolean
    levelGranted?: boolean
    grantsSpellSlots?: boolean
  }

  export type SubclassFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"subclassFeatureId" | "subclassId" | "featureId" | "levelGranted" | "grantsSpellSlots", ExtArgs["result"]["subclassFeature"]>
  export type SubclassFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    subclass?: boolean | SubclassDefaultArgs<ExtArgs>
  }
  export type SubclassFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    subclass?: boolean | SubclassDefaultArgs<ExtArgs>
  }
  export type SubclassFeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    subclass?: boolean | SubclassDefaultArgs<ExtArgs>
  }

  export type $SubclassFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubclassFeature"
    objects: {
      feature: Prisma.$FeaturePayload<ExtArgs>
      subclass: Prisma.$SubclassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      subclassFeatureId: number
      subclassId: number
      featureId: number
      levelGranted: number
      grantsSpellSlots: boolean
    }, ExtArgs["result"]["subclassFeature"]>
    composites: {}
  }

  type SubclassFeatureGetPayload<S extends boolean | null | undefined | SubclassFeatureDefaultArgs> = $Result.GetResult<Prisma.$SubclassFeaturePayload, S>

  type SubclassFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubclassFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubclassFeatureCountAggregateInputType | true
    }

  export interface SubclassFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubclassFeature'], meta: { name: 'SubclassFeature' } }
    /**
     * Find zero or one SubclassFeature that matches the filter.
     * @param {SubclassFeatureFindUniqueArgs} args - Arguments to find a SubclassFeature
     * @example
     * // Get one SubclassFeature
     * const subclassFeature = await prisma.subclassFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubclassFeatureFindUniqueArgs>(args: SelectSubset<T, SubclassFeatureFindUniqueArgs<ExtArgs>>): Prisma__SubclassFeatureClient<$Result.GetResult<Prisma.$SubclassFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubclassFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubclassFeatureFindUniqueOrThrowArgs} args - Arguments to find a SubclassFeature
     * @example
     * // Get one SubclassFeature
     * const subclassFeature = await prisma.subclassFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubclassFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, SubclassFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubclassFeatureClient<$Result.GetResult<Prisma.$SubclassFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubclassFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubclassFeatureFindFirstArgs} args - Arguments to find a SubclassFeature
     * @example
     * // Get one SubclassFeature
     * const subclassFeature = await prisma.subclassFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubclassFeatureFindFirstArgs>(args?: SelectSubset<T, SubclassFeatureFindFirstArgs<ExtArgs>>): Prisma__SubclassFeatureClient<$Result.GetResult<Prisma.$SubclassFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubclassFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubclassFeatureFindFirstOrThrowArgs} args - Arguments to find a SubclassFeature
     * @example
     * // Get one SubclassFeature
     * const subclassFeature = await prisma.subclassFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubclassFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, SubclassFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubclassFeatureClient<$Result.GetResult<Prisma.$SubclassFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubclassFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubclassFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubclassFeatures
     * const subclassFeatures = await prisma.subclassFeature.findMany()
     * 
     * // Get first 10 SubclassFeatures
     * const subclassFeatures = await prisma.subclassFeature.findMany({ take: 10 })
     * 
     * // Only select the `subclassFeatureId`
     * const subclassFeatureWithSubclassFeatureIdOnly = await prisma.subclassFeature.findMany({ select: { subclassFeatureId: true } })
     * 
     */
    findMany<T extends SubclassFeatureFindManyArgs>(args?: SelectSubset<T, SubclassFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubclassFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubclassFeature.
     * @param {SubclassFeatureCreateArgs} args - Arguments to create a SubclassFeature.
     * @example
     * // Create one SubclassFeature
     * const SubclassFeature = await prisma.subclassFeature.create({
     *   data: {
     *     // ... data to create a SubclassFeature
     *   }
     * })
     * 
     */
    create<T extends SubclassFeatureCreateArgs>(args: SelectSubset<T, SubclassFeatureCreateArgs<ExtArgs>>): Prisma__SubclassFeatureClient<$Result.GetResult<Prisma.$SubclassFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubclassFeatures.
     * @param {SubclassFeatureCreateManyArgs} args - Arguments to create many SubclassFeatures.
     * @example
     * // Create many SubclassFeatures
     * const subclassFeature = await prisma.subclassFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubclassFeatureCreateManyArgs>(args?: SelectSubset<T, SubclassFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubclassFeatures and returns the data saved in the database.
     * @param {SubclassFeatureCreateManyAndReturnArgs} args - Arguments to create many SubclassFeatures.
     * @example
     * // Create many SubclassFeatures
     * const subclassFeature = await prisma.subclassFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubclassFeatures and only return the `subclassFeatureId`
     * const subclassFeatureWithSubclassFeatureIdOnly = await prisma.subclassFeature.createManyAndReturn({
     *   select: { subclassFeatureId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubclassFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, SubclassFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubclassFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubclassFeature.
     * @param {SubclassFeatureDeleteArgs} args - Arguments to delete one SubclassFeature.
     * @example
     * // Delete one SubclassFeature
     * const SubclassFeature = await prisma.subclassFeature.delete({
     *   where: {
     *     // ... filter to delete one SubclassFeature
     *   }
     * })
     * 
     */
    delete<T extends SubclassFeatureDeleteArgs>(args: SelectSubset<T, SubclassFeatureDeleteArgs<ExtArgs>>): Prisma__SubclassFeatureClient<$Result.GetResult<Prisma.$SubclassFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubclassFeature.
     * @param {SubclassFeatureUpdateArgs} args - Arguments to update one SubclassFeature.
     * @example
     * // Update one SubclassFeature
     * const subclassFeature = await prisma.subclassFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubclassFeatureUpdateArgs>(args: SelectSubset<T, SubclassFeatureUpdateArgs<ExtArgs>>): Prisma__SubclassFeatureClient<$Result.GetResult<Prisma.$SubclassFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubclassFeatures.
     * @param {SubclassFeatureDeleteManyArgs} args - Arguments to filter SubclassFeatures to delete.
     * @example
     * // Delete a few SubclassFeatures
     * const { count } = await prisma.subclassFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubclassFeatureDeleteManyArgs>(args?: SelectSubset<T, SubclassFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubclassFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubclassFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubclassFeatures
     * const subclassFeature = await prisma.subclassFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubclassFeatureUpdateManyArgs>(args: SelectSubset<T, SubclassFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubclassFeatures and returns the data updated in the database.
     * @param {SubclassFeatureUpdateManyAndReturnArgs} args - Arguments to update many SubclassFeatures.
     * @example
     * // Update many SubclassFeatures
     * const subclassFeature = await prisma.subclassFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubclassFeatures and only return the `subclassFeatureId`
     * const subclassFeatureWithSubclassFeatureIdOnly = await prisma.subclassFeature.updateManyAndReturn({
     *   select: { subclassFeatureId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubclassFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, SubclassFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubclassFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubclassFeature.
     * @param {SubclassFeatureUpsertArgs} args - Arguments to update or create a SubclassFeature.
     * @example
     * // Update or create a SubclassFeature
     * const subclassFeature = await prisma.subclassFeature.upsert({
     *   create: {
     *     // ... data to create a SubclassFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubclassFeature we want to update
     *   }
     * })
     */
    upsert<T extends SubclassFeatureUpsertArgs>(args: SelectSubset<T, SubclassFeatureUpsertArgs<ExtArgs>>): Prisma__SubclassFeatureClient<$Result.GetResult<Prisma.$SubclassFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubclassFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubclassFeatureCountArgs} args - Arguments to filter SubclassFeatures to count.
     * @example
     * // Count the number of SubclassFeatures
     * const count = await prisma.subclassFeature.count({
     *   where: {
     *     // ... the filter for the SubclassFeatures we want to count
     *   }
     * })
    **/
    count<T extends SubclassFeatureCountArgs>(
      args?: Subset<T, SubclassFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubclassFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubclassFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubclassFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubclassFeatureAggregateArgs>(args: Subset<T, SubclassFeatureAggregateArgs>): Prisma.PrismaPromise<GetSubclassFeatureAggregateType<T>>

    /**
     * Group by SubclassFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubclassFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubclassFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubclassFeatureGroupByArgs['orderBy'] }
        : { orderBy?: SubclassFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubclassFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubclassFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubclassFeature model
   */
  readonly fields: SubclassFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubclassFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubclassFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feature<T extends FeatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureDefaultArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subclass<T extends SubclassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubclassDefaultArgs<ExtArgs>>): Prisma__SubclassClient<$Result.GetResult<Prisma.$SubclassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubclassFeature model
   */
  interface SubclassFeatureFieldRefs {
    readonly subclassFeatureId: FieldRef<"SubclassFeature", 'Int'>
    readonly subclassId: FieldRef<"SubclassFeature", 'Int'>
    readonly featureId: FieldRef<"SubclassFeature", 'Int'>
    readonly levelGranted: FieldRef<"SubclassFeature", 'Int'>
    readonly grantsSpellSlots: FieldRef<"SubclassFeature", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SubclassFeature findUnique
   */
  export type SubclassFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubclassFeature
     */
    select?: SubclassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubclassFeature
     */
    omit?: SubclassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassFeatureInclude<ExtArgs> | null
    /**
     * Filter, which SubclassFeature to fetch.
     */
    where: SubclassFeatureWhereUniqueInput
  }

  /**
   * SubclassFeature findUniqueOrThrow
   */
  export type SubclassFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubclassFeature
     */
    select?: SubclassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubclassFeature
     */
    omit?: SubclassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassFeatureInclude<ExtArgs> | null
    /**
     * Filter, which SubclassFeature to fetch.
     */
    where: SubclassFeatureWhereUniqueInput
  }

  /**
   * SubclassFeature findFirst
   */
  export type SubclassFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubclassFeature
     */
    select?: SubclassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubclassFeature
     */
    omit?: SubclassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassFeatureInclude<ExtArgs> | null
    /**
     * Filter, which SubclassFeature to fetch.
     */
    where?: SubclassFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubclassFeatures to fetch.
     */
    orderBy?: SubclassFeatureOrderByWithRelationInput | SubclassFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubclassFeatures.
     */
    cursor?: SubclassFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubclassFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubclassFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubclassFeatures.
     */
    distinct?: SubclassFeatureScalarFieldEnum | SubclassFeatureScalarFieldEnum[]
  }

  /**
   * SubclassFeature findFirstOrThrow
   */
  export type SubclassFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubclassFeature
     */
    select?: SubclassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubclassFeature
     */
    omit?: SubclassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassFeatureInclude<ExtArgs> | null
    /**
     * Filter, which SubclassFeature to fetch.
     */
    where?: SubclassFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubclassFeatures to fetch.
     */
    orderBy?: SubclassFeatureOrderByWithRelationInput | SubclassFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubclassFeatures.
     */
    cursor?: SubclassFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubclassFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubclassFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubclassFeatures.
     */
    distinct?: SubclassFeatureScalarFieldEnum | SubclassFeatureScalarFieldEnum[]
  }

  /**
   * SubclassFeature findMany
   */
  export type SubclassFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubclassFeature
     */
    select?: SubclassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubclassFeature
     */
    omit?: SubclassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassFeatureInclude<ExtArgs> | null
    /**
     * Filter, which SubclassFeatures to fetch.
     */
    where?: SubclassFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubclassFeatures to fetch.
     */
    orderBy?: SubclassFeatureOrderByWithRelationInput | SubclassFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubclassFeatures.
     */
    cursor?: SubclassFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubclassFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubclassFeatures.
     */
    skip?: number
    distinct?: SubclassFeatureScalarFieldEnum | SubclassFeatureScalarFieldEnum[]
  }

  /**
   * SubclassFeature create
   */
  export type SubclassFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubclassFeature
     */
    select?: SubclassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubclassFeature
     */
    omit?: SubclassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a SubclassFeature.
     */
    data: XOR<SubclassFeatureCreateInput, SubclassFeatureUncheckedCreateInput>
  }

  /**
   * SubclassFeature createMany
   */
  export type SubclassFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubclassFeatures.
     */
    data: SubclassFeatureCreateManyInput | SubclassFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubclassFeature createManyAndReturn
   */
  export type SubclassFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubclassFeature
     */
    select?: SubclassFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubclassFeature
     */
    omit?: SubclassFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many SubclassFeatures.
     */
    data: SubclassFeatureCreateManyInput | SubclassFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubclassFeature update
   */
  export type SubclassFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubclassFeature
     */
    select?: SubclassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubclassFeature
     */
    omit?: SubclassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a SubclassFeature.
     */
    data: XOR<SubclassFeatureUpdateInput, SubclassFeatureUncheckedUpdateInput>
    /**
     * Choose, which SubclassFeature to update.
     */
    where: SubclassFeatureWhereUniqueInput
  }

  /**
   * SubclassFeature updateMany
   */
  export type SubclassFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubclassFeatures.
     */
    data: XOR<SubclassFeatureUpdateManyMutationInput, SubclassFeatureUncheckedUpdateManyInput>
    /**
     * Filter which SubclassFeatures to update
     */
    where?: SubclassFeatureWhereInput
    /**
     * Limit how many SubclassFeatures to update.
     */
    limit?: number
  }

  /**
   * SubclassFeature updateManyAndReturn
   */
  export type SubclassFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubclassFeature
     */
    select?: SubclassFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubclassFeature
     */
    omit?: SubclassFeatureOmit<ExtArgs> | null
    /**
     * The data used to update SubclassFeatures.
     */
    data: XOR<SubclassFeatureUpdateManyMutationInput, SubclassFeatureUncheckedUpdateManyInput>
    /**
     * Filter which SubclassFeatures to update
     */
    where?: SubclassFeatureWhereInput
    /**
     * Limit how many SubclassFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassFeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubclassFeature upsert
   */
  export type SubclassFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubclassFeature
     */
    select?: SubclassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubclassFeature
     */
    omit?: SubclassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the SubclassFeature to update in case it exists.
     */
    where: SubclassFeatureWhereUniqueInput
    /**
     * In case the SubclassFeature found by the `where` argument doesn't exist, create a new SubclassFeature with this data.
     */
    create: XOR<SubclassFeatureCreateInput, SubclassFeatureUncheckedCreateInput>
    /**
     * In case the SubclassFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubclassFeatureUpdateInput, SubclassFeatureUncheckedUpdateInput>
  }

  /**
   * SubclassFeature delete
   */
  export type SubclassFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubclassFeature
     */
    select?: SubclassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubclassFeature
     */
    omit?: SubclassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassFeatureInclude<ExtArgs> | null
    /**
     * Filter which SubclassFeature to delete.
     */
    where: SubclassFeatureWhereUniqueInput
  }

  /**
   * SubclassFeature deleteMany
   */
  export type SubclassFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubclassFeatures to delete
     */
    where?: SubclassFeatureWhereInput
    /**
     * Limit how many SubclassFeatures to delete.
     */
    limit?: number
  }

  /**
   * SubclassFeature without action
   */
  export type SubclassFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubclassFeature
     */
    select?: SubclassFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubclassFeature
     */
    omit?: SubclassFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubclassFeatureInclude<ExtArgs> | null
  }


  /**
   * Model RaceTrait
   */

  export type AggregateRaceTrait = {
    _count: RaceTraitCountAggregateOutputType | null
    _avg: RaceTraitAvgAggregateOutputType | null
    _sum: RaceTraitSumAggregateOutputType | null
    _min: RaceTraitMinAggregateOutputType | null
    _max: RaceTraitMaxAggregateOutputType | null
  }

  export type RaceTraitAvgAggregateOutputType = {
    raceTraitId: number | null
    raceId: number | null
    featureId: number | null
  }

  export type RaceTraitSumAggregateOutputType = {
    raceTraitId: number | null
    raceId: number | null
    featureId: number | null
  }

  export type RaceTraitMinAggregateOutputType = {
    raceTraitId: number | null
    raceId: number | null
    featureId: number | null
  }

  export type RaceTraitMaxAggregateOutputType = {
    raceTraitId: number | null
    raceId: number | null
    featureId: number | null
  }

  export type RaceTraitCountAggregateOutputType = {
    raceTraitId: number
    raceId: number
    featureId: number
    _all: number
  }


  export type RaceTraitAvgAggregateInputType = {
    raceTraitId?: true
    raceId?: true
    featureId?: true
  }

  export type RaceTraitSumAggregateInputType = {
    raceTraitId?: true
    raceId?: true
    featureId?: true
  }

  export type RaceTraitMinAggregateInputType = {
    raceTraitId?: true
    raceId?: true
    featureId?: true
  }

  export type RaceTraitMaxAggregateInputType = {
    raceTraitId?: true
    raceId?: true
    featureId?: true
  }

  export type RaceTraitCountAggregateInputType = {
    raceTraitId?: true
    raceId?: true
    featureId?: true
    _all?: true
  }

  export type RaceTraitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceTrait to aggregate.
     */
    where?: RaceTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceTraits to fetch.
     */
    orderBy?: RaceTraitOrderByWithRelationInput | RaceTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaceTraits
    **/
    _count?: true | RaceTraitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceTraitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceTraitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceTraitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceTraitMaxAggregateInputType
  }

  export type GetRaceTraitAggregateType<T extends RaceTraitAggregateArgs> = {
        [P in keyof T & keyof AggregateRaceTrait]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaceTrait[P]>
      : GetScalarType<T[P], AggregateRaceTrait[P]>
  }




  export type RaceTraitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceTraitWhereInput
    orderBy?: RaceTraitOrderByWithAggregationInput | RaceTraitOrderByWithAggregationInput[]
    by: RaceTraitScalarFieldEnum[] | RaceTraitScalarFieldEnum
    having?: RaceTraitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceTraitCountAggregateInputType | true
    _avg?: RaceTraitAvgAggregateInputType
    _sum?: RaceTraitSumAggregateInputType
    _min?: RaceTraitMinAggregateInputType
    _max?: RaceTraitMaxAggregateInputType
  }

  export type RaceTraitGroupByOutputType = {
    raceTraitId: number
    raceId: number
    featureId: number
    _count: RaceTraitCountAggregateOutputType | null
    _avg: RaceTraitAvgAggregateOutputType | null
    _sum: RaceTraitSumAggregateOutputType | null
    _min: RaceTraitMinAggregateOutputType | null
    _max: RaceTraitMaxAggregateOutputType | null
  }

  type GetRaceTraitGroupByPayload<T extends RaceTraitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceTraitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceTraitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceTraitGroupByOutputType[P]>
            : GetScalarType<T[P], RaceTraitGroupByOutputType[P]>
        }
      >
    >


  export type RaceTraitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceTraitId?: boolean
    raceId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    subraces?: boolean | RaceTrait$subracesArgs<ExtArgs>
    raceVariants?: boolean | RaceTrait$raceVariantsArgs<ExtArgs>
    _count?: boolean | RaceTraitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceTrait"]>

  export type RaceTraitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceTraitId?: boolean
    raceId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceTrait"]>

  export type RaceTraitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceTraitId?: boolean
    raceId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceTrait"]>

  export type RaceTraitSelectScalar = {
    raceTraitId?: boolean
    raceId?: boolean
    featureId?: boolean
  }

  export type RaceTraitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"raceTraitId" | "raceId" | "featureId", ExtArgs["result"]["raceTrait"]>
  export type RaceTraitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    subraces?: boolean | RaceTrait$subracesArgs<ExtArgs>
    raceVariants?: boolean | RaceTrait$raceVariantsArgs<ExtArgs>
    _count?: boolean | RaceTraitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RaceTraitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }
  export type RaceTraitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }

  export type $RaceTraitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaceTrait"
    objects: {
      feature: Prisma.$FeaturePayload<ExtArgs>
      race: Prisma.$RacePayload<ExtArgs>
      subraces: Prisma.$SubracePayload<ExtArgs>[]
      raceVariants: Prisma.$RaceVariantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      raceTraitId: number
      raceId: number
      featureId: number
    }, ExtArgs["result"]["raceTrait"]>
    composites: {}
  }

  type RaceTraitGetPayload<S extends boolean | null | undefined | RaceTraitDefaultArgs> = $Result.GetResult<Prisma.$RaceTraitPayload, S>

  type RaceTraitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceTraitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceTraitCountAggregateInputType | true
    }

  export interface RaceTraitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaceTrait'], meta: { name: 'RaceTrait' } }
    /**
     * Find zero or one RaceTrait that matches the filter.
     * @param {RaceTraitFindUniqueArgs} args - Arguments to find a RaceTrait
     * @example
     * // Get one RaceTrait
     * const raceTrait = await prisma.raceTrait.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceTraitFindUniqueArgs>(args: SelectSubset<T, RaceTraitFindUniqueArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RaceTrait that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceTraitFindUniqueOrThrowArgs} args - Arguments to find a RaceTrait
     * @example
     * // Get one RaceTrait
     * const raceTrait = await prisma.raceTrait.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceTraitFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceTraitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceTrait that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitFindFirstArgs} args - Arguments to find a RaceTrait
     * @example
     * // Get one RaceTrait
     * const raceTrait = await prisma.raceTrait.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceTraitFindFirstArgs>(args?: SelectSubset<T, RaceTraitFindFirstArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceTrait that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitFindFirstOrThrowArgs} args - Arguments to find a RaceTrait
     * @example
     * // Get one RaceTrait
     * const raceTrait = await prisma.raceTrait.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceTraitFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceTraitFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RaceTraits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaceTraits
     * const raceTraits = await prisma.raceTrait.findMany()
     * 
     * // Get first 10 RaceTraits
     * const raceTraits = await prisma.raceTrait.findMany({ take: 10 })
     * 
     * // Only select the `raceTraitId`
     * const raceTraitWithRaceTraitIdOnly = await prisma.raceTrait.findMany({ select: { raceTraitId: true } })
     * 
     */
    findMany<T extends RaceTraitFindManyArgs>(args?: SelectSubset<T, RaceTraitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RaceTrait.
     * @param {RaceTraitCreateArgs} args - Arguments to create a RaceTrait.
     * @example
     * // Create one RaceTrait
     * const RaceTrait = await prisma.raceTrait.create({
     *   data: {
     *     // ... data to create a RaceTrait
     *   }
     * })
     * 
     */
    create<T extends RaceTraitCreateArgs>(args: SelectSubset<T, RaceTraitCreateArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RaceTraits.
     * @param {RaceTraitCreateManyArgs} args - Arguments to create many RaceTraits.
     * @example
     * // Create many RaceTraits
     * const raceTrait = await prisma.raceTrait.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceTraitCreateManyArgs>(args?: SelectSubset<T, RaceTraitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RaceTraits and returns the data saved in the database.
     * @param {RaceTraitCreateManyAndReturnArgs} args - Arguments to create many RaceTraits.
     * @example
     * // Create many RaceTraits
     * const raceTrait = await prisma.raceTrait.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RaceTraits and only return the `raceTraitId`
     * const raceTraitWithRaceTraitIdOnly = await prisma.raceTrait.createManyAndReturn({
     *   select: { raceTraitId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaceTraitCreateManyAndReturnArgs>(args?: SelectSubset<T, RaceTraitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RaceTrait.
     * @param {RaceTraitDeleteArgs} args - Arguments to delete one RaceTrait.
     * @example
     * // Delete one RaceTrait
     * const RaceTrait = await prisma.raceTrait.delete({
     *   where: {
     *     // ... filter to delete one RaceTrait
     *   }
     * })
     * 
     */
    delete<T extends RaceTraitDeleteArgs>(args: SelectSubset<T, RaceTraitDeleteArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RaceTrait.
     * @param {RaceTraitUpdateArgs} args - Arguments to update one RaceTrait.
     * @example
     * // Update one RaceTrait
     * const raceTrait = await prisma.raceTrait.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceTraitUpdateArgs>(args: SelectSubset<T, RaceTraitUpdateArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RaceTraits.
     * @param {RaceTraitDeleteManyArgs} args - Arguments to filter RaceTraits to delete.
     * @example
     * // Delete a few RaceTraits
     * const { count } = await prisma.raceTrait.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceTraitDeleteManyArgs>(args?: SelectSubset<T, RaceTraitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaceTraits
     * const raceTrait = await prisma.raceTrait.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceTraitUpdateManyArgs>(args: SelectSubset<T, RaceTraitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceTraits and returns the data updated in the database.
     * @param {RaceTraitUpdateManyAndReturnArgs} args - Arguments to update many RaceTraits.
     * @example
     * // Update many RaceTraits
     * const raceTrait = await prisma.raceTrait.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RaceTraits and only return the `raceTraitId`
     * const raceTraitWithRaceTraitIdOnly = await prisma.raceTrait.updateManyAndReturn({
     *   select: { raceTraitId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaceTraitUpdateManyAndReturnArgs>(args: SelectSubset<T, RaceTraitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RaceTrait.
     * @param {RaceTraitUpsertArgs} args - Arguments to update or create a RaceTrait.
     * @example
     * // Update or create a RaceTrait
     * const raceTrait = await prisma.raceTrait.upsert({
     *   create: {
     *     // ... data to create a RaceTrait
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaceTrait we want to update
     *   }
     * })
     */
    upsert<T extends RaceTraitUpsertArgs>(args: SelectSubset<T, RaceTraitUpsertArgs<ExtArgs>>): Prisma__RaceTraitClient<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RaceTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitCountArgs} args - Arguments to filter RaceTraits to count.
     * @example
     * // Count the number of RaceTraits
     * const count = await prisma.raceTrait.count({
     *   where: {
     *     // ... the filter for the RaceTraits we want to count
     *   }
     * })
    **/
    count<T extends RaceTraitCountArgs>(
      args?: Subset<T, RaceTraitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceTraitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaceTrait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceTraitAggregateArgs>(args: Subset<T, RaceTraitAggregateArgs>): Prisma.PrismaPromise<GetRaceTraitAggregateType<T>>

    /**
     * Group by RaceTrait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceTraitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceTraitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceTraitGroupByArgs['orderBy'] }
        : { orderBy?: RaceTraitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceTraitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceTraitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaceTrait model
   */
  readonly fields: RaceTraitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaceTrait.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceTraitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feature<T extends FeatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureDefaultArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    race<T extends RaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceDefaultArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subraces<T extends RaceTrait$subracesArgs<ExtArgs> = {}>(args?: Subset<T, RaceTrait$subracesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    raceVariants<T extends RaceTrait$raceVariantsArgs<ExtArgs> = {}>(args?: Subset<T, RaceTrait$raceVariantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RaceTrait model
   */
  interface RaceTraitFieldRefs {
    readonly raceTraitId: FieldRef<"RaceTrait", 'Int'>
    readonly raceId: FieldRef<"RaceTrait", 'Int'>
    readonly featureId: FieldRef<"RaceTrait", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RaceTrait findUnique
   */
  export type RaceTraitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceTrait to fetch.
     */
    where: RaceTraitWhereUniqueInput
  }

  /**
   * RaceTrait findUniqueOrThrow
   */
  export type RaceTraitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceTrait to fetch.
     */
    where: RaceTraitWhereUniqueInput
  }

  /**
   * RaceTrait findFirst
   */
  export type RaceTraitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceTrait to fetch.
     */
    where?: RaceTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceTraits to fetch.
     */
    orderBy?: RaceTraitOrderByWithRelationInput | RaceTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceTraits.
     */
    cursor?: RaceTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceTraits.
     */
    distinct?: RaceTraitScalarFieldEnum | RaceTraitScalarFieldEnum[]
  }

  /**
   * RaceTrait findFirstOrThrow
   */
  export type RaceTraitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceTrait to fetch.
     */
    where?: RaceTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceTraits to fetch.
     */
    orderBy?: RaceTraitOrderByWithRelationInput | RaceTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceTraits.
     */
    cursor?: RaceTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceTraits.
     */
    distinct?: RaceTraitScalarFieldEnum | RaceTraitScalarFieldEnum[]
  }

  /**
   * RaceTrait findMany
   */
  export type RaceTraitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceTraits to fetch.
     */
    where?: RaceTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceTraits to fetch.
     */
    orderBy?: RaceTraitOrderByWithRelationInput | RaceTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaceTraits.
     */
    cursor?: RaceTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceTraits.
     */
    skip?: number
    distinct?: RaceTraitScalarFieldEnum | RaceTraitScalarFieldEnum[]
  }

  /**
   * RaceTrait create
   */
  export type RaceTraitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * The data needed to create a RaceTrait.
     */
    data: XOR<RaceTraitCreateInput, RaceTraitUncheckedCreateInput>
  }

  /**
   * RaceTrait createMany
   */
  export type RaceTraitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaceTraits.
     */
    data: RaceTraitCreateManyInput | RaceTraitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RaceTrait createManyAndReturn
   */
  export type RaceTraitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * The data used to create many RaceTraits.
     */
    data: RaceTraitCreateManyInput | RaceTraitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaceTrait update
   */
  export type RaceTraitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * The data needed to update a RaceTrait.
     */
    data: XOR<RaceTraitUpdateInput, RaceTraitUncheckedUpdateInput>
    /**
     * Choose, which RaceTrait to update.
     */
    where: RaceTraitWhereUniqueInput
  }

  /**
   * RaceTrait updateMany
   */
  export type RaceTraitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaceTraits.
     */
    data: XOR<RaceTraitUpdateManyMutationInput, RaceTraitUncheckedUpdateManyInput>
    /**
     * Filter which RaceTraits to update
     */
    where?: RaceTraitWhereInput
    /**
     * Limit how many RaceTraits to update.
     */
    limit?: number
  }

  /**
   * RaceTrait updateManyAndReturn
   */
  export type RaceTraitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * The data used to update RaceTraits.
     */
    data: XOR<RaceTraitUpdateManyMutationInput, RaceTraitUncheckedUpdateManyInput>
    /**
     * Filter which RaceTraits to update
     */
    where?: RaceTraitWhereInput
    /**
     * Limit how many RaceTraits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaceTrait upsert
   */
  export type RaceTraitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * The filter to search for the RaceTrait to update in case it exists.
     */
    where: RaceTraitWhereUniqueInput
    /**
     * In case the RaceTrait found by the `where` argument doesn't exist, create a new RaceTrait with this data.
     */
    create: XOR<RaceTraitCreateInput, RaceTraitUncheckedCreateInput>
    /**
     * In case the RaceTrait was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceTraitUpdateInput, RaceTraitUncheckedUpdateInput>
  }

  /**
   * RaceTrait delete
   */
  export type RaceTraitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    /**
     * Filter which RaceTrait to delete.
     */
    where: RaceTraitWhereUniqueInput
  }

  /**
   * RaceTrait deleteMany
   */
  export type RaceTraitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceTraits to delete
     */
    where?: RaceTraitWhereInput
    /**
     * Limit how many RaceTraits to delete.
     */
    limit?: number
  }

  /**
   * RaceTrait.subraces
   */
  export type RaceTrait$subracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceInclude<ExtArgs> | null
    where?: SubraceWhereInput
    orderBy?: SubraceOrderByWithRelationInput | SubraceOrderByWithRelationInput[]
    cursor?: SubraceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubraceScalarFieldEnum | SubraceScalarFieldEnum[]
  }

  /**
   * RaceTrait.raceVariants
   */
  export type RaceTrait$raceVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariant
     */
    select?: RaceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariant
     */
    omit?: RaceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantInclude<ExtArgs> | null
    where?: RaceVariantWhereInput
    orderBy?: RaceVariantOrderByWithRelationInput | RaceVariantOrderByWithRelationInput[]
    cursor?: RaceVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceVariantScalarFieldEnum | RaceVariantScalarFieldEnum[]
  }

  /**
   * RaceTrait without action
   */
  export type RaceTraitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
  }


  /**
   * Model SubraceTrait
   */

  export type AggregateSubraceTrait = {
    _count: SubraceTraitCountAggregateOutputType | null
    _avg: SubraceTraitAvgAggregateOutputType | null
    _sum: SubraceTraitSumAggregateOutputType | null
    _min: SubraceTraitMinAggregateOutputType | null
    _max: SubraceTraitMaxAggregateOutputType | null
  }

  export type SubraceTraitAvgAggregateOutputType = {
    subraceTraitId: number | null
    subraceId: number | null
    featureId: number | null
  }

  export type SubraceTraitSumAggregateOutputType = {
    subraceTraitId: number | null
    subraceId: number | null
    featureId: number | null
  }

  export type SubraceTraitMinAggregateOutputType = {
    subraceTraitId: number | null
    subraceId: number | null
    featureId: number | null
  }

  export type SubraceTraitMaxAggregateOutputType = {
    subraceTraitId: number | null
    subraceId: number | null
    featureId: number | null
  }

  export type SubraceTraitCountAggregateOutputType = {
    subraceTraitId: number
    subraceId: number
    featureId: number
    _all: number
  }


  export type SubraceTraitAvgAggregateInputType = {
    subraceTraitId?: true
    subraceId?: true
    featureId?: true
  }

  export type SubraceTraitSumAggregateInputType = {
    subraceTraitId?: true
    subraceId?: true
    featureId?: true
  }

  export type SubraceTraitMinAggregateInputType = {
    subraceTraitId?: true
    subraceId?: true
    featureId?: true
  }

  export type SubraceTraitMaxAggregateInputType = {
    subraceTraitId?: true
    subraceId?: true
    featureId?: true
  }

  export type SubraceTraitCountAggregateInputType = {
    subraceTraitId?: true
    subraceId?: true
    featureId?: true
    _all?: true
  }

  export type SubraceTraitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubraceTrait to aggregate.
     */
    where?: SubraceTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubraceTraits to fetch.
     */
    orderBy?: SubraceTraitOrderByWithRelationInput | SubraceTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubraceTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubraceTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubraceTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubraceTraits
    **/
    _count?: true | SubraceTraitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubraceTraitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubraceTraitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubraceTraitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubraceTraitMaxAggregateInputType
  }

  export type GetSubraceTraitAggregateType<T extends SubraceTraitAggregateArgs> = {
        [P in keyof T & keyof AggregateSubraceTrait]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubraceTrait[P]>
      : GetScalarType<T[P], AggregateSubraceTrait[P]>
  }




  export type SubraceTraitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubraceTraitWhereInput
    orderBy?: SubraceTraitOrderByWithAggregationInput | SubraceTraitOrderByWithAggregationInput[]
    by: SubraceTraitScalarFieldEnum[] | SubraceTraitScalarFieldEnum
    having?: SubraceTraitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubraceTraitCountAggregateInputType | true
    _avg?: SubraceTraitAvgAggregateInputType
    _sum?: SubraceTraitSumAggregateInputType
    _min?: SubraceTraitMinAggregateInputType
    _max?: SubraceTraitMaxAggregateInputType
  }

  export type SubraceTraitGroupByOutputType = {
    subraceTraitId: number
    subraceId: number
    featureId: number
    _count: SubraceTraitCountAggregateOutputType | null
    _avg: SubraceTraitAvgAggregateOutputType | null
    _sum: SubraceTraitSumAggregateOutputType | null
    _min: SubraceTraitMinAggregateOutputType | null
    _max: SubraceTraitMaxAggregateOutputType | null
  }

  type GetSubraceTraitGroupByPayload<T extends SubraceTraitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubraceTraitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubraceTraitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubraceTraitGroupByOutputType[P]>
            : GetScalarType<T[P], SubraceTraitGroupByOutputType[P]>
        }
      >
    >


  export type SubraceTraitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subraceTraitId?: boolean
    subraceId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    subrace?: boolean | SubraceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subraceTrait"]>

  export type SubraceTraitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subraceTraitId?: boolean
    subraceId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    subrace?: boolean | SubraceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subraceTrait"]>

  export type SubraceTraitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subraceTraitId?: boolean
    subraceId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    subrace?: boolean | SubraceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subraceTrait"]>

  export type SubraceTraitSelectScalar = {
    subraceTraitId?: boolean
    subraceId?: boolean
    featureId?: boolean
  }

  export type SubraceTraitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"subraceTraitId" | "subraceId" | "featureId", ExtArgs["result"]["subraceTrait"]>
  export type SubraceTraitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    subrace?: boolean | SubraceDefaultArgs<ExtArgs>
  }
  export type SubraceTraitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    subrace?: boolean | SubraceDefaultArgs<ExtArgs>
  }
  export type SubraceTraitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    subrace?: boolean | SubraceDefaultArgs<ExtArgs>
  }

  export type $SubraceTraitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubraceTrait"
    objects: {
      feature: Prisma.$FeaturePayload<ExtArgs>
      subrace: Prisma.$SubracePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      subraceTraitId: number
      subraceId: number
      featureId: number
    }, ExtArgs["result"]["subraceTrait"]>
    composites: {}
  }

  type SubraceTraitGetPayload<S extends boolean | null | undefined | SubraceTraitDefaultArgs> = $Result.GetResult<Prisma.$SubraceTraitPayload, S>

  type SubraceTraitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubraceTraitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubraceTraitCountAggregateInputType | true
    }

  export interface SubraceTraitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubraceTrait'], meta: { name: 'SubraceTrait' } }
    /**
     * Find zero or one SubraceTrait that matches the filter.
     * @param {SubraceTraitFindUniqueArgs} args - Arguments to find a SubraceTrait
     * @example
     * // Get one SubraceTrait
     * const subraceTrait = await prisma.subraceTrait.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubraceTraitFindUniqueArgs>(args: SelectSubset<T, SubraceTraitFindUniqueArgs<ExtArgs>>): Prisma__SubraceTraitClient<$Result.GetResult<Prisma.$SubraceTraitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubraceTrait that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubraceTraitFindUniqueOrThrowArgs} args - Arguments to find a SubraceTrait
     * @example
     * // Get one SubraceTrait
     * const subraceTrait = await prisma.subraceTrait.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubraceTraitFindUniqueOrThrowArgs>(args: SelectSubset<T, SubraceTraitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubraceTraitClient<$Result.GetResult<Prisma.$SubraceTraitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubraceTrait that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubraceTraitFindFirstArgs} args - Arguments to find a SubraceTrait
     * @example
     * // Get one SubraceTrait
     * const subraceTrait = await prisma.subraceTrait.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubraceTraitFindFirstArgs>(args?: SelectSubset<T, SubraceTraitFindFirstArgs<ExtArgs>>): Prisma__SubraceTraitClient<$Result.GetResult<Prisma.$SubraceTraitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubraceTrait that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubraceTraitFindFirstOrThrowArgs} args - Arguments to find a SubraceTrait
     * @example
     * // Get one SubraceTrait
     * const subraceTrait = await prisma.subraceTrait.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubraceTraitFindFirstOrThrowArgs>(args?: SelectSubset<T, SubraceTraitFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubraceTraitClient<$Result.GetResult<Prisma.$SubraceTraitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubraceTraits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubraceTraitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubraceTraits
     * const subraceTraits = await prisma.subraceTrait.findMany()
     * 
     * // Get first 10 SubraceTraits
     * const subraceTraits = await prisma.subraceTrait.findMany({ take: 10 })
     * 
     * // Only select the `subraceTraitId`
     * const subraceTraitWithSubraceTraitIdOnly = await prisma.subraceTrait.findMany({ select: { subraceTraitId: true } })
     * 
     */
    findMany<T extends SubraceTraitFindManyArgs>(args?: SelectSubset<T, SubraceTraitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubraceTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubraceTrait.
     * @param {SubraceTraitCreateArgs} args - Arguments to create a SubraceTrait.
     * @example
     * // Create one SubraceTrait
     * const SubraceTrait = await prisma.subraceTrait.create({
     *   data: {
     *     // ... data to create a SubraceTrait
     *   }
     * })
     * 
     */
    create<T extends SubraceTraitCreateArgs>(args: SelectSubset<T, SubraceTraitCreateArgs<ExtArgs>>): Prisma__SubraceTraitClient<$Result.GetResult<Prisma.$SubraceTraitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubraceTraits.
     * @param {SubraceTraitCreateManyArgs} args - Arguments to create many SubraceTraits.
     * @example
     * // Create many SubraceTraits
     * const subraceTrait = await prisma.subraceTrait.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubraceTraitCreateManyArgs>(args?: SelectSubset<T, SubraceTraitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubraceTraits and returns the data saved in the database.
     * @param {SubraceTraitCreateManyAndReturnArgs} args - Arguments to create many SubraceTraits.
     * @example
     * // Create many SubraceTraits
     * const subraceTrait = await prisma.subraceTrait.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubraceTraits and only return the `subraceTraitId`
     * const subraceTraitWithSubraceTraitIdOnly = await prisma.subraceTrait.createManyAndReturn({
     *   select: { subraceTraitId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubraceTraitCreateManyAndReturnArgs>(args?: SelectSubset<T, SubraceTraitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubraceTraitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubraceTrait.
     * @param {SubraceTraitDeleteArgs} args - Arguments to delete one SubraceTrait.
     * @example
     * // Delete one SubraceTrait
     * const SubraceTrait = await prisma.subraceTrait.delete({
     *   where: {
     *     // ... filter to delete one SubraceTrait
     *   }
     * })
     * 
     */
    delete<T extends SubraceTraitDeleteArgs>(args: SelectSubset<T, SubraceTraitDeleteArgs<ExtArgs>>): Prisma__SubraceTraitClient<$Result.GetResult<Prisma.$SubraceTraitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubraceTrait.
     * @param {SubraceTraitUpdateArgs} args - Arguments to update one SubraceTrait.
     * @example
     * // Update one SubraceTrait
     * const subraceTrait = await prisma.subraceTrait.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubraceTraitUpdateArgs>(args: SelectSubset<T, SubraceTraitUpdateArgs<ExtArgs>>): Prisma__SubraceTraitClient<$Result.GetResult<Prisma.$SubraceTraitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubraceTraits.
     * @param {SubraceTraitDeleteManyArgs} args - Arguments to filter SubraceTraits to delete.
     * @example
     * // Delete a few SubraceTraits
     * const { count } = await prisma.subraceTrait.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubraceTraitDeleteManyArgs>(args?: SelectSubset<T, SubraceTraitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubraceTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubraceTraitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubraceTraits
     * const subraceTrait = await prisma.subraceTrait.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubraceTraitUpdateManyArgs>(args: SelectSubset<T, SubraceTraitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubraceTraits and returns the data updated in the database.
     * @param {SubraceTraitUpdateManyAndReturnArgs} args - Arguments to update many SubraceTraits.
     * @example
     * // Update many SubraceTraits
     * const subraceTrait = await prisma.subraceTrait.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubraceTraits and only return the `subraceTraitId`
     * const subraceTraitWithSubraceTraitIdOnly = await prisma.subraceTrait.updateManyAndReturn({
     *   select: { subraceTraitId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubraceTraitUpdateManyAndReturnArgs>(args: SelectSubset<T, SubraceTraitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubraceTraitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubraceTrait.
     * @param {SubraceTraitUpsertArgs} args - Arguments to update or create a SubraceTrait.
     * @example
     * // Update or create a SubraceTrait
     * const subraceTrait = await prisma.subraceTrait.upsert({
     *   create: {
     *     // ... data to create a SubraceTrait
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubraceTrait we want to update
     *   }
     * })
     */
    upsert<T extends SubraceTraitUpsertArgs>(args: SelectSubset<T, SubraceTraitUpsertArgs<ExtArgs>>): Prisma__SubraceTraitClient<$Result.GetResult<Prisma.$SubraceTraitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubraceTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubraceTraitCountArgs} args - Arguments to filter SubraceTraits to count.
     * @example
     * // Count the number of SubraceTraits
     * const count = await prisma.subraceTrait.count({
     *   where: {
     *     // ... the filter for the SubraceTraits we want to count
     *   }
     * })
    **/
    count<T extends SubraceTraitCountArgs>(
      args?: Subset<T, SubraceTraitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubraceTraitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubraceTrait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubraceTraitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubraceTraitAggregateArgs>(args: Subset<T, SubraceTraitAggregateArgs>): Prisma.PrismaPromise<GetSubraceTraitAggregateType<T>>

    /**
     * Group by SubraceTrait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubraceTraitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubraceTraitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubraceTraitGroupByArgs['orderBy'] }
        : { orderBy?: SubraceTraitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubraceTraitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubraceTraitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubraceTrait model
   */
  readonly fields: SubraceTraitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubraceTrait.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubraceTraitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feature<T extends FeatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureDefaultArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subrace<T extends SubraceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubraceDefaultArgs<ExtArgs>>): Prisma__SubraceClient<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubraceTrait model
   */
  interface SubraceTraitFieldRefs {
    readonly subraceTraitId: FieldRef<"SubraceTrait", 'Int'>
    readonly subraceId: FieldRef<"SubraceTrait", 'Int'>
    readonly featureId: FieldRef<"SubraceTrait", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SubraceTrait findUnique
   */
  export type SubraceTraitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubraceTrait
     */
    select?: SubraceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubraceTrait
     */
    omit?: SubraceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceTraitInclude<ExtArgs> | null
    /**
     * Filter, which SubraceTrait to fetch.
     */
    where: SubraceTraitWhereUniqueInput
  }

  /**
   * SubraceTrait findUniqueOrThrow
   */
  export type SubraceTraitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubraceTrait
     */
    select?: SubraceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubraceTrait
     */
    omit?: SubraceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceTraitInclude<ExtArgs> | null
    /**
     * Filter, which SubraceTrait to fetch.
     */
    where: SubraceTraitWhereUniqueInput
  }

  /**
   * SubraceTrait findFirst
   */
  export type SubraceTraitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubraceTrait
     */
    select?: SubraceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubraceTrait
     */
    omit?: SubraceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceTraitInclude<ExtArgs> | null
    /**
     * Filter, which SubraceTrait to fetch.
     */
    where?: SubraceTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubraceTraits to fetch.
     */
    orderBy?: SubraceTraitOrderByWithRelationInput | SubraceTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubraceTraits.
     */
    cursor?: SubraceTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubraceTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubraceTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubraceTraits.
     */
    distinct?: SubraceTraitScalarFieldEnum | SubraceTraitScalarFieldEnum[]
  }

  /**
   * SubraceTrait findFirstOrThrow
   */
  export type SubraceTraitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubraceTrait
     */
    select?: SubraceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubraceTrait
     */
    omit?: SubraceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceTraitInclude<ExtArgs> | null
    /**
     * Filter, which SubraceTrait to fetch.
     */
    where?: SubraceTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubraceTraits to fetch.
     */
    orderBy?: SubraceTraitOrderByWithRelationInput | SubraceTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubraceTraits.
     */
    cursor?: SubraceTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubraceTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubraceTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubraceTraits.
     */
    distinct?: SubraceTraitScalarFieldEnum | SubraceTraitScalarFieldEnum[]
  }

  /**
   * SubraceTrait findMany
   */
  export type SubraceTraitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubraceTrait
     */
    select?: SubraceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubraceTrait
     */
    omit?: SubraceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceTraitInclude<ExtArgs> | null
    /**
     * Filter, which SubraceTraits to fetch.
     */
    where?: SubraceTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubraceTraits to fetch.
     */
    orderBy?: SubraceTraitOrderByWithRelationInput | SubraceTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubraceTraits.
     */
    cursor?: SubraceTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubraceTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubraceTraits.
     */
    skip?: number
    distinct?: SubraceTraitScalarFieldEnum | SubraceTraitScalarFieldEnum[]
  }

  /**
   * SubraceTrait create
   */
  export type SubraceTraitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubraceTrait
     */
    select?: SubraceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubraceTrait
     */
    omit?: SubraceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceTraitInclude<ExtArgs> | null
    /**
     * The data needed to create a SubraceTrait.
     */
    data: XOR<SubraceTraitCreateInput, SubraceTraitUncheckedCreateInput>
  }

  /**
   * SubraceTrait createMany
   */
  export type SubraceTraitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubraceTraits.
     */
    data: SubraceTraitCreateManyInput | SubraceTraitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubraceTrait createManyAndReturn
   */
  export type SubraceTraitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubraceTrait
     */
    select?: SubraceTraitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubraceTrait
     */
    omit?: SubraceTraitOmit<ExtArgs> | null
    /**
     * The data used to create many SubraceTraits.
     */
    data: SubraceTraitCreateManyInput | SubraceTraitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceTraitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubraceTrait update
   */
  export type SubraceTraitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubraceTrait
     */
    select?: SubraceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubraceTrait
     */
    omit?: SubraceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceTraitInclude<ExtArgs> | null
    /**
     * The data needed to update a SubraceTrait.
     */
    data: XOR<SubraceTraitUpdateInput, SubraceTraitUncheckedUpdateInput>
    /**
     * Choose, which SubraceTrait to update.
     */
    where: SubraceTraitWhereUniqueInput
  }

  /**
   * SubraceTrait updateMany
   */
  export type SubraceTraitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubraceTraits.
     */
    data: XOR<SubraceTraitUpdateManyMutationInput, SubraceTraitUncheckedUpdateManyInput>
    /**
     * Filter which SubraceTraits to update
     */
    where?: SubraceTraitWhereInput
    /**
     * Limit how many SubraceTraits to update.
     */
    limit?: number
  }

  /**
   * SubraceTrait updateManyAndReturn
   */
  export type SubraceTraitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubraceTrait
     */
    select?: SubraceTraitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubraceTrait
     */
    omit?: SubraceTraitOmit<ExtArgs> | null
    /**
     * The data used to update SubraceTraits.
     */
    data: XOR<SubraceTraitUpdateManyMutationInput, SubraceTraitUncheckedUpdateManyInput>
    /**
     * Filter which SubraceTraits to update
     */
    where?: SubraceTraitWhereInput
    /**
     * Limit how many SubraceTraits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceTraitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubraceTrait upsert
   */
  export type SubraceTraitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubraceTrait
     */
    select?: SubraceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubraceTrait
     */
    omit?: SubraceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceTraitInclude<ExtArgs> | null
    /**
     * The filter to search for the SubraceTrait to update in case it exists.
     */
    where: SubraceTraitWhereUniqueInput
    /**
     * In case the SubraceTrait found by the `where` argument doesn't exist, create a new SubraceTrait with this data.
     */
    create: XOR<SubraceTraitCreateInput, SubraceTraitUncheckedCreateInput>
    /**
     * In case the SubraceTrait was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubraceTraitUpdateInput, SubraceTraitUncheckedUpdateInput>
  }

  /**
   * SubraceTrait delete
   */
  export type SubraceTraitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubraceTrait
     */
    select?: SubraceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubraceTrait
     */
    omit?: SubraceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceTraitInclude<ExtArgs> | null
    /**
     * Filter which SubraceTrait to delete.
     */
    where: SubraceTraitWhereUniqueInput
  }

  /**
   * SubraceTrait deleteMany
   */
  export type SubraceTraitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubraceTraits to delete
     */
    where?: SubraceTraitWhereInput
    /**
     * Limit how many SubraceTraits to delete.
     */
    limit?: number
  }

  /**
   * SubraceTrait without action
   */
  export type SubraceTraitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubraceTrait
     */
    select?: SubraceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubraceTrait
     */
    omit?: SubraceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceTraitInclude<ExtArgs> | null
  }


  /**
   * Model RaceVariantTrait
   */

  export type AggregateRaceVariantTrait = {
    _count: RaceVariantTraitCountAggregateOutputType | null
    _avg: RaceVariantTraitAvgAggregateOutputType | null
    _sum: RaceVariantTraitSumAggregateOutputType | null
    _min: RaceVariantTraitMinAggregateOutputType | null
    _max: RaceVariantTraitMaxAggregateOutputType | null
  }

  export type RaceVariantTraitAvgAggregateOutputType = {
    raceVariantTraitId: number | null
    raceVariantId: number | null
    featureId: number | null
  }

  export type RaceVariantTraitSumAggregateOutputType = {
    raceVariantTraitId: number | null
    raceVariantId: number | null
    featureId: number | null
  }

  export type RaceVariantTraitMinAggregateOutputType = {
    raceVariantTraitId: number | null
    raceVariantId: number | null
    featureId: number | null
  }

  export type RaceVariantTraitMaxAggregateOutputType = {
    raceVariantTraitId: number | null
    raceVariantId: number | null
    featureId: number | null
  }

  export type RaceVariantTraitCountAggregateOutputType = {
    raceVariantTraitId: number
    raceVariantId: number
    featureId: number
    _all: number
  }


  export type RaceVariantTraitAvgAggregateInputType = {
    raceVariantTraitId?: true
    raceVariantId?: true
    featureId?: true
  }

  export type RaceVariantTraitSumAggregateInputType = {
    raceVariantTraitId?: true
    raceVariantId?: true
    featureId?: true
  }

  export type RaceVariantTraitMinAggregateInputType = {
    raceVariantTraitId?: true
    raceVariantId?: true
    featureId?: true
  }

  export type RaceVariantTraitMaxAggregateInputType = {
    raceVariantTraitId?: true
    raceVariantId?: true
    featureId?: true
  }

  export type RaceVariantTraitCountAggregateInputType = {
    raceVariantTraitId?: true
    raceVariantId?: true
    featureId?: true
    _all?: true
  }

  export type RaceVariantTraitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceVariantTrait to aggregate.
     */
    where?: RaceVariantTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceVariantTraits to fetch.
     */
    orderBy?: RaceVariantTraitOrderByWithRelationInput | RaceVariantTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceVariantTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceVariantTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceVariantTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaceVariantTraits
    **/
    _count?: true | RaceVariantTraitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceVariantTraitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceVariantTraitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceVariantTraitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceVariantTraitMaxAggregateInputType
  }

  export type GetRaceVariantTraitAggregateType<T extends RaceVariantTraitAggregateArgs> = {
        [P in keyof T & keyof AggregateRaceVariantTrait]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaceVariantTrait[P]>
      : GetScalarType<T[P], AggregateRaceVariantTrait[P]>
  }




  export type RaceVariantTraitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceVariantTraitWhereInput
    orderBy?: RaceVariantTraitOrderByWithAggregationInput | RaceVariantTraitOrderByWithAggregationInput[]
    by: RaceVariantTraitScalarFieldEnum[] | RaceVariantTraitScalarFieldEnum
    having?: RaceVariantTraitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceVariantTraitCountAggregateInputType | true
    _avg?: RaceVariantTraitAvgAggregateInputType
    _sum?: RaceVariantTraitSumAggregateInputType
    _min?: RaceVariantTraitMinAggregateInputType
    _max?: RaceVariantTraitMaxAggregateInputType
  }

  export type RaceVariantTraitGroupByOutputType = {
    raceVariantTraitId: number
    raceVariantId: number
    featureId: number
    _count: RaceVariantTraitCountAggregateOutputType | null
    _avg: RaceVariantTraitAvgAggregateOutputType | null
    _sum: RaceVariantTraitSumAggregateOutputType | null
    _min: RaceVariantTraitMinAggregateOutputType | null
    _max: RaceVariantTraitMaxAggregateOutputType | null
  }

  type GetRaceVariantTraitGroupByPayload<T extends RaceVariantTraitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceVariantTraitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceVariantTraitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceVariantTraitGroupByOutputType[P]>
            : GetScalarType<T[P], RaceVariantTraitGroupByOutputType[P]>
        }
      >
    >


  export type RaceVariantTraitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceVariantTraitId?: boolean
    raceVariantId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    raceVariant?: boolean | RaceVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceVariantTrait"]>

  export type RaceVariantTraitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceVariantTraitId?: boolean
    raceVariantId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    raceVariant?: boolean | RaceVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceVariantTrait"]>

  export type RaceVariantTraitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceVariantTraitId?: boolean
    raceVariantId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    raceVariant?: boolean | RaceVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceVariantTrait"]>

  export type RaceVariantTraitSelectScalar = {
    raceVariantTraitId?: boolean
    raceVariantId?: boolean
    featureId?: boolean
  }

  export type RaceVariantTraitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"raceVariantTraitId" | "raceVariantId" | "featureId", ExtArgs["result"]["raceVariantTrait"]>
  export type RaceVariantTraitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    raceVariant?: boolean | RaceVariantDefaultArgs<ExtArgs>
  }
  export type RaceVariantTraitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    raceVariant?: boolean | RaceVariantDefaultArgs<ExtArgs>
  }
  export type RaceVariantTraitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    raceVariant?: boolean | RaceVariantDefaultArgs<ExtArgs>
  }

  export type $RaceVariantTraitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaceVariantTrait"
    objects: {
      feature: Prisma.$FeaturePayload<ExtArgs>
      raceVariant: Prisma.$RaceVariantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      raceVariantTraitId: number
      raceVariantId: number
      featureId: number
    }, ExtArgs["result"]["raceVariantTrait"]>
    composites: {}
  }

  type RaceVariantTraitGetPayload<S extends boolean | null | undefined | RaceVariantTraitDefaultArgs> = $Result.GetResult<Prisma.$RaceVariantTraitPayload, S>

  type RaceVariantTraitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceVariantTraitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceVariantTraitCountAggregateInputType | true
    }

  export interface RaceVariantTraitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaceVariantTrait'], meta: { name: 'RaceVariantTrait' } }
    /**
     * Find zero or one RaceVariantTrait that matches the filter.
     * @param {RaceVariantTraitFindUniqueArgs} args - Arguments to find a RaceVariantTrait
     * @example
     * // Get one RaceVariantTrait
     * const raceVariantTrait = await prisma.raceVariantTrait.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceVariantTraitFindUniqueArgs>(args: SelectSubset<T, RaceVariantTraitFindUniqueArgs<ExtArgs>>): Prisma__RaceVariantTraitClient<$Result.GetResult<Prisma.$RaceVariantTraitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RaceVariantTrait that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceVariantTraitFindUniqueOrThrowArgs} args - Arguments to find a RaceVariantTrait
     * @example
     * // Get one RaceVariantTrait
     * const raceVariantTrait = await prisma.raceVariantTrait.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceVariantTraitFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceVariantTraitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceVariantTraitClient<$Result.GetResult<Prisma.$RaceVariantTraitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceVariantTrait that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceVariantTraitFindFirstArgs} args - Arguments to find a RaceVariantTrait
     * @example
     * // Get one RaceVariantTrait
     * const raceVariantTrait = await prisma.raceVariantTrait.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceVariantTraitFindFirstArgs>(args?: SelectSubset<T, RaceVariantTraitFindFirstArgs<ExtArgs>>): Prisma__RaceVariantTraitClient<$Result.GetResult<Prisma.$RaceVariantTraitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceVariantTrait that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceVariantTraitFindFirstOrThrowArgs} args - Arguments to find a RaceVariantTrait
     * @example
     * // Get one RaceVariantTrait
     * const raceVariantTrait = await prisma.raceVariantTrait.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceVariantTraitFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceVariantTraitFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceVariantTraitClient<$Result.GetResult<Prisma.$RaceVariantTraitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RaceVariantTraits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceVariantTraitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaceVariantTraits
     * const raceVariantTraits = await prisma.raceVariantTrait.findMany()
     * 
     * // Get first 10 RaceVariantTraits
     * const raceVariantTraits = await prisma.raceVariantTrait.findMany({ take: 10 })
     * 
     * // Only select the `raceVariantTraitId`
     * const raceVariantTraitWithRaceVariantTraitIdOnly = await prisma.raceVariantTrait.findMany({ select: { raceVariantTraitId: true } })
     * 
     */
    findMany<T extends RaceVariantTraitFindManyArgs>(args?: SelectSubset<T, RaceVariantTraitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceVariantTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RaceVariantTrait.
     * @param {RaceVariantTraitCreateArgs} args - Arguments to create a RaceVariantTrait.
     * @example
     * // Create one RaceVariantTrait
     * const RaceVariantTrait = await prisma.raceVariantTrait.create({
     *   data: {
     *     // ... data to create a RaceVariantTrait
     *   }
     * })
     * 
     */
    create<T extends RaceVariantTraitCreateArgs>(args: SelectSubset<T, RaceVariantTraitCreateArgs<ExtArgs>>): Prisma__RaceVariantTraitClient<$Result.GetResult<Prisma.$RaceVariantTraitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RaceVariantTraits.
     * @param {RaceVariantTraitCreateManyArgs} args - Arguments to create many RaceVariantTraits.
     * @example
     * // Create many RaceVariantTraits
     * const raceVariantTrait = await prisma.raceVariantTrait.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceVariantTraitCreateManyArgs>(args?: SelectSubset<T, RaceVariantTraitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RaceVariantTraits and returns the data saved in the database.
     * @param {RaceVariantTraitCreateManyAndReturnArgs} args - Arguments to create many RaceVariantTraits.
     * @example
     * // Create many RaceVariantTraits
     * const raceVariantTrait = await prisma.raceVariantTrait.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RaceVariantTraits and only return the `raceVariantTraitId`
     * const raceVariantTraitWithRaceVariantTraitIdOnly = await prisma.raceVariantTrait.createManyAndReturn({
     *   select: { raceVariantTraitId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaceVariantTraitCreateManyAndReturnArgs>(args?: SelectSubset<T, RaceVariantTraitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceVariantTraitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RaceVariantTrait.
     * @param {RaceVariantTraitDeleteArgs} args - Arguments to delete one RaceVariantTrait.
     * @example
     * // Delete one RaceVariantTrait
     * const RaceVariantTrait = await prisma.raceVariantTrait.delete({
     *   where: {
     *     // ... filter to delete one RaceVariantTrait
     *   }
     * })
     * 
     */
    delete<T extends RaceVariantTraitDeleteArgs>(args: SelectSubset<T, RaceVariantTraitDeleteArgs<ExtArgs>>): Prisma__RaceVariantTraitClient<$Result.GetResult<Prisma.$RaceVariantTraitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RaceVariantTrait.
     * @param {RaceVariantTraitUpdateArgs} args - Arguments to update one RaceVariantTrait.
     * @example
     * // Update one RaceVariantTrait
     * const raceVariantTrait = await prisma.raceVariantTrait.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceVariantTraitUpdateArgs>(args: SelectSubset<T, RaceVariantTraitUpdateArgs<ExtArgs>>): Prisma__RaceVariantTraitClient<$Result.GetResult<Prisma.$RaceVariantTraitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RaceVariantTraits.
     * @param {RaceVariantTraitDeleteManyArgs} args - Arguments to filter RaceVariantTraits to delete.
     * @example
     * // Delete a few RaceVariantTraits
     * const { count } = await prisma.raceVariantTrait.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceVariantTraitDeleteManyArgs>(args?: SelectSubset<T, RaceVariantTraitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceVariantTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceVariantTraitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaceVariantTraits
     * const raceVariantTrait = await prisma.raceVariantTrait.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceVariantTraitUpdateManyArgs>(args: SelectSubset<T, RaceVariantTraitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceVariantTraits and returns the data updated in the database.
     * @param {RaceVariantTraitUpdateManyAndReturnArgs} args - Arguments to update many RaceVariantTraits.
     * @example
     * // Update many RaceVariantTraits
     * const raceVariantTrait = await prisma.raceVariantTrait.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RaceVariantTraits and only return the `raceVariantTraitId`
     * const raceVariantTraitWithRaceVariantTraitIdOnly = await prisma.raceVariantTrait.updateManyAndReturn({
     *   select: { raceVariantTraitId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaceVariantTraitUpdateManyAndReturnArgs>(args: SelectSubset<T, RaceVariantTraitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceVariantTraitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RaceVariantTrait.
     * @param {RaceVariantTraitUpsertArgs} args - Arguments to update or create a RaceVariantTrait.
     * @example
     * // Update or create a RaceVariantTrait
     * const raceVariantTrait = await prisma.raceVariantTrait.upsert({
     *   create: {
     *     // ... data to create a RaceVariantTrait
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaceVariantTrait we want to update
     *   }
     * })
     */
    upsert<T extends RaceVariantTraitUpsertArgs>(args: SelectSubset<T, RaceVariantTraitUpsertArgs<ExtArgs>>): Prisma__RaceVariantTraitClient<$Result.GetResult<Prisma.$RaceVariantTraitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RaceVariantTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceVariantTraitCountArgs} args - Arguments to filter RaceVariantTraits to count.
     * @example
     * // Count the number of RaceVariantTraits
     * const count = await prisma.raceVariantTrait.count({
     *   where: {
     *     // ... the filter for the RaceVariantTraits we want to count
     *   }
     * })
    **/
    count<T extends RaceVariantTraitCountArgs>(
      args?: Subset<T, RaceVariantTraitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceVariantTraitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaceVariantTrait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceVariantTraitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceVariantTraitAggregateArgs>(args: Subset<T, RaceVariantTraitAggregateArgs>): Prisma.PrismaPromise<GetRaceVariantTraitAggregateType<T>>

    /**
     * Group by RaceVariantTrait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceVariantTraitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceVariantTraitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceVariantTraitGroupByArgs['orderBy'] }
        : { orderBy?: RaceVariantTraitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceVariantTraitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceVariantTraitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaceVariantTrait model
   */
  readonly fields: RaceVariantTraitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaceVariantTrait.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceVariantTraitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feature<T extends FeatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureDefaultArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    raceVariant<T extends RaceVariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceVariantDefaultArgs<ExtArgs>>): Prisma__RaceVariantClient<$Result.GetResult<Prisma.$RaceVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RaceVariantTrait model
   */
  interface RaceVariantTraitFieldRefs {
    readonly raceVariantTraitId: FieldRef<"RaceVariantTrait", 'Int'>
    readonly raceVariantId: FieldRef<"RaceVariantTrait", 'Int'>
    readonly featureId: FieldRef<"RaceVariantTrait", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RaceVariantTrait findUnique
   */
  export type RaceVariantTraitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariantTrait
     */
    select?: RaceVariantTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariantTrait
     */
    omit?: RaceVariantTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceVariantTrait to fetch.
     */
    where: RaceVariantTraitWhereUniqueInput
  }

  /**
   * RaceVariantTrait findUniqueOrThrow
   */
  export type RaceVariantTraitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariantTrait
     */
    select?: RaceVariantTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariantTrait
     */
    omit?: RaceVariantTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceVariantTrait to fetch.
     */
    where: RaceVariantTraitWhereUniqueInput
  }

  /**
   * RaceVariantTrait findFirst
   */
  export type RaceVariantTraitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariantTrait
     */
    select?: RaceVariantTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariantTrait
     */
    omit?: RaceVariantTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceVariantTrait to fetch.
     */
    where?: RaceVariantTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceVariantTraits to fetch.
     */
    orderBy?: RaceVariantTraitOrderByWithRelationInput | RaceVariantTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceVariantTraits.
     */
    cursor?: RaceVariantTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceVariantTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceVariantTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceVariantTraits.
     */
    distinct?: RaceVariantTraitScalarFieldEnum | RaceVariantTraitScalarFieldEnum[]
  }

  /**
   * RaceVariantTrait findFirstOrThrow
   */
  export type RaceVariantTraitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariantTrait
     */
    select?: RaceVariantTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariantTrait
     */
    omit?: RaceVariantTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceVariantTrait to fetch.
     */
    where?: RaceVariantTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceVariantTraits to fetch.
     */
    orderBy?: RaceVariantTraitOrderByWithRelationInput | RaceVariantTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceVariantTraits.
     */
    cursor?: RaceVariantTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceVariantTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceVariantTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceVariantTraits.
     */
    distinct?: RaceVariantTraitScalarFieldEnum | RaceVariantTraitScalarFieldEnum[]
  }

  /**
   * RaceVariantTrait findMany
   */
  export type RaceVariantTraitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariantTrait
     */
    select?: RaceVariantTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariantTrait
     */
    omit?: RaceVariantTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceVariantTraits to fetch.
     */
    where?: RaceVariantTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceVariantTraits to fetch.
     */
    orderBy?: RaceVariantTraitOrderByWithRelationInput | RaceVariantTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaceVariantTraits.
     */
    cursor?: RaceVariantTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceVariantTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceVariantTraits.
     */
    skip?: number
    distinct?: RaceVariantTraitScalarFieldEnum | RaceVariantTraitScalarFieldEnum[]
  }

  /**
   * RaceVariantTrait create
   */
  export type RaceVariantTraitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariantTrait
     */
    select?: RaceVariantTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariantTrait
     */
    omit?: RaceVariantTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantTraitInclude<ExtArgs> | null
    /**
     * The data needed to create a RaceVariantTrait.
     */
    data: XOR<RaceVariantTraitCreateInput, RaceVariantTraitUncheckedCreateInput>
  }

  /**
   * RaceVariantTrait createMany
   */
  export type RaceVariantTraitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaceVariantTraits.
     */
    data: RaceVariantTraitCreateManyInput | RaceVariantTraitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RaceVariantTrait createManyAndReturn
   */
  export type RaceVariantTraitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariantTrait
     */
    select?: RaceVariantTraitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariantTrait
     */
    omit?: RaceVariantTraitOmit<ExtArgs> | null
    /**
     * The data used to create many RaceVariantTraits.
     */
    data: RaceVariantTraitCreateManyInput | RaceVariantTraitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantTraitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaceVariantTrait update
   */
  export type RaceVariantTraitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariantTrait
     */
    select?: RaceVariantTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariantTrait
     */
    omit?: RaceVariantTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantTraitInclude<ExtArgs> | null
    /**
     * The data needed to update a RaceVariantTrait.
     */
    data: XOR<RaceVariantTraitUpdateInput, RaceVariantTraitUncheckedUpdateInput>
    /**
     * Choose, which RaceVariantTrait to update.
     */
    where: RaceVariantTraitWhereUniqueInput
  }

  /**
   * RaceVariantTrait updateMany
   */
  export type RaceVariantTraitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaceVariantTraits.
     */
    data: XOR<RaceVariantTraitUpdateManyMutationInput, RaceVariantTraitUncheckedUpdateManyInput>
    /**
     * Filter which RaceVariantTraits to update
     */
    where?: RaceVariantTraitWhereInput
    /**
     * Limit how many RaceVariantTraits to update.
     */
    limit?: number
  }

  /**
   * RaceVariantTrait updateManyAndReturn
   */
  export type RaceVariantTraitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariantTrait
     */
    select?: RaceVariantTraitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariantTrait
     */
    omit?: RaceVariantTraitOmit<ExtArgs> | null
    /**
     * The data used to update RaceVariantTraits.
     */
    data: XOR<RaceVariantTraitUpdateManyMutationInput, RaceVariantTraitUncheckedUpdateManyInput>
    /**
     * Filter which RaceVariantTraits to update
     */
    where?: RaceVariantTraitWhereInput
    /**
     * Limit how many RaceVariantTraits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantTraitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaceVariantTrait upsert
   */
  export type RaceVariantTraitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariantTrait
     */
    select?: RaceVariantTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariantTrait
     */
    omit?: RaceVariantTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantTraitInclude<ExtArgs> | null
    /**
     * The filter to search for the RaceVariantTrait to update in case it exists.
     */
    where: RaceVariantTraitWhereUniqueInput
    /**
     * In case the RaceVariantTrait found by the `where` argument doesn't exist, create a new RaceVariantTrait with this data.
     */
    create: XOR<RaceVariantTraitCreateInput, RaceVariantTraitUncheckedCreateInput>
    /**
     * In case the RaceVariantTrait was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceVariantTraitUpdateInput, RaceVariantTraitUncheckedUpdateInput>
  }

  /**
   * RaceVariantTrait delete
   */
  export type RaceVariantTraitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariantTrait
     */
    select?: RaceVariantTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariantTrait
     */
    omit?: RaceVariantTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantTraitInclude<ExtArgs> | null
    /**
     * Filter which RaceVariantTrait to delete.
     */
    where: RaceVariantTraitWhereUniqueInput
  }

  /**
   * RaceVariantTrait deleteMany
   */
  export type RaceVariantTraitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceVariantTraits to delete
     */
    where?: RaceVariantTraitWhereInput
    /**
     * Limit how many RaceVariantTraits to delete.
     */
    limit?: number
  }

  /**
   * RaceVariantTrait without action
   */
  export type RaceVariantTraitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariantTrait
     */
    select?: RaceVariantTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariantTrait
     */
    omit?: RaceVariantTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantTraitInclude<ExtArgs> | null
  }


  /**
   * Model RaceChoiceOptionTrait
   */

  export type AggregateRaceChoiceOptionTrait = {
    _count: RaceChoiceOptionTraitCountAggregateOutputType | null
    _avg: RaceChoiceOptionTraitAvgAggregateOutputType | null
    _sum: RaceChoiceOptionTraitSumAggregateOutputType | null
    _min: RaceChoiceOptionTraitMinAggregateOutputType | null
    _max: RaceChoiceOptionTraitMaxAggregateOutputType | null
  }

  export type RaceChoiceOptionTraitAvgAggregateOutputType = {
    raceChoiceOptionTraitId: number | null
    optionId: number | null
    featureId: number | null
  }

  export type RaceChoiceOptionTraitSumAggregateOutputType = {
    raceChoiceOptionTraitId: number | null
    optionId: number | null
    featureId: number | null
  }

  export type RaceChoiceOptionTraitMinAggregateOutputType = {
    raceChoiceOptionTraitId: number | null
    optionId: number | null
    featureId: number | null
  }

  export type RaceChoiceOptionTraitMaxAggregateOutputType = {
    raceChoiceOptionTraitId: number | null
    optionId: number | null
    featureId: number | null
  }

  export type RaceChoiceOptionTraitCountAggregateOutputType = {
    raceChoiceOptionTraitId: number
    optionId: number
    featureId: number
    _all: number
  }


  export type RaceChoiceOptionTraitAvgAggregateInputType = {
    raceChoiceOptionTraitId?: true
    optionId?: true
    featureId?: true
  }

  export type RaceChoiceOptionTraitSumAggregateInputType = {
    raceChoiceOptionTraitId?: true
    optionId?: true
    featureId?: true
  }

  export type RaceChoiceOptionTraitMinAggregateInputType = {
    raceChoiceOptionTraitId?: true
    optionId?: true
    featureId?: true
  }

  export type RaceChoiceOptionTraitMaxAggregateInputType = {
    raceChoiceOptionTraitId?: true
    optionId?: true
    featureId?: true
  }

  export type RaceChoiceOptionTraitCountAggregateInputType = {
    raceChoiceOptionTraitId?: true
    optionId?: true
    featureId?: true
    _all?: true
  }

  export type RaceChoiceOptionTraitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceChoiceOptionTrait to aggregate.
     */
    where?: RaceChoiceOptionTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceChoiceOptionTraits to fetch.
     */
    orderBy?: RaceChoiceOptionTraitOrderByWithRelationInput | RaceChoiceOptionTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceChoiceOptionTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceChoiceOptionTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceChoiceOptionTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaceChoiceOptionTraits
    **/
    _count?: true | RaceChoiceOptionTraitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceChoiceOptionTraitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceChoiceOptionTraitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceChoiceOptionTraitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceChoiceOptionTraitMaxAggregateInputType
  }

  export type GetRaceChoiceOptionTraitAggregateType<T extends RaceChoiceOptionTraitAggregateArgs> = {
        [P in keyof T & keyof AggregateRaceChoiceOptionTrait]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaceChoiceOptionTrait[P]>
      : GetScalarType<T[P], AggregateRaceChoiceOptionTrait[P]>
  }




  export type RaceChoiceOptionTraitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceChoiceOptionTraitWhereInput
    orderBy?: RaceChoiceOptionTraitOrderByWithAggregationInput | RaceChoiceOptionTraitOrderByWithAggregationInput[]
    by: RaceChoiceOptionTraitScalarFieldEnum[] | RaceChoiceOptionTraitScalarFieldEnum
    having?: RaceChoiceOptionTraitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceChoiceOptionTraitCountAggregateInputType | true
    _avg?: RaceChoiceOptionTraitAvgAggregateInputType
    _sum?: RaceChoiceOptionTraitSumAggregateInputType
    _min?: RaceChoiceOptionTraitMinAggregateInputType
    _max?: RaceChoiceOptionTraitMaxAggregateInputType
  }

  export type RaceChoiceOptionTraitGroupByOutputType = {
    raceChoiceOptionTraitId: number
    optionId: number
    featureId: number
    _count: RaceChoiceOptionTraitCountAggregateOutputType | null
    _avg: RaceChoiceOptionTraitAvgAggregateOutputType | null
    _sum: RaceChoiceOptionTraitSumAggregateOutputType | null
    _min: RaceChoiceOptionTraitMinAggregateOutputType | null
    _max: RaceChoiceOptionTraitMaxAggregateOutputType | null
  }

  type GetRaceChoiceOptionTraitGroupByPayload<T extends RaceChoiceOptionTraitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceChoiceOptionTraitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceChoiceOptionTraitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceChoiceOptionTraitGroupByOutputType[P]>
            : GetScalarType<T[P], RaceChoiceOptionTraitGroupByOutputType[P]>
        }
      >
    >


  export type RaceChoiceOptionTraitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceChoiceOptionTraitId?: boolean
    optionId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    raceChoiceOption?: boolean | RaceChoiceOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceChoiceOptionTrait"]>

  export type RaceChoiceOptionTraitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceChoiceOptionTraitId?: boolean
    optionId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    raceChoiceOption?: boolean | RaceChoiceOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceChoiceOptionTrait"]>

  export type RaceChoiceOptionTraitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceChoiceOptionTraitId?: boolean
    optionId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    raceChoiceOption?: boolean | RaceChoiceOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceChoiceOptionTrait"]>

  export type RaceChoiceOptionTraitSelectScalar = {
    raceChoiceOptionTraitId?: boolean
    optionId?: boolean
    featureId?: boolean
  }

  export type RaceChoiceOptionTraitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"raceChoiceOptionTraitId" | "optionId" | "featureId", ExtArgs["result"]["raceChoiceOptionTrait"]>
  export type RaceChoiceOptionTraitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    raceChoiceOption?: boolean | RaceChoiceOptionDefaultArgs<ExtArgs>
  }
  export type RaceChoiceOptionTraitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    raceChoiceOption?: boolean | RaceChoiceOptionDefaultArgs<ExtArgs>
  }
  export type RaceChoiceOptionTraitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    raceChoiceOption?: boolean | RaceChoiceOptionDefaultArgs<ExtArgs>
  }

  export type $RaceChoiceOptionTraitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaceChoiceOptionTrait"
    objects: {
      feature: Prisma.$FeaturePayload<ExtArgs>
      raceChoiceOption: Prisma.$RaceChoiceOptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      raceChoiceOptionTraitId: number
      optionId: number
      featureId: number
    }, ExtArgs["result"]["raceChoiceOptionTrait"]>
    composites: {}
  }

  type RaceChoiceOptionTraitGetPayload<S extends boolean | null | undefined | RaceChoiceOptionTraitDefaultArgs> = $Result.GetResult<Prisma.$RaceChoiceOptionTraitPayload, S>

  type RaceChoiceOptionTraitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceChoiceOptionTraitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceChoiceOptionTraitCountAggregateInputType | true
    }

  export interface RaceChoiceOptionTraitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaceChoiceOptionTrait'], meta: { name: 'RaceChoiceOptionTrait' } }
    /**
     * Find zero or one RaceChoiceOptionTrait that matches the filter.
     * @param {RaceChoiceOptionTraitFindUniqueArgs} args - Arguments to find a RaceChoiceOptionTrait
     * @example
     * // Get one RaceChoiceOptionTrait
     * const raceChoiceOptionTrait = await prisma.raceChoiceOptionTrait.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceChoiceOptionTraitFindUniqueArgs>(args: SelectSubset<T, RaceChoiceOptionTraitFindUniqueArgs<ExtArgs>>): Prisma__RaceChoiceOptionTraitClient<$Result.GetResult<Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RaceChoiceOptionTrait that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceChoiceOptionTraitFindUniqueOrThrowArgs} args - Arguments to find a RaceChoiceOptionTrait
     * @example
     * // Get one RaceChoiceOptionTrait
     * const raceChoiceOptionTrait = await prisma.raceChoiceOptionTrait.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceChoiceOptionTraitFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceChoiceOptionTraitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceChoiceOptionTraitClient<$Result.GetResult<Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceChoiceOptionTrait that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceChoiceOptionTraitFindFirstArgs} args - Arguments to find a RaceChoiceOptionTrait
     * @example
     * // Get one RaceChoiceOptionTrait
     * const raceChoiceOptionTrait = await prisma.raceChoiceOptionTrait.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceChoiceOptionTraitFindFirstArgs>(args?: SelectSubset<T, RaceChoiceOptionTraitFindFirstArgs<ExtArgs>>): Prisma__RaceChoiceOptionTraitClient<$Result.GetResult<Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceChoiceOptionTrait that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceChoiceOptionTraitFindFirstOrThrowArgs} args - Arguments to find a RaceChoiceOptionTrait
     * @example
     * // Get one RaceChoiceOptionTrait
     * const raceChoiceOptionTrait = await prisma.raceChoiceOptionTrait.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceChoiceOptionTraitFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceChoiceOptionTraitFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceChoiceOptionTraitClient<$Result.GetResult<Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RaceChoiceOptionTraits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceChoiceOptionTraitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaceChoiceOptionTraits
     * const raceChoiceOptionTraits = await prisma.raceChoiceOptionTrait.findMany()
     * 
     * // Get first 10 RaceChoiceOptionTraits
     * const raceChoiceOptionTraits = await prisma.raceChoiceOptionTrait.findMany({ take: 10 })
     * 
     * // Only select the `raceChoiceOptionTraitId`
     * const raceChoiceOptionTraitWithRaceChoiceOptionTraitIdOnly = await prisma.raceChoiceOptionTrait.findMany({ select: { raceChoiceOptionTraitId: true } })
     * 
     */
    findMany<T extends RaceChoiceOptionTraitFindManyArgs>(args?: SelectSubset<T, RaceChoiceOptionTraitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RaceChoiceOptionTrait.
     * @param {RaceChoiceOptionTraitCreateArgs} args - Arguments to create a RaceChoiceOptionTrait.
     * @example
     * // Create one RaceChoiceOptionTrait
     * const RaceChoiceOptionTrait = await prisma.raceChoiceOptionTrait.create({
     *   data: {
     *     // ... data to create a RaceChoiceOptionTrait
     *   }
     * })
     * 
     */
    create<T extends RaceChoiceOptionTraitCreateArgs>(args: SelectSubset<T, RaceChoiceOptionTraitCreateArgs<ExtArgs>>): Prisma__RaceChoiceOptionTraitClient<$Result.GetResult<Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RaceChoiceOptionTraits.
     * @param {RaceChoiceOptionTraitCreateManyArgs} args - Arguments to create many RaceChoiceOptionTraits.
     * @example
     * // Create many RaceChoiceOptionTraits
     * const raceChoiceOptionTrait = await prisma.raceChoiceOptionTrait.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceChoiceOptionTraitCreateManyArgs>(args?: SelectSubset<T, RaceChoiceOptionTraitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RaceChoiceOptionTraits and returns the data saved in the database.
     * @param {RaceChoiceOptionTraitCreateManyAndReturnArgs} args - Arguments to create many RaceChoiceOptionTraits.
     * @example
     * // Create many RaceChoiceOptionTraits
     * const raceChoiceOptionTrait = await prisma.raceChoiceOptionTrait.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RaceChoiceOptionTraits and only return the `raceChoiceOptionTraitId`
     * const raceChoiceOptionTraitWithRaceChoiceOptionTraitIdOnly = await prisma.raceChoiceOptionTrait.createManyAndReturn({
     *   select: { raceChoiceOptionTraitId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaceChoiceOptionTraitCreateManyAndReturnArgs>(args?: SelectSubset<T, RaceChoiceOptionTraitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RaceChoiceOptionTrait.
     * @param {RaceChoiceOptionTraitDeleteArgs} args - Arguments to delete one RaceChoiceOptionTrait.
     * @example
     * // Delete one RaceChoiceOptionTrait
     * const RaceChoiceOptionTrait = await prisma.raceChoiceOptionTrait.delete({
     *   where: {
     *     // ... filter to delete one RaceChoiceOptionTrait
     *   }
     * })
     * 
     */
    delete<T extends RaceChoiceOptionTraitDeleteArgs>(args: SelectSubset<T, RaceChoiceOptionTraitDeleteArgs<ExtArgs>>): Prisma__RaceChoiceOptionTraitClient<$Result.GetResult<Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RaceChoiceOptionTrait.
     * @param {RaceChoiceOptionTraitUpdateArgs} args - Arguments to update one RaceChoiceOptionTrait.
     * @example
     * // Update one RaceChoiceOptionTrait
     * const raceChoiceOptionTrait = await prisma.raceChoiceOptionTrait.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceChoiceOptionTraitUpdateArgs>(args: SelectSubset<T, RaceChoiceOptionTraitUpdateArgs<ExtArgs>>): Prisma__RaceChoiceOptionTraitClient<$Result.GetResult<Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RaceChoiceOptionTraits.
     * @param {RaceChoiceOptionTraitDeleteManyArgs} args - Arguments to filter RaceChoiceOptionTraits to delete.
     * @example
     * // Delete a few RaceChoiceOptionTraits
     * const { count } = await prisma.raceChoiceOptionTrait.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceChoiceOptionTraitDeleteManyArgs>(args?: SelectSubset<T, RaceChoiceOptionTraitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceChoiceOptionTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceChoiceOptionTraitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaceChoiceOptionTraits
     * const raceChoiceOptionTrait = await prisma.raceChoiceOptionTrait.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceChoiceOptionTraitUpdateManyArgs>(args: SelectSubset<T, RaceChoiceOptionTraitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceChoiceOptionTraits and returns the data updated in the database.
     * @param {RaceChoiceOptionTraitUpdateManyAndReturnArgs} args - Arguments to update many RaceChoiceOptionTraits.
     * @example
     * // Update many RaceChoiceOptionTraits
     * const raceChoiceOptionTrait = await prisma.raceChoiceOptionTrait.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RaceChoiceOptionTraits and only return the `raceChoiceOptionTraitId`
     * const raceChoiceOptionTraitWithRaceChoiceOptionTraitIdOnly = await prisma.raceChoiceOptionTrait.updateManyAndReturn({
     *   select: { raceChoiceOptionTraitId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaceChoiceOptionTraitUpdateManyAndReturnArgs>(args: SelectSubset<T, RaceChoiceOptionTraitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RaceChoiceOptionTrait.
     * @param {RaceChoiceOptionTraitUpsertArgs} args - Arguments to update or create a RaceChoiceOptionTrait.
     * @example
     * // Update or create a RaceChoiceOptionTrait
     * const raceChoiceOptionTrait = await prisma.raceChoiceOptionTrait.upsert({
     *   create: {
     *     // ... data to create a RaceChoiceOptionTrait
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaceChoiceOptionTrait we want to update
     *   }
     * })
     */
    upsert<T extends RaceChoiceOptionTraitUpsertArgs>(args: SelectSubset<T, RaceChoiceOptionTraitUpsertArgs<ExtArgs>>): Prisma__RaceChoiceOptionTraitClient<$Result.GetResult<Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RaceChoiceOptionTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceChoiceOptionTraitCountArgs} args - Arguments to filter RaceChoiceOptionTraits to count.
     * @example
     * // Count the number of RaceChoiceOptionTraits
     * const count = await prisma.raceChoiceOptionTrait.count({
     *   where: {
     *     // ... the filter for the RaceChoiceOptionTraits we want to count
     *   }
     * })
    **/
    count<T extends RaceChoiceOptionTraitCountArgs>(
      args?: Subset<T, RaceChoiceOptionTraitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceChoiceOptionTraitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaceChoiceOptionTrait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceChoiceOptionTraitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceChoiceOptionTraitAggregateArgs>(args: Subset<T, RaceChoiceOptionTraitAggregateArgs>): Prisma.PrismaPromise<GetRaceChoiceOptionTraitAggregateType<T>>

    /**
     * Group by RaceChoiceOptionTrait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceChoiceOptionTraitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceChoiceOptionTraitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceChoiceOptionTraitGroupByArgs['orderBy'] }
        : { orderBy?: RaceChoiceOptionTraitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceChoiceOptionTraitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceChoiceOptionTraitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaceChoiceOptionTrait model
   */
  readonly fields: RaceChoiceOptionTraitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaceChoiceOptionTrait.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceChoiceOptionTraitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feature<T extends FeatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureDefaultArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    raceChoiceOption<T extends RaceChoiceOptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceChoiceOptionDefaultArgs<ExtArgs>>): Prisma__RaceChoiceOptionClient<$Result.GetResult<Prisma.$RaceChoiceOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RaceChoiceOptionTrait model
   */
  interface RaceChoiceOptionTraitFieldRefs {
    readonly raceChoiceOptionTraitId: FieldRef<"RaceChoiceOptionTrait", 'Int'>
    readonly optionId: FieldRef<"RaceChoiceOptionTrait", 'Int'>
    readonly featureId: FieldRef<"RaceChoiceOptionTrait", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RaceChoiceOptionTrait findUnique
   */
  export type RaceChoiceOptionTraitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOptionTrait
     */
    select?: RaceChoiceOptionTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOptionTrait
     */
    omit?: RaceChoiceOptionTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceChoiceOptionTrait to fetch.
     */
    where: RaceChoiceOptionTraitWhereUniqueInput
  }

  /**
   * RaceChoiceOptionTrait findUniqueOrThrow
   */
  export type RaceChoiceOptionTraitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOptionTrait
     */
    select?: RaceChoiceOptionTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOptionTrait
     */
    omit?: RaceChoiceOptionTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceChoiceOptionTrait to fetch.
     */
    where: RaceChoiceOptionTraitWhereUniqueInput
  }

  /**
   * RaceChoiceOptionTrait findFirst
   */
  export type RaceChoiceOptionTraitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOptionTrait
     */
    select?: RaceChoiceOptionTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOptionTrait
     */
    omit?: RaceChoiceOptionTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceChoiceOptionTrait to fetch.
     */
    where?: RaceChoiceOptionTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceChoiceOptionTraits to fetch.
     */
    orderBy?: RaceChoiceOptionTraitOrderByWithRelationInput | RaceChoiceOptionTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceChoiceOptionTraits.
     */
    cursor?: RaceChoiceOptionTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceChoiceOptionTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceChoiceOptionTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceChoiceOptionTraits.
     */
    distinct?: RaceChoiceOptionTraitScalarFieldEnum | RaceChoiceOptionTraitScalarFieldEnum[]
  }

  /**
   * RaceChoiceOptionTrait findFirstOrThrow
   */
  export type RaceChoiceOptionTraitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOptionTrait
     */
    select?: RaceChoiceOptionTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOptionTrait
     */
    omit?: RaceChoiceOptionTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceChoiceOptionTrait to fetch.
     */
    where?: RaceChoiceOptionTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceChoiceOptionTraits to fetch.
     */
    orderBy?: RaceChoiceOptionTraitOrderByWithRelationInput | RaceChoiceOptionTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceChoiceOptionTraits.
     */
    cursor?: RaceChoiceOptionTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceChoiceOptionTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceChoiceOptionTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceChoiceOptionTraits.
     */
    distinct?: RaceChoiceOptionTraitScalarFieldEnum | RaceChoiceOptionTraitScalarFieldEnum[]
  }

  /**
   * RaceChoiceOptionTrait findMany
   */
  export type RaceChoiceOptionTraitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOptionTrait
     */
    select?: RaceChoiceOptionTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOptionTrait
     */
    omit?: RaceChoiceOptionTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionTraitInclude<ExtArgs> | null
    /**
     * Filter, which RaceChoiceOptionTraits to fetch.
     */
    where?: RaceChoiceOptionTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceChoiceOptionTraits to fetch.
     */
    orderBy?: RaceChoiceOptionTraitOrderByWithRelationInput | RaceChoiceOptionTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaceChoiceOptionTraits.
     */
    cursor?: RaceChoiceOptionTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceChoiceOptionTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceChoiceOptionTraits.
     */
    skip?: number
    distinct?: RaceChoiceOptionTraitScalarFieldEnum | RaceChoiceOptionTraitScalarFieldEnum[]
  }

  /**
   * RaceChoiceOptionTrait create
   */
  export type RaceChoiceOptionTraitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOptionTrait
     */
    select?: RaceChoiceOptionTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOptionTrait
     */
    omit?: RaceChoiceOptionTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionTraitInclude<ExtArgs> | null
    /**
     * The data needed to create a RaceChoiceOptionTrait.
     */
    data: XOR<RaceChoiceOptionTraitCreateInput, RaceChoiceOptionTraitUncheckedCreateInput>
  }

  /**
   * RaceChoiceOptionTrait createMany
   */
  export type RaceChoiceOptionTraitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaceChoiceOptionTraits.
     */
    data: RaceChoiceOptionTraitCreateManyInput | RaceChoiceOptionTraitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RaceChoiceOptionTrait createManyAndReturn
   */
  export type RaceChoiceOptionTraitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOptionTrait
     */
    select?: RaceChoiceOptionTraitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOptionTrait
     */
    omit?: RaceChoiceOptionTraitOmit<ExtArgs> | null
    /**
     * The data used to create many RaceChoiceOptionTraits.
     */
    data: RaceChoiceOptionTraitCreateManyInput | RaceChoiceOptionTraitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionTraitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaceChoiceOptionTrait update
   */
  export type RaceChoiceOptionTraitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOptionTrait
     */
    select?: RaceChoiceOptionTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOptionTrait
     */
    omit?: RaceChoiceOptionTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionTraitInclude<ExtArgs> | null
    /**
     * The data needed to update a RaceChoiceOptionTrait.
     */
    data: XOR<RaceChoiceOptionTraitUpdateInput, RaceChoiceOptionTraitUncheckedUpdateInput>
    /**
     * Choose, which RaceChoiceOptionTrait to update.
     */
    where: RaceChoiceOptionTraitWhereUniqueInput
  }

  /**
   * RaceChoiceOptionTrait updateMany
   */
  export type RaceChoiceOptionTraitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaceChoiceOptionTraits.
     */
    data: XOR<RaceChoiceOptionTraitUpdateManyMutationInput, RaceChoiceOptionTraitUncheckedUpdateManyInput>
    /**
     * Filter which RaceChoiceOptionTraits to update
     */
    where?: RaceChoiceOptionTraitWhereInput
    /**
     * Limit how many RaceChoiceOptionTraits to update.
     */
    limit?: number
  }

  /**
   * RaceChoiceOptionTrait updateManyAndReturn
   */
  export type RaceChoiceOptionTraitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOptionTrait
     */
    select?: RaceChoiceOptionTraitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOptionTrait
     */
    omit?: RaceChoiceOptionTraitOmit<ExtArgs> | null
    /**
     * The data used to update RaceChoiceOptionTraits.
     */
    data: XOR<RaceChoiceOptionTraitUpdateManyMutationInput, RaceChoiceOptionTraitUncheckedUpdateManyInput>
    /**
     * Filter which RaceChoiceOptionTraits to update
     */
    where?: RaceChoiceOptionTraitWhereInput
    /**
     * Limit how many RaceChoiceOptionTraits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionTraitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaceChoiceOptionTrait upsert
   */
  export type RaceChoiceOptionTraitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOptionTrait
     */
    select?: RaceChoiceOptionTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOptionTrait
     */
    omit?: RaceChoiceOptionTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionTraitInclude<ExtArgs> | null
    /**
     * The filter to search for the RaceChoiceOptionTrait to update in case it exists.
     */
    where: RaceChoiceOptionTraitWhereUniqueInput
    /**
     * In case the RaceChoiceOptionTrait found by the `where` argument doesn't exist, create a new RaceChoiceOptionTrait with this data.
     */
    create: XOR<RaceChoiceOptionTraitCreateInput, RaceChoiceOptionTraitUncheckedCreateInput>
    /**
     * In case the RaceChoiceOptionTrait was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceChoiceOptionTraitUpdateInput, RaceChoiceOptionTraitUncheckedUpdateInput>
  }

  /**
   * RaceChoiceOptionTrait delete
   */
  export type RaceChoiceOptionTraitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOptionTrait
     */
    select?: RaceChoiceOptionTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOptionTrait
     */
    omit?: RaceChoiceOptionTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionTraitInclude<ExtArgs> | null
    /**
     * Filter which RaceChoiceOptionTrait to delete.
     */
    where: RaceChoiceOptionTraitWhereUniqueInput
  }

  /**
   * RaceChoiceOptionTrait deleteMany
   */
  export type RaceChoiceOptionTraitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceChoiceOptionTraits to delete
     */
    where?: RaceChoiceOptionTraitWhereInput
    /**
     * Limit how many RaceChoiceOptionTraits to delete.
     */
    limit?: number
  }

  /**
   * RaceChoiceOptionTrait without action
   */
  export type RaceChoiceOptionTraitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOptionTrait
     */
    select?: RaceChoiceOptionTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOptionTrait
     */
    omit?: RaceChoiceOptionTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionTraitInclude<ExtArgs> | null
  }


  /**
   * Model FeatFeature
   */

  export type AggregateFeatFeature = {
    _count: FeatFeatureCountAggregateOutputType | null
    _avg: FeatFeatureAvgAggregateOutputType | null
    _sum: FeatFeatureSumAggregateOutputType | null
    _min: FeatFeatureMinAggregateOutputType | null
    _max: FeatFeatureMaxAggregateOutputType | null
  }

  export type FeatFeatureAvgAggregateOutputType = {
    featFeatureId: number | null
    featId: number | null
    featureId: number | null
  }

  export type FeatFeatureSumAggregateOutputType = {
    featFeatureId: number | null
    featId: number | null
    featureId: number | null
  }

  export type FeatFeatureMinAggregateOutputType = {
    featFeatureId: number | null
    featId: number | null
    featureId: number | null
  }

  export type FeatFeatureMaxAggregateOutputType = {
    featFeatureId: number | null
    featId: number | null
    featureId: number | null
  }

  export type FeatFeatureCountAggregateOutputType = {
    featFeatureId: number
    featId: number
    featureId: number
    _all: number
  }


  export type FeatFeatureAvgAggregateInputType = {
    featFeatureId?: true
    featId?: true
    featureId?: true
  }

  export type FeatFeatureSumAggregateInputType = {
    featFeatureId?: true
    featId?: true
    featureId?: true
  }

  export type FeatFeatureMinAggregateInputType = {
    featFeatureId?: true
    featId?: true
    featureId?: true
  }

  export type FeatFeatureMaxAggregateInputType = {
    featFeatureId?: true
    featId?: true
    featureId?: true
  }

  export type FeatFeatureCountAggregateInputType = {
    featFeatureId?: true
    featId?: true
    featureId?: true
    _all?: true
  }

  export type FeatFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatFeature to aggregate.
     */
    where?: FeatFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatFeatures to fetch.
     */
    orderBy?: FeatFeatureOrderByWithRelationInput | FeatFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatFeatures
    **/
    _count?: true | FeatFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatFeatureMaxAggregateInputType
  }

  export type GetFeatFeatureAggregateType<T extends FeatFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatFeature[P]>
      : GetScalarType<T[P], AggregateFeatFeature[P]>
  }




  export type FeatFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatFeatureWhereInput
    orderBy?: FeatFeatureOrderByWithAggregationInput | FeatFeatureOrderByWithAggregationInput[]
    by: FeatFeatureScalarFieldEnum[] | FeatFeatureScalarFieldEnum
    having?: FeatFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatFeatureCountAggregateInputType | true
    _avg?: FeatFeatureAvgAggregateInputType
    _sum?: FeatFeatureSumAggregateInputType
    _min?: FeatFeatureMinAggregateInputType
    _max?: FeatFeatureMaxAggregateInputType
  }

  export type FeatFeatureGroupByOutputType = {
    featFeatureId: number
    featId: number
    featureId: number
    _count: FeatFeatureCountAggregateOutputType | null
    _avg: FeatFeatureAvgAggregateOutputType | null
    _sum: FeatFeatureSumAggregateOutputType | null
    _min: FeatFeatureMinAggregateOutputType | null
    _max: FeatFeatureMaxAggregateOutputType | null
  }

  type GetFeatFeatureGroupByPayload<T extends FeatFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], FeatFeatureGroupByOutputType[P]>
        }
      >
    >


  export type FeatFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    featFeatureId?: boolean
    featId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featFeature"]>

  export type FeatFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    featFeatureId?: boolean
    featId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featFeature"]>

  export type FeatFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    featFeatureId?: boolean
    featId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featFeature"]>

  export type FeatFeatureSelectScalar = {
    featFeatureId?: boolean
    featId?: boolean
    featureId?: boolean
  }

  export type FeatFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"featFeatureId" | "featId" | "featureId", ExtArgs["result"]["featFeature"]>
  export type FeatFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }
  export type FeatFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }
  export type FeatFeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }

  export type $FeatFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatFeature"
    objects: {
      feature: Prisma.$FeaturePayload<ExtArgs>
      feat: Prisma.$FeatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      featFeatureId: number
      featId: number
      featureId: number
    }, ExtArgs["result"]["featFeature"]>
    composites: {}
  }

  type FeatFeatureGetPayload<S extends boolean | null | undefined | FeatFeatureDefaultArgs> = $Result.GetResult<Prisma.$FeatFeaturePayload, S>

  type FeatFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatFeatureCountAggregateInputType | true
    }

  export interface FeatFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatFeature'], meta: { name: 'FeatFeature' } }
    /**
     * Find zero or one FeatFeature that matches the filter.
     * @param {FeatFeatureFindUniqueArgs} args - Arguments to find a FeatFeature
     * @example
     * // Get one FeatFeature
     * const featFeature = await prisma.featFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatFeatureFindUniqueArgs>(args: SelectSubset<T, FeatFeatureFindUniqueArgs<ExtArgs>>): Prisma__FeatFeatureClient<$Result.GetResult<Prisma.$FeatFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeatFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatFeatureFindUniqueOrThrowArgs} args - Arguments to find a FeatFeature
     * @example
     * // Get one FeatFeature
     * const featFeature = await prisma.featFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatFeatureClient<$Result.GetResult<Prisma.$FeatFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatFeatureFindFirstArgs} args - Arguments to find a FeatFeature
     * @example
     * // Get one FeatFeature
     * const featFeature = await prisma.featFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatFeatureFindFirstArgs>(args?: SelectSubset<T, FeatFeatureFindFirstArgs<ExtArgs>>): Prisma__FeatFeatureClient<$Result.GetResult<Prisma.$FeatFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatFeatureFindFirstOrThrowArgs} args - Arguments to find a FeatFeature
     * @example
     * // Get one FeatFeature
     * const featFeature = await prisma.featFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatFeatureClient<$Result.GetResult<Prisma.$FeatFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeatFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatFeatures
     * const featFeatures = await prisma.featFeature.findMany()
     * 
     * // Get first 10 FeatFeatures
     * const featFeatures = await prisma.featFeature.findMany({ take: 10 })
     * 
     * // Only select the `featFeatureId`
     * const featFeatureWithFeatFeatureIdOnly = await prisma.featFeature.findMany({ select: { featFeatureId: true } })
     * 
     */
    findMany<T extends FeatFeatureFindManyArgs>(args?: SelectSubset<T, FeatFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeatFeature.
     * @param {FeatFeatureCreateArgs} args - Arguments to create a FeatFeature.
     * @example
     * // Create one FeatFeature
     * const FeatFeature = await prisma.featFeature.create({
     *   data: {
     *     // ... data to create a FeatFeature
     *   }
     * })
     * 
     */
    create<T extends FeatFeatureCreateArgs>(args: SelectSubset<T, FeatFeatureCreateArgs<ExtArgs>>): Prisma__FeatFeatureClient<$Result.GetResult<Prisma.$FeatFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeatFeatures.
     * @param {FeatFeatureCreateManyArgs} args - Arguments to create many FeatFeatures.
     * @example
     * // Create many FeatFeatures
     * const featFeature = await prisma.featFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatFeatureCreateManyArgs>(args?: SelectSubset<T, FeatFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeatFeatures and returns the data saved in the database.
     * @param {FeatFeatureCreateManyAndReturnArgs} args - Arguments to create many FeatFeatures.
     * @example
     * // Create many FeatFeatures
     * const featFeature = await prisma.featFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeatFeatures and only return the `featFeatureId`
     * const featFeatureWithFeatFeatureIdOnly = await prisma.featFeature.createManyAndReturn({
     *   select: { featFeatureId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeatFeature.
     * @param {FeatFeatureDeleteArgs} args - Arguments to delete one FeatFeature.
     * @example
     * // Delete one FeatFeature
     * const FeatFeature = await prisma.featFeature.delete({
     *   where: {
     *     // ... filter to delete one FeatFeature
     *   }
     * })
     * 
     */
    delete<T extends FeatFeatureDeleteArgs>(args: SelectSubset<T, FeatFeatureDeleteArgs<ExtArgs>>): Prisma__FeatFeatureClient<$Result.GetResult<Prisma.$FeatFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeatFeature.
     * @param {FeatFeatureUpdateArgs} args - Arguments to update one FeatFeature.
     * @example
     * // Update one FeatFeature
     * const featFeature = await prisma.featFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatFeatureUpdateArgs>(args: SelectSubset<T, FeatFeatureUpdateArgs<ExtArgs>>): Prisma__FeatFeatureClient<$Result.GetResult<Prisma.$FeatFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeatFeatures.
     * @param {FeatFeatureDeleteManyArgs} args - Arguments to filter FeatFeatures to delete.
     * @example
     * // Delete a few FeatFeatures
     * const { count } = await prisma.featFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatFeatureDeleteManyArgs>(args?: SelectSubset<T, FeatFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatFeatures
     * const featFeature = await prisma.featFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatFeatureUpdateManyArgs>(args: SelectSubset<T, FeatFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatFeatures and returns the data updated in the database.
     * @param {FeatFeatureUpdateManyAndReturnArgs} args - Arguments to update many FeatFeatures.
     * @example
     * // Update many FeatFeatures
     * const featFeature = await prisma.featFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeatFeatures and only return the `featFeatureId`
     * const featFeatureWithFeatFeatureIdOnly = await prisma.featFeature.updateManyAndReturn({
     *   select: { featFeatureId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeatFeature.
     * @param {FeatFeatureUpsertArgs} args - Arguments to update or create a FeatFeature.
     * @example
     * // Update or create a FeatFeature
     * const featFeature = await prisma.featFeature.upsert({
     *   create: {
     *     // ... data to create a FeatFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatFeature we want to update
     *   }
     * })
     */
    upsert<T extends FeatFeatureUpsertArgs>(args: SelectSubset<T, FeatFeatureUpsertArgs<ExtArgs>>): Prisma__FeatFeatureClient<$Result.GetResult<Prisma.$FeatFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeatFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatFeatureCountArgs} args - Arguments to filter FeatFeatures to count.
     * @example
     * // Count the number of FeatFeatures
     * const count = await prisma.featFeature.count({
     *   where: {
     *     // ... the filter for the FeatFeatures we want to count
     *   }
     * })
    **/
    count<T extends FeatFeatureCountArgs>(
      args?: Subset<T, FeatFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatFeatureAggregateArgs>(args: Subset<T, FeatFeatureAggregateArgs>): Prisma.PrismaPromise<GetFeatFeatureAggregateType<T>>

    /**
     * Group by FeatFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatFeatureGroupByArgs['orderBy'] }
        : { orderBy?: FeatFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatFeature model
   */
  readonly fields: FeatFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feature<T extends FeatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureDefaultArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    feat<T extends FeatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatDefaultArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeatFeature model
   */
  interface FeatFeatureFieldRefs {
    readonly featFeatureId: FieldRef<"FeatFeature", 'Int'>
    readonly featId: FieldRef<"FeatFeature", 'Int'>
    readonly featureId: FieldRef<"FeatFeature", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FeatFeature findUnique
   */
  export type FeatFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatFeature
     */
    select?: FeatFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatFeature
     */
    omit?: FeatFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatFeatureInclude<ExtArgs> | null
    /**
     * Filter, which FeatFeature to fetch.
     */
    where: FeatFeatureWhereUniqueInput
  }

  /**
   * FeatFeature findUniqueOrThrow
   */
  export type FeatFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatFeature
     */
    select?: FeatFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatFeature
     */
    omit?: FeatFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatFeatureInclude<ExtArgs> | null
    /**
     * Filter, which FeatFeature to fetch.
     */
    where: FeatFeatureWhereUniqueInput
  }

  /**
   * FeatFeature findFirst
   */
  export type FeatFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatFeature
     */
    select?: FeatFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatFeature
     */
    omit?: FeatFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatFeatureInclude<ExtArgs> | null
    /**
     * Filter, which FeatFeature to fetch.
     */
    where?: FeatFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatFeatures to fetch.
     */
    orderBy?: FeatFeatureOrderByWithRelationInput | FeatFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatFeatures.
     */
    cursor?: FeatFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatFeatures.
     */
    distinct?: FeatFeatureScalarFieldEnum | FeatFeatureScalarFieldEnum[]
  }

  /**
   * FeatFeature findFirstOrThrow
   */
  export type FeatFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatFeature
     */
    select?: FeatFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatFeature
     */
    omit?: FeatFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatFeatureInclude<ExtArgs> | null
    /**
     * Filter, which FeatFeature to fetch.
     */
    where?: FeatFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatFeatures to fetch.
     */
    orderBy?: FeatFeatureOrderByWithRelationInput | FeatFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatFeatures.
     */
    cursor?: FeatFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatFeatures.
     */
    distinct?: FeatFeatureScalarFieldEnum | FeatFeatureScalarFieldEnum[]
  }

  /**
   * FeatFeature findMany
   */
  export type FeatFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatFeature
     */
    select?: FeatFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatFeature
     */
    omit?: FeatFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatFeatureInclude<ExtArgs> | null
    /**
     * Filter, which FeatFeatures to fetch.
     */
    where?: FeatFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatFeatures to fetch.
     */
    orderBy?: FeatFeatureOrderByWithRelationInput | FeatFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatFeatures.
     */
    cursor?: FeatFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatFeatures.
     */
    skip?: number
    distinct?: FeatFeatureScalarFieldEnum | FeatFeatureScalarFieldEnum[]
  }

  /**
   * FeatFeature create
   */
  export type FeatFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatFeature
     */
    select?: FeatFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatFeature
     */
    omit?: FeatFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a FeatFeature.
     */
    data: XOR<FeatFeatureCreateInput, FeatFeatureUncheckedCreateInput>
  }

  /**
   * FeatFeature createMany
   */
  export type FeatFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatFeatures.
     */
    data: FeatFeatureCreateManyInput | FeatFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatFeature createManyAndReturn
   */
  export type FeatFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatFeature
     */
    select?: FeatFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatFeature
     */
    omit?: FeatFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many FeatFeatures.
     */
    data: FeatFeatureCreateManyInput | FeatFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeatFeature update
   */
  export type FeatFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatFeature
     */
    select?: FeatFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatFeature
     */
    omit?: FeatFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a FeatFeature.
     */
    data: XOR<FeatFeatureUpdateInput, FeatFeatureUncheckedUpdateInput>
    /**
     * Choose, which FeatFeature to update.
     */
    where: FeatFeatureWhereUniqueInput
  }

  /**
   * FeatFeature updateMany
   */
  export type FeatFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatFeatures.
     */
    data: XOR<FeatFeatureUpdateManyMutationInput, FeatFeatureUncheckedUpdateManyInput>
    /**
     * Filter which FeatFeatures to update
     */
    where?: FeatFeatureWhereInput
    /**
     * Limit how many FeatFeatures to update.
     */
    limit?: number
  }

  /**
   * FeatFeature updateManyAndReturn
   */
  export type FeatFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatFeature
     */
    select?: FeatFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatFeature
     */
    omit?: FeatFeatureOmit<ExtArgs> | null
    /**
     * The data used to update FeatFeatures.
     */
    data: XOR<FeatFeatureUpdateManyMutationInput, FeatFeatureUncheckedUpdateManyInput>
    /**
     * Filter which FeatFeatures to update
     */
    where?: FeatFeatureWhereInput
    /**
     * Limit how many FeatFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatFeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeatFeature upsert
   */
  export type FeatFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatFeature
     */
    select?: FeatFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatFeature
     */
    omit?: FeatFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the FeatFeature to update in case it exists.
     */
    where: FeatFeatureWhereUniqueInput
    /**
     * In case the FeatFeature found by the `where` argument doesn't exist, create a new FeatFeature with this data.
     */
    create: XOR<FeatFeatureCreateInput, FeatFeatureUncheckedCreateInput>
    /**
     * In case the FeatFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatFeatureUpdateInput, FeatFeatureUncheckedUpdateInput>
  }

  /**
   * FeatFeature delete
   */
  export type FeatFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatFeature
     */
    select?: FeatFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatFeature
     */
    omit?: FeatFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatFeatureInclude<ExtArgs> | null
    /**
     * Filter which FeatFeature to delete.
     */
    where: FeatFeatureWhereUniqueInput
  }

  /**
   * FeatFeature deleteMany
   */
  export type FeatFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatFeatures to delete
     */
    where?: FeatFeatureWhereInput
    /**
     * Limit how many FeatFeatures to delete.
     */
    limit?: number
  }

  /**
   * FeatFeature without action
   */
  export type FeatFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatFeature
     */
    select?: FeatFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatFeature
     */
    omit?: FeatFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatFeatureInclude<ExtArgs> | null
  }


  /**
   * Model MagicItemFeature
   */

  export type AggregateMagicItemFeature = {
    _count: MagicItemFeatureCountAggregateOutputType | null
    _avg: MagicItemFeatureAvgAggregateOutputType | null
    _sum: MagicItemFeatureSumAggregateOutputType | null
    _min: MagicItemFeatureMinAggregateOutputType | null
    _max: MagicItemFeatureMaxAggregateOutputType | null
  }

  export type MagicItemFeatureAvgAggregateOutputType = {
    magicItemFeatureId: number | null
    magicItemId: number | null
    featureId: number | null
  }

  export type MagicItemFeatureSumAggregateOutputType = {
    magicItemFeatureId: number | null
    magicItemId: number | null
    featureId: number | null
  }

  export type MagicItemFeatureMinAggregateOutputType = {
    magicItemFeatureId: number | null
    magicItemId: number | null
    featureId: number | null
  }

  export type MagicItemFeatureMaxAggregateOutputType = {
    magicItemFeatureId: number | null
    magicItemId: number | null
    featureId: number | null
  }

  export type MagicItemFeatureCountAggregateOutputType = {
    magicItemFeatureId: number
    magicItemId: number
    featureId: number
    _all: number
  }


  export type MagicItemFeatureAvgAggregateInputType = {
    magicItemFeatureId?: true
    magicItemId?: true
    featureId?: true
  }

  export type MagicItemFeatureSumAggregateInputType = {
    magicItemFeatureId?: true
    magicItemId?: true
    featureId?: true
  }

  export type MagicItemFeatureMinAggregateInputType = {
    magicItemFeatureId?: true
    magicItemId?: true
    featureId?: true
  }

  export type MagicItemFeatureMaxAggregateInputType = {
    magicItemFeatureId?: true
    magicItemId?: true
    featureId?: true
  }

  export type MagicItemFeatureCountAggregateInputType = {
    magicItemFeatureId?: true
    magicItemId?: true
    featureId?: true
    _all?: true
  }

  export type MagicItemFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicItemFeature to aggregate.
     */
    where?: MagicItemFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemFeatures to fetch.
     */
    orderBy?: MagicItemFeatureOrderByWithRelationInput | MagicItemFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MagicItemFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MagicItemFeatures
    **/
    _count?: true | MagicItemFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MagicItemFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MagicItemFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MagicItemFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MagicItemFeatureMaxAggregateInputType
  }

  export type GetMagicItemFeatureAggregateType<T extends MagicItemFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateMagicItemFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMagicItemFeature[P]>
      : GetScalarType<T[P], AggregateMagicItemFeature[P]>
  }




  export type MagicItemFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicItemFeatureWhereInput
    orderBy?: MagicItemFeatureOrderByWithAggregationInput | MagicItemFeatureOrderByWithAggregationInput[]
    by: MagicItemFeatureScalarFieldEnum[] | MagicItemFeatureScalarFieldEnum
    having?: MagicItemFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MagicItemFeatureCountAggregateInputType | true
    _avg?: MagicItemFeatureAvgAggregateInputType
    _sum?: MagicItemFeatureSumAggregateInputType
    _min?: MagicItemFeatureMinAggregateInputType
    _max?: MagicItemFeatureMaxAggregateInputType
  }

  export type MagicItemFeatureGroupByOutputType = {
    magicItemFeatureId: number
    magicItemId: number
    featureId: number
    _count: MagicItemFeatureCountAggregateOutputType | null
    _avg: MagicItemFeatureAvgAggregateOutputType | null
    _sum: MagicItemFeatureSumAggregateOutputType | null
    _min: MagicItemFeatureMinAggregateOutputType | null
    _max: MagicItemFeatureMaxAggregateOutputType | null
  }

  type GetMagicItemFeatureGroupByPayload<T extends MagicItemFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MagicItemFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MagicItemFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MagicItemFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], MagicItemFeatureGroupByOutputType[P]>
        }
      >
    >


  export type MagicItemFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    magicItemFeatureId?: boolean
    magicItemId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicItemFeature"]>

  export type MagicItemFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    magicItemFeatureId?: boolean
    magicItemId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicItemFeature"]>

  export type MagicItemFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    magicItemFeatureId?: boolean
    magicItemId?: boolean
    featureId?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicItemFeature"]>

  export type MagicItemFeatureSelectScalar = {
    magicItemFeatureId?: boolean
    magicItemId?: boolean
    featureId?: boolean
  }

  export type MagicItemFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"magicItemFeatureId" | "magicItemId" | "featureId", ExtArgs["result"]["magicItemFeature"]>
  export type MagicItemFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
  }
  export type MagicItemFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
  }
  export type MagicItemFeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
  }

  export type $MagicItemFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MagicItemFeature"
    objects: {
      feature: Prisma.$FeaturePayload<ExtArgs>
      magicItem: Prisma.$MagicItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      magicItemFeatureId: number
      magicItemId: number
      featureId: number
    }, ExtArgs["result"]["magicItemFeature"]>
    composites: {}
  }

  type MagicItemFeatureGetPayload<S extends boolean | null | undefined | MagicItemFeatureDefaultArgs> = $Result.GetResult<Prisma.$MagicItemFeaturePayload, S>

  type MagicItemFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MagicItemFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MagicItemFeatureCountAggregateInputType | true
    }

  export interface MagicItemFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MagicItemFeature'], meta: { name: 'MagicItemFeature' } }
    /**
     * Find zero or one MagicItemFeature that matches the filter.
     * @param {MagicItemFeatureFindUniqueArgs} args - Arguments to find a MagicItemFeature
     * @example
     * // Get one MagicItemFeature
     * const magicItemFeature = await prisma.magicItemFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MagicItemFeatureFindUniqueArgs>(args: SelectSubset<T, MagicItemFeatureFindUniqueArgs<ExtArgs>>): Prisma__MagicItemFeatureClient<$Result.GetResult<Prisma.$MagicItemFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MagicItemFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MagicItemFeatureFindUniqueOrThrowArgs} args - Arguments to find a MagicItemFeature
     * @example
     * // Get one MagicItemFeature
     * const magicItemFeature = await prisma.magicItemFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MagicItemFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, MagicItemFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MagicItemFeatureClient<$Result.GetResult<Prisma.$MagicItemFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MagicItemFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemFeatureFindFirstArgs} args - Arguments to find a MagicItemFeature
     * @example
     * // Get one MagicItemFeature
     * const magicItemFeature = await prisma.magicItemFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MagicItemFeatureFindFirstArgs>(args?: SelectSubset<T, MagicItemFeatureFindFirstArgs<ExtArgs>>): Prisma__MagicItemFeatureClient<$Result.GetResult<Prisma.$MagicItemFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MagicItemFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemFeatureFindFirstOrThrowArgs} args - Arguments to find a MagicItemFeature
     * @example
     * // Get one MagicItemFeature
     * const magicItemFeature = await prisma.magicItemFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MagicItemFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, MagicItemFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__MagicItemFeatureClient<$Result.GetResult<Prisma.$MagicItemFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MagicItemFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MagicItemFeatures
     * const magicItemFeatures = await prisma.magicItemFeature.findMany()
     * 
     * // Get first 10 MagicItemFeatures
     * const magicItemFeatures = await prisma.magicItemFeature.findMany({ take: 10 })
     * 
     * // Only select the `magicItemFeatureId`
     * const magicItemFeatureWithMagicItemFeatureIdOnly = await prisma.magicItemFeature.findMany({ select: { magicItemFeatureId: true } })
     * 
     */
    findMany<T extends MagicItemFeatureFindManyArgs>(args?: SelectSubset<T, MagicItemFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MagicItemFeature.
     * @param {MagicItemFeatureCreateArgs} args - Arguments to create a MagicItemFeature.
     * @example
     * // Create one MagicItemFeature
     * const MagicItemFeature = await prisma.magicItemFeature.create({
     *   data: {
     *     // ... data to create a MagicItemFeature
     *   }
     * })
     * 
     */
    create<T extends MagicItemFeatureCreateArgs>(args: SelectSubset<T, MagicItemFeatureCreateArgs<ExtArgs>>): Prisma__MagicItemFeatureClient<$Result.GetResult<Prisma.$MagicItemFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MagicItemFeatures.
     * @param {MagicItemFeatureCreateManyArgs} args - Arguments to create many MagicItemFeatures.
     * @example
     * // Create many MagicItemFeatures
     * const magicItemFeature = await prisma.magicItemFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MagicItemFeatureCreateManyArgs>(args?: SelectSubset<T, MagicItemFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MagicItemFeatures and returns the data saved in the database.
     * @param {MagicItemFeatureCreateManyAndReturnArgs} args - Arguments to create many MagicItemFeatures.
     * @example
     * // Create many MagicItemFeatures
     * const magicItemFeature = await prisma.magicItemFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MagicItemFeatures and only return the `magicItemFeatureId`
     * const magicItemFeatureWithMagicItemFeatureIdOnly = await prisma.magicItemFeature.createManyAndReturn({
     *   select: { magicItemFeatureId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MagicItemFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, MagicItemFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MagicItemFeature.
     * @param {MagicItemFeatureDeleteArgs} args - Arguments to delete one MagicItemFeature.
     * @example
     * // Delete one MagicItemFeature
     * const MagicItemFeature = await prisma.magicItemFeature.delete({
     *   where: {
     *     // ... filter to delete one MagicItemFeature
     *   }
     * })
     * 
     */
    delete<T extends MagicItemFeatureDeleteArgs>(args: SelectSubset<T, MagicItemFeatureDeleteArgs<ExtArgs>>): Prisma__MagicItemFeatureClient<$Result.GetResult<Prisma.$MagicItemFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MagicItemFeature.
     * @param {MagicItemFeatureUpdateArgs} args - Arguments to update one MagicItemFeature.
     * @example
     * // Update one MagicItemFeature
     * const magicItemFeature = await prisma.magicItemFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MagicItemFeatureUpdateArgs>(args: SelectSubset<T, MagicItemFeatureUpdateArgs<ExtArgs>>): Prisma__MagicItemFeatureClient<$Result.GetResult<Prisma.$MagicItemFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MagicItemFeatures.
     * @param {MagicItemFeatureDeleteManyArgs} args - Arguments to filter MagicItemFeatures to delete.
     * @example
     * // Delete a few MagicItemFeatures
     * const { count } = await prisma.magicItemFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MagicItemFeatureDeleteManyArgs>(args?: SelectSubset<T, MagicItemFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicItemFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MagicItemFeatures
     * const magicItemFeature = await prisma.magicItemFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MagicItemFeatureUpdateManyArgs>(args: SelectSubset<T, MagicItemFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicItemFeatures and returns the data updated in the database.
     * @param {MagicItemFeatureUpdateManyAndReturnArgs} args - Arguments to update many MagicItemFeatures.
     * @example
     * // Update many MagicItemFeatures
     * const magicItemFeature = await prisma.magicItemFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MagicItemFeatures and only return the `magicItemFeatureId`
     * const magicItemFeatureWithMagicItemFeatureIdOnly = await prisma.magicItemFeature.updateManyAndReturn({
     *   select: { magicItemFeatureId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MagicItemFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, MagicItemFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MagicItemFeature.
     * @param {MagicItemFeatureUpsertArgs} args - Arguments to update or create a MagicItemFeature.
     * @example
     * // Update or create a MagicItemFeature
     * const magicItemFeature = await prisma.magicItemFeature.upsert({
     *   create: {
     *     // ... data to create a MagicItemFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MagicItemFeature we want to update
     *   }
     * })
     */
    upsert<T extends MagicItemFeatureUpsertArgs>(args: SelectSubset<T, MagicItemFeatureUpsertArgs<ExtArgs>>): Prisma__MagicItemFeatureClient<$Result.GetResult<Prisma.$MagicItemFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MagicItemFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemFeatureCountArgs} args - Arguments to filter MagicItemFeatures to count.
     * @example
     * // Count the number of MagicItemFeatures
     * const count = await prisma.magicItemFeature.count({
     *   where: {
     *     // ... the filter for the MagicItemFeatures we want to count
     *   }
     * })
    **/
    count<T extends MagicItemFeatureCountArgs>(
      args?: Subset<T, MagicItemFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MagicItemFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MagicItemFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MagicItemFeatureAggregateArgs>(args: Subset<T, MagicItemFeatureAggregateArgs>): Prisma.PrismaPromise<GetMagicItemFeatureAggregateType<T>>

    /**
     * Group by MagicItemFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MagicItemFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MagicItemFeatureGroupByArgs['orderBy'] }
        : { orderBy?: MagicItemFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MagicItemFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMagicItemFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MagicItemFeature model
   */
  readonly fields: MagicItemFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MagicItemFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MagicItemFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feature<T extends FeatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureDefaultArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    magicItem<T extends MagicItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MagicItemDefaultArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MagicItemFeature model
   */
  interface MagicItemFeatureFieldRefs {
    readonly magicItemFeatureId: FieldRef<"MagicItemFeature", 'Int'>
    readonly magicItemId: FieldRef<"MagicItemFeature", 'Int'>
    readonly featureId: FieldRef<"MagicItemFeature", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MagicItemFeature findUnique
   */
  export type MagicItemFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemFeature
     */
    select?: MagicItemFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemFeature
     */
    omit?: MagicItemFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemFeatureInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemFeature to fetch.
     */
    where: MagicItemFeatureWhereUniqueInput
  }

  /**
   * MagicItemFeature findUniqueOrThrow
   */
  export type MagicItemFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemFeature
     */
    select?: MagicItemFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemFeature
     */
    omit?: MagicItemFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemFeatureInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemFeature to fetch.
     */
    where: MagicItemFeatureWhereUniqueInput
  }

  /**
   * MagicItemFeature findFirst
   */
  export type MagicItemFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemFeature
     */
    select?: MagicItemFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemFeature
     */
    omit?: MagicItemFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemFeatureInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemFeature to fetch.
     */
    where?: MagicItemFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemFeatures to fetch.
     */
    orderBy?: MagicItemFeatureOrderByWithRelationInput | MagicItemFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicItemFeatures.
     */
    cursor?: MagicItemFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicItemFeatures.
     */
    distinct?: MagicItemFeatureScalarFieldEnum | MagicItemFeatureScalarFieldEnum[]
  }

  /**
   * MagicItemFeature findFirstOrThrow
   */
  export type MagicItemFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemFeature
     */
    select?: MagicItemFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemFeature
     */
    omit?: MagicItemFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemFeatureInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemFeature to fetch.
     */
    where?: MagicItemFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemFeatures to fetch.
     */
    orderBy?: MagicItemFeatureOrderByWithRelationInput | MagicItemFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicItemFeatures.
     */
    cursor?: MagicItemFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicItemFeatures.
     */
    distinct?: MagicItemFeatureScalarFieldEnum | MagicItemFeatureScalarFieldEnum[]
  }

  /**
   * MagicItemFeature findMany
   */
  export type MagicItemFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemFeature
     */
    select?: MagicItemFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemFeature
     */
    omit?: MagicItemFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemFeatureInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemFeatures to fetch.
     */
    where?: MagicItemFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemFeatures to fetch.
     */
    orderBy?: MagicItemFeatureOrderByWithRelationInput | MagicItemFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MagicItemFeatures.
     */
    cursor?: MagicItemFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemFeatures.
     */
    skip?: number
    distinct?: MagicItemFeatureScalarFieldEnum | MagicItemFeatureScalarFieldEnum[]
  }

  /**
   * MagicItemFeature create
   */
  export type MagicItemFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemFeature
     */
    select?: MagicItemFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemFeature
     */
    omit?: MagicItemFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a MagicItemFeature.
     */
    data: XOR<MagicItemFeatureCreateInput, MagicItemFeatureUncheckedCreateInput>
  }

  /**
   * MagicItemFeature createMany
   */
  export type MagicItemFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MagicItemFeatures.
     */
    data: MagicItemFeatureCreateManyInput | MagicItemFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MagicItemFeature createManyAndReturn
   */
  export type MagicItemFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemFeature
     */
    select?: MagicItemFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemFeature
     */
    omit?: MagicItemFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many MagicItemFeatures.
     */
    data: MagicItemFeatureCreateManyInput | MagicItemFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MagicItemFeature update
   */
  export type MagicItemFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemFeature
     */
    select?: MagicItemFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemFeature
     */
    omit?: MagicItemFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a MagicItemFeature.
     */
    data: XOR<MagicItemFeatureUpdateInput, MagicItemFeatureUncheckedUpdateInput>
    /**
     * Choose, which MagicItemFeature to update.
     */
    where: MagicItemFeatureWhereUniqueInput
  }

  /**
   * MagicItemFeature updateMany
   */
  export type MagicItemFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MagicItemFeatures.
     */
    data: XOR<MagicItemFeatureUpdateManyMutationInput, MagicItemFeatureUncheckedUpdateManyInput>
    /**
     * Filter which MagicItemFeatures to update
     */
    where?: MagicItemFeatureWhereInput
    /**
     * Limit how many MagicItemFeatures to update.
     */
    limit?: number
  }

  /**
   * MagicItemFeature updateManyAndReturn
   */
  export type MagicItemFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemFeature
     */
    select?: MagicItemFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemFeature
     */
    omit?: MagicItemFeatureOmit<ExtArgs> | null
    /**
     * The data used to update MagicItemFeatures.
     */
    data: XOR<MagicItemFeatureUpdateManyMutationInput, MagicItemFeatureUncheckedUpdateManyInput>
    /**
     * Filter which MagicItemFeatures to update
     */
    where?: MagicItemFeatureWhereInput
    /**
     * Limit how many MagicItemFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemFeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MagicItemFeature upsert
   */
  export type MagicItemFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemFeature
     */
    select?: MagicItemFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemFeature
     */
    omit?: MagicItemFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the MagicItemFeature to update in case it exists.
     */
    where: MagicItemFeatureWhereUniqueInput
    /**
     * In case the MagicItemFeature found by the `where` argument doesn't exist, create a new MagicItemFeature with this data.
     */
    create: XOR<MagicItemFeatureCreateInput, MagicItemFeatureUncheckedCreateInput>
    /**
     * In case the MagicItemFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MagicItemFeatureUpdateInput, MagicItemFeatureUncheckedUpdateInput>
  }

  /**
   * MagicItemFeature delete
   */
  export type MagicItemFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemFeature
     */
    select?: MagicItemFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemFeature
     */
    omit?: MagicItemFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemFeatureInclude<ExtArgs> | null
    /**
     * Filter which MagicItemFeature to delete.
     */
    where: MagicItemFeatureWhereUniqueInput
  }

  /**
   * MagicItemFeature deleteMany
   */
  export type MagicItemFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicItemFeatures to delete
     */
    where?: MagicItemFeatureWhereInput
    /**
     * Limit how many MagicItemFeatures to delete.
     */
    limit?: number
  }

  /**
   * MagicItemFeature without action
   */
  export type MagicItemFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemFeature
     */
    select?: MagicItemFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemFeature
     */
    omit?: MagicItemFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemFeatureInclude<ExtArgs> | null
  }


  /**
   * Model Race
   */

  export type AggregateRace = {
    _count: RaceCountAggregateOutputType | null
    _avg: RaceAvgAggregateOutputType | null
    _sum: RaceSumAggregateOutputType | null
    _min: RaceMinAggregateOutputType | null
    _max: RaceMaxAggregateOutputType | null
  }

  export type RaceAvgAggregateOutputType = {
    raceId: number | null
    speed: number | null
    burrowSpeed: number | null
    flightSpeed: number | null
    swimSpeed: number | null
    climbSpeed: number | null
    ac: number | null
    languagesToChooseCount: number | null
  }

  export type RaceSumAggregateOutputType = {
    raceId: number | null
    speed: number | null
    burrowSpeed: number | null
    flightSpeed: number | null
    swimSpeed: number | null
    climbSpeed: number | null
    ac: number | null
    languagesToChooseCount: number | null
  }

  export type RaceMinAggregateOutputType = {
    raceId: number | null
    name: $Enums.Races | null
    speed: number | null
    burrowSpeed: number | null
    flightSpeed: number | null
    swimSpeed: number | null
    climbSpeed: number | null
    ac: number | null
    source: $Enums.Source | null
    languagesToChooseCount: number | null
  }

  export type RaceMaxAggregateOutputType = {
    raceId: number | null
    name: $Enums.Races | null
    speed: number | null
    burrowSpeed: number | null
    flightSpeed: number | null
    swimSpeed: number | null
    climbSpeed: number | null
    ac: number | null
    source: $Enums.Source | null
    languagesToChooseCount: number | null
  }

  export type RaceCountAggregateOutputType = {
    raceId: number
    name: number
    size: number
    speed: number
    burrowSpeed: number
    flightSpeed: number
    swimSpeed: number
    climbSpeed: number
    ac: number
    source: number
    languages: number
    languagesToChooseCount: number
    ASI: number
    toolProficiencies: number
    skillProficiencies: number
    weaponProficiencies: number
    armorProficiencies: number
    _all: number
  }


  export type RaceAvgAggregateInputType = {
    raceId?: true
    speed?: true
    burrowSpeed?: true
    flightSpeed?: true
    swimSpeed?: true
    climbSpeed?: true
    ac?: true
    languagesToChooseCount?: true
  }

  export type RaceSumAggregateInputType = {
    raceId?: true
    speed?: true
    burrowSpeed?: true
    flightSpeed?: true
    swimSpeed?: true
    climbSpeed?: true
    ac?: true
    languagesToChooseCount?: true
  }

  export type RaceMinAggregateInputType = {
    raceId?: true
    name?: true
    speed?: true
    burrowSpeed?: true
    flightSpeed?: true
    swimSpeed?: true
    climbSpeed?: true
    ac?: true
    source?: true
    languagesToChooseCount?: true
  }

  export type RaceMaxAggregateInputType = {
    raceId?: true
    name?: true
    speed?: true
    burrowSpeed?: true
    flightSpeed?: true
    swimSpeed?: true
    climbSpeed?: true
    ac?: true
    source?: true
    languagesToChooseCount?: true
  }

  export type RaceCountAggregateInputType = {
    raceId?: true
    name?: true
    size?: true
    speed?: true
    burrowSpeed?: true
    flightSpeed?: true
    swimSpeed?: true
    climbSpeed?: true
    ac?: true
    source?: true
    languages?: true
    languagesToChooseCount?: true
    ASI?: true
    toolProficiencies?: true
    skillProficiencies?: true
    weaponProficiencies?: true
    armorProficiencies?: true
    _all?: true
  }

  export type RaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Race to aggregate.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Races
    **/
    _count?: true | RaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceMaxAggregateInputType
  }

  export type GetRaceAggregateType<T extends RaceAggregateArgs> = {
        [P in keyof T & keyof AggregateRace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRace[P]>
      : GetScalarType<T[P], AggregateRace[P]>
  }




  export type RaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceWhereInput
    orderBy?: RaceOrderByWithAggregationInput | RaceOrderByWithAggregationInput[]
    by: RaceScalarFieldEnum[] | RaceScalarFieldEnum
    having?: RaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceCountAggregateInputType | true
    _avg?: RaceAvgAggregateInputType
    _sum?: RaceSumAggregateInputType
    _min?: RaceMinAggregateInputType
    _max?: RaceMaxAggregateInputType
  }

  export type RaceGroupByOutputType = {
    raceId: number
    name: $Enums.Races
    size: $Enums.Size[]
    speed: number
    burrowSpeed: number
    flightSpeed: number
    swimSpeed: number
    climbSpeed: number
    ac: number
    source: $Enums.Source
    languages: $Enums.Language[]
    languagesToChooseCount: number
    ASI: JsonValue
    toolProficiencies: $Enums.ToolCategory[]
    skillProficiencies: $Enums.Skills[]
    weaponProficiencies: $Enums.WeaponCategory[]
    armorProficiencies: $Enums.ArmorType[]
    _count: RaceCountAggregateOutputType | null
    _avg: RaceAvgAggregateOutputType | null
    _sum: RaceSumAggregateOutputType | null
    _min: RaceMinAggregateOutputType | null
    _max: RaceMaxAggregateOutputType | null
  }

  type GetRaceGroupByPayload<T extends RaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceGroupByOutputType[P]>
            : GetScalarType<T[P], RaceGroupByOutputType[P]>
        }
      >
    >


  export type RaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceId?: boolean
    name?: boolean
    size?: boolean
    speed?: boolean
    burrowSpeed?: boolean
    flightSpeed?: boolean
    swimSpeed?: boolean
    climbSpeed?: boolean
    ac?: boolean
    source?: boolean
    languages?: boolean
    languagesToChooseCount?: boolean
    ASI?: boolean
    toolProficiencies?: boolean
    skillProficiencies?: boolean
    weaponProficiencies?: boolean
    armorProficiencies?: boolean
    subraces?: boolean | Race$subracesArgs<ExtArgs>
    perses?: boolean | Race$persesArgs<ExtArgs>
    raceChoiceOptions?: boolean | Race$raceChoiceOptionsArgs<ExtArgs>
    raceVariants?: boolean | Race$raceVariantsArgs<ExtArgs>
    traits?: boolean | Race$traitsArgs<ExtArgs>
    _count?: boolean | RaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["race"]>

  export type RaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceId?: boolean
    name?: boolean
    size?: boolean
    speed?: boolean
    burrowSpeed?: boolean
    flightSpeed?: boolean
    swimSpeed?: boolean
    climbSpeed?: boolean
    ac?: boolean
    source?: boolean
    languages?: boolean
    languagesToChooseCount?: boolean
    ASI?: boolean
    toolProficiencies?: boolean
    skillProficiencies?: boolean
    weaponProficiencies?: boolean
    armorProficiencies?: boolean
  }, ExtArgs["result"]["race"]>

  export type RaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceId?: boolean
    name?: boolean
    size?: boolean
    speed?: boolean
    burrowSpeed?: boolean
    flightSpeed?: boolean
    swimSpeed?: boolean
    climbSpeed?: boolean
    ac?: boolean
    source?: boolean
    languages?: boolean
    languagesToChooseCount?: boolean
    ASI?: boolean
    toolProficiencies?: boolean
    skillProficiencies?: boolean
    weaponProficiencies?: boolean
    armorProficiencies?: boolean
  }, ExtArgs["result"]["race"]>

  export type RaceSelectScalar = {
    raceId?: boolean
    name?: boolean
    size?: boolean
    speed?: boolean
    burrowSpeed?: boolean
    flightSpeed?: boolean
    swimSpeed?: boolean
    climbSpeed?: boolean
    ac?: boolean
    source?: boolean
    languages?: boolean
    languagesToChooseCount?: boolean
    ASI?: boolean
    toolProficiencies?: boolean
    skillProficiencies?: boolean
    weaponProficiencies?: boolean
    armorProficiencies?: boolean
  }

  export type RaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"raceId" | "name" | "size" | "speed" | "burrowSpeed" | "flightSpeed" | "swimSpeed" | "climbSpeed" | "ac" | "source" | "languages" | "languagesToChooseCount" | "ASI" | "toolProficiencies" | "skillProficiencies" | "weaponProficiencies" | "armorProficiencies", ExtArgs["result"]["race"]>
  export type RaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subraces?: boolean | Race$subracesArgs<ExtArgs>
    perses?: boolean | Race$persesArgs<ExtArgs>
    raceChoiceOptions?: boolean | Race$raceChoiceOptionsArgs<ExtArgs>
    raceVariants?: boolean | Race$raceVariantsArgs<ExtArgs>
    traits?: boolean | Race$traitsArgs<ExtArgs>
    _count?: boolean | RaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Race"
    objects: {
      subraces: Prisma.$SubracePayload<ExtArgs>[]
      perses: Prisma.$PersPayload<ExtArgs>[]
      raceChoiceOptions: Prisma.$RaceChoiceOptionPayload<ExtArgs>[]
      raceVariants: Prisma.$RaceVariantPayload<ExtArgs>[]
      traits: Prisma.$RaceTraitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      raceId: number
      name: $Enums.Races
      size: $Enums.Size[]
      speed: number
      burrowSpeed: number
      flightSpeed: number
      swimSpeed: number
      climbSpeed: number
      ac: number
      source: $Enums.Source
      languages: $Enums.Language[]
      languagesToChooseCount: number
      ASI: Prisma.JsonValue
      toolProficiencies: $Enums.ToolCategory[]
      skillProficiencies: $Enums.Skills[]
      weaponProficiencies: $Enums.WeaponCategory[]
      armorProficiencies: $Enums.ArmorType[]
    }, ExtArgs["result"]["race"]>
    composites: {}
  }

  type RaceGetPayload<S extends boolean | null | undefined | RaceDefaultArgs> = $Result.GetResult<Prisma.$RacePayload, S>

  type RaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceCountAggregateInputType | true
    }

  export interface RaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Race'], meta: { name: 'Race' } }
    /**
     * Find zero or one Race that matches the filter.
     * @param {RaceFindUniqueArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceFindUniqueArgs>(args: SelectSubset<T, RaceFindUniqueArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Race that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceFindUniqueOrThrowArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Race that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindFirstArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceFindFirstArgs>(args?: SelectSubset<T, RaceFindFirstArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Race that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindFirstOrThrowArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Races that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Races
     * const races = await prisma.race.findMany()
     * 
     * // Get first 10 Races
     * const races = await prisma.race.findMany({ take: 10 })
     * 
     * // Only select the `raceId`
     * const raceWithRaceIdOnly = await prisma.race.findMany({ select: { raceId: true } })
     * 
     */
    findMany<T extends RaceFindManyArgs>(args?: SelectSubset<T, RaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Race.
     * @param {RaceCreateArgs} args - Arguments to create a Race.
     * @example
     * // Create one Race
     * const Race = await prisma.race.create({
     *   data: {
     *     // ... data to create a Race
     *   }
     * })
     * 
     */
    create<T extends RaceCreateArgs>(args: SelectSubset<T, RaceCreateArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Races.
     * @param {RaceCreateManyArgs} args - Arguments to create many Races.
     * @example
     * // Create many Races
     * const race = await prisma.race.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceCreateManyArgs>(args?: SelectSubset<T, RaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Races and returns the data saved in the database.
     * @param {RaceCreateManyAndReturnArgs} args - Arguments to create many Races.
     * @example
     * // Create many Races
     * const race = await prisma.race.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Races and only return the `raceId`
     * const raceWithRaceIdOnly = await prisma.race.createManyAndReturn({
     *   select: { raceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaceCreateManyAndReturnArgs>(args?: SelectSubset<T, RaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Race.
     * @param {RaceDeleteArgs} args - Arguments to delete one Race.
     * @example
     * // Delete one Race
     * const Race = await prisma.race.delete({
     *   where: {
     *     // ... filter to delete one Race
     *   }
     * })
     * 
     */
    delete<T extends RaceDeleteArgs>(args: SelectSubset<T, RaceDeleteArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Race.
     * @param {RaceUpdateArgs} args - Arguments to update one Race.
     * @example
     * // Update one Race
     * const race = await prisma.race.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceUpdateArgs>(args: SelectSubset<T, RaceUpdateArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Races.
     * @param {RaceDeleteManyArgs} args - Arguments to filter Races to delete.
     * @example
     * // Delete a few Races
     * const { count } = await prisma.race.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceDeleteManyArgs>(args?: SelectSubset<T, RaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Races.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Races
     * const race = await prisma.race.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceUpdateManyArgs>(args: SelectSubset<T, RaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Races and returns the data updated in the database.
     * @param {RaceUpdateManyAndReturnArgs} args - Arguments to update many Races.
     * @example
     * // Update many Races
     * const race = await prisma.race.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Races and only return the `raceId`
     * const raceWithRaceIdOnly = await prisma.race.updateManyAndReturn({
     *   select: { raceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaceUpdateManyAndReturnArgs>(args: SelectSubset<T, RaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Race.
     * @param {RaceUpsertArgs} args - Arguments to update or create a Race.
     * @example
     * // Update or create a Race
     * const race = await prisma.race.upsert({
     *   create: {
     *     // ... data to create a Race
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Race we want to update
     *   }
     * })
     */
    upsert<T extends RaceUpsertArgs>(args: SelectSubset<T, RaceUpsertArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Races.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceCountArgs} args - Arguments to filter Races to count.
     * @example
     * // Count the number of Races
     * const count = await prisma.race.count({
     *   where: {
     *     // ... the filter for the Races we want to count
     *   }
     * })
    **/
    count<T extends RaceCountArgs>(
      args?: Subset<T, RaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Race.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceAggregateArgs>(args: Subset<T, RaceAggregateArgs>): Prisma.PrismaPromise<GetRaceAggregateType<T>>

    /**
     * Group by Race.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceGroupByArgs['orderBy'] }
        : { orderBy?: RaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Race model
   */
  readonly fields: RaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Race.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subraces<T extends Race$subracesArgs<ExtArgs> = {}>(args?: Subset<T, Race$subracesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    perses<T extends Race$persesArgs<ExtArgs> = {}>(args?: Subset<T, Race$persesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    raceChoiceOptions<T extends Race$raceChoiceOptionsArgs<ExtArgs> = {}>(args?: Subset<T, Race$raceChoiceOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceChoiceOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    raceVariants<T extends Race$raceVariantsArgs<ExtArgs> = {}>(args?: Subset<T, Race$raceVariantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    traits<T extends Race$traitsArgs<ExtArgs> = {}>(args?: Subset<T, Race$traitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Race model
   */
  interface RaceFieldRefs {
    readonly raceId: FieldRef<"Race", 'Int'>
    readonly name: FieldRef<"Race", 'Races'>
    readonly size: FieldRef<"Race", 'Size[]'>
    readonly speed: FieldRef<"Race", 'Int'>
    readonly burrowSpeed: FieldRef<"Race", 'Int'>
    readonly flightSpeed: FieldRef<"Race", 'Int'>
    readonly swimSpeed: FieldRef<"Race", 'Int'>
    readonly climbSpeed: FieldRef<"Race", 'Int'>
    readonly ac: FieldRef<"Race", 'Int'>
    readonly source: FieldRef<"Race", 'Source'>
    readonly languages: FieldRef<"Race", 'Language[]'>
    readonly languagesToChooseCount: FieldRef<"Race", 'Int'>
    readonly ASI: FieldRef<"Race", 'Json'>
    readonly toolProficiencies: FieldRef<"Race", 'ToolCategory[]'>
    readonly skillProficiencies: FieldRef<"Race", 'Skills[]'>
    readonly weaponProficiencies: FieldRef<"Race", 'WeaponCategory[]'>
    readonly armorProficiencies: FieldRef<"Race", 'ArmorType[]'>
  }
    

  // Custom InputTypes
  /**
   * Race findUnique
   */
  export type RaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race findUniqueOrThrow
   */
  export type RaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race findFirst
   */
  export type RaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Races.
     */
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race findFirstOrThrow
   */
  export type RaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Races.
     */
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race findMany
   */
  export type RaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Races to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race create
   */
  export type RaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Race.
     */
    data: XOR<RaceCreateInput, RaceUncheckedCreateInput>
  }

  /**
   * Race createMany
   */
  export type RaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Races.
     */
    data: RaceCreateManyInput | RaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Race createManyAndReturn
   */
  export type RaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * The data used to create many Races.
     */
    data: RaceCreateManyInput | RaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Race update
   */
  export type RaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Race.
     */
    data: XOR<RaceUpdateInput, RaceUncheckedUpdateInput>
    /**
     * Choose, which Race to update.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race updateMany
   */
  export type RaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Races.
     */
    data: XOR<RaceUpdateManyMutationInput, RaceUncheckedUpdateManyInput>
    /**
     * Filter which Races to update
     */
    where?: RaceWhereInput
    /**
     * Limit how many Races to update.
     */
    limit?: number
  }

  /**
   * Race updateManyAndReturn
   */
  export type RaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * The data used to update Races.
     */
    data: XOR<RaceUpdateManyMutationInput, RaceUncheckedUpdateManyInput>
    /**
     * Filter which Races to update
     */
    where?: RaceWhereInput
    /**
     * Limit how many Races to update.
     */
    limit?: number
  }

  /**
   * Race upsert
   */
  export type RaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Race to update in case it exists.
     */
    where: RaceWhereUniqueInput
    /**
     * In case the Race found by the `where` argument doesn't exist, create a new Race with this data.
     */
    create: XOR<RaceCreateInput, RaceUncheckedCreateInput>
    /**
     * In case the Race was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceUpdateInput, RaceUncheckedUpdateInput>
  }

  /**
   * Race delete
   */
  export type RaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter which Race to delete.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race deleteMany
   */
  export type RaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Races to delete
     */
    where?: RaceWhereInput
    /**
     * Limit how many Races to delete.
     */
    limit?: number
  }

  /**
   * Race.subraces
   */
  export type Race$subracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceInclude<ExtArgs> | null
    where?: SubraceWhereInput
    orderBy?: SubraceOrderByWithRelationInput | SubraceOrderByWithRelationInput[]
    cursor?: SubraceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubraceScalarFieldEnum | SubraceScalarFieldEnum[]
  }

  /**
   * Race.perses
   */
  export type Race$persesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    where?: PersWhereInput
    orderBy?: PersOrderByWithRelationInput | PersOrderByWithRelationInput[]
    cursor?: PersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersScalarFieldEnum | PersScalarFieldEnum[]
  }

  /**
   * Race.raceChoiceOptions
   */
  export type Race$raceChoiceOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOption
     */
    select?: RaceChoiceOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOption
     */
    omit?: RaceChoiceOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionInclude<ExtArgs> | null
    where?: RaceChoiceOptionWhereInput
    orderBy?: RaceChoiceOptionOrderByWithRelationInput | RaceChoiceOptionOrderByWithRelationInput[]
    cursor?: RaceChoiceOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceChoiceOptionScalarFieldEnum | RaceChoiceOptionScalarFieldEnum[]
  }

  /**
   * Race.raceVariants
   */
  export type Race$raceVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariant
     */
    select?: RaceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariant
     */
    omit?: RaceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantInclude<ExtArgs> | null
    where?: RaceVariantWhereInput
    orderBy?: RaceVariantOrderByWithRelationInput | RaceVariantOrderByWithRelationInput[]
    cursor?: RaceVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceVariantScalarFieldEnum | RaceVariantScalarFieldEnum[]
  }

  /**
   * Race.traits
   */
  export type Race$traitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    where?: RaceTraitWhereInput
    orderBy?: RaceTraitOrderByWithRelationInput | RaceTraitOrderByWithRelationInput[]
    cursor?: RaceTraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceTraitScalarFieldEnum | RaceTraitScalarFieldEnum[]
  }

  /**
   * Race without action
   */
  export type RaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Race
     */
    omit?: RaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
  }


  /**
   * Model Subrace
   */

  export type AggregateSubrace = {
    _count: SubraceCountAggregateOutputType | null
    _avg: SubraceAvgAggregateOutputType | null
    _sum: SubraceSumAggregateOutputType | null
    _min: SubraceMinAggregateOutputType | null
    _max: SubraceMaxAggregateOutputType | null
  }

  export type SubraceAvgAggregateOutputType = {
    subraceId: number | null
    raceId: number | null
    speedModifier: number | null
    languagesToChooseCount: number | null
  }

  export type SubraceSumAggregateOutputType = {
    subraceId: number | null
    raceId: number | null
    speedModifier: number | null
    languagesToChooseCount: number | null
  }

  export type SubraceMinAggregateOutputType = {
    subraceId: number | null
    raceId: number | null
    name: $Enums.Subraces | null
    speedModifier: number | null
    source: $Enums.Source | null
    replacesASI: boolean | null
    languagesToChooseCount: number | null
  }

  export type SubraceMaxAggregateOutputType = {
    subraceId: number | null
    raceId: number | null
    name: $Enums.Subraces | null
    speedModifier: number | null
    source: $Enums.Source | null
    replacesASI: boolean | null
    languagesToChooseCount: number | null
  }

  export type SubraceCountAggregateOutputType = {
    subraceId: number
    raceId: number
    name: number
    speedModifier: number
    source: number
    replacesASI: number
    additionalASI: number
    additionalLanguages: number
    languagesToChooseCount: number
    toolProficiencies: number
    skillProficiencies: number
    weaponProficiencies: number
    armorProficiencies: number
    _all: number
  }


  export type SubraceAvgAggregateInputType = {
    subraceId?: true
    raceId?: true
    speedModifier?: true
    languagesToChooseCount?: true
  }

  export type SubraceSumAggregateInputType = {
    subraceId?: true
    raceId?: true
    speedModifier?: true
    languagesToChooseCount?: true
  }

  export type SubraceMinAggregateInputType = {
    subraceId?: true
    raceId?: true
    name?: true
    speedModifier?: true
    source?: true
    replacesASI?: true
    languagesToChooseCount?: true
  }

  export type SubraceMaxAggregateInputType = {
    subraceId?: true
    raceId?: true
    name?: true
    speedModifier?: true
    source?: true
    replacesASI?: true
    languagesToChooseCount?: true
  }

  export type SubraceCountAggregateInputType = {
    subraceId?: true
    raceId?: true
    name?: true
    speedModifier?: true
    source?: true
    replacesASI?: true
    additionalASI?: true
    additionalLanguages?: true
    languagesToChooseCount?: true
    toolProficiencies?: true
    skillProficiencies?: true
    weaponProficiencies?: true
    armorProficiencies?: true
    _all?: true
  }

  export type SubraceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subrace to aggregate.
     */
    where?: SubraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subraces to fetch.
     */
    orderBy?: SubraceOrderByWithRelationInput | SubraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subraces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subraces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subraces
    **/
    _count?: true | SubraceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubraceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubraceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubraceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubraceMaxAggregateInputType
  }

  export type GetSubraceAggregateType<T extends SubraceAggregateArgs> = {
        [P in keyof T & keyof AggregateSubrace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubrace[P]>
      : GetScalarType<T[P], AggregateSubrace[P]>
  }




  export type SubraceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubraceWhereInput
    orderBy?: SubraceOrderByWithAggregationInput | SubraceOrderByWithAggregationInput[]
    by: SubraceScalarFieldEnum[] | SubraceScalarFieldEnum
    having?: SubraceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubraceCountAggregateInputType | true
    _avg?: SubraceAvgAggregateInputType
    _sum?: SubraceSumAggregateInputType
    _min?: SubraceMinAggregateInputType
    _max?: SubraceMaxAggregateInputType
  }

  export type SubraceGroupByOutputType = {
    subraceId: number
    raceId: number
    name: $Enums.Subraces
    speedModifier: number | null
    source: $Enums.Source
    replacesASI: boolean
    additionalASI: JsonValue | null
    additionalLanguages: $Enums.Language[]
    languagesToChooseCount: number
    toolProficiencies: $Enums.ToolCategory[]
    skillProficiencies: JsonValue | null
    weaponProficiencies: $Enums.WeaponCategory[]
    armorProficiencies: $Enums.ArmorType[]
    _count: SubraceCountAggregateOutputType | null
    _avg: SubraceAvgAggregateOutputType | null
    _sum: SubraceSumAggregateOutputType | null
    _min: SubraceMinAggregateOutputType | null
    _max: SubraceMaxAggregateOutputType | null
  }

  type GetSubraceGroupByPayload<T extends SubraceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubraceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubraceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubraceGroupByOutputType[P]>
            : GetScalarType<T[P], SubraceGroupByOutputType[P]>
        }
      >
    >


  export type SubraceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subraceId?: boolean
    raceId?: boolean
    name?: boolean
    speedModifier?: boolean
    source?: boolean
    replacesASI?: boolean
    additionalASI?: boolean
    additionalLanguages?: boolean
    languagesToChooseCount?: boolean
    toolProficiencies?: boolean
    skillProficiencies?: boolean
    weaponProficiencies?: boolean
    armorProficiencies?: boolean
    replacesTraits?: boolean | Subrace$replacesTraitsArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    perses?: boolean | Subrace$persesArgs<ExtArgs>
    raceChoiceOptions?: boolean | Subrace$raceChoiceOptionsArgs<ExtArgs>
    traits?: boolean | Subrace$traitsArgs<ExtArgs>
    _count?: boolean | SubraceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subrace"]>

  export type SubraceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subraceId?: boolean
    raceId?: boolean
    name?: boolean
    speedModifier?: boolean
    source?: boolean
    replacesASI?: boolean
    additionalASI?: boolean
    additionalLanguages?: boolean
    languagesToChooseCount?: boolean
    toolProficiencies?: boolean
    skillProficiencies?: boolean
    weaponProficiencies?: boolean
    armorProficiencies?: boolean
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subrace"]>

  export type SubraceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subraceId?: boolean
    raceId?: boolean
    name?: boolean
    speedModifier?: boolean
    source?: boolean
    replacesASI?: boolean
    additionalASI?: boolean
    additionalLanguages?: boolean
    languagesToChooseCount?: boolean
    toolProficiencies?: boolean
    skillProficiencies?: boolean
    weaponProficiencies?: boolean
    armorProficiencies?: boolean
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subrace"]>

  export type SubraceSelectScalar = {
    subraceId?: boolean
    raceId?: boolean
    name?: boolean
    speedModifier?: boolean
    source?: boolean
    replacesASI?: boolean
    additionalASI?: boolean
    additionalLanguages?: boolean
    languagesToChooseCount?: boolean
    toolProficiencies?: boolean
    skillProficiencies?: boolean
    weaponProficiencies?: boolean
    armorProficiencies?: boolean
  }

  export type SubraceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"subraceId" | "raceId" | "name" | "speedModifier" | "source" | "replacesASI" | "additionalASI" | "additionalLanguages" | "languagesToChooseCount" | "toolProficiencies" | "skillProficiencies" | "weaponProficiencies" | "armorProficiencies", ExtArgs["result"]["subrace"]>
  export type SubraceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replacesTraits?: boolean | Subrace$replacesTraitsArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    perses?: boolean | Subrace$persesArgs<ExtArgs>
    raceChoiceOptions?: boolean | Subrace$raceChoiceOptionsArgs<ExtArgs>
    traits?: boolean | Subrace$traitsArgs<ExtArgs>
    _count?: boolean | SubraceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubraceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }
  export type SubraceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }

  export type $SubracePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subrace"
    objects: {
      replacesTraits: Prisma.$RaceTraitPayload<ExtArgs>[]
      race: Prisma.$RacePayload<ExtArgs>
      perses: Prisma.$PersPayload<ExtArgs>[]
      raceChoiceOptions: Prisma.$RaceChoiceOptionPayload<ExtArgs>[]
      traits: Prisma.$SubraceTraitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      subraceId: number
      raceId: number
      name: $Enums.Subraces
      speedModifier: number | null
      source: $Enums.Source
      replacesASI: boolean
      additionalASI: Prisma.JsonValue | null
      additionalLanguages: $Enums.Language[]
      languagesToChooseCount: number
      toolProficiencies: $Enums.ToolCategory[]
      skillProficiencies: Prisma.JsonValue | null
      weaponProficiencies: $Enums.WeaponCategory[]
      armorProficiencies: $Enums.ArmorType[]
    }, ExtArgs["result"]["subrace"]>
    composites: {}
  }

  type SubraceGetPayload<S extends boolean | null | undefined | SubraceDefaultArgs> = $Result.GetResult<Prisma.$SubracePayload, S>

  type SubraceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubraceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubraceCountAggregateInputType | true
    }

  export interface SubraceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subrace'], meta: { name: 'Subrace' } }
    /**
     * Find zero or one Subrace that matches the filter.
     * @param {SubraceFindUniqueArgs} args - Arguments to find a Subrace
     * @example
     * // Get one Subrace
     * const subrace = await prisma.subrace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubraceFindUniqueArgs>(args: SelectSubset<T, SubraceFindUniqueArgs<ExtArgs>>): Prisma__SubraceClient<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subrace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubraceFindUniqueOrThrowArgs} args - Arguments to find a Subrace
     * @example
     * // Get one Subrace
     * const subrace = await prisma.subrace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubraceFindUniqueOrThrowArgs>(args: SelectSubset<T, SubraceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubraceClient<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subrace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubraceFindFirstArgs} args - Arguments to find a Subrace
     * @example
     * // Get one Subrace
     * const subrace = await prisma.subrace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubraceFindFirstArgs>(args?: SelectSubset<T, SubraceFindFirstArgs<ExtArgs>>): Prisma__SubraceClient<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subrace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubraceFindFirstOrThrowArgs} args - Arguments to find a Subrace
     * @example
     * // Get one Subrace
     * const subrace = await prisma.subrace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubraceFindFirstOrThrowArgs>(args?: SelectSubset<T, SubraceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubraceClient<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subraces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubraceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subraces
     * const subraces = await prisma.subrace.findMany()
     * 
     * // Get first 10 Subraces
     * const subraces = await prisma.subrace.findMany({ take: 10 })
     * 
     * // Only select the `subraceId`
     * const subraceWithSubraceIdOnly = await prisma.subrace.findMany({ select: { subraceId: true } })
     * 
     */
    findMany<T extends SubraceFindManyArgs>(args?: SelectSubset<T, SubraceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subrace.
     * @param {SubraceCreateArgs} args - Arguments to create a Subrace.
     * @example
     * // Create one Subrace
     * const Subrace = await prisma.subrace.create({
     *   data: {
     *     // ... data to create a Subrace
     *   }
     * })
     * 
     */
    create<T extends SubraceCreateArgs>(args: SelectSubset<T, SubraceCreateArgs<ExtArgs>>): Prisma__SubraceClient<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subraces.
     * @param {SubraceCreateManyArgs} args - Arguments to create many Subraces.
     * @example
     * // Create many Subraces
     * const subrace = await prisma.subrace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubraceCreateManyArgs>(args?: SelectSubset<T, SubraceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subraces and returns the data saved in the database.
     * @param {SubraceCreateManyAndReturnArgs} args - Arguments to create many Subraces.
     * @example
     * // Create many Subraces
     * const subrace = await prisma.subrace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subraces and only return the `subraceId`
     * const subraceWithSubraceIdOnly = await prisma.subrace.createManyAndReturn({
     *   select: { subraceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubraceCreateManyAndReturnArgs>(args?: SelectSubset<T, SubraceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subrace.
     * @param {SubraceDeleteArgs} args - Arguments to delete one Subrace.
     * @example
     * // Delete one Subrace
     * const Subrace = await prisma.subrace.delete({
     *   where: {
     *     // ... filter to delete one Subrace
     *   }
     * })
     * 
     */
    delete<T extends SubraceDeleteArgs>(args: SelectSubset<T, SubraceDeleteArgs<ExtArgs>>): Prisma__SubraceClient<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subrace.
     * @param {SubraceUpdateArgs} args - Arguments to update one Subrace.
     * @example
     * // Update one Subrace
     * const subrace = await prisma.subrace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubraceUpdateArgs>(args: SelectSubset<T, SubraceUpdateArgs<ExtArgs>>): Prisma__SubraceClient<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subraces.
     * @param {SubraceDeleteManyArgs} args - Arguments to filter Subraces to delete.
     * @example
     * // Delete a few Subraces
     * const { count } = await prisma.subrace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubraceDeleteManyArgs>(args?: SelectSubset<T, SubraceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subraces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubraceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subraces
     * const subrace = await prisma.subrace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubraceUpdateManyArgs>(args: SelectSubset<T, SubraceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subraces and returns the data updated in the database.
     * @param {SubraceUpdateManyAndReturnArgs} args - Arguments to update many Subraces.
     * @example
     * // Update many Subraces
     * const subrace = await prisma.subrace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subraces and only return the `subraceId`
     * const subraceWithSubraceIdOnly = await prisma.subrace.updateManyAndReturn({
     *   select: { subraceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubraceUpdateManyAndReturnArgs>(args: SelectSubset<T, SubraceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subrace.
     * @param {SubraceUpsertArgs} args - Arguments to update or create a Subrace.
     * @example
     * // Update or create a Subrace
     * const subrace = await prisma.subrace.upsert({
     *   create: {
     *     // ... data to create a Subrace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subrace we want to update
     *   }
     * })
     */
    upsert<T extends SubraceUpsertArgs>(args: SelectSubset<T, SubraceUpsertArgs<ExtArgs>>): Prisma__SubraceClient<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subraces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubraceCountArgs} args - Arguments to filter Subraces to count.
     * @example
     * // Count the number of Subraces
     * const count = await prisma.subrace.count({
     *   where: {
     *     // ... the filter for the Subraces we want to count
     *   }
     * })
    **/
    count<T extends SubraceCountArgs>(
      args?: Subset<T, SubraceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubraceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subrace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubraceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubraceAggregateArgs>(args: Subset<T, SubraceAggregateArgs>): Prisma.PrismaPromise<GetSubraceAggregateType<T>>

    /**
     * Group by Subrace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubraceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubraceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubraceGroupByArgs['orderBy'] }
        : { orderBy?: SubraceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubraceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubraceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subrace model
   */
  readonly fields: SubraceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subrace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubraceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    replacesTraits<T extends Subrace$replacesTraitsArgs<ExtArgs> = {}>(args?: Subset<T, Subrace$replacesTraitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    race<T extends RaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceDefaultArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    perses<T extends Subrace$persesArgs<ExtArgs> = {}>(args?: Subset<T, Subrace$persesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    raceChoiceOptions<T extends Subrace$raceChoiceOptionsArgs<ExtArgs> = {}>(args?: Subset<T, Subrace$raceChoiceOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceChoiceOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    traits<T extends Subrace$traitsArgs<ExtArgs> = {}>(args?: Subset<T, Subrace$traitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubraceTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subrace model
   */
  interface SubraceFieldRefs {
    readonly subraceId: FieldRef<"Subrace", 'Int'>
    readonly raceId: FieldRef<"Subrace", 'Int'>
    readonly name: FieldRef<"Subrace", 'Subraces'>
    readonly speedModifier: FieldRef<"Subrace", 'Int'>
    readonly source: FieldRef<"Subrace", 'Source'>
    readonly replacesASI: FieldRef<"Subrace", 'Boolean'>
    readonly additionalASI: FieldRef<"Subrace", 'Json'>
    readonly additionalLanguages: FieldRef<"Subrace", 'Language[]'>
    readonly languagesToChooseCount: FieldRef<"Subrace", 'Int'>
    readonly toolProficiencies: FieldRef<"Subrace", 'ToolCategory[]'>
    readonly skillProficiencies: FieldRef<"Subrace", 'Json'>
    readonly weaponProficiencies: FieldRef<"Subrace", 'WeaponCategory[]'>
    readonly armorProficiencies: FieldRef<"Subrace", 'ArmorType[]'>
  }
    

  // Custom InputTypes
  /**
   * Subrace findUnique
   */
  export type SubraceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceInclude<ExtArgs> | null
    /**
     * Filter, which Subrace to fetch.
     */
    where: SubraceWhereUniqueInput
  }

  /**
   * Subrace findUniqueOrThrow
   */
  export type SubraceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceInclude<ExtArgs> | null
    /**
     * Filter, which Subrace to fetch.
     */
    where: SubraceWhereUniqueInput
  }

  /**
   * Subrace findFirst
   */
  export type SubraceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceInclude<ExtArgs> | null
    /**
     * Filter, which Subrace to fetch.
     */
    where?: SubraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subraces to fetch.
     */
    orderBy?: SubraceOrderByWithRelationInput | SubraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subraces.
     */
    cursor?: SubraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subraces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subraces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subraces.
     */
    distinct?: SubraceScalarFieldEnum | SubraceScalarFieldEnum[]
  }

  /**
   * Subrace findFirstOrThrow
   */
  export type SubraceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceInclude<ExtArgs> | null
    /**
     * Filter, which Subrace to fetch.
     */
    where?: SubraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subraces to fetch.
     */
    orderBy?: SubraceOrderByWithRelationInput | SubraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subraces.
     */
    cursor?: SubraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subraces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subraces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subraces.
     */
    distinct?: SubraceScalarFieldEnum | SubraceScalarFieldEnum[]
  }

  /**
   * Subrace findMany
   */
  export type SubraceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceInclude<ExtArgs> | null
    /**
     * Filter, which Subraces to fetch.
     */
    where?: SubraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subraces to fetch.
     */
    orderBy?: SubraceOrderByWithRelationInput | SubraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subraces.
     */
    cursor?: SubraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subraces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subraces.
     */
    skip?: number
    distinct?: SubraceScalarFieldEnum | SubraceScalarFieldEnum[]
  }

  /**
   * Subrace create
   */
  export type SubraceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceInclude<ExtArgs> | null
    /**
     * The data needed to create a Subrace.
     */
    data: XOR<SubraceCreateInput, SubraceUncheckedCreateInput>
  }

  /**
   * Subrace createMany
   */
  export type SubraceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subraces.
     */
    data: SubraceCreateManyInput | SubraceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subrace createManyAndReturn
   */
  export type SubraceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * The data used to create many Subraces.
     */
    data: SubraceCreateManyInput | SubraceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subrace update
   */
  export type SubraceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceInclude<ExtArgs> | null
    /**
     * The data needed to update a Subrace.
     */
    data: XOR<SubraceUpdateInput, SubraceUncheckedUpdateInput>
    /**
     * Choose, which Subrace to update.
     */
    where: SubraceWhereUniqueInput
  }

  /**
   * Subrace updateMany
   */
  export type SubraceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subraces.
     */
    data: XOR<SubraceUpdateManyMutationInput, SubraceUncheckedUpdateManyInput>
    /**
     * Filter which Subraces to update
     */
    where?: SubraceWhereInput
    /**
     * Limit how many Subraces to update.
     */
    limit?: number
  }

  /**
   * Subrace updateManyAndReturn
   */
  export type SubraceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * The data used to update Subraces.
     */
    data: XOR<SubraceUpdateManyMutationInput, SubraceUncheckedUpdateManyInput>
    /**
     * Filter which Subraces to update
     */
    where?: SubraceWhereInput
    /**
     * Limit how many Subraces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subrace upsert
   */
  export type SubraceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceInclude<ExtArgs> | null
    /**
     * The filter to search for the Subrace to update in case it exists.
     */
    where: SubraceWhereUniqueInput
    /**
     * In case the Subrace found by the `where` argument doesn't exist, create a new Subrace with this data.
     */
    create: XOR<SubraceCreateInput, SubraceUncheckedCreateInput>
    /**
     * In case the Subrace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubraceUpdateInput, SubraceUncheckedUpdateInput>
  }

  /**
   * Subrace delete
   */
  export type SubraceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceInclude<ExtArgs> | null
    /**
     * Filter which Subrace to delete.
     */
    where: SubraceWhereUniqueInput
  }

  /**
   * Subrace deleteMany
   */
  export type SubraceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subraces to delete
     */
    where?: SubraceWhereInput
    /**
     * Limit how many Subraces to delete.
     */
    limit?: number
  }

  /**
   * Subrace.replacesTraits
   */
  export type Subrace$replacesTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    where?: RaceTraitWhereInput
    orderBy?: RaceTraitOrderByWithRelationInput | RaceTraitOrderByWithRelationInput[]
    cursor?: RaceTraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceTraitScalarFieldEnum | RaceTraitScalarFieldEnum[]
  }

  /**
   * Subrace.perses
   */
  export type Subrace$persesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    where?: PersWhereInput
    orderBy?: PersOrderByWithRelationInput | PersOrderByWithRelationInput[]
    cursor?: PersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersScalarFieldEnum | PersScalarFieldEnum[]
  }

  /**
   * Subrace.raceChoiceOptions
   */
  export type Subrace$raceChoiceOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOption
     */
    select?: RaceChoiceOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOption
     */
    omit?: RaceChoiceOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionInclude<ExtArgs> | null
    where?: RaceChoiceOptionWhereInput
    orderBy?: RaceChoiceOptionOrderByWithRelationInput | RaceChoiceOptionOrderByWithRelationInput[]
    cursor?: RaceChoiceOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceChoiceOptionScalarFieldEnum | RaceChoiceOptionScalarFieldEnum[]
  }

  /**
   * Subrace.traits
   */
  export type Subrace$traitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubraceTrait
     */
    select?: SubraceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubraceTrait
     */
    omit?: SubraceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceTraitInclude<ExtArgs> | null
    where?: SubraceTraitWhereInput
    orderBy?: SubraceTraitOrderByWithRelationInput | SubraceTraitOrderByWithRelationInput[]
    cursor?: SubraceTraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubraceTraitScalarFieldEnum | SubraceTraitScalarFieldEnum[]
  }

  /**
   * Subrace without action
   */
  export type SubraceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceInclude<ExtArgs> | null
  }


  /**
   * Model RaceVariant
   */

  export type AggregateRaceVariant = {
    _count: RaceVariantCountAggregateOutputType | null
    _avg: RaceVariantAvgAggregateOutputType | null
    _sum: RaceVariantSumAggregateOutputType | null
    _min: RaceVariantMinAggregateOutputType | null
    _max: RaceVariantMaxAggregateOutputType | null
  }

  export type RaceVariantAvgAggregateOutputType = {
    raceVariantId: number | null
    raceId: number | null
    overridesRaceSpeed: number | null
    overridesFlightSpeed: number | null
  }

  export type RaceVariantSumAggregateOutputType = {
    raceVariantId: number | null
    raceId: number | null
    overridesRaceSpeed: number | null
    overridesFlightSpeed: number | null
  }

  export type RaceVariantMinAggregateOutputType = {
    raceVariantId: number | null
    raceId: number | null
    name: $Enums.Variants | null
    source: $Enums.Source | null
    exclusivityGroup: string | null
    overridesRaceSpeed: number | null
    overridesFlightSpeed: number | null
  }

  export type RaceVariantMaxAggregateOutputType = {
    raceVariantId: number | null
    raceId: number | null
    name: $Enums.Variants | null
    source: $Enums.Source | null
    exclusivityGroup: string | null
    overridesRaceSpeed: number | null
    overridesFlightSpeed: number | null
  }

  export type RaceVariantCountAggregateOutputType = {
    raceVariantId: number
    raceId: number
    name: number
    source: number
    exclusivityGroup: number
    overridesRaceASI: number
    overridesRaceSpeed: number
    overridesFlightSpeed: number
    _all: number
  }


  export type RaceVariantAvgAggregateInputType = {
    raceVariantId?: true
    raceId?: true
    overridesRaceSpeed?: true
    overridesFlightSpeed?: true
  }

  export type RaceVariantSumAggregateInputType = {
    raceVariantId?: true
    raceId?: true
    overridesRaceSpeed?: true
    overridesFlightSpeed?: true
  }

  export type RaceVariantMinAggregateInputType = {
    raceVariantId?: true
    raceId?: true
    name?: true
    source?: true
    exclusivityGroup?: true
    overridesRaceSpeed?: true
    overridesFlightSpeed?: true
  }

  export type RaceVariantMaxAggregateInputType = {
    raceVariantId?: true
    raceId?: true
    name?: true
    source?: true
    exclusivityGroup?: true
    overridesRaceSpeed?: true
    overridesFlightSpeed?: true
  }

  export type RaceVariantCountAggregateInputType = {
    raceVariantId?: true
    raceId?: true
    name?: true
    source?: true
    exclusivityGroup?: true
    overridesRaceASI?: true
    overridesRaceSpeed?: true
    overridesFlightSpeed?: true
    _all?: true
  }

  export type RaceVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceVariant to aggregate.
     */
    where?: RaceVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceVariants to fetch.
     */
    orderBy?: RaceVariantOrderByWithRelationInput | RaceVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaceVariants
    **/
    _count?: true | RaceVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceVariantMaxAggregateInputType
  }

  export type GetRaceVariantAggregateType<T extends RaceVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateRaceVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaceVariant[P]>
      : GetScalarType<T[P], AggregateRaceVariant[P]>
  }




  export type RaceVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceVariantWhereInput
    orderBy?: RaceVariantOrderByWithAggregationInput | RaceVariantOrderByWithAggregationInput[]
    by: RaceVariantScalarFieldEnum[] | RaceVariantScalarFieldEnum
    having?: RaceVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceVariantCountAggregateInputType | true
    _avg?: RaceVariantAvgAggregateInputType
    _sum?: RaceVariantSumAggregateInputType
    _min?: RaceVariantMinAggregateInputType
    _max?: RaceVariantMaxAggregateInputType
  }

  export type RaceVariantGroupByOutputType = {
    raceVariantId: number
    raceId: number
    name: $Enums.Variants
    source: $Enums.Source
    exclusivityGroup: string | null
    overridesRaceASI: JsonValue
    overridesRaceSpeed: number | null
    overridesFlightSpeed: number | null
    _count: RaceVariantCountAggregateOutputType | null
    _avg: RaceVariantAvgAggregateOutputType | null
    _sum: RaceVariantSumAggregateOutputType | null
    _min: RaceVariantMinAggregateOutputType | null
    _max: RaceVariantMaxAggregateOutputType | null
  }

  type GetRaceVariantGroupByPayload<T extends RaceVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceVariantGroupByOutputType[P]>
            : GetScalarType<T[P], RaceVariantGroupByOutputType[P]>
        }
      >
    >


  export type RaceVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceVariantId?: boolean
    raceId?: boolean
    name?: boolean
    source?: boolean
    exclusivityGroup?: boolean
    overridesRaceASI?: boolean
    overridesRaceSpeed?: boolean
    overridesFlightSpeed?: boolean
    replacesTraits?: boolean | RaceVariant$replacesTraitsArgs<ExtArgs>
    traits?: boolean | RaceVariant$traitsArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    perses?: boolean | RaceVariant$persesArgs<ExtArgs>
    _count?: boolean | RaceVariantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceVariant"]>

  export type RaceVariantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceVariantId?: boolean
    raceId?: boolean
    name?: boolean
    source?: boolean
    exclusivityGroup?: boolean
    overridesRaceASI?: boolean
    overridesRaceSpeed?: boolean
    overridesFlightSpeed?: boolean
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceVariant"]>

  export type RaceVariantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raceVariantId?: boolean
    raceId?: boolean
    name?: boolean
    source?: boolean
    exclusivityGroup?: boolean
    overridesRaceASI?: boolean
    overridesRaceSpeed?: boolean
    overridesFlightSpeed?: boolean
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceVariant"]>

  export type RaceVariantSelectScalar = {
    raceVariantId?: boolean
    raceId?: boolean
    name?: boolean
    source?: boolean
    exclusivityGroup?: boolean
    overridesRaceASI?: boolean
    overridesRaceSpeed?: boolean
    overridesFlightSpeed?: boolean
  }

  export type RaceVariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"raceVariantId" | "raceId" | "name" | "source" | "exclusivityGroup" | "overridesRaceASI" | "overridesRaceSpeed" | "overridesFlightSpeed", ExtArgs["result"]["raceVariant"]>
  export type RaceVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replacesTraits?: boolean | RaceVariant$replacesTraitsArgs<ExtArgs>
    traits?: boolean | RaceVariant$traitsArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    perses?: boolean | RaceVariant$persesArgs<ExtArgs>
    _count?: boolean | RaceVariantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RaceVariantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }
  export type RaceVariantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    race?: boolean | RaceDefaultArgs<ExtArgs>
  }

  export type $RaceVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaceVariant"
    objects: {
      replacesTraits: Prisma.$RaceTraitPayload<ExtArgs>[]
      traits: Prisma.$RaceVariantTraitPayload<ExtArgs>[]
      race: Prisma.$RacePayload<ExtArgs>
      perses: Prisma.$PersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      raceVariantId: number
      raceId: number
      name: $Enums.Variants
      source: $Enums.Source
      exclusivityGroup: string | null
      overridesRaceASI: Prisma.JsonValue
      overridesRaceSpeed: number | null
      overridesFlightSpeed: number | null
    }, ExtArgs["result"]["raceVariant"]>
    composites: {}
  }

  type RaceVariantGetPayload<S extends boolean | null | undefined | RaceVariantDefaultArgs> = $Result.GetResult<Prisma.$RaceVariantPayload, S>

  type RaceVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceVariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceVariantCountAggregateInputType | true
    }

  export interface RaceVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaceVariant'], meta: { name: 'RaceVariant' } }
    /**
     * Find zero or one RaceVariant that matches the filter.
     * @param {RaceVariantFindUniqueArgs} args - Arguments to find a RaceVariant
     * @example
     * // Get one RaceVariant
     * const raceVariant = await prisma.raceVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceVariantFindUniqueArgs>(args: SelectSubset<T, RaceVariantFindUniqueArgs<ExtArgs>>): Prisma__RaceVariantClient<$Result.GetResult<Prisma.$RaceVariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RaceVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceVariantFindUniqueOrThrowArgs} args - Arguments to find a RaceVariant
     * @example
     * // Get one RaceVariant
     * const raceVariant = await prisma.raceVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceVariantClient<$Result.GetResult<Prisma.$RaceVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceVariantFindFirstArgs} args - Arguments to find a RaceVariant
     * @example
     * // Get one RaceVariant
     * const raceVariant = await prisma.raceVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceVariantFindFirstArgs>(args?: SelectSubset<T, RaceVariantFindFirstArgs<ExtArgs>>): Prisma__RaceVariantClient<$Result.GetResult<Prisma.$RaceVariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceVariantFindFirstOrThrowArgs} args - Arguments to find a RaceVariant
     * @example
     * // Get one RaceVariant
     * const raceVariant = await prisma.raceVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceVariantClient<$Result.GetResult<Prisma.$RaceVariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RaceVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaceVariants
     * const raceVariants = await prisma.raceVariant.findMany()
     * 
     * // Get first 10 RaceVariants
     * const raceVariants = await prisma.raceVariant.findMany({ take: 10 })
     * 
     * // Only select the `raceVariantId`
     * const raceVariantWithRaceVariantIdOnly = await prisma.raceVariant.findMany({ select: { raceVariantId: true } })
     * 
     */
    findMany<T extends RaceVariantFindManyArgs>(args?: SelectSubset<T, RaceVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RaceVariant.
     * @param {RaceVariantCreateArgs} args - Arguments to create a RaceVariant.
     * @example
     * // Create one RaceVariant
     * const RaceVariant = await prisma.raceVariant.create({
     *   data: {
     *     // ... data to create a RaceVariant
     *   }
     * })
     * 
     */
    create<T extends RaceVariantCreateArgs>(args: SelectSubset<T, RaceVariantCreateArgs<ExtArgs>>): Prisma__RaceVariantClient<$Result.GetResult<Prisma.$RaceVariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RaceVariants.
     * @param {RaceVariantCreateManyArgs} args - Arguments to create many RaceVariants.
     * @example
     * // Create many RaceVariants
     * const raceVariant = await prisma.raceVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceVariantCreateManyArgs>(args?: SelectSubset<T, RaceVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RaceVariants and returns the data saved in the database.
     * @param {RaceVariantCreateManyAndReturnArgs} args - Arguments to create many RaceVariants.
     * @example
     * // Create many RaceVariants
     * const raceVariant = await prisma.raceVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RaceVariants and only return the `raceVariantId`
     * const raceVariantWithRaceVariantIdOnly = await prisma.raceVariant.createManyAndReturn({
     *   select: { raceVariantId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaceVariantCreateManyAndReturnArgs>(args?: SelectSubset<T, RaceVariantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceVariantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RaceVariant.
     * @param {RaceVariantDeleteArgs} args - Arguments to delete one RaceVariant.
     * @example
     * // Delete one RaceVariant
     * const RaceVariant = await prisma.raceVariant.delete({
     *   where: {
     *     // ... filter to delete one RaceVariant
     *   }
     * })
     * 
     */
    delete<T extends RaceVariantDeleteArgs>(args: SelectSubset<T, RaceVariantDeleteArgs<ExtArgs>>): Prisma__RaceVariantClient<$Result.GetResult<Prisma.$RaceVariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RaceVariant.
     * @param {RaceVariantUpdateArgs} args - Arguments to update one RaceVariant.
     * @example
     * // Update one RaceVariant
     * const raceVariant = await prisma.raceVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceVariantUpdateArgs>(args: SelectSubset<T, RaceVariantUpdateArgs<ExtArgs>>): Prisma__RaceVariantClient<$Result.GetResult<Prisma.$RaceVariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RaceVariants.
     * @param {RaceVariantDeleteManyArgs} args - Arguments to filter RaceVariants to delete.
     * @example
     * // Delete a few RaceVariants
     * const { count } = await prisma.raceVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceVariantDeleteManyArgs>(args?: SelectSubset<T, RaceVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaceVariants
     * const raceVariant = await prisma.raceVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceVariantUpdateManyArgs>(args: SelectSubset<T, RaceVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceVariants and returns the data updated in the database.
     * @param {RaceVariantUpdateManyAndReturnArgs} args - Arguments to update many RaceVariants.
     * @example
     * // Update many RaceVariants
     * const raceVariant = await prisma.raceVariant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RaceVariants and only return the `raceVariantId`
     * const raceVariantWithRaceVariantIdOnly = await prisma.raceVariant.updateManyAndReturn({
     *   select: { raceVariantId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaceVariantUpdateManyAndReturnArgs>(args: SelectSubset<T, RaceVariantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceVariantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RaceVariant.
     * @param {RaceVariantUpsertArgs} args - Arguments to update or create a RaceVariant.
     * @example
     * // Update or create a RaceVariant
     * const raceVariant = await prisma.raceVariant.upsert({
     *   create: {
     *     // ... data to create a RaceVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaceVariant we want to update
     *   }
     * })
     */
    upsert<T extends RaceVariantUpsertArgs>(args: SelectSubset<T, RaceVariantUpsertArgs<ExtArgs>>): Prisma__RaceVariantClient<$Result.GetResult<Prisma.$RaceVariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RaceVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceVariantCountArgs} args - Arguments to filter RaceVariants to count.
     * @example
     * // Count the number of RaceVariants
     * const count = await prisma.raceVariant.count({
     *   where: {
     *     // ... the filter for the RaceVariants we want to count
     *   }
     * })
    **/
    count<T extends RaceVariantCountArgs>(
      args?: Subset<T, RaceVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaceVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceVariantAggregateArgs>(args: Subset<T, RaceVariantAggregateArgs>): Prisma.PrismaPromise<GetRaceVariantAggregateType<T>>

    /**
     * Group by RaceVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceVariantGroupByArgs['orderBy'] }
        : { orderBy?: RaceVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaceVariant model
   */
  readonly fields: RaceVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaceVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    replacesTraits<T extends RaceVariant$replacesTraitsArgs<ExtArgs> = {}>(args?: Subset<T, RaceVariant$replacesTraitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    traits<T extends RaceVariant$traitsArgs<ExtArgs> = {}>(args?: Subset<T, RaceVariant$traitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceVariantTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    race<T extends RaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceDefaultArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    perses<T extends RaceVariant$persesArgs<ExtArgs> = {}>(args?: Subset<T, RaceVariant$persesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RaceVariant model
   */
  interface RaceVariantFieldRefs {
    readonly raceVariantId: FieldRef<"RaceVariant", 'Int'>
    readonly raceId: FieldRef<"RaceVariant", 'Int'>
    readonly name: FieldRef<"RaceVariant", 'Variants'>
    readonly source: FieldRef<"RaceVariant", 'Source'>
    readonly exclusivityGroup: FieldRef<"RaceVariant", 'String'>
    readonly overridesRaceASI: FieldRef<"RaceVariant", 'Json'>
    readonly overridesRaceSpeed: FieldRef<"RaceVariant", 'Int'>
    readonly overridesFlightSpeed: FieldRef<"RaceVariant", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RaceVariant findUnique
   */
  export type RaceVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariant
     */
    select?: RaceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariant
     */
    omit?: RaceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantInclude<ExtArgs> | null
    /**
     * Filter, which RaceVariant to fetch.
     */
    where: RaceVariantWhereUniqueInput
  }

  /**
   * RaceVariant findUniqueOrThrow
   */
  export type RaceVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariant
     */
    select?: RaceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariant
     */
    omit?: RaceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantInclude<ExtArgs> | null
    /**
     * Filter, which RaceVariant to fetch.
     */
    where: RaceVariantWhereUniqueInput
  }

  /**
   * RaceVariant findFirst
   */
  export type RaceVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariant
     */
    select?: RaceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariant
     */
    omit?: RaceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantInclude<ExtArgs> | null
    /**
     * Filter, which RaceVariant to fetch.
     */
    where?: RaceVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceVariants to fetch.
     */
    orderBy?: RaceVariantOrderByWithRelationInput | RaceVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceVariants.
     */
    cursor?: RaceVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceVariants.
     */
    distinct?: RaceVariantScalarFieldEnum | RaceVariantScalarFieldEnum[]
  }

  /**
   * RaceVariant findFirstOrThrow
   */
  export type RaceVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariant
     */
    select?: RaceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariant
     */
    omit?: RaceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantInclude<ExtArgs> | null
    /**
     * Filter, which RaceVariant to fetch.
     */
    where?: RaceVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceVariants to fetch.
     */
    orderBy?: RaceVariantOrderByWithRelationInput | RaceVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceVariants.
     */
    cursor?: RaceVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceVariants.
     */
    distinct?: RaceVariantScalarFieldEnum | RaceVariantScalarFieldEnum[]
  }

  /**
   * RaceVariant findMany
   */
  export type RaceVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariant
     */
    select?: RaceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariant
     */
    omit?: RaceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantInclude<ExtArgs> | null
    /**
     * Filter, which RaceVariants to fetch.
     */
    where?: RaceVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceVariants to fetch.
     */
    orderBy?: RaceVariantOrderByWithRelationInput | RaceVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaceVariants.
     */
    cursor?: RaceVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceVariants.
     */
    skip?: number
    distinct?: RaceVariantScalarFieldEnum | RaceVariantScalarFieldEnum[]
  }

  /**
   * RaceVariant create
   */
  export type RaceVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariant
     */
    select?: RaceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariant
     */
    omit?: RaceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a RaceVariant.
     */
    data: XOR<RaceVariantCreateInput, RaceVariantUncheckedCreateInput>
  }

  /**
   * RaceVariant createMany
   */
  export type RaceVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaceVariants.
     */
    data: RaceVariantCreateManyInput | RaceVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RaceVariant createManyAndReturn
   */
  export type RaceVariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariant
     */
    select?: RaceVariantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariant
     */
    omit?: RaceVariantOmit<ExtArgs> | null
    /**
     * The data used to create many RaceVariants.
     */
    data: RaceVariantCreateManyInput | RaceVariantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaceVariant update
   */
  export type RaceVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariant
     */
    select?: RaceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariant
     */
    omit?: RaceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a RaceVariant.
     */
    data: XOR<RaceVariantUpdateInput, RaceVariantUncheckedUpdateInput>
    /**
     * Choose, which RaceVariant to update.
     */
    where: RaceVariantWhereUniqueInput
  }

  /**
   * RaceVariant updateMany
   */
  export type RaceVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaceVariants.
     */
    data: XOR<RaceVariantUpdateManyMutationInput, RaceVariantUncheckedUpdateManyInput>
    /**
     * Filter which RaceVariants to update
     */
    where?: RaceVariantWhereInput
    /**
     * Limit how many RaceVariants to update.
     */
    limit?: number
  }

  /**
   * RaceVariant updateManyAndReturn
   */
  export type RaceVariantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariant
     */
    select?: RaceVariantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariant
     */
    omit?: RaceVariantOmit<ExtArgs> | null
    /**
     * The data used to update RaceVariants.
     */
    data: XOR<RaceVariantUpdateManyMutationInput, RaceVariantUncheckedUpdateManyInput>
    /**
     * Filter which RaceVariants to update
     */
    where?: RaceVariantWhereInput
    /**
     * Limit how many RaceVariants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaceVariant upsert
   */
  export type RaceVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariant
     */
    select?: RaceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariant
     */
    omit?: RaceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the RaceVariant to update in case it exists.
     */
    where: RaceVariantWhereUniqueInput
    /**
     * In case the RaceVariant found by the `where` argument doesn't exist, create a new RaceVariant with this data.
     */
    create: XOR<RaceVariantCreateInput, RaceVariantUncheckedCreateInput>
    /**
     * In case the RaceVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceVariantUpdateInput, RaceVariantUncheckedUpdateInput>
  }

  /**
   * RaceVariant delete
   */
  export type RaceVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariant
     */
    select?: RaceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariant
     */
    omit?: RaceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantInclude<ExtArgs> | null
    /**
     * Filter which RaceVariant to delete.
     */
    where: RaceVariantWhereUniqueInput
  }

  /**
   * RaceVariant deleteMany
   */
  export type RaceVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceVariants to delete
     */
    where?: RaceVariantWhereInput
    /**
     * Limit how many RaceVariants to delete.
     */
    limit?: number
  }

  /**
   * RaceVariant.replacesTraits
   */
  export type RaceVariant$replacesTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceTrait
     */
    select?: RaceTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceTrait
     */
    omit?: RaceTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceTraitInclude<ExtArgs> | null
    where?: RaceTraitWhereInput
    orderBy?: RaceTraitOrderByWithRelationInput | RaceTraitOrderByWithRelationInput[]
    cursor?: RaceTraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceTraitScalarFieldEnum | RaceTraitScalarFieldEnum[]
  }

  /**
   * RaceVariant.traits
   */
  export type RaceVariant$traitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariantTrait
     */
    select?: RaceVariantTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariantTrait
     */
    omit?: RaceVariantTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantTraitInclude<ExtArgs> | null
    where?: RaceVariantTraitWhereInput
    orderBy?: RaceVariantTraitOrderByWithRelationInput | RaceVariantTraitOrderByWithRelationInput[]
    cursor?: RaceVariantTraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceVariantTraitScalarFieldEnum | RaceVariantTraitScalarFieldEnum[]
  }

  /**
   * RaceVariant.perses
   */
  export type RaceVariant$persesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    where?: PersWhereInput
    orderBy?: PersOrderByWithRelationInput | PersOrderByWithRelationInput[]
    cursor?: PersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersScalarFieldEnum | PersScalarFieldEnum[]
  }

  /**
   * RaceVariant without action
   */
  export type RaceVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceVariant
     */
    select?: RaceVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceVariant
     */
    omit?: RaceVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceVariantInclude<ExtArgs> | null
  }


  /**
   * Model RaceChoiceOption
   */

  export type AggregateRaceChoiceOption = {
    _count: RaceChoiceOptionCountAggregateOutputType | null
    _avg: RaceChoiceOptionAvgAggregateOutputType | null
    _sum: RaceChoiceOptionSumAggregateOutputType | null
    _min: RaceChoiceOptionMinAggregateOutputType | null
    _max: RaceChoiceOptionMaxAggregateOutputType | null
  }

  export type RaceChoiceOptionAvgAggregateOutputType = {
    optionId: number | null
    raceId: number | null
    subraceId: number | null
    maxSelection: number | null
    languagesToChooseCount: number | null
    modifiesSpeed: number | null
  }

  export type RaceChoiceOptionSumAggregateOutputType = {
    optionId: number | null
    raceId: number | null
    subraceId: number | null
    maxSelection: number | null
    languagesToChooseCount: number | null
    modifiesSpeed: number | null
  }

  export type RaceChoiceOptionMinAggregateOutputType = {
    optionId: number | null
    raceId: number | null
    subraceId: number | null
    choiceGroupName: string | null
    optionName: string | null
    description: string | null
    selectMultiple: boolean | null
    maxSelection: number | null
    languagesToChooseCount: number | null
    modifiesSpeed: number | null
    draconicDamageType: $Enums.DamageType | null
    breathWeaponShape: $Enums.AOEShapes | null
    breathWeaponAOE: string | null
  }

  export type RaceChoiceOptionMaxAggregateOutputType = {
    optionId: number | null
    raceId: number | null
    subraceId: number | null
    choiceGroupName: string | null
    optionName: string | null
    description: string | null
    selectMultiple: boolean | null
    maxSelection: number | null
    languagesToChooseCount: number | null
    modifiesSpeed: number | null
    draconicDamageType: $Enums.DamageType | null
    breathWeaponShape: $Enums.AOEShapes | null
    breathWeaponAOE: string | null
  }

  export type RaceChoiceOptionCountAggregateOutputType = {
    optionId: number
    raceId: number
    subraceId: number
    choiceGroupName: number
    optionName: number
    description: number
    selectMultiple: number
    maxSelection: number
    grantsASI: number
    grantsSkillProficiencies: number
    grantsLanguages: number
    languagesToChooseCount: number
    modifiesSpeed: number
    draconicDamageType: number
    breathWeaponShape: number
    breathWeaponAOE: number
    _all: number
  }


  export type RaceChoiceOptionAvgAggregateInputType = {
    optionId?: true
    raceId?: true
    subraceId?: true
    maxSelection?: true
    languagesToChooseCount?: true
    modifiesSpeed?: true
  }

  export type RaceChoiceOptionSumAggregateInputType = {
    optionId?: true
    raceId?: true
    subraceId?: true
    maxSelection?: true
    languagesToChooseCount?: true
    modifiesSpeed?: true
  }

  export type RaceChoiceOptionMinAggregateInputType = {
    optionId?: true
    raceId?: true
    subraceId?: true
    choiceGroupName?: true
    optionName?: true
    description?: true
    selectMultiple?: true
    maxSelection?: true
    languagesToChooseCount?: true
    modifiesSpeed?: true
    draconicDamageType?: true
    breathWeaponShape?: true
    breathWeaponAOE?: true
  }

  export type RaceChoiceOptionMaxAggregateInputType = {
    optionId?: true
    raceId?: true
    subraceId?: true
    choiceGroupName?: true
    optionName?: true
    description?: true
    selectMultiple?: true
    maxSelection?: true
    languagesToChooseCount?: true
    modifiesSpeed?: true
    draconicDamageType?: true
    breathWeaponShape?: true
    breathWeaponAOE?: true
  }

  export type RaceChoiceOptionCountAggregateInputType = {
    optionId?: true
    raceId?: true
    subraceId?: true
    choiceGroupName?: true
    optionName?: true
    description?: true
    selectMultiple?: true
    maxSelection?: true
    grantsASI?: true
    grantsSkillProficiencies?: true
    grantsLanguages?: true
    languagesToChooseCount?: true
    modifiesSpeed?: true
    draconicDamageType?: true
    breathWeaponShape?: true
    breathWeaponAOE?: true
    _all?: true
  }

  export type RaceChoiceOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceChoiceOption to aggregate.
     */
    where?: RaceChoiceOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceChoiceOptions to fetch.
     */
    orderBy?: RaceChoiceOptionOrderByWithRelationInput | RaceChoiceOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceChoiceOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceChoiceOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceChoiceOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaceChoiceOptions
    **/
    _count?: true | RaceChoiceOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceChoiceOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceChoiceOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceChoiceOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceChoiceOptionMaxAggregateInputType
  }

  export type GetRaceChoiceOptionAggregateType<T extends RaceChoiceOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateRaceChoiceOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaceChoiceOption[P]>
      : GetScalarType<T[P], AggregateRaceChoiceOption[P]>
  }




  export type RaceChoiceOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceChoiceOptionWhereInput
    orderBy?: RaceChoiceOptionOrderByWithAggregationInput | RaceChoiceOptionOrderByWithAggregationInput[]
    by: RaceChoiceOptionScalarFieldEnum[] | RaceChoiceOptionScalarFieldEnum
    having?: RaceChoiceOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceChoiceOptionCountAggregateInputType | true
    _avg?: RaceChoiceOptionAvgAggregateInputType
    _sum?: RaceChoiceOptionSumAggregateInputType
    _min?: RaceChoiceOptionMinAggregateInputType
    _max?: RaceChoiceOptionMaxAggregateInputType
  }

  export type RaceChoiceOptionGroupByOutputType = {
    optionId: number
    raceId: number
    subraceId: number | null
    choiceGroupName: string
    optionName: string
    description: string | null
    selectMultiple: boolean
    maxSelection: number
    grantsASI: JsonValue | null
    grantsSkillProficiencies: $Enums.Skills[]
    grantsLanguages: $Enums.Language[]
    languagesToChooseCount: number
    modifiesSpeed: number | null
    draconicDamageType: $Enums.DamageType | null
    breathWeaponShape: $Enums.AOEShapes | null
    breathWeaponAOE: string | null
    _count: RaceChoiceOptionCountAggregateOutputType | null
    _avg: RaceChoiceOptionAvgAggregateOutputType | null
    _sum: RaceChoiceOptionSumAggregateOutputType | null
    _min: RaceChoiceOptionMinAggregateOutputType | null
    _max: RaceChoiceOptionMaxAggregateOutputType | null
  }

  type GetRaceChoiceOptionGroupByPayload<T extends RaceChoiceOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceChoiceOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceChoiceOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceChoiceOptionGroupByOutputType[P]>
            : GetScalarType<T[P], RaceChoiceOptionGroupByOutputType[P]>
        }
      >
    >


  export type RaceChoiceOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    optionId?: boolean
    raceId?: boolean
    subraceId?: boolean
    choiceGroupName?: boolean
    optionName?: boolean
    description?: boolean
    selectMultiple?: boolean
    maxSelection?: boolean
    grantsASI?: boolean
    grantsSkillProficiencies?: boolean
    grantsLanguages?: boolean
    languagesToChooseCount?: boolean
    modifiesSpeed?: boolean
    draconicDamageType?: boolean
    breathWeaponShape?: boolean
    breathWeaponAOE?: boolean
    grantsTraits?: boolean | RaceChoiceOption$grantsTraitsArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    subrace?: boolean | RaceChoiceOption$subraceArgs<ExtArgs>
    perses?: boolean | RaceChoiceOption$persesArgs<ExtArgs>
    _count?: boolean | RaceChoiceOptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceChoiceOption"]>

  export type RaceChoiceOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    optionId?: boolean
    raceId?: boolean
    subraceId?: boolean
    choiceGroupName?: boolean
    optionName?: boolean
    description?: boolean
    selectMultiple?: boolean
    maxSelection?: boolean
    grantsASI?: boolean
    grantsSkillProficiencies?: boolean
    grantsLanguages?: boolean
    languagesToChooseCount?: boolean
    modifiesSpeed?: boolean
    draconicDamageType?: boolean
    breathWeaponShape?: boolean
    breathWeaponAOE?: boolean
    race?: boolean | RaceDefaultArgs<ExtArgs>
    subrace?: boolean | RaceChoiceOption$subraceArgs<ExtArgs>
  }, ExtArgs["result"]["raceChoiceOption"]>

  export type RaceChoiceOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    optionId?: boolean
    raceId?: boolean
    subraceId?: boolean
    choiceGroupName?: boolean
    optionName?: boolean
    description?: boolean
    selectMultiple?: boolean
    maxSelection?: boolean
    grantsASI?: boolean
    grantsSkillProficiencies?: boolean
    grantsLanguages?: boolean
    languagesToChooseCount?: boolean
    modifiesSpeed?: boolean
    draconicDamageType?: boolean
    breathWeaponShape?: boolean
    breathWeaponAOE?: boolean
    race?: boolean | RaceDefaultArgs<ExtArgs>
    subrace?: boolean | RaceChoiceOption$subraceArgs<ExtArgs>
  }, ExtArgs["result"]["raceChoiceOption"]>

  export type RaceChoiceOptionSelectScalar = {
    optionId?: boolean
    raceId?: boolean
    subraceId?: boolean
    choiceGroupName?: boolean
    optionName?: boolean
    description?: boolean
    selectMultiple?: boolean
    maxSelection?: boolean
    grantsASI?: boolean
    grantsSkillProficiencies?: boolean
    grantsLanguages?: boolean
    languagesToChooseCount?: boolean
    modifiesSpeed?: boolean
    draconicDamageType?: boolean
    breathWeaponShape?: boolean
    breathWeaponAOE?: boolean
  }

  export type RaceChoiceOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"optionId" | "raceId" | "subraceId" | "choiceGroupName" | "optionName" | "description" | "selectMultiple" | "maxSelection" | "grantsASI" | "grantsSkillProficiencies" | "grantsLanguages" | "languagesToChooseCount" | "modifiesSpeed" | "draconicDamageType" | "breathWeaponShape" | "breathWeaponAOE", ExtArgs["result"]["raceChoiceOption"]>
  export type RaceChoiceOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grantsTraits?: boolean | RaceChoiceOption$grantsTraitsArgs<ExtArgs>
    race?: boolean | RaceDefaultArgs<ExtArgs>
    subrace?: boolean | RaceChoiceOption$subraceArgs<ExtArgs>
    perses?: boolean | RaceChoiceOption$persesArgs<ExtArgs>
    _count?: boolean | RaceChoiceOptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RaceChoiceOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    race?: boolean | RaceDefaultArgs<ExtArgs>
    subrace?: boolean | RaceChoiceOption$subraceArgs<ExtArgs>
  }
  export type RaceChoiceOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    race?: boolean | RaceDefaultArgs<ExtArgs>
    subrace?: boolean | RaceChoiceOption$subraceArgs<ExtArgs>
  }

  export type $RaceChoiceOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaceChoiceOption"
    objects: {
      grantsTraits: Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>[]
      race: Prisma.$RacePayload<ExtArgs>
      subrace: Prisma.$SubracePayload<ExtArgs> | null
      perses: Prisma.$PersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      optionId: number
      raceId: number
      subraceId: number | null
      choiceGroupName: string
      optionName: string
      description: string | null
      selectMultiple: boolean
      maxSelection: number
      grantsASI: Prisma.JsonValue | null
      grantsSkillProficiencies: $Enums.Skills[]
      grantsLanguages: $Enums.Language[]
      languagesToChooseCount: number
      modifiesSpeed: number | null
      draconicDamageType: $Enums.DamageType | null
      breathWeaponShape: $Enums.AOEShapes | null
      breathWeaponAOE: string | null
    }, ExtArgs["result"]["raceChoiceOption"]>
    composites: {}
  }

  type RaceChoiceOptionGetPayload<S extends boolean | null | undefined | RaceChoiceOptionDefaultArgs> = $Result.GetResult<Prisma.$RaceChoiceOptionPayload, S>

  type RaceChoiceOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceChoiceOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceChoiceOptionCountAggregateInputType | true
    }

  export interface RaceChoiceOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaceChoiceOption'], meta: { name: 'RaceChoiceOption' } }
    /**
     * Find zero or one RaceChoiceOption that matches the filter.
     * @param {RaceChoiceOptionFindUniqueArgs} args - Arguments to find a RaceChoiceOption
     * @example
     * // Get one RaceChoiceOption
     * const raceChoiceOption = await prisma.raceChoiceOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceChoiceOptionFindUniqueArgs>(args: SelectSubset<T, RaceChoiceOptionFindUniqueArgs<ExtArgs>>): Prisma__RaceChoiceOptionClient<$Result.GetResult<Prisma.$RaceChoiceOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RaceChoiceOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceChoiceOptionFindUniqueOrThrowArgs} args - Arguments to find a RaceChoiceOption
     * @example
     * // Get one RaceChoiceOption
     * const raceChoiceOption = await prisma.raceChoiceOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceChoiceOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceChoiceOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceChoiceOptionClient<$Result.GetResult<Prisma.$RaceChoiceOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceChoiceOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceChoiceOptionFindFirstArgs} args - Arguments to find a RaceChoiceOption
     * @example
     * // Get one RaceChoiceOption
     * const raceChoiceOption = await prisma.raceChoiceOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceChoiceOptionFindFirstArgs>(args?: SelectSubset<T, RaceChoiceOptionFindFirstArgs<ExtArgs>>): Prisma__RaceChoiceOptionClient<$Result.GetResult<Prisma.$RaceChoiceOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceChoiceOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceChoiceOptionFindFirstOrThrowArgs} args - Arguments to find a RaceChoiceOption
     * @example
     * // Get one RaceChoiceOption
     * const raceChoiceOption = await prisma.raceChoiceOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceChoiceOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceChoiceOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceChoiceOptionClient<$Result.GetResult<Prisma.$RaceChoiceOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RaceChoiceOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceChoiceOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaceChoiceOptions
     * const raceChoiceOptions = await prisma.raceChoiceOption.findMany()
     * 
     * // Get first 10 RaceChoiceOptions
     * const raceChoiceOptions = await prisma.raceChoiceOption.findMany({ take: 10 })
     * 
     * // Only select the `optionId`
     * const raceChoiceOptionWithOptionIdOnly = await prisma.raceChoiceOption.findMany({ select: { optionId: true } })
     * 
     */
    findMany<T extends RaceChoiceOptionFindManyArgs>(args?: SelectSubset<T, RaceChoiceOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceChoiceOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RaceChoiceOption.
     * @param {RaceChoiceOptionCreateArgs} args - Arguments to create a RaceChoiceOption.
     * @example
     * // Create one RaceChoiceOption
     * const RaceChoiceOption = await prisma.raceChoiceOption.create({
     *   data: {
     *     // ... data to create a RaceChoiceOption
     *   }
     * })
     * 
     */
    create<T extends RaceChoiceOptionCreateArgs>(args: SelectSubset<T, RaceChoiceOptionCreateArgs<ExtArgs>>): Prisma__RaceChoiceOptionClient<$Result.GetResult<Prisma.$RaceChoiceOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RaceChoiceOptions.
     * @param {RaceChoiceOptionCreateManyArgs} args - Arguments to create many RaceChoiceOptions.
     * @example
     * // Create many RaceChoiceOptions
     * const raceChoiceOption = await prisma.raceChoiceOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceChoiceOptionCreateManyArgs>(args?: SelectSubset<T, RaceChoiceOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RaceChoiceOptions and returns the data saved in the database.
     * @param {RaceChoiceOptionCreateManyAndReturnArgs} args - Arguments to create many RaceChoiceOptions.
     * @example
     * // Create many RaceChoiceOptions
     * const raceChoiceOption = await prisma.raceChoiceOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RaceChoiceOptions and only return the `optionId`
     * const raceChoiceOptionWithOptionIdOnly = await prisma.raceChoiceOption.createManyAndReturn({
     *   select: { optionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaceChoiceOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, RaceChoiceOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceChoiceOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RaceChoiceOption.
     * @param {RaceChoiceOptionDeleteArgs} args - Arguments to delete one RaceChoiceOption.
     * @example
     * // Delete one RaceChoiceOption
     * const RaceChoiceOption = await prisma.raceChoiceOption.delete({
     *   where: {
     *     // ... filter to delete one RaceChoiceOption
     *   }
     * })
     * 
     */
    delete<T extends RaceChoiceOptionDeleteArgs>(args: SelectSubset<T, RaceChoiceOptionDeleteArgs<ExtArgs>>): Prisma__RaceChoiceOptionClient<$Result.GetResult<Prisma.$RaceChoiceOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RaceChoiceOption.
     * @param {RaceChoiceOptionUpdateArgs} args - Arguments to update one RaceChoiceOption.
     * @example
     * // Update one RaceChoiceOption
     * const raceChoiceOption = await prisma.raceChoiceOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceChoiceOptionUpdateArgs>(args: SelectSubset<T, RaceChoiceOptionUpdateArgs<ExtArgs>>): Prisma__RaceChoiceOptionClient<$Result.GetResult<Prisma.$RaceChoiceOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RaceChoiceOptions.
     * @param {RaceChoiceOptionDeleteManyArgs} args - Arguments to filter RaceChoiceOptions to delete.
     * @example
     * // Delete a few RaceChoiceOptions
     * const { count } = await prisma.raceChoiceOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceChoiceOptionDeleteManyArgs>(args?: SelectSubset<T, RaceChoiceOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceChoiceOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceChoiceOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaceChoiceOptions
     * const raceChoiceOption = await prisma.raceChoiceOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceChoiceOptionUpdateManyArgs>(args: SelectSubset<T, RaceChoiceOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceChoiceOptions and returns the data updated in the database.
     * @param {RaceChoiceOptionUpdateManyAndReturnArgs} args - Arguments to update many RaceChoiceOptions.
     * @example
     * // Update many RaceChoiceOptions
     * const raceChoiceOption = await prisma.raceChoiceOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RaceChoiceOptions and only return the `optionId`
     * const raceChoiceOptionWithOptionIdOnly = await prisma.raceChoiceOption.updateManyAndReturn({
     *   select: { optionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaceChoiceOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, RaceChoiceOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceChoiceOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RaceChoiceOption.
     * @param {RaceChoiceOptionUpsertArgs} args - Arguments to update or create a RaceChoiceOption.
     * @example
     * // Update or create a RaceChoiceOption
     * const raceChoiceOption = await prisma.raceChoiceOption.upsert({
     *   create: {
     *     // ... data to create a RaceChoiceOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaceChoiceOption we want to update
     *   }
     * })
     */
    upsert<T extends RaceChoiceOptionUpsertArgs>(args: SelectSubset<T, RaceChoiceOptionUpsertArgs<ExtArgs>>): Prisma__RaceChoiceOptionClient<$Result.GetResult<Prisma.$RaceChoiceOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RaceChoiceOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceChoiceOptionCountArgs} args - Arguments to filter RaceChoiceOptions to count.
     * @example
     * // Count the number of RaceChoiceOptions
     * const count = await prisma.raceChoiceOption.count({
     *   where: {
     *     // ... the filter for the RaceChoiceOptions we want to count
     *   }
     * })
    **/
    count<T extends RaceChoiceOptionCountArgs>(
      args?: Subset<T, RaceChoiceOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceChoiceOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaceChoiceOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceChoiceOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceChoiceOptionAggregateArgs>(args: Subset<T, RaceChoiceOptionAggregateArgs>): Prisma.PrismaPromise<GetRaceChoiceOptionAggregateType<T>>

    /**
     * Group by RaceChoiceOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceChoiceOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceChoiceOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceChoiceOptionGroupByArgs['orderBy'] }
        : { orderBy?: RaceChoiceOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceChoiceOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceChoiceOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaceChoiceOption model
   */
  readonly fields: RaceChoiceOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaceChoiceOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceChoiceOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grantsTraits<T extends RaceChoiceOption$grantsTraitsArgs<ExtArgs> = {}>(args?: Subset<T, RaceChoiceOption$grantsTraitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceChoiceOptionTraitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    race<T extends RaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceDefaultArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subrace<T extends RaceChoiceOption$subraceArgs<ExtArgs> = {}>(args?: Subset<T, RaceChoiceOption$subraceArgs<ExtArgs>>): Prisma__SubraceClient<$Result.GetResult<Prisma.$SubracePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    perses<T extends RaceChoiceOption$persesArgs<ExtArgs> = {}>(args?: Subset<T, RaceChoiceOption$persesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RaceChoiceOption model
   */
  interface RaceChoiceOptionFieldRefs {
    readonly optionId: FieldRef<"RaceChoiceOption", 'Int'>
    readonly raceId: FieldRef<"RaceChoiceOption", 'Int'>
    readonly subraceId: FieldRef<"RaceChoiceOption", 'Int'>
    readonly choiceGroupName: FieldRef<"RaceChoiceOption", 'String'>
    readonly optionName: FieldRef<"RaceChoiceOption", 'String'>
    readonly description: FieldRef<"RaceChoiceOption", 'String'>
    readonly selectMultiple: FieldRef<"RaceChoiceOption", 'Boolean'>
    readonly maxSelection: FieldRef<"RaceChoiceOption", 'Int'>
    readonly grantsASI: FieldRef<"RaceChoiceOption", 'Json'>
    readonly grantsSkillProficiencies: FieldRef<"RaceChoiceOption", 'Skills[]'>
    readonly grantsLanguages: FieldRef<"RaceChoiceOption", 'Language[]'>
    readonly languagesToChooseCount: FieldRef<"RaceChoiceOption", 'Int'>
    readonly modifiesSpeed: FieldRef<"RaceChoiceOption", 'Int'>
    readonly draconicDamageType: FieldRef<"RaceChoiceOption", 'DamageType'>
    readonly breathWeaponShape: FieldRef<"RaceChoiceOption", 'AOEShapes'>
    readonly breathWeaponAOE: FieldRef<"RaceChoiceOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RaceChoiceOption findUnique
   */
  export type RaceChoiceOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOption
     */
    select?: RaceChoiceOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOption
     */
    omit?: RaceChoiceOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionInclude<ExtArgs> | null
    /**
     * Filter, which RaceChoiceOption to fetch.
     */
    where: RaceChoiceOptionWhereUniqueInput
  }

  /**
   * RaceChoiceOption findUniqueOrThrow
   */
  export type RaceChoiceOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOption
     */
    select?: RaceChoiceOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOption
     */
    omit?: RaceChoiceOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionInclude<ExtArgs> | null
    /**
     * Filter, which RaceChoiceOption to fetch.
     */
    where: RaceChoiceOptionWhereUniqueInput
  }

  /**
   * RaceChoiceOption findFirst
   */
  export type RaceChoiceOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOption
     */
    select?: RaceChoiceOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOption
     */
    omit?: RaceChoiceOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionInclude<ExtArgs> | null
    /**
     * Filter, which RaceChoiceOption to fetch.
     */
    where?: RaceChoiceOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceChoiceOptions to fetch.
     */
    orderBy?: RaceChoiceOptionOrderByWithRelationInput | RaceChoiceOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceChoiceOptions.
     */
    cursor?: RaceChoiceOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceChoiceOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceChoiceOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceChoiceOptions.
     */
    distinct?: RaceChoiceOptionScalarFieldEnum | RaceChoiceOptionScalarFieldEnum[]
  }

  /**
   * RaceChoiceOption findFirstOrThrow
   */
  export type RaceChoiceOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOption
     */
    select?: RaceChoiceOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOption
     */
    omit?: RaceChoiceOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionInclude<ExtArgs> | null
    /**
     * Filter, which RaceChoiceOption to fetch.
     */
    where?: RaceChoiceOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceChoiceOptions to fetch.
     */
    orderBy?: RaceChoiceOptionOrderByWithRelationInput | RaceChoiceOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceChoiceOptions.
     */
    cursor?: RaceChoiceOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceChoiceOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceChoiceOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceChoiceOptions.
     */
    distinct?: RaceChoiceOptionScalarFieldEnum | RaceChoiceOptionScalarFieldEnum[]
  }

  /**
   * RaceChoiceOption findMany
   */
  export type RaceChoiceOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOption
     */
    select?: RaceChoiceOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOption
     */
    omit?: RaceChoiceOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionInclude<ExtArgs> | null
    /**
     * Filter, which RaceChoiceOptions to fetch.
     */
    where?: RaceChoiceOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceChoiceOptions to fetch.
     */
    orderBy?: RaceChoiceOptionOrderByWithRelationInput | RaceChoiceOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaceChoiceOptions.
     */
    cursor?: RaceChoiceOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceChoiceOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceChoiceOptions.
     */
    skip?: number
    distinct?: RaceChoiceOptionScalarFieldEnum | RaceChoiceOptionScalarFieldEnum[]
  }

  /**
   * RaceChoiceOption create
   */
  export type RaceChoiceOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOption
     */
    select?: RaceChoiceOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOption
     */
    omit?: RaceChoiceOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a RaceChoiceOption.
     */
    data: XOR<RaceChoiceOptionCreateInput, RaceChoiceOptionUncheckedCreateInput>
  }

  /**
   * RaceChoiceOption createMany
   */
  export type RaceChoiceOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaceChoiceOptions.
     */
    data: RaceChoiceOptionCreateManyInput | RaceChoiceOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RaceChoiceOption createManyAndReturn
   */
  export type RaceChoiceOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOption
     */
    select?: RaceChoiceOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOption
     */
    omit?: RaceChoiceOptionOmit<ExtArgs> | null
    /**
     * The data used to create many RaceChoiceOptions.
     */
    data: RaceChoiceOptionCreateManyInput | RaceChoiceOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaceChoiceOption update
   */
  export type RaceChoiceOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOption
     */
    select?: RaceChoiceOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOption
     */
    omit?: RaceChoiceOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a RaceChoiceOption.
     */
    data: XOR<RaceChoiceOptionUpdateInput, RaceChoiceOptionUncheckedUpdateInput>
    /**
     * Choose, which RaceChoiceOption to update.
     */
    where: RaceChoiceOptionWhereUniqueInput
  }

  /**
   * RaceChoiceOption updateMany
   */
  export type RaceChoiceOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaceChoiceOptions.
     */
    data: XOR<RaceChoiceOptionUpdateManyMutationInput, RaceChoiceOptionUncheckedUpdateManyInput>
    /**
     * Filter which RaceChoiceOptions to update
     */
    where?: RaceChoiceOptionWhereInput
    /**
     * Limit how many RaceChoiceOptions to update.
     */
    limit?: number
  }

  /**
   * RaceChoiceOption updateManyAndReturn
   */
  export type RaceChoiceOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOption
     */
    select?: RaceChoiceOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOption
     */
    omit?: RaceChoiceOptionOmit<ExtArgs> | null
    /**
     * The data used to update RaceChoiceOptions.
     */
    data: XOR<RaceChoiceOptionUpdateManyMutationInput, RaceChoiceOptionUncheckedUpdateManyInput>
    /**
     * Filter which RaceChoiceOptions to update
     */
    where?: RaceChoiceOptionWhereInput
    /**
     * Limit how many RaceChoiceOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaceChoiceOption upsert
   */
  export type RaceChoiceOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOption
     */
    select?: RaceChoiceOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOption
     */
    omit?: RaceChoiceOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the RaceChoiceOption to update in case it exists.
     */
    where: RaceChoiceOptionWhereUniqueInput
    /**
     * In case the RaceChoiceOption found by the `where` argument doesn't exist, create a new RaceChoiceOption with this data.
     */
    create: XOR<RaceChoiceOptionCreateInput, RaceChoiceOptionUncheckedCreateInput>
    /**
     * In case the RaceChoiceOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceChoiceOptionUpdateInput, RaceChoiceOptionUncheckedUpdateInput>
  }

  /**
   * RaceChoiceOption delete
   */
  export type RaceChoiceOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOption
     */
    select?: RaceChoiceOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOption
     */
    omit?: RaceChoiceOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionInclude<ExtArgs> | null
    /**
     * Filter which RaceChoiceOption to delete.
     */
    where: RaceChoiceOptionWhereUniqueInput
  }

  /**
   * RaceChoiceOption deleteMany
   */
  export type RaceChoiceOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceChoiceOptions to delete
     */
    where?: RaceChoiceOptionWhereInput
    /**
     * Limit how many RaceChoiceOptions to delete.
     */
    limit?: number
  }

  /**
   * RaceChoiceOption.grantsTraits
   */
  export type RaceChoiceOption$grantsTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOptionTrait
     */
    select?: RaceChoiceOptionTraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOptionTrait
     */
    omit?: RaceChoiceOptionTraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionTraitInclude<ExtArgs> | null
    where?: RaceChoiceOptionTraitWhereInput
    orderBy?: RaceChoiceOptionTraitOrderByWithRelationInput | RaceChoiceOptionTraitOrderByWithRelationInput[]
    cursor?: RaceChoiceOptionTraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceChoiceOptionTraitScalarFieldEnum | RaceChoiceOptionTraitScalarFieldEnum[]
  }

  /**
   * RaceChoiceOption.subrace
   */
  export type RaceChoiceOption$subraceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subrace
     */
    select?: SubraceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subrace
     */
    omit?: SubraceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubraceInclude<ExtArgs> | null
    where?: SubraceWhereInput
  }

  /**
   * RaceChoiceOption.perses
   */
  export type RaceChoiceOption$persesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    where?: PersWhereInput
    orderBy?: PersOrderByWithRelationInput | PersOrderByWithRelationInput[]
    cursor?: PersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersScalarFieldEnum | PersScalarFieldEnum[]
  }

  /**
   * RaceChoiceOption without action
   */
  export type RaceChoiceOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceChoiceOption
     */
    select?: RaceChoiceOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceChoiceOption
     */
    omit?: RaceChoiceOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceChoiceOptionInclude<ExtArgs> | null
  }


  /**
   * Model Background
   */

  export type AggregateBackground = {
    _count: BackgroundCountAggregateOutputType | null
    _avg: BackgroundAvgAggregateOutputType | null
    _sum: BackgroundSumAggregateOutputType | null
    _min: BackgroundMinAggregateOutputType | null
    _max: BackgroundMaxAggregateOutputType | null
  }

  export type BackgroundAvgAggregateOutputType = {
    backgroundId: number | null
    languagesToChooseCount: number | null
  }

  export type BackgroundSumAggregateOutputType = {
    backgroundId: number | null
    languagesToChooseCount: number | null
  }

  export type BackgroundMinAggregateOutputType = {
    backgroundId: number | null
    name: $Enums.BackgroundCategory | null
    source: $Enums.Source | null
    languagesToChooseCount: number | null
  }

  export type BackgroundMaxAggregateOutputType = {
    backgroundId: number | null
    name: $Enums.BackgroundCategory | null
    source: $Enums.Source | null
    languagesToChooseCount: number | null
  }

  export type BackgroundCountAggregateOutputType = {
    backgroundId: number
    name: number
    source: number
    toolProficiencies: number
    skillProficiencies: number
    languagesToChooseCount: number
    items: number
    _all: number
  }


  export type BackgroundAvgAggregateInputType = {
    backgroundId?: true
    languagesToChooseCount?: true
  }

  export type BackgroundSumAggregateInputType = {
    backgroundId?: true
    languagesToChooseCount?: true
  }

  export type BackgroundMinAggregateInputType = {
    backgroundId?: true
    name?: true
    source?: true
    languagesToChooseCount?: true
  }

  export type BackgroundMaxAggregateInputType = {
    backgroundId?: true
    name?: true
    source?: true
    languagesToChooseCount?: true
  }

  export type BackgroundCountAggregateInputType = {
    backgroundId?: true
    name?: true
    source?: true
    toolProficiencies?: true
    skillProficiencies?: true
    languagesToChooseCount?: true
    items?: true
    _all?: true
  }

  export type BackgroundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Background to aggregate.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Backgrounds
    **/
    _count?: true | BackgroundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BackgroundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BackgroundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BackgroundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BackgroundMaxAggregateInputType
  }

  export type GetBackgroundAggregateType<T extends BackgroundAggregateArgs> = {
        [P in keyof T & keyof AggregateBackground]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackground[P]>
      : GetScalarType<T[P], AggregateBackground[P]>
  }




  export type BackgroundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BackgroundWhereInput
    orderBy?: BackgroundOrderByWithAggregationInput | BackgroundOrderByWithAggregationInput[]
    by: BackgroundScalarFieldEnum[] | BackgroundScalarFieldEnum
    having?: BackgroundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BackgroundCountAggregateInputType | true
    _avg?: BackgroundAvgAggregateInputType
    _sum?: BackgroundSumAggregateInputType
    _min?: BackgroundMinAggregateInputType
    _max?: BackgroundMaxAggregateInputType
  }

  export type BackgroundGroupByOutputType = {
    backgroundId: number
    name: $Enums.BackgroundCategory
    source: $Enums.Source
    toolProficiencies: $Enums.ToolCategory[]
    skillProficiencies: $Enums.Skills[]
    languagesToChooseCount: number
    items: JsonValue | null
    _count: BackgroundCountAggregateOutputType | null
    _avg: BackgroundAvgAggregateOutputType | null
    _sum: BackgroundSumAggregateOutputType | null
    _min: BackgroundMinAggregateOutputType | null
    _max: BackgroundMaxAggregateOutputType | null
  }

  type GetBackgroundGroupByPayload<T extends BackgroundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BackgroundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BackgroundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BackgroundGroupByOutputType[P]>
            : GetScalarType<T[P], BackgroundGroupByOutputType[P]>
        }
      >
    >


  export type BackgroundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    backgroundId?: boolean
    name?: boolean
    source?: boolean
    toolProficiencies?: boolean
    skillProficiencies?: boolean
    languagesToChooseCount?: boolean
    items?: boolean
    perses?: boolean | Background$persesArgs<ExtArgs>
    _count?: boolean | BackgroundCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["background"]>

  export type BackgroundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    backgroundId?: boolean
    name?: boolean
    source?: boolean
    toolProficiencies?: boolean
    skillProficiencies?: boolean
    languagesToChooseCount?: boolean
    items?: boolean
  }, ExtArgs["result"]["background"]>

  export type BackgroundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    backgroundId?: boolean
    name?: boolean
    source?: boolean
    toolProficiencies?: boolean
    skillProficiencies?: boolean
    languagesToChooseCount?: boolean
    items?: boolean
  }, ExtArgs["result"]["background"]>

  export type BackgroundSelectScalar = {
    backgroundId?: boolean
    name?: boolean
    source?: boolean
    toolProficiencies?: boolean
    skillProficiencies?: boolean
    languagesToChooseCount?: boolean
    items?: boolean
  }

  export type BackgroundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"backgroundId" | "name" | "source" | "toolProficiencies" | "skillProficiencies" | "languagesToChooseCount" | "items", ExtArgs["result"]["background"]>
  export type BackgroundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    perses?: boolean | Background$persesArgs<ExtArgs>
    _count?: boolean | BackgroundCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BackgroundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BackgroundIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BackgroundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Background"
    objects: {
      perses: Prisma.$PersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      backgroundId: number
      name: $Enums.BackgroundCategory
      source: $Enums.Source
      toolProficiencies: $Enums.ToolCategory[]
      skillProficiencies: $Enums.Skills[]
      languagesToChooseCount: number
      items: Prisma.JsonValue | null
    }, ExtArgs["result"]["background"]>
    composites: {}
  }

  type BackgroundGetPayload<S extends boolean | null | undefined | BackgroundDefaultArgs> = $Result.GetResult<Prisma.$BackgroundPayload, S>

  type BackgroundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BackgroundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BackgroundCountAggregateInputType | true
    }

  export interface BackgroundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Background'], meta: { name: 'Background' } }
    /**
     * Find zero or one Background that matches the filter.
     * @param {BackgroundFindUniqueArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BackgroundFindUniqueArgs>(args: SelectSubset<T, BackgroundFindUniqueArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Background that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BackgroundFindUniqueOrThrowArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BackgroundFindUniqueOrThrowArgs>(args: SelectSubset<T, BackgroundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Background that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundFindFirstArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BackgroundFindFirstArgs>(args?: SelectSubset<T, BackgroundFindFirstArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Background that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundFindFirstOrThrowArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BackgroundFindFirstOrThrowArgs>(args?: SelectSubset<T, BackgroundFindFirstOrThrowArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Backgrounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Backgrounds
     * const backgrounds = await prisma.background.findMany()
     * 
     * // Get first 10 Backgrounds
     * const backgrounds = await prisma.background.findMany({ take: 10 })
     * 
     * // Only select the `backgroundId`
     * const backgroundWithBackgroundIdOnly = await prisma.background.findMany({ select: { backgroundId: true } })
     * 
     */
    findMany<T extends BackgroundFindManyArgs>(args?: SelectSubset<T, BackgroundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Background.
     * @param {BackgroundCreateArgs} args - Arguments to create a Background.
     * @example
     * // Create one Background
     * const Background = await prisma.background.create({
     *   data: {
     *     // ... data to create a Background
     *   }
     * })
     * 
     */
    create<T extends BackgroundCreateArgs>(args: SelectSubset<T, BackgroundCreateArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Backgrounds.
     * @param {BackgroundCreateManyArgs} args - Arguments to create many Backgrounds.
     * @example
     * // Create many Backgrounds
     * const background = await prisma.background.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BackgroundCreateManyArgs>(args?: SelectSubset<T, BackgroundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Backgrounds and returns the data saved in the database.
     * @param {BackgroundCreateManyAndReturnArgs} args - Arguments to create many Backgrounds.
     * @example
     * // Create many Backgrounds
     * const background = await prisma.background.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Backgrounds and only return the `backgroundId`
     * const backgroundWithBackgroundIdOnly = await prisma.background.createManyAndReturn({
     *   select: { backgroundId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BackgroundCreateManyAndReturnArgs>(args?: SelectSubset<T, BackgroundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Background.
     * @param {BackgroundDeleteArgs} args - Arguments to delete one Background.
     * @example
     * // Delete one Background
     * const Background = await prisma.background.delete({
     *   where: {
     *     // ... filter to delete one Background
     *   }
     * })
     * 
     */
    delete<T extends BackgroundDeleteArgs>(args: SelectSubset<T, BackgroundDeleteArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Background.
     * @param {BackgroundUpdateArgs} args - Arguments to update one Background.
     * @example
     * // Update one Background
     * const background = await prisma.background.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BackgroundUpdateArgs>(args: SelectSubset<T, BackgroundUpdateArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Backgrounds.
     * @param {BackgroundDeleteManyArgs} args - Arguments to filter Backgrounds to delete.
     * @example
     * // Delete a few Backgrounds
     * const { count } = await prisma.background.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BackgroundDeleteManyArgs>(args?: SelectSubset<T, BackgroundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Backgrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Backgrounds
     * const background = await prisma.background.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BackgroundUpdateManyArgs>(args: SelectSubset<T, BackgroundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Backgrounds and returns the data updated in the database.
     * @param {BackgroundUpdateManyAndReturnArgs} args - Arguments to update many Backgrounds.
     * @example
     * // Update many Backgrounds
     * const background = await prisma.background.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Backgrounds and only return the `backgroundId`
     * const backgroundWithBackgroundIdOnly = await prisma.background.updateManyAndReturn({
     *   select: { backgroundId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BackgroundUpdateManyAndReturnArgs>(args: SelectSubset<T, BackgroundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Background.
     * @param {BackgroundUpsertArgs} args - Arguments to update or create a Background.
     * @example
     * // Update or create a Background
     * const background = await prisma.background.upsert({
     *   create: {
     *     // ... data to create a Background
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Background we want to update
     *   }
     * })
     */
    upsert<T extends BackgroundUpsertArgs>(args: SelectSubset<T, BackgroundUpsertArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Backgrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundCountArgs} args - Arguments to filter Backgrounds to count.
     * @example
     * // Count the number of Backgrounds
     * const count = await prisma.background.count({
     *   where: {
     *     // ... the filter for the Backgrounds we want to count
     *   }
     * })
    **/
    count<T extends BackgroundCountArgs>(
      args?: Subset<T, BackgroundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BackgroundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Background.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BackgroundAggregateArgs>(args: Subset<T, BackgroundAggregateArgs>): Prisma.PrismaPromise<GetBackgroundAggregateType<T>>

    /**
     * Group by Background.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BackgroundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BackgroundGroupByArgs['orderBy'] }
        : { orderBy?: BackgroundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BackgroundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBackgroundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Background model
   */
  readonly fields: BackgroundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Background.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BackgroundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    perses<T extends Background$persesArgs<ExtArgs> = {}>(args?: Subset<T, Background$persesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Background model
   */
  interface BackgroundFieldRefs {
    readonly backgroundId: FieldRef<"Background", 'Int'>
    readonly name: FieldRef<"Background", 'BackgroundCategory'>
    readonly source: FieldRef<"Background", 'Source'>
    readonly toolProficiencies: FieldRef<"Background", 'ToolCategory[]'>
    readonly skillProficiencies: FieldRef<"Background", 'Skills[]'>
    readonly languagesToChooseCount: FieldRef<"Background", 'Int'>
    readonly items: FieldRef<"Background", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Background findUnique
   */
  export type BackgroundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackgroundInclude<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background findUniqueOrThrow
   */
  export type BackgroundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackgroundInclude<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background findFirst
   */
  export type BackgroundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackgroundInclude<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Backgrounds.
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Backgrounds.
     */
    distinct?: BackgroundScalarFieldEnum | BackgroundScalarFieldEnum[]
  }

  /**
   * Background findFirstOrThrow
   */
  export type BackgroundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackgroundInclude<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Backgrounds.
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Backgrounds.
     */
    distinct?: BackgroundScalarFieldEnum | BackgroundScalarFieldEnum[]
  }

  /**
   * Background findMany
   */
  export type BackgroundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackgroundInclude<ExtArgs> | null
    /**
     * Filter, which Backgrounds to fetch.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Backgrounds.
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    distinct?: BackgroundScalarFieldEnum | BackgroundScalarFieldEnum[]
  }

  /**
   * Background create
   */
  export type BackgroundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackgroundInclude<ExtArgs> | null
    /**
     * The data needed to create a Background.
     */
    data: XOR<BackgroundCreateInput, BackgroundUncheckedCreateInput>
  }

  /**
   * Background createMany
   */
  export type BackgroundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Backgrounds.
     */
    data: BackgroundCreateManyInput | BackgroundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Background createManyAndReturn
   */
  export type BackgroundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The data used to create many Backgrounds.
     */
    data: BackgroundCreateManyInput | BackgroundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Background update
   */
  export type BackgroundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackgroundInclude<ExtArgs> | null
    /**
     * The data needed to update a Background.
     */
    data: XOR<BackgroundUpdateInput, BackgroundUncheckedUpdateInput>
    /**
     * Choose, which Background to update.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background updateMany
   */
  export type BackgroundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Backgrounds.
     */
    data: XOR<BackgroundUpdateManyMutationInput, BackgroundUncheckedUpdateManyInput>
    /**
     * Filter which Backgrounds to update
     */
    where?: BackgroundWhereInput
    /**
     * Limit how many Backgrounds to update.
     */
    limit?: number
  }

  /**
   * Background updateManyAndReturn
   */
  export type BackgroundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The data used to update Backgrounds.
     */
    data: XOR<BackgroundUpdateManyMutationInput, BackgroundUncheckedUpdateManyInput>
    /**
     * Filter which Backgrounds to update
     */
    where?: BackgroundWhereInput
    /**
     * Limit how many Backgrounds to update.
     */
    limit?: number
  }

  /**
   * Background upsert
   */
  export type BackgroundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackgroundInclude<ExtArgs> | null
    /**
     * The filter to search for the Background to update in case it exists.
     */
    where: BackgroundWhereUniqueInput
    /**
     * In case the Background found by the `where` argument doesn't exist, create a new Background with this data.
     */
    create: XOR<BackgroundCreateInput, BackgroundUncheckedCreateInput>
    /**
     * In case the Background was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BackgroundUpdateInput, BackgroundUncheckedUpdateInput>
  }

  /**
   * Background delete
   */
  export type BackgroundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackgroundInclude<ExtArgs> | null
    /**
     * Filter which Background to delete.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background deleteMany
   */
  export type BackgroundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Backgrounds to delete
     */
    where?: BackgroundWhereInput
    /**
     * Limit how many Backgrounds to delete.
     */
    limit?: number
  }

  /**
   * Background.perses
   */
  export type Background$persesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pers
     */
    select?: PersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pers
     */
    omit?: PersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersInclude<ExtArgs> | null
    where?: PersWhereInput
    orderBy?: PersOrderByWithRelationInput | PersOrderByWithRelationInput[]
    cursor?: PersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersScalarFieldEnum | PersScalarFieldEnum[]
  }

  /**
   * Background without action
   */
  export type BackgroundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackgroundInclude<ExtArgs> | null
  }


  /**
   * Model Feat
   */

  export type AggregateFeat = {
    _count: FeatCountAggregateOutputType | null
    _avg: FeatAvgAggregateOutputType | null
    _sum: FeatSumAggregateOutputType | null
    _min: FeatMinAggregateOutputType | null
    _max: FeatMaxAggregateOutputType | null
  }

  export type FeatAvgAggregateOutputType = {
    featId: number | null
    languagesToChooseCount: number | null
  }

  export type FeatSumAggregateOutputType = {
    featId: number | null
    languagesToChooseCount: number | null
  }

  export type FeatMinAggregateOutputType = {
    featId: number | null
    name: string | null
    category: $Enums.FeatCategory | null
    shortDescription: string | null
    longDescription: string | null
    languagesToChooseCount: number | null
  }

  export type FeatMaxAggregateOutputType = {
    featId: number | null
    name: string | null
    category: $Enums.FeatCategory | null
    shortDescription: string | null
    longDescription: string | null
    languagesToChooseCount: number | null
  }

  export type FeatCountAggregateOutputType = {
    featId: number
    name: number
    category: number
    shortDescription: number
    longDescription: number
    languagesToChooseCount: number
    languages: number
    prerequisites: number
    _all: number
  }


  export type FeatAvgAggregateInputType = {
    featId?: true
    languagesToChooseCount?: true
  }

  export type FeatSumAggregateInputType = {
    featId?: true
    languagesToChooseCount?: true
  }

  export type FeatMinAggregateInputType = {
    featId?: true
    name?: true
    category?: true
    shortDescription?: true
    longDescription?: true
    languagesToChooseCount?: true
  }

  export type FeatMaxAggregateInputType = {
    featId?: true
    name?: true
    category?: true
    shortDescription?: true
    longDescription?: true
    languagesToChooseCount?: true
  }

  export type FeatCountAggregateInputType = {
    featId?: true
    name?: true
    category?: true
    shortDescription?: true
    longDescription?: true
    languagesToChooseCount?: true
    languages?: true
    prerequisites?: true
    _all?: true
  }

  export type FeatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feat to aggregate.
     */
    where?: FeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feats to fetch.
     */
    orderBy?: FeatOrderByWithRelationInput | FeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feats
    **/
    _count?: true | FeatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatMaxAggregateInputType
  }

  export type GetFeatAggregateType<T extends FeatAggregateArgs> = {
        [P in keyof T & keyof AggregateFeat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeat[P]>
      : GetScalarType<T[P], AggregateFeat[P]>
  }




  export type FeatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatWhereInput
    orderBy?: FeatOrderByWithAggregationInput | FeatOrderByWithAggregationInput[]
    by: FeatScalarFieldEnum[] | FeatScalarFieldEnum
    having?: FeatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatCountAggregateInputType | true
    _avg?: FeatAvgAggregateInputType
    _sum?: FeatSumAggregateInputType
    _min?: FeatMinAggregateInputType
    _max?: FeatMaxAggregateInputType
  }

  export type FeatGroupByOutputType = {
    featId: number
    name: string
    category: $Enums.FeatCategory
    shortDescription: string
    longDescription: string
    languagesToChooseCount: number
    languages: $Enums.Language[]
    prerequisites: JsonValue | null
    _count: FeatCountAggregateOutputType | null
    _avg: FeatAvgAggregateOutputType | null
    _sum: FeatSumAggregateOutputType | null
    _min: FeatMinAggregateOutputType | null
    _max: FeatMaxAggregateOutputType | null
  }

  type GetFeatGroupByPayload<T extends FeatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatGroupByOutputType[P]>
            : GetScalarType<T[P], FeatGroupByOutputType[P]>
        }
      >
    >


  export type FeatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    featId?: boolean
    name?: boolean
    category?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    languagesToChooseCount?: boolean
    languages?: boolean
    prerequisites?: boolean
    featFeatures?: boolean | Feat$featFeaturesArgs<ExtArgs>
    featAbilityBoost?: boolean | Feat$featAbilityBoostArgs<ExtArgs>
    persFeats?: boolean | Feat$persFeatsArgs<ExtArgs>
    _count?: boolean | FeatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feat"]>

  export type FeatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    featId?: boolean
    name?: boolean
    category?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    languagesToChooseCount?: boolean
    languages?: boolean
    prerequisites?: boolean
  }, ExtArgs["result"]["feat"]>

  export type FeatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    featId?: boolean
    name?: boolean
    category?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    languagesToChooseCount?: boolean
    languages?: boolean
    prerequisites?: boolean
  }, ExtArgs["result"]["feat"]>

  export type FeatSelectScalar = {
    featId?: boolean
    name?: boolean
    category?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    languagesToChooseCount?: boolean
    languages?: boolean
    prerequisites?: boolean
  }

  export type FeatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"featId" | "name" | "category" | "shortDescription" | "longDescription" | "languagesToChooseCount" | "languages" | "prerequisites", ExtArgs["result"]["feat"]>
  export type FeatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    featFeatures?: boolean | Feat$featFeaturesArgs<ExtArgs>
    featAbilityBoost?: boolean | Feat$featAbilityBoostArgs<ExtArgs>
    persFeats?: boolean | Feat$persFeatsArgs<ExtArgs>
    _count?: boolean | FeatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FeatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FeatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feat"
    objects: {
      featFeatures: Prisma.$FeatFeaturePayload<ExtArgs>[]
      featAbilityBoost: Prisma.$FeatAbilityBoostPayload<ExtArgs> | null
      persFeats: Prisma.$PersFeatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      featId: number
      name: string
      category: $Enums.FeatCategory
      shortDescription: string
      longDescription: string
      languagesToChooseCount: number
      languages: $Enums.Language[]
      prerequisites: Prisma.JsonValue | null
    }, ExtArgs["result"]["feat"]>
    composites: {}
  }

  type FeatGetPayload<S extends boolean | null | undefined | FeatDefaultArgs> = $Result.GetResult<Prisma.$FeatPayload, S>

  type FeatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatCountAggregateInputType | true
    }

  export interface FeatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feat'], meta: { name: 'Feat' } }
    /**
     * Find zero or one Feat that matches the filter.
     * @param {FeatFindUniqueArgs} args - Arguments to find a Feat
     * @example
     * // Get one Feat
     * const feat = await prisma.feat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatFindUniqueArgs>(args: SelectSubset<T, FeatFindUniqueArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatFindUniqueOrThrowArgs} args - Arguments to find a Feat
     * @example
     * // Get one Feat
     * const feat = await prisma.feat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatFindFirstArgs} args - Arguments to find a Feat
     * @example
     * // Get one Feat
     * const feat = await prisma.feat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatFindFirstArgs>(args?: SelectSubset<T, FeatFindFirstArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatFindFirstOrThrowArgs} args - Arguments to find a Feat
     * @example
     * // Get one Feat
     * const feat = await prisma.feat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feats
     * const feats = await prisma.feat.findMany()
     * 
     * // Get first 10 Feats
     * const feats = await prisma.feat.findMany({ take: 10 })
     * 
     * // Only select the `featId`
     * const featWithFeatIdOnly = await prisma.feat.findMany({ select: { featId: true } })
     * 
     */
    findMany<T extends FeatFindManyArgs>(args?: SelectSubset<T, FeatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feat.
     * @param {FeatCreateArgs} args - Arguments to create a Feat.
     * @example
     * // Create one Feat
     * const Feat = await prisma.feat.create({
     *   data: {
     *     // ... data to create a Feat
     *   }
     * })
     * 
     */
    create<T extends FeatCreateArgs>(args: SelectSubset<T, FeatCreateArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feats.
     * @param {FeatCreateManyArgs} args - Arguments to create many Feats.
     * @example
     * // Create many Feats
     * const feat = await prisma.feat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatCreateManyArgs>(args?: SelectSubset<T, FeatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feats and returns the data saved in the database.
     * @param {FeatCreateManyAndReturnArgs} args - Arguments to create many Feats.
     * @example
     * // Create many Feats
     * const feat = await prisma.feat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feats and only return the `featId`
     * const featWithFeatIdOnly = await prisma.feat.createManyAndReturn({
     *   select: { featId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feat.
     * @param {FeatDeleteArgs} args - Arguments to delete one Feat.
     * @example
     * // Delete one Feat
     * const Feat = await prisma.feat.delete({
     *   where: {
     *     // ... filter to delete one Feat
     *   }
     * })
     * 
     */
    delete<T extends FeatDeleteArgs>(args: SelectSubset<T, FeatDeleteArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feat.
     * @param {FeatUpdateArgs} args - Arguments to update one Feat.
     * @example
     * // Update one Feat
     * const feat = await prisma.feat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatUpdateArgs>(args: SelectSubset<T, FeatUpdateArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feats.
     * @param {FeatDeleteManyArgs} args - Arguments to filter Feats to delete.
     * @example
     * // Delete a few Feats
     * const { count } = await prisma.feat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatDeleteManyArgs>(args?: SelectSubset<T, FeatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feats
     * const feat = await prisma.feat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatUpdateManyArgs>(args: SelectSubset<T, FeatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feats and returns the data updated in the database.
     * @param {FeatUpdateManyAndReturnArgs} args - Arguments to update many Feats.
     * @example
     * // Update many Feats
     * const feat = await prisma.feat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Feats and only return the `featId`
     * const featWithFeatIdOnly = await prisma.feat.updateManyAndReturn({
     *   select: { featId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feat.
     * @param {FeatUpsertArgs} args - Arguments to update or create a Feat.
     * @example
     * // Update or create a Feat
     * const feat = await prisma.feat.upsert({
     *   create: {
     *     // ... data to create a Feat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feat we want to update
     *   }
     * })
     */
    upsert<T extends FeatUpsertArgs>(args: SelectSubset<T, FeatUpsertArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Feats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatCountArgs} args - Arguments to filter Feats to count.
     * @example
     * // Count the number of Feats
     * const count = await prisma.feat.count({
     *   where: {
     *     // ... the filter for the Feats we want to count
     *   }
     * })
    **/
    count<T extends FeatCountArgs>(
      args?: Subset<T, FeatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatAggregateArgs>(args: Subset<T, FeatAggregateArgs>): Prisma.PrismaPromise<GetFeatAggregateType<T>>

    /**
     * Group by Feat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatGroupByArgs['orderBy'] }
        : { orderBy?: FeatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feat model
   */
  readonly fields: FeatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    featFeatures<T extends Feat$featFeaturesArgs<ExtArgs> = {}>(args?: Subset<T, Feat$featFeaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    featAbilityBoost<T extends Feat$featAbilityBoostArgs<ExtArgs> = {}>(args?: Subset<T, Feat$featAbilityBoostArgs<ExtArgs>>): Prisma__FeatAbilityBoostClient<$Result.GetResult<Prisma.$FeatAbilityBoostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    persFeats<T extends Feat$persFeatsArgs<ExtArgs> = {}>(args?: Subset<T, Feat$persFeatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersFeatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feat model
   */
  interface FeatFieldRefs {
    readonly featId: FieldRef<"Feat", 'Int'>
    readonly name: FieldRef<"Feat", 'String'>
    readonly category: FieldRef<"Feat", 'FeatCategory'>
    readonly shortDescription: FieldRef<"Feat", 'String'>
    readonly longDescription: FieldRef<"Feat", 'String'>
    readonly languagesToChooseCount: FieldRef<"Feat", 'Int'>
    readonly languages: FieldRef<"Feat", 'Language[]'>
    readonly prerequisites: FieldRef<"Feat", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Feat findUnique
   */
  export type FeatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * Filter, which Feat to fetch.
     */
    where: FeatWhereUniqueInput
  }

  /**
   * Feat findUniqueOrThrow
   */
  export type FeatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * Filter, which Feat to fetch.
     */
    where: FeatWhereUniqueInput
  }

  /**
   * Feat findFirst
   */
  export type FeatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * Filter, which Feat to fetch.
     */
    where?: FeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feats to fetch.
     */
    orderBy?: FeatOrderByWithRelationInput | FeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feats.
     */
    cursor?: FeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feats.
     */
    distinct?: FeatScalarFieldEnum | FeatScalarFieldEnum[]
  }

  /**
   * Feat findFirstOrThrow
   */
  export type FeatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * Filter, which Feat to fetch.
     */
    where?: FeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feats to fetch.
     */
    orderBy?: FeatOrderByWithRelationInput | FeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feats.
     */
    cursor?: FeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feats.
     */
    distinct?: FeatScalarFieldEnum | FeatScalarFieldEnum[]
  }

  /**
   * Feat findMany
   */
  export type FeatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * Filter, which Feats to fetch.
     */
    where?: FeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feats to fetch.
     */
    orderBy?: FeatOrderByWithRelationInput | FeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feats.
     */
    cursor?: FeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feats.
     */
    skip?: number
    distinct?: FeatScalarFieldEnum | FeatScalarFieldEnum[]
  }

  /**
   * Feat create
   */
  export type FeatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * The data needed to create a Feat.
     */
    data: XOR<FeatCreateInput, FeatUncheckedCreateInput>
  }

  /**
   * Feat createMany
   */
  export type FeatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feats.
     */
    data: FeatCreateManyInput | FeatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feat createManyAndReturn
   */
  export type FeatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * The data used to create many Feats.
     */
    data: FeatCreateManyInput | FeatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feat update
   */
  export type FeatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * The data needed to update a Feat.
     */
    data: XOR<FeatUpdateInput, FeatUncheckedUpdateInput>
    /**
     * Choose, which Feat to update.
     */
    where: FeatWhereUniqueInput
  }

  /**
   * Feat updateMany
   */
  export type FeatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feats.
     */
    data: XOR<FeatUpdateManyMutationInput, FeatUncheckedUpdateManyInput>
    /**
     * Filter which Feats to update
     */
    where?: FeatWhereInput
    /**
     * Limit how many Feats to update.
     */
    limit?: number
  }

  /**
   * Feat updateManyAndReturn
   */
  export type FeatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * The data used to update Feats.
     */
    data: XOR<FeatUpdateManyMutationInput, FeatUncheckedUpdateManyInput>
    /**
     * Filter which Feats to update
     */
    where?: FeatWhereInput
    /**
     * Limit how many Feats to update.
     */
    limit?: number
  }

  /**
   * Feat upsert
   */
  export type FeatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * The filter to search for the Feat to update in case it exists.
     */
    where: FeatWhereUniqueInput
    /**
     * In case the Feat found by the `where` argument doesn't exist, create a new Feat with this data.
     */
    create: XOR<FeatCreateInput, FeatUncheckedCreateInput>
    /**
     * In case the Feat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatUpdateInput, FeatUncheckedUpdateInput>
  }

  /**
   * Feat delete
   */
  export type FeatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
    /**
     * Filter which Feat to delete.
     */
    where: FeatWhereUniqueInput
  }

  /**
   * Feat deleteMany
   */
  export type FeatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feats to delete
     */
    where?: FeatWhereInput
    /**
     * Limit how many Feats to delete.
     */
    limit?: number
  }

  /**
   * Feat.featFeatures
   */
  export type Feat$featFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatFeature
     */
    select?: FeatFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatFeature
     */
    omit?: FeatFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatFeatureInclude<ExtArgs> | null
    where?: FeatFeatureWhereInput
    orderBy?: FeatFeatureOrderByWithRelationInput | FeatFeatureOrderByWithRelationInput[]
    cursor?: FeatFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeatFeatureScalarFieldEnum | FeatFeatureScalarFieldEnum[]
  }

  /**
   * Feat.featAbilityBoost
   */
  export type Feat$featAbilityBoostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatAbilityBoost
     */
    select?: FeatAbilityBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatAbilityBoost
     */
    omit?: FeatAbilityBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatAbilityBoostInclude<ExtArgs> | null
    where?: FeatAbilityBoostWhereInput
  }

  /**
   * Feat.persFeats
   */
  export type Feat$persFeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeat
     */
    select?: PersFeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeat
     */
    omit?: PersFeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatInclude<ExtArgs> | null
    where?: PersFeatWhereInput
    orderBy?: PersFeatOrderByWithRelationInput | PersFeatOrderByWithRelationInput[]
    cursor?: PersFeatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersFeatScalarFieldEnum | PersFeatScalarFieldEnum[]
  }

  /**
   * Feat without action
   */
  export type FeatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feat
     */
    select?: FeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feat
     */
    omit?: FeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatInclude<ExtArgs> | null
  }


  /**
   * Model FeatAbilityBoost
   */

  export type AggregateFeatAbilityBoost = {
    _count: FeatAbilityBoostCountAggregateOutputType | null
    _avg: FeatAbilityBoostAvgAggregateOutputType | null
    _sum: FeatAbilityBoostSumAggregateOutputType | null
    _min: FeatAbilityBoostMinAggregateOutputType | null
    _max: FeatAbilityBoostMaxAggregateOutputType | null
  }

  export type FeatAbilityBoostAvgAggregateOutputType = {
    boostId: number | null
    featId: number | null
    increaseValue: number | null
    maxValue: number | null
  }

  export type FeatAbilityBoostSumAggregateOutputType = {
    boostId: number | null
    featId: number | null
    increaseValue: number | null
    maxValue: number | null
  }

  export type FeatAbilityBoostMinAggregateOutputType = {
    boostId: number | null
    featId: number | null
    ability: $Enums.Ability | null
    increaseValue: number | null
    maxValue: number | null
  }

  export type FeatAbilityBoostMaxAggregateOutputType = {
    boostId: number | null
    featId: number | null
    ability: $Enums.Ability | null
    increaseValue: number | null
    maxValue: number | null
  }

  export type FeatAbilityBoostCountAggregateOutputType = {
    boostId: number
    featId: number
    ability: number
    increaseValue: number
    abilitiesToChoose: number
    maxValue: number
    _all: number
  }


  export type FeatAbilityBoostAvgAggregateInputType = {
    boostId?: true
    featId?: true
    increaseValue?: true
    maxValue?: true
  }

  export type FeatAbilityBoostSumAggregateInputType = {
    boostId?: true
    featId?: true
    increaseValue?: true
    maxValue?: true
  }

  export type FeatAbilityBoostMinAggregateInputType = {
    boostId?: true
    featId?: true
    ability?: true
    increaseValue?: true
    maxValue?: true
  }

  export type FeatAbilityBoostMaxAggregateInputType = {
    boostId?: true
    featId?: true
    ability?: true
    increaseValue?: true
    maxValue?: true
  }

  export type FeatAbilityBoostCountAggregateInputType = {
    boostId?: true
    featId?: true
    ability?: true
    increaseValue?: true
    abilitiesToChoose?: true
    maxValue?: true
    _all?: true
  }

  export type FeatAbilityBoostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatAbilityBoost to aggregate.
     */
    where?: FeatAbilityBoostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatAbilityBoosts to fetch.
     */
    orderBy?: FeatAbilityBoostOrderByWithRelationInput | FeatAbilityBoostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatAbilityBoostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatAbilityBoosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatAbilityBoosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatAbilityBoosts
    **/
    _count?: true | FeatAbilityBoostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatAbilityBoostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatAbilityBoostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatAbilityBoostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatAbilityBoostMaxAggregateInputType
  }

  export type GetFeatAbilityBoostAggregateType<T extends FeatAbilityBoostAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatAbilityBoost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatAbilityBoost[P]>
      : GetScalarType<T[P], AggregateFeatAbilityBoost[P]>
  }




  export type FeatAbilityBoostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatAbilityBoostWhereInput
    orderBy?: FeatAbilityBoostOrderByWithAggregationInput | FeatAbilityBoostOrderByWithAggregationInput[]
    by: FeatAbilityBoostScalarFieldEnum[] | FeatAbilityBoostScalarFieldEnum
    having?: FeatAbilityBoostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatAbilityBoostCountAggregateInputType | true
    _avg?: FeatAbilityBoostAvgAggregateInputType
    _sum?: FeatAbilityBoostSumAggregateInputType
    _min?: FeatAbilityBoostMinAggregateInputType
    _max?: FeatAbilityBoostMaxAggregateInputType
  }

  export type FeatAbilityBoostGroupByOutputType = {
    boostId: number
    featId: number
    ability: $Enums.Ability | null
    increaseValue: number
    abilitiesToChoose: $Enums.Ability[]
    maxValue: number
    _count: FeatAbilityBoostCountAggregateOutputType | null
    _avg: FeatAbilityBoostAvgAggregateOutputType | null
    _sum: FeatAbilityBoostSumAggregateOutputType | null
    _min: FeatAbilityBoostMinAggregateOutputType | null
    _max: FeatAbilityBoostMaxAggregateOutputType | null
  }

  type GetFeatAbilityBoostGroupByPayload<T extends FeatAbilityBoostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatAbilityBoostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatAbilityBoostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatAbilityBoostGroupByOutputType[P]>
            : GetScalarType<T[P], FeatAbilityBoostGroupByOutputType[P]>
        }
      >
    >


  export type FeatAbilityBoostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    boostId?: boolean
    featId?: boolean
    ability?: boolean
    increaseValue?: boolean
    abilitiesToChoose?: boolean
    maxValue?: boolean
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featAbilityBoost"]>

  export type FeatAbilityBoostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    boostId?: boolean
    featId?: boolean
    ability?: boolean
    increaseValue?: boolean
    abilitiesToChoose?: boolean
    maxValue?: boolean
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featAbilityBoost"]>

  export type FeatAbilityBoostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    boostId?: boolean
    featId?: boolean
    ability?: boolean
    increaseValue?: boolean
    abilitiesToChoose?: boolean
    maxValue?: boolean
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featAbilityBoost"]>

  export type FeatAbilityBoostSelectScalar = {
    boostId?: boolean
    featId?: boolean
    ability?: boolean
    increaseValue?: boolean
    abilitiesToChoose?: boolean
    maxValue?: boolean
  }

  export type FeatAbilityBoostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"boostId" | "featId" | "ability" | "increaseValue" | "abilitiesToChoose" | "maxValue", ExtArgs["result"]["featAbilityBoost"]>
  export type FeatAbilityBoostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }
  export type FeatAbilityBoostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }
  export type FeatAbilityBoostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feat?: boolean | FeatDefaultArgs<ExtArgs>
  }

  export type $FeatAbilityBoostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatAbilityBoost"
    objects: {
      feat: Prisma.$FeatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      boostId: number
      featId: number
      ability: $Enums.Ability | null
      increaseValue: number
      abilitiesToChoose: $Enums.Ability[]
      maxValue: number
    }, ExtArgs["result"]["featAbilityBoost"]>
    composites: {}
  }

  type FeatAbilityBoostGetPayload<S extends boolean | null | undefined | FeatAbilityBoostDefaultArgs> = $Result.GetResult<Prisma.$FeatAbilityBoostPayload, S>

  type FeatAbilityBoostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatAbilityBoostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatAbilityBoostCountAggregateInputType | true
    }

  export interface FeatAbilityBoostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatAbilityBoost'], meta: { name: 'FeatAbilityBoost' } }
    /**
     * Find zero or one FeatAbilityBoost that matches the filter.
     * @param {FeatAbilityBoostFindUniqueArgs} args - Arguments to find a FeatAbilityBoost
     * @example
     * // Get one FeatAbilityBoost
     * const featAbilityBoost = await prisma.featAbilityBoost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatAbilityBoostFindUniqueArgs>(args: SelectSubset<T, FeatAbilityBoostFindUniqueArgs<ExtArgs>>): Prisma__FeatAbilityBoostClient<$Result.GetResult<Prisma.$FeatAbilityBoostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeatAbilityBoost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatAbilityBoostFindUniqueOrThrowArgs} args - Arguments to find a FeatAbilityBoost
     * @example
     * // Get one FeatAbilityBoost
     * const featAbilityBoost = await prisma.featAbilityBoost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatAbilityBoostFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatAbilityBoostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatAbilityBoostClient<$Result.GetResult<Prisma.$FeatAbilityBoostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatAbilityBoost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatAbilityBoostFindFirstArgs} args - Arguments to find a FeatAbilityBoost
     * @example
     * // Get one FeatAbilityBoost
     * const featAbilityBoost = await prisma.featAbilityBoost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatAbilityBoostFindFirstArgs>(args?: SelectSubset<T, FeatAbilityBoostFindFirstArgs<ExtArgs>>): Prisma__FeatAbilityBoostClient<$Result.GetResult<Prisma.$FeatAbilityBoostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatAbilityBoost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatAbilityBoostFindFirstOrThrowArgs} args - Arguments to find a FeatAbilityBoost
     * @example
     * // Get one FeatAbilityBoost
     * const featAbilityBoost = await prisma.featAbilityBoost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatAbilityBoostFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatAbilityBoostFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatAbilityBoostClient<$Result.GetResult<Prisma.$FeatAbilityBoostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeatAbilityBoosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatAbilityBoostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatAbilityBoosts
     * const featAbilityBoosts = await prisma.featAbilityBoost.findMany()
     * 
     * // Get first 10 FeatAbilityBoosts
     * const featAbilityBoosts = await prisma.featAbilityBoost.findMany({ take: 10 })
     * 
     * // Only select the `boostId`
     * const featAbilityBoostWithBoostIdOnly = await prisma.featAbilityBoost.findMany({ select: { boostId: true } })
     * 
     */
    findMany<T extends FeatAbilityBoostFindManyArgs>(args?: SelectSubset<T, FeatAbilityBoostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatAbilityBoostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeatAbilityBoost.
     * @param {FeatAbilityBoostCreateArgs} args - Arguments to create a FeatAbilityBoost.
     * @example
     * // Create one FeatAbilityBoost
     * const FeatAbilityBoost = await prisma.featAbilityBoost.create({
     *   data: {
     *     // ... data to create a FeatAbilityBoost
     *   }
     * })
     * 
     */
    create<T extends FeatAbilityBoostCreateArgs>(args: SelectSubset<T, FeatAbilityBoostCreateArgs<ExtArgs>>): Prisma__FeatAbilityBoostClient<$Result.GetResult<Prisma.$FeatAbilityBoostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeatAbilityBoosts.
     * @param {FeatAbilityBoostCreateManyArgs} args - Arguments to create many FeatAbilityBoosts.
     * @example
     * // Create many FeatAbilityBoosts
     * const featAbilityBoost = await prisma.featAbilityBoost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatAbilityBoostCreateManyArgs>(args?: SelectSubset<T, FeatAbilityBoostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeatAbilityBoosts and returns the data saved in the database.
     * @param {FeatAbilityBoostCreateManyAndReturnArgs} args - Arguments to create many FeatAbilityBoosts.
     * @example
     * // Create many FeatAbilityBoosts
     * const featAbilityBoost = await prisma.featAbilityBoost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeatAbilityBoosts and only return the `boostId`
     * const featAbilityBoostWithBoostIdOnly = await prisma.featAbilityBoost.createManyAndReturn({
     *   select: { boostId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatAbilityBoostCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatAbilityBoostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatAbilityBoostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeatAbilityBoost.
     * @param {FeatAbilityBoostDeleteArgs} args - Arguments to delete one FeatAbilityBoost.
     * @example
     * // Delete one FeatAbilityBoost
     * const FeatAbilityBoost = await prisma.featAbilityBoost.delete({
     *   where: {
     *     // ... filter to delete one FeatAbilityBoost
     *   }
     * })
     * 
     */
    delete<T extends FeatAbilityBoostDeleteArgs>(args: SelectSubset<T, FeatAbilityBoostDeleteArgs<ExtArgs>>): Prisma__FeatAbilityBoostClient<$Result.GetResult<Prisma.$FeatAbilityBoostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeatAbilityBoost.
     * @param {FeatAbilityBoostUpdateArgs} args - Arguments to update one FeatAbilityBoost.
     * @example
     * // Update one FeatAbilityBoost
     * const featAbilityBoost = await prisma.featAbilityBoost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatAbilityBoostUpdateArgs>(args: SelectSubset<T, FeatAbilityBoostUpdateArgs<ExtArgs>>): Prisma__FeatAbilityBoostClient<$Result.GetResult<Prisma.$FeatAbilityBoostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeatAbilityBoosts.
     * @param {FeatAbilityBoostDeleteManyArgs} args - Arguments to filter FeatAbilityBoosts to delete.
     * @example
     * // Delete a few FeatAbilityBoosts
     * const { count } = await prisma.featAbilityBoost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatAbilityBoostDeleteManyArgs>(args?: SelectSubset<T, FeatAbilityBoostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatAbilityBoosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatAbilityBoostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatAbilityBoosts
     * const featAbilityBoost = await prisma.featAbilityBoost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatAbilityBoostUpdateManyArgs>(args: SelectSubset<T, FeatAbilityBoostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatAbilityBoosts and returns the data updated in the database.
     * @param {FeatAbilityBoostUpdateManyAndReturnArgs} args - Arguments to update many FeatAbilityBoosts.
     * @example
     * // Update many FeatAbilityBoosts
     * const featAbilityBoost = await prisma.featAbilityBoost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeatAbilityBoosts and only return the `boostId`
     * const featAbilityBoostWithBoostIdOnly = await prisma.featAbilityBoost.updateManyAndReturn({
     *   select: { boostId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatAbilityBoostUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatAbilityBoostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatAbilityBoostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeatAbilityBoost.
     * @param {FeatAbilityBoostUpsertArgs} args - Arguments to update or create a FeatAbilityBoost.
     * @example
     * // Update or create a FeatAbilityBoost
     * const featAbilityBoost = await prisma.featAbilityBoost.upsert({
     *   create: {
     *     // ... data to create a FeatAbilityBoost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatAbilityBoost we want to update
     *   }
     * })
     */
    upsert<T extends FeatAbilityBoostUpsertArgs>(args: SelectSubset<T, FeatAbilityBoostUpsertArgs<ExtArgs>>): Prisma__FeatAbilityBoostClient<$Result.GetResult<Prisma.$FeatAbilityBoostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeatAbilityBoosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatAbilityBoostCountArgs} args - Arguments to filter FeatAbilityBoosts to count.
     * @example
     * // Count the number of FeatAbilityBoosts
     * const count = await prisma.featAbilityBoost.count({
     *   where: {
     *     // ... the filter for the FeatAbilityBoosts we want to count
     *   }
     * })
    **/
    count<T extends FeatAbilityBoostCountArgs>(
      args?: Subset<T, FeatAbilityBoostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatAbilityBoostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatAbilityBoost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatAbilityBoostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatAbilityBoostAggregateArgs>(args: Subset<T, FeatAbilityBoostAggregateArgs>): Prisma.PrismaPromise<GetFeatAbilityBoostAggregateType<T>>

    /**
     * Group by FeatAbilityBoost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatAbilityBoostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatAbilityBoostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatAbilityBoostGroupByArgs['orderBy'] }
        : { orderBy?: FeatAbilityBoostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatAbilityBoostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatAbilityBoostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatAbilityBoost model
   */
  readonly fields: FeatAbilityBoostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatAbilityBoost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatAbilityBoostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feat<T extends FeatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatDefaultArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeatAbilityBoost model
   */
  interface FeatAbilityBoostFieldRefs {
    readonly boostId: FieldRef<"FeatAbilityBoost", 'Int'>
    readonly featId: FieldRef<"FeatAbilityBoost", 'Int'>
    readonly ability: FieldRef<"FeatAbilityBoost", 'Ability'>
    readonly increaseValue: FieldRef<"FeatAbilityBoost", 'Int'>
    readonly abilitiesToChoose: FieldRef<"FeatAbilityBoost", 'Ability[]'>
    readonly maxValue: FieldRef<"FeatAbilityBoost", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FeatAbilityBoost findUnique
   */
  export type FeatAbilityBoostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatAbilityBoost
     */
    select?: FeatAbilityBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatAbilityBoost
     */
    omit?: FeatAbilityBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatAbilityBoostInclude<ExtArgs> | null
    /**
     * Filter, which FeatAbilityBoost to fetch.
     */
    where: FeatAbilityBoostWhereUniqueInput
  }

  /**
   * FeatAbilityBoost findUniqueOrThrow
   */
  export type FeatAbilityBoostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatAbilityBoost
     */
    select?: FeatAbilityBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatAbilityBoost
     */
    omit?: FeatAbilityBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatAbilityBoostInclude<ExtArgs> | null
    /**
     * Filter, which FeatAbilityBoost to fetch.
     */
    where: FeatAbilityBoostWhereUniqueInput
  }

  /**
   * FeatAbilityBoost findFirst
   */
  export type FeatAbilityBoostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatAbilityBoost
     */
    select?: FeatAbilityBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatAbilityBoost
     */
    omit?: FeatAbilityBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatAbilityBoostInclude<ExtArgs> | null
    /**
     * Filter, which FeatAbilityBoost to fetch.
     */
    where?: FeatAbilityBoostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatAbilityBoosts to fetch.
     */
    orderBy?: FeatAbilityBoostOrderByWithRelationInput | FeatAbilityBoostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatAbilityBoosts.
     */
    cursor?: FeatAbilityBoostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatAbilityBoosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatAbilityBoosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatAbilityBoosts.
     */
    distinct?: FeatAbilityBoostScalarFieldEnum | FeatAbilityBoostScalarFieldEnum[]
  }

  /**
   * FeatAbilityBoost findFirstOrThrow
   */
  export type FeatAbilityBoostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatAbilityBoost
     */
    select?: FeatAbilityBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatAbilityBoost
     */
    omit?: FeatAbilityBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatAbilityBoostInclude<ExtArgs> | null
    /**
     * Filter, which FeatAbilityBoost to fetch.
     */
    where?: FeatAbilityBoostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatAbilityBoosts to fetch.
     */
    orderBy?: FeatAbilityBoostOrderByWithRelationInput | FeatAbilityBoostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatAbilityBoosts.
     */
    cursor?: FeatAbilityBoostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatAbilityBoosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatAbilityBoosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatAbilityBoosts.
     */
    distinct?: FeatAbilityBoostScalarFieldEnum | FeatAbilityBoostScalarFieldEnum[]
  }

  /**
   * FeatAbilityBoost findMany
   */
  export type FeatAbilityBoostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatAbilityBoost
     */
    select?: FeatAbilityBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatAbilityBoost
     */
    omit?: FeatAbilityBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatAbilityBoostInclude<ExtArgs> | null
    /**
     * Filter, which FeatAbilityBoosts to fetch.
     */
    where?: FeatAbilityBoostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatAbilityBoosts to fetch.
     */
    orderBy?: FeatAbilityBoostOrderByWithRelationInput | FeatAbilityBoostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatAbilityBoosts.
     */
    cursor?: FeatAbilityBoostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatAbilityBoosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatAbilityBoosts.
     */
    skip?: number
    distinct?: FeatAbilityBoostScalarFieldEnum | FeatAbilityBoostScalarFieldEnum[]
  }

  /**
   * FeatAbilityBoost create
   */
  export type FeatAbilityBoostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatAbilityBoost
     */
    select?: FeatAbilityBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatAbilityBoost
     */
    omit?: FeatAbilityBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatAbilityBoostInclude<ExtArgs> | null
    /**
     * The data needed to create a FeatAbilityBoost.
     */
    data: XOR<FeatAbilityBoostCreateInput, FeatAbilityBoostUncheckedCreateInput>
  }

  /**
   * FeatAbilityBoost createMany
   */
  export type FeatAbilityBoostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatAbilityBoosts.
     */
    data: FeatAbilityBoostCreateManyInput | FeatAbilityBoostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatAbilityBoost createManyAndReturn
   */
  export type FeatAbilityBoostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatAbilityBoost
     */
    select?: FeatAbilityBoostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatAbilityBoost
     */
    omit?: FeatAbilityBoostOmit<ExtArgs> | null
    /**
     * The data used to create many FeatAbilityBoosts.
     */
    data: FeatAbilityBoostCreateManyInput | FeatAbilityBoostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatAbilityBoostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeatAbilityBoost update
   */
  export type FeatAbilityBoostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatAbilityBoost
     */
    select?: FeatAbilityBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatAbilityBoost
     */
    omit?: FeatAbilityBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatAbilityBoostInclude<ExtArgs> | null
    /**
     * The data needed to update a FeatAbilityBoost.
     */
    data: XOR<FeatAbilityBoostUpdateInput, FeatAbilityBoostUncheckedUpdateInput>
    /**
     * Choose, which FeatAbilityBoost to update.
     */
    where: FeatAbilityBoostWhereUniqueInput
  }

  /**
   * FeatAbilityBoost updateMany
   */
  export type FeatAbilityBoostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatAbilityBoosts.
     */
    data: XOR<FeatAbilityBoostUpdateManyMutationInput, FeatAbilityBoostUncheckedUpdateManyInput>
    /**
     * Filter which FeatAbilityBoosts to update
     */
    where?: FeatAbilityBoostWhereInput
    /**
     * Limit how many FeatAbilityBoosts to update.
     */
    limit?: number
  }

  /**
   * FeatAbilityBoost updateManyAndReturn
   */
  export type FeatAbilityBoostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatAbilityBoost
     */
    select?: FeatAbilityBoostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatAbilityBoost
     */
    omit?: FeatAbilityBoostOmit<ExtArgs> | null
    /**
     * The data used to update FeatAbilityBoosts.
     */
    data: XOR<FeatAbilityBoostUpdateManyMutationInput, FeatAbilityBoostUncheckedUpdateManyInput>
    /**
     * Filter which FeatAbilityBoosts to update
     */
    where?: FeatAbilityBoostWhereInput
    /**
     * Limit how many FeatAbilityBoosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatAbilityBoostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeatAbilityBoost upsert
   */
  export type FeatAbilityBoostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatAbilityBoost
     */
    select?: FeatAbilityBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatAbilityBoost
     */
    omit?: FeatAbilityBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatAbilityBoostInclude<ExtArgs> | null
    /**
     * The filter to search for the FeatAbilityBoost to update in case it exists.
     */
    where: FeatAbilityBoostWhereUniqueInput
    /**
     * In case the FeatAbilityBoost found by the `where` argument doesn't exist, create a new FeatAbilityBoost with this data.
     */
    create: XOR<FeatAbilityBoostCreateInput, FeatAbilityBoostUncheckedCreateInput>
    /**
     * In case the FeatAbilityBoost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatAbilityBoostUpdateInput, FeatAbilityBoostUncheckedUpdateInput>
  }

  /**
   * FeatAbilityBoost delete
   */
  export type FeatAbilityBoostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatAbilityBoost
     */
    select?: FeatAbilityBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatAbilityBoost
     */
    omit?: FeatAbilityBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatAbilityBoostInclude<ExtArgs> | null
    /**
     * Filter which FeatAbilityBoost to delete.
     */
    where: FeatAbilityBoostWhereUniqueInput
  }

  /**
   * FeatAbilityBoost deleteMany
   */
  export type FeatAbilityBoostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatAbilityBoosts to delete
     */
    where?: FeatAbilityBoostWhereInput
    /**
     * Limit how many FeatAbilityBoosts to delete.
     */
    limit?: number
  }

  /**
   * FeatAbilityBoost without action
   */
  export type FeatAbilityBoostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatAbilityBoost
     */
    select?: FeatAbilityBoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatAbilityBoost
     */
    omit?: FeatAbilityBoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatAbilityBoostInclude<ExtArgs> | null
  }


  /**
   * Model PersFeat
   */

  export type AggregatePersFeat = {
    _count: PersFeatCountAggregateOutputType | null
    _avg: PersFeatAvgAggregateOutputType | null
    _sum: PersFeatSumAggregateOutputType | null
    _min: PersFeatMinAggregateOutputType | null
    _max: PersFeatMaxAggregateOutputType | null
  }

  export type PersFeatAvgAggregateOutputType = {
    persFeatId: number | null
    featId: number | null
    persId: number | null
  }

  export type PersFeatSumAggregateOutputType = {
    persFeatId: number | null
    featId: number | null
    persId: number | null
  }

  export type PersFeatMinAggregateOutputType = {
    persFeatId: number | null
    featId: number | null
    persId: number | null
  }

  export type PersFeatMaxAggregateOutputType = {
    persFeatId: number | null
    featId: number | null
    persId: number | null
  }

  export type PersFeatCountAggregateOutputType = {
    persFeatId: number
    featId: number
    persId: number
    _all: number
  }


  export type PersFeatAvgAggregateInputType = {
    persFeatId?: true
    featId?: true
    persId?: true
  }

  export type PersFeatSumAggregateInputType = {
    persFeatId?: true
    featId?: true
    persId?: true
  }

  export type PersFeatMinAggregateInputType = {
    persFeatId?: true
    featId?: true
    persId?: true
  }

  export type PersFeatMaxAggregateInputType = {
    persFeatId?: true
    featId?: true
    persId?: true
  }

  export type PersFeatCountAggregateInputType = {
    persFeatId?: true
    featId?: true
    persId?: true
    _all?: true
  }

  export type PersFeatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersFeat to aggregate.
     */
    where?: PersFeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersFeats to fetch.
     */
    orderBy?: PersFeatOrderByWithRelationInput | PersFeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersFeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersFeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersFeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersFeats
    **/
    _count?: true | PersFeatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersFeatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersFeatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersFeatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersFeatMaxAggregateInputType
  }

  export type GetPersFeatAggregateType<T extends PersFeatAggregateArgs> = {
        [P in keyof T & keyof AggregatePersFeat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersFeat[P]>
      : GetScalarType<T[P], AggregatePersFeat[P]>
  }




  export type PersFeatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersFeatWhereInput
    orderBy?: PersFeatOrderByWithAggregationInput | PersFeatOrderByWithAggregationInput[]
    by: PersFeatScalarFieldEnum[] | PersFeatScalarFieldEnum
    having?: PersFeatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersFeatCountAggregateInputType | true
    _avg?: PersFeatAvgAggregateInputType
    _sum?: PersFeatSumAggregateInputType
    _min?: PersFeatMinAggregateInputType
    _max?: PersFeatMaxAggregateInputType
  }

  export type PersFeatGroupByOutputType = {
    persFeatId: number
    featId: number
    persId: number
    _count: PersFeatCountAggregateOutputType | null
    _avg: PersFeatAvgAggregateOutputType | null
    _sum: PersFeatSumAggregateOutputType | null
    _min: PersFeatMinAggregateOutputType | null
    _max: PersFeatMaxAggregateOutputType | null
  }

  type GetPersFeatGroupByPayload<T extends PersFeatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersFeatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersFeatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersFeatGroupByOutputType[P]>
            : GetScalarType<T[P], PersFeatGroupByOutputType[P]>
        }
      >
    >


  export type PersFeatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persFeatId?: boolean
    featId?: boolean
    persId?: boolean
    feat?: boolean | FeatDefaultArgs<ExtArgs>
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persFeat"]>

  export type PersFeatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persFeatId?: boolean
    featId?: boolean
    persId?: boolean
    feat?: boolean | FeatDefaultArgs<ExtArgs>
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persFeat"]>

  export type PersFeatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persFeatId?: boolean
    featId?: boolean
    persId?: boolean
    feat?: boolean | FeatDefaultArgs<ExtArgs>
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persFeat"]>

  export type PersFeatSelectScalar = {
    persFeatId?: boolean
    featId?: boolean
    persId?: boolean
  }

  export type PersFeatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"persFeatId" | "featId" | "persId", ExtArgs["result"]["persFeat"]>
  export type PersFeatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feat?: boolean | FeatDefaultArgs<ExtArgs>
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }
  export type PersFeatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feat?: boolean | FeatDefaultArgs<ExtArgs>
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }
  export type PersFeatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feat?: boolean | FeatDefaultArgs<ExtArgs>
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }

  export type $PersFeatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersFeat"
    objects: {
      feat: Prisma.$FeatPayload<ExtArgs>
      pers: Prisma.$PersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      persFeatId: number
      featId: number
      persId: number
    }, ExtArgs["result"]["persFeat"]>
    composites: {}
  }

  type PersFeatGetPayload<S extends boolean | null | undefined | PersFeatDefaultArgs> = $Result.GetResult<Prisma.$PersFeatPayload, S>

  type PersFeatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersFeatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersFeatCountAggregateInputType | true
    }

  export interface PersFeatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersFeat'], meta: { name: 'PersFeat' } }
    /**
     * Find zero or one PersFeat that matches the filter.
     * @param {PersFeatFindUniqueArgs} args - Arguments to find a PersFeat
     * @example
     * // Get one PersFeat
     * const persFeat = await prisma.persFeat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersFeatFindUniqueArgs>(args: SelectSubset<T, PersFeatFindUniqueArgs<ExtArgs>>): Prisma__PersFeatClient<$Result.GetResult<Prisma.$PersFeatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersFeat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersFeatFindUniqueOrThrowArgs} args - Arguments to find a PersFeat
     * @example
     * // Get one PersFeat
     * const persFeat = await prisma.persFeat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersFeatFindUniqueOrThrowArgs>(args: SelectSubset<T, PersFeatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersFeatClient<$Result.GetResult<Prisma.$PersFeatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersFeat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFeatFindFirstArgs} args - Arguments to find a PersFeat
     * @example
     * // Get one PersFeat
     * const persFeat = await prisma.persFeat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersFeatFindFirstArgs>(args?: SelectSubset<T, PersFeatFindFirstArgs<ExtArgs>>): Prisma__PersFeatClient<$Result.GetResult<Prisma.$PersFeatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersFeat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFeatFindFirstOrThrowArgs} args - Arguments to find a PersFeat
     * @example
     * // Get one PersFeat
     * const persFeat = await prisma.persFeat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersFeatFindFirstOrThrowArgs>(args?: SelectSubset<T, PersFeatFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersFeatClient<$Result.GetResult<Prisma.$PersFeatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersFeats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFeatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersFeats
     * const persFeats = await prisma.persFeat.findMany()
     * 
     * // Get first 10 PersFeats
     * const persFeats = await prisma.persFeat.findMany({ take: 10 })
     * 
     * // Only select the `persFeatId`
     * const persFeatWithPersFeatIdOnly = await prisma.persFeat.findMany({ select: { persFeatId: true } })
     * 
     */
    findMany<T extends PersFeatFindManyArgs>(args?: SelectSubset<T, PersFeatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersFeatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersFeat.
     * @param {PersFeatCreateArgs} args - Arguments to create a PersFeat.
     * @example
     * // Create one PersFeat
     * const PersFeat = await prisma.persFeat.create({
     *   data: {
     *     // ... data to create a PersFeat
     *   }
     * })
     * 
     */
    create<T extends PersFeatCreateArgs>(args: SelectSubset<T, PersFeatCreateArgs<ExtArgs>>): Prisma__PersFeatClient<$Result.GetResult<Prisma.$PersFeatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersFeats.
     * @param {PersFeatCreateManyArgs} args - Arguments to create many PersFeats.
     * @example
     * // Create many PersFeats
     * const persFeat = await prisma.persFeat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersFeatCreateManyArgs>(args?: SelectSubset<T, PersFeatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersFeats and returns the data saved in the database.
     * @param {PersFeatCreateManyAndReturnArgs} args - Arguments to create many PersFeats.
     * @example
     * // Create many PersFeats
     * const persFeat = await prisma.persFeat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersFeats and only return the `persFeatId`
     * const persFeatWithPersFeatIdOnly = await prisma.persFeat.createManyAndReturn({
     *   select: { persFeatId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersFeatCreateManyAndReturnArgs>(args?: SelectSubset<T, PersFeatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersFeatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersFeat.
     * @param {PersFeatDeleteArgs} args - Arguments to delete one PersFeat.
     * @example
     * // Delete one PersFeat
     * const PersFeat = await prisma.persFeat.delete({
     *   where: {
     *     // ... filter to delete one PersFeat
     *   }
     * })
     * 
     */
    delete<T extends PersFeatDeleteArgs>(args: SelectSubset<T, PersFeatDeleteArgs<ExtArgs>>): Prisma__PersFeatClient<$Result.GetResult<Prisma.$PersFeatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersFeat.
     * @param {PersFeatUpdateArgs} args - Arguments to update one PersFeat.
     * @example
     * // Update one PersFeat
     * const persFeat = await prisma.persFeat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersFeatUpdateArgs>(args: SelectSubset<T, PersFeatUpdateArgs<ExtArgs>>): Prisma__PersFeatClient<$Result.GetResult<Prisma.$PersFeatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersFeats.
     * @param {PersFeatDeleteManyArgs} args - Arguments to filter PersFeats to delete.
     * @example
     * // Delete a few PersFeats
     * const { count } = await prisma.persFeat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersFeatDeleteManyArgs>(args?: SelectSubset<T, PersFeatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersFeats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFeatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersFeats
     * const persFeat = await prisma.persFeat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersFeatUpdateManyArgs>(args: SelectSubset<T, PersFeatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersFeats and returns the data updated in the database.
     * @param {PersFeatUpdateManyAndReturnArgs} args - Arguments to update many PersFeats.
     * @example
     * // Update many PersFeats
     * const persFeat = await prisma.persFeat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersFeats and only return the `persFeatId`
     * const persFeatWithPersFeatIdOnly = await prisma.persFeat.updateManyAndReturn({
     *   select: { persFeatId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersFeatUpdateManyAndReturnArgs>(args: SelectSubset<T, PersFeatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersFeatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersFeat.
     * @param {PersFeatUpsertArgs} args - Arguments to update or create a PersFeat.
     * @example
     * // Update or create a PersFeat
     * const persFeat = await prisma.persFeat.upsert({
     *   create: {
     *     // ... data to create a PersFeat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersFeat we want to update
     *   }
     * })
     */
    upsert<T extends PersFeatUpsertArgs>(args: SelectSubset<T, PersFeatUpsertArgs<ExtArgs>>): Prisma__PersFeatClient<$Result.GetResult<Prisma.$PersFeatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersFeats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFeatCountArgs} args - Arguments to filter PersFeats to count.
     * @example
     * // Count the number of PersFeats
     * const count = await prisma.persFeat.count({
     *   where: {
     *     // ... the filter for the PersFeats we want to count
     *   }
     * })
    **/
    count<T extends PersFeatCountArgs>(
      args?: Subset<T, PersFeatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersFeatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersFeat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFeatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersFeatAggregateArgs>(args: Subset<T, PersFeatAggregateArgs>): Prisma.PrismaPromise<GetPersFeatAggregateType<T>>

    /**
     * Group by PersFeat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersFeatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersFeatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersFeatGroupByArgs['orderBy'] }
        : { orderBy?: PersFeatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersFeatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersFeatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersFeat model
   */
  readonly fields: PersFeatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersFeat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersFeatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feat<T extends FeatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatDefaultArgs<ExtArgs>>): Prisma__FeatClient<$Result.GetResult<Prisma.$FeatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pers<T extends PersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersDefaultArgs<ExtArgs>>): Prisma__PersClient<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersFeat model
   */
  interface PersFeatFieldRefs {
    readonly persFeatId: FieldRef<"PersFeat", 'Int'>
    readonly featId: FieldRef<"PersFeat", 'Int'>
    readonly persId: FieldRef<"PersFeat", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PersFeat findUnique
   */
  export type PersFeatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeat
     */
    select?: PersFeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeat
     */
    omit?: PersFeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatInclude<ExtArgs> | null
    /**
     * Filter, which PersFeat to fetch.
     */
    where: PersFeatWhereUniqueInput
  }

  /**
   * PersFeat findUniqueOrThrow
   */
  export type PersFeatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeat
     */
    select?: PersFeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeat
     */
    omit?: PersFeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatInclude<ExtArgs> | null
    /**
     * Filter, which PersFeat to fetch.
     */
    where: PersFeatWhereUniqueInput
  }

  /**
   * PersFeat findFirst
   */
  export type PersFeatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeat
     */
    select?: PersFeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeat
     */
    omit?: PersFeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatInclude<ExtArgs> | null
    /**
     * Filter, which PersFeat to fetch.
     */
    where?: PersFeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersFeats to fetch.
     */
    orderBy?: PersFeatOrderByWithRelationInput | PersFeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersFeats.
     */
    cursor?: PersFeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersFeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersFeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersFeats.
     */
    distinct?: PersFeatScalarFieldEnum | PersFeatScalarFieldEnum[]
  }

  /**
   * PersFeat findFirstOrThrow
   */
  export type PersFeatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeat
     */
    select?: PersFeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeat
     */
    omit?: PersFeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatInclude<ExtArgs> | null
    /**
     * Filter, which PersFeat to fetch.
     */
    where?: PersFeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersFeats to fetch.
     */
    orderBy?: PersFeatOrderByWithRelationInput | PersFeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersFeats.
     */
    cursor?: PersFeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersFeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersFeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersFeats.
     */
    distinct?: PersFeatScalarFieldEnum | PersFeatScalarFieldEnum[]
  }

  /**
   * PersFeat findMany
   */
  export type PersFeatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeat
     */
    select?: PersFeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeat
     */
    omit?: PersFeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatInclude<ExtArgs> | null
    /**
     * Filter, which PersFeats to fetch.
     */
    where?: PersFeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersFeats to fetch.
     */
    orderBy?: PersFeatOrderByWithRelationInput | PersFeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersFeats.
     */
    cursor?: PersFeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersFeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersFeats.
     */
    skip?: number
    distinct?: PersFeatScalarFieldEnum | PersFeatScalarFieldEnum[]
  }

  /**
   * PersFeat create
   */
  export type PersFeatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeat
     */
    select?: PersFeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeat
     */
    omit?: PersFeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatInclude<ExtArgs> | null
    /**
     * The data needed to create a PersFeat.
     */
    data: XOR<PersFeatCreateInput, PersFeatUncheckedCreateInput>
  }

  /**
   * PersFeat createMany
   */
  export type PersFeatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersFeats.
     */
    data: PersFeatCreateManyInput | PersFeatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersFeat createManyAndReturn
   */
  export type PersFeatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeat
     */
    select?: PersFeatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeat
     */
    omit?: PersFeatOmit<ExtArgs> | null
    /**
     * The data used to create many PersFeats.
     */
    data: PersFeatCreateManyInput | PersFeatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersFeat update
   */
  export type PersFeatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeat
     */
    select?: PersFeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeat
     */
    omit?: PersFeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatInclude<ExtArgs> | null
    /**
     * The data needed to update a PersFeat.
     */
    data: XOR<PersFeatUpdateInput, PersFeatUncheckedUpdateInput>
    /**
     * Choose, which PersFeat to update.
     */
    where: PersFeatWhereUniqueInput
  }

  /**
   * PersFeat updateMany
   */
  export type PersFeatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersFeats.
     */
    data: XOR<PersFeatUpdateManyMutationInput, PersFeatUncheckedUpdateManyInput>
    /**
     * Filter which PersFeats to update
     */
    where?: PersFeatWhereInput
    /**
     * Limit how many PersFeats to update.
     */
    limit?: number
  }

  /**
   * PersFeat updateManyAndReturn
   */
  export type PersFeatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeat
     */
    select?: PersFeatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeat
     */
    omit?: PersFeatOmit<ExtArgs> | null
    /**
     * The data used to update PersFeats.
     */
    data: XOR<PersFeatUpdateManyMutationInput, PersFeatUncheckedUpdateManyInput>
    /**
     * Filter which PersFeats to update
     */
    where?: PersFeatWhereInput
    /**
     * Limit how many PersFeats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersFeat upsert
   */
  export type PersFeatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeat
     */
    select?: PersFeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeat
     */
    omit?: PersFeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatInclude<ExtArgs> | null
    /**
     * The filter to search for the PersFeat to update in case it exists.
     */
    where: PersFeatWhereUniqueInput
    /**
     * In case the PersFeat found by the `where` argument doesn't exist, create a new PersFeat with this data.
     */
    create: XOR<PersFeatCreateInput, PersFeatUncheckedCreateInput>
    /**
     * In case the PersFeat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersFeatUpdateInput, PersFeatUncheckedUpdateInput>
  }

  /**
   * PersFeat delete
   */
  export type PersFeatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeat
     */
    select?: PersFeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeat
     */
    omit?: PersFeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatInclude<ExtArgs> | null
    /**
     * Filter which PersFeat to delete.
     */
    where: PersFeatWhereUniqueInput
  }

  /**
   * PersFeat deleteMany
   */
  export type PersFeatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersFeats to delete
     */
    where?: PersFeatWhereInput
    /**
     * Limit how many PersFeats to delete.
     */
    limit?: number
  }

  /**
   * PersFeat without action
   */
  export type PersFeatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersFeat
     */
    select?: PersFeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersFeat
     */
    omit?: PersFeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersFeatInclude<ExtArgs> | null
  }


  /**
   * Model MagicItem
   */

  export type AggregateMagicItem = {
    _count: MagicItemCountAggregateOutputType | null
    _avg: MagicItemAvgAggregateOutputType | null
    _sum: MagicItemSumAggregateOutputType | null
    _min: MagicItemMinAggregateOutputType | null
    _max: MagicItemMaxAggregateOutputType | null
  }

  export type MagicItemAvgAggregateOutputType = {
    magicItemId: number | null
    bonusToAC: number | null
    bonusToAttackRoll: number | null
    bonusToDamage: number | null
  }

  export type MagicItemSumAggregateOutputType = {
    magicItemId: number | null
    bonusToAC: number | null
    bonusToAttackRoll: number | null
    bonusToDamage: number | null
  }

  export type MagicItemMinAggregateOutputType = {
    magicItemId: number | null
    name: string | null
    itemType: $Enums.MagicItemType | null
    rarity: $Enums.ItemRarity | null
    description: string | null
    bonusToAC: number | null
    bonusToAttackRoll: number | null
    bonusToDamage: number | null
  }

  export type MagicItemMaxAggregateOutputType = {
    magicItemId: number | null
    name: string | null
    itemType: $Enums.MagicItemType | null
    rarity: $Enums.ItemRarity | null
    description: string | null
    bonusToAC: number | null
    bonusToAttackRoll: number | null
    bonusToDamage: number | null
  }

  export type MagicItemCountAggregateOutputType = {
    magicItemId: number
    name: number
    itemType: number
    rarity: number
    description: number
    bonusToAC: number
    bonusToAttackRoll: number
    bonusToDamage: number
    _all: number
  }


  export type MagicItemAvgAggregateInputType = {
    magicItemId?: true
    bonusToAC?: true
    bonusToAttackRoll?: true
    bonusToDamage?: true
  }

  export type MagicItemSumAggregateInputType = {
    magicItemId?: true
    bonusToAC?: true
    bonusToAttackRoll?: true
    bonusToDamage?: true
  }

  export type MagicItemMinAggregateInputType = {
    magicItemId?: true
    name?: true
    itemType?: true
    rarity?: true
    description?: true
    bonusToAC?: true
    bonusToAttackRoll?: true
    bonusToDamage?: true
  }

  export type MagicItemMaxAggregateInputType = {
    magicItemId?: true
    name?: true
    itemType?: true
    rarity?: true
    description?: true
    bonusToAC?: true
    bonusToAttackRoll?: true
    bonusToDamage?: true
  }

  export type MagicItemCountAggregateInputType = {
    magicItemId?: true
    name?: true
    itemType?: true
    rarity?: true
    description?: true
    bonusToAC?: true
    bonusToAttackRoll?: true
    bonusToDamage?: true
    _all?: true
  }

  export type MagicItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicItem to aggregate.
     */
    where?: MagicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItems to fetch.
     */
    orderBy?: MagicItemOrderByWithRelationInput | MagicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MagicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MagicItems
    **/
    _count?: true | MagicItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MagicItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MagicItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MagicItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MagicItemMaxAggregateInputType
  }

  export type GetMagicItemAggregateType<T extends MagicItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMagicItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMagicItem[P]>
      : GetScalarType<T[P], AggregateMagicItem[P]>
  }




  export type MagicItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicItemWhereInput
    orderBy?: MagicItemOrderByWithAggregationInput | MagicItemOrderByWithAggregationInput[]
    by: MagicItemScalarFieldEnum[] | MagicItemScalarFieldEnum
    having?: MagicItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MagicItemCountAggregateInputType | true
    _avg?: MagicItemAvgAggregateInputType
    _sum?: MagicItemSumAggregateInputType
    _min?: MagicItemMinAggregateInputType
    _max?: MagicItemMaxAggregateInputType
  }

  export type MagicItemGroupByOutputType = {
    magicItemId: number
    name: string
    itemType: $Enums.MagicItemType
    rarity: $Enums.ItemRarity
    description: string
    bonusToAC: number | null
    bonusToAttackRoll: number | null
    bonusToDamage: number | null
    _count: MagicItemCountAggregateOutputType | null
    _avg: MagicItemAvgAggregateOutputType | null
    _sum: MagicItemSumAggregateOutputType | null
    _min: MagicItemMinAggregateOutputType | null
    _max: MagicItemMaxAggregateOutputType | null
  }

  type GetMagicItemGroupByPayload<T extends MagicItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MagicItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MagicItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MagicItemGroupByOutputType[P]>
            : GetScalarType<T[P], MagicItemGroupByOutputType[P]>
        }
      >
    >


  export type MagicItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    magicItemId?: boolean
    name?: boolean
    itemType?: boolean
    rarity?: boolean
    description?: boolean
    bonusToAC?: boolean
    bonusToAttackRoll?: boolean
    bonusToDamage?: boolean
    features?: boolean | MagicItem$featuresArgs<ExtArgs>
    persMagicItems?: boolean | MagicItem$persMagicItemsArgs<ExtArgs>
    _count?: boolean | MagicItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicItem"]>

  export type MagicItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    magicItemId?: boolean
    name?: boolean
    itemType?: boolean
    rarity?: boolean
    description?: boolean
    bonusToAC?: boolean
    bonusToAttackRoll?: boolean
    bonusToDamage?: boolean
  }, ExtArgs["result"]["magicItem"]>

  export type MagicItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    magicItemId?: boolean
    name?: boolean
    itemType?: boolean
    rarity?: boolean
    description?: boolean
    bonusToAC?: boolean
    bonusToAttackRoll?: boolean
    bonusToDamage?: boolean
  }, ExtArgs["result"]["magicItem"]>

  export type MagicItemSelectScalar = {
    magicItemId?: boolean
    name?: boolean
    itemType?: boolean
    rarity?: boolean
    description?: boolean
    bonusToAC?: boolean
    bonusToAttackRoll?: boolean
    bonusToDamage?: boolean
  }

  export type MagicItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"magicItemId" | "name" | "itemType" | "rarity" | "description" | "bonusToAC" | "bonusToAttackRoll" | "bonusToDamage", ExtArgs["result"]["magicItem"]>
  export type MagicItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | MagicItem$featuresArgs<ExtArgs>
    persMagicItems?: boolean | MagicItem$persMagicItemsArgs<ExtArgs>
    _count?: boolean | MagicItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MagicItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MagicItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MagicItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MagicItem"
    objects: {
      features: Prisma.$MagicItemFeaturePayload<ExtArgs>[]
      persMagicItems: Prisma.$PersMagicItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      magicItemId: number
      name: string
      itemType: $Enums.MagicItemType
      rarity: $Enums.ItemRarity
      description: string
      bonusToAC: number | null
      bonusToAttackRoll: number | null
      bonusToDamage: number | null
    }, ExtArgs["result"]["magicItem"]>
    composites: {}
  }

  type MagicItemGetPayload<S extends boolean | null | undefined | MagicItemDefaultArgs> = $Result.GetResult<Prisma.$MagicItemPayload, S>

  type MagicItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MagicItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MagicItemCountAggregateInputType | true
    }

  export interface MagicItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MagicItem'], meta: { name: 'MagicItem' } }
    /**
     * Find zero or one MagicItem that matches the filter.
     * @param {MagicItemFindUniqueArgs} args - Arguments to find a MagicItem
     * @example
     * // Get one MagicItem
     * const magicItem = await prisma.magicItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MagicItemFindUniqueArgs>(args: SelectSubset<T, MagicItemFindUniqueArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MagicItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MagicItemFindUniqueOrThrowArgs} args - Arguments to find a MagicItem
     * @example
     * // Get one MagicItem
     * const magicItem = await prisma.magicItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MagicItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MagicItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MagicItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemFindFirstArgs} args - Arguments to find a MagicItem
     * @example
     * // Get one MagicItem
     * const magicItem = await prisma.magicItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MagicItemFindFirstArgs>(args?: SelectSubset<T, MagicItemFindFirstArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MagicItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemFindFirstOrThrowArgs} args - Arguments to find a MagicItem
     * @example
     * // Get one MagicItem
     * const magicItem = await prisma.magicItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MagicItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MagicItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MagicItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MagicItems
     * const magicItems = await prisma.magicItem.findMany()
     * 
     * // Get first 10 MagicItems
     * const magicItems = await prisma.magicItem.findMany({ take: 10 })
     * 
     * // Only select the `magicItemId`
     * const magicItemWithMagicItemIdOnly = await prisma.magicItem.findMany({ select: { magicItemId: true } })
     * 
     */
    findMany<T extends MagicItemFindManyArgs>(args?: SelectSubset<T, MagicItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MagicItem.
     * @param {MagicItemCreateArgs} args - Arguments to create a MagicItem.
     * @example
     * // Create one MagicItem
     * const MagicItem = await prisma.magicItem.create({
     *   data: {
     *     // ... data to create a MagicItem
     *   }
     * })
     * 
     */
    create<T extends MagicItemCreateArgs>(args: SelectSubset<T, MagicItemCreateArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MagicItems.
     * @param {MagicItemCreateManyArgs} args - Arguments to create many MagicItems.
     * @example
     * // Create many MagicItems
     * const magicItem = await prisma.magicItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MagicItemCreateManyArgs>(args?: SelectSubset<T, MagicItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MagicItems and returns the data saved in the database.
     * @param {MagicItemCreateManyAndReturnArgs} args - Arguments to create many MagicItems.
     * @example
     * // Create many MagicItems
     * const magicItem = await prisma.magicItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MagicItems and only return the `magicItemId`
     * const magicItemWithMagicItemIdOnly = await prisma.magicItem.createManyAndReturn({
     *   select: { magicItemId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MagicItemCreateManyAndReturnArgs>(args?: SelectSubset<T, MagicItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MagicItem.
     * @param {MagicItemDeleteArgs} args - Arguments to delete one MagicItem.
     * @example
     * // Delete one MagicItem
     * const MagicItem = await prisma.magicItem.delete({
     *   where: {
     *     // ... filter to delete one MagicItem
     *   }
     * })
     * 
     */
    delete<T extends MagicItemDeleteArgs>(args: SelectSubset<T, MagicItemDeleteArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MagicItem.
     * @param {MagicItemUpdateArgs} args - Arguments to update one MagicItem.
     * @example
     * // Update one MagicItem
     * const magicItem = await prisma.magicItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MagicItemUpdateArgs>(args: SelectSubset<T, MagicItemUpdateArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MagicItems.
     * @param {MagicItemDeleteManyArgs} args - Arguments to filter MagicItems to delete.
     * @example
     * // Delete a few MagicItems
     * const { count } = await prisma.magicItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MagicItemDeleteManyArgs>(args?: SelectSubset<T, MagicItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MagicItems
     * const magicItem = await prisma.magicItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MagicItemUpdateManyArgs>(args: SelectSubset<T, MagicItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicItems and returns the data updated in the database.
     * @param {MagicItemUpdateManyAndReturnArgs} args - Arguments to update many MagicItems.
     * @example
     * // Update many MagicItems
     * const magicItem = await prisma.magicItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MagicItems and only return the `magicItemId`
     * const magicItemWithMagicItemIdOnly = await prisma.magicItem.updateManyAndReturn({
     *   select: { magicItemId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MagicItemUpdateManyAndReturnArgs>(args: SelectSubset<T, MagicItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MagicItem.
     * @param {MagicItemUpsertArgs} args - Arguments to update or create a MagicItem.
     * @example
     * // Update or create a MagicItem
     * const magicItem = await prisma.magicItem.upsert({
     *   create: {
     *     // ... data to create a MagicItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MagicItem we want to update
     *   }
     * })
     */
    upsert<T extends MagicItemUpsertArgs>(args: SelectSubset<T, MagicItemUpsertArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MagicItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemCountArgs} args - Arguments to filter MagicItems to count.
     * @example
     * // Count the number of MagicItems
     * const count = await prisma.magicItem.count({
     *   where: {
     *     // ... the filter for the MagicItems we want to count
     *   }
     * })
    **/
    count<T extends MagicItemCountArgs>(
      args?: Subset<T, MagicItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MagicItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MagicItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MagicItemAggregateArgs>(args: Subset<T, MagicItemAggregateArgs>): Prisma.PrismaPromise<GetMagicItemAggregateType<T>>

    /**
     * Group by MagicItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MagicItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MagicItemGroupByArgs['orderBy'] }
        : { orderBy?: MagicItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MagicItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMagicItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MagicItem model
   */
  readonly fields: MagicItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MagicItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MagicItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    features<T extends MagicItem$featuresArgs<ExtArgs> = {}>(args?: Subset<T, MagicItem$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    persMagicItems<T extends MagicItem$persMagicItemsArgs<ExtArgs> = {}>(args?: Subset<T, MagicItem$persMagicItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersMagicItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MagicItem model
   */
  interface MagicItemFieldRefs {
    readonly magicItemId: FieldRef<"MagicItem", 'Int'>
    readonly name: FieldRef<"MagicItem", 'String'>
    readonly itemType: FieldRef<"MagicItem", 'MagicItemType'>
    readonly rarity: FieldRef<"MagicItem", 'ItemRarity'>
    readonly description: FieldRef<"MagicItem", 'String'>
    readonly bonusToAC: FieldRef<"MagicItem", 'Int'>
    readonly bonusToAttackRoll: FieldRef<"MagicItem", 'Int'>
    readonly bonusToDamage: FieldRef<"MagicItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MagicItem findUnique
   */
  export type MagicItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * Filter, which MagicItem to fetch.
     */
    where: MagicItemWhereUniqueInput
  }

  /**
   * MagicItem findUniqueOrThrow
   */
  export type MagicItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * Filter, which MagicItem to fetch.
     */
    where: MagicItemWhereUniqueInput
  }

  /**
   * MagicItem findFirst
   */
  export type MagicItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * Filter, which MagicItem to fetch.
     */
    where?: MagicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItems to fetch.
     */
    orderBy?: MagicItemOrderByWithRelationInput | MagicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicItems.
     */
    cursor?: MagicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicItems.
     */
    distinct?: MagicItemScalarFieldEnum | MagicItemScalarFieldEnum[]
  }

  /**
   * MagicItem findFirstOrThrow
   */
  export type MagicItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * Filter, which MagicItem to fetch.
     */
    where?: MagicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItems to fetch.
     */
    orderBy?: MagicItemOrderByWithRelationInput | MagicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicItems.
     */
    cursor?: MagicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicItems.
     */
    distinct?: MagicItemScalarFieldEnum | MagicItemScalarFieldEnum[]
  }

  /**
   * MagicItem findMany
   */
  export type MagicItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * Filter, which MagicItems to fetch.
     */
    where?: MagicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItems to fetch.
     */
    orderBy?: MagicItemOrderByWithRelationInput | MagicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MagicItems.
     */
    cursor?: MagicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItems.
     */
    skip?: number
    distinct?: MagicItemScalarFieldEnum | MagicItemScalarFieldEnum[]
  }

  /**
   * MagicItem create
   */
  export type MagicItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MagicItem.
     */
    data: XOR<MagicItemCreateInput, MagicItemUncheckedCreateInput>
  }

  /**
   * MagicItem createMany
   */
  export type MagicItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MagicItems.
     */
    data: MagicItemCreateManyInput | MagicItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MagicItem createManyAndReturn
   */
  export type MagicItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * The data used to create many MagicItems.
     */
    data: MagicItemCreateManyInput | MagicItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MagicItem update
   */
  export type MagicItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MagicItem.
     */
    data: XOR<MagicItemUpdateInput, MagicItemUncheckedUpdateInput>
    /**
     * Choose, which MagicItem to update.
     */
    where: MagicItemWhereUniqueInput
  }

  /**
   * MagicItem updateMany
   */
  export type MagicItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MagicItems.
     */
    data: XOR<MagicItemUpdateManyMutationInput, MagicItemUncheckedUpdateManyInput>
    /**
     * Filter which MagicItems to update
     */
    where?: MagicItemWhereInput
    /**
     * Limit how many MagicItems to update.
     */
    limit?: number
  }

  /**
   * MagicItem updateManyAndReturn
   */
  export type MagicItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * The data used to update MagicItems.
     */
    data: XOR<MagicItemUpdateManyMutationInput, MagicItemUncheckedUpdateManyInput>
    /**
     * Filter which MagicItems to update
     */
    where?: MagicItemWhereInput
    /**
     * Limit how many MagicItems to update.
     */
    limit?: number
  }

  /**
   * MagicItem upsert
   */
  export type MagicItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MagicItem to update in case it exists.
     */
    where: MagicItemWhereUniqueInput
    /**
     * In case the MagicItem found by the `where` argument doesn't exist, create a new MagicItem with this data.
     */
    create: XOR<MagicItemCreateInput, MagicItemUncheckedCreateInput>
    /**
     * In case the MagicItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MagicItemUpdateInput, MagicItemUncheckedUpdateInput>
  }

  /**
   * MagicItem delete
   */
  export type MagicItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * Filter which MagicItem to delete.
     */
    where: MagicItemWhereUniqueInput
  }

  /**
   * MagicItem deleteMany
   */
  export type MagicItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicItems to delete
     */
    where?: MagicItemWhereInput
    /**
     * Limit how many MagicItems to delete.
     */
    limit?: number
  }

  /**
   * MagicItem.features
   */
  export type MagicItem$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemFeature
     */
    select?: MagicItemFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemFeature
     */
    omit?: MagicItemFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemFeatureInclude<ExtArgs> | null
    where?: MagicItemFeatureWhereInput
    orderBy?: MagicItemFeatureOrderByWithRelationInput | MagicItemFeatureOrderByWithRelationInput[]
    cursor?: MagicItemFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MagicItemFeatureScalarFieldEnum | MagicItemFeatureScalarFieldEnum[]
  }

  /**
   * MagicItem.persMagicItems
   */
  export type MagicItem$persMagicItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMagicItem
     */
    select?: PersMagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMagicItem
     */
    omit?: PersMagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMagicItemInclude<ExtArgs> | null
    where?: PersMagicItemWhereInput
    orderBy?: PersMagicItemOrderByWithRelationInput | PersMagicItemOrderByWithRelationInput[]
    cursor?: PersMagicItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersMagicItemScalarFieldEnum | PersMagicItemScalarFieldEnum[]
  }

  /**
   * MagicItem without action
   */
  export type MagicItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
  }


  /**
   * Model Weapon
   */

  export type AggregateWeapon = {
    _count: WeaponCountAggregateOutputType | null
    _avg: WeaponAvgAggregateOutputType | null
    _sum: WeaponSumAggregateOutputType | null
    _min: WeaponMinAggregateOutputType | null
    _max: WeaponMaxAggregateOutputType | null
  }

  export type WeaponAvgAggregateOutputType = {
    weaponId: number | null
    normalRange: number | null
    longRange: number | null
  }

  export type WeaponSumAggregateOutputType = {
    weaponId: number | null
    normalRange: number | null
    longRange: number | null
  }

  export type WeaponMinAggregateOutputType = {
    weaponId: number | null
    name: $Enums.WeaponCategory | null
    damage: string | null
    damageType: $Enums.DamageType | null
    weaponType: $Enums.WeaponType | null
    versatileDamage: string | null
    normalRange: number | null
    longRange: number | null
  }

  export type WeaponMaxAggregateOutputType = {
    weaponId: number | null
    name: $Enums.WeaponCategory | null
    damage: string | null
    damageType: $Enums.DamageType | null
    weaponType: $Enums.WeaponType | null
    versatileDamage: string | null
    normalRange: number | null
    longRange: number | null
  }

  export type WeaponCountAggregateOutputType = {
    weaponId: number
    name: number
    damage: number
    damageType: number
    weaponType: number
    properties: number
    versatileDamage: number
    normalRange: number
    longRange: number
    _all: number
  }


  export type WeaponAvgAggregateInputType = {
    weaponId?: true
    normalRange?: true
    longRange?: true
  }

  export type WeaponSumAggregateInputType = {
    weaponId?: true
    normalRange?: true
    longRange?: true
  }

  export type WeaponMinAggregateInputType = {
    weaponId?: true
    name?: true
    damage?: true
    damageType?: true
    weaponType?: true
    versatileDamage?: true
    normalRange?: true
    longRange?: true
  }

  export type WeaponMaxAggregateInputType = {
    weaponId?: true
    name?: true
    damage?: true
    damageType?: true
    weaponType?: true
    versatileDamage?: true
    normalRange?: true
    longRange?: true
  }

  export type WeaponCountAggregateInputType = {
    weaponId?: true
    name?: true
    damage?: true
    damageType?: true
    weaponType?: true
    properties?: true
    versatileDamage?: true
    normalRange?: true
    longRange?: true
    _all?: true
  }

  export type WeaponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weapon to aggregate.
     */
    where?: WeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weapons to fetch.
     */
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weapons
    **/
    _count?: true | WeaponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeaponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeaponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeaponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeaponMaxAggregateInputType
  }

  export type GetWeaponAggregateType<T extends WeaponAggregateArgs> = {
        [P in keyof T & keyof AggregateWeapon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeapon[P]>
      : GetScalarType<T[P], AggregateWeapon[P]>
  }




  export type WeaponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaponWhereInput
    orderBy?: WeaponOrderByWithAggregationInput | WeaponOrderByWithAggregationInput[]
    by: WeaponScalarFieldEnum[] | WeaponScalarFieldEnum
    having?: WeaponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeaponCountAggregateInputType | true
    _avg?: WeaponAvgAggregateInputType
    _sum?: WeaponSumAggregateInputType
    _min?: WeaponMinAggregateInputType
    _max?: WeaponMaxAggregateInputType
  }

  export type WeaponGroupByOutputType = {
    weaponId: number
    name: $Enums.WeaponCategory
    damage: string
    damageType: $Enums.DamageType
    weaponType: $Enums.WeaponType
    properties: $Enums.WeaponProperty[]
    versatileDamage: string | null
    normalRange: number | null
    longRange: number | null
    _count: WeaponCountAggregateOutputType | null
    _avg: WeaponAvgAggregateOutputType | null
    _sum: WeaponSumAggregateOutputType | null
    _min: WeaponMinAggregateOutputType | null
    _max: WeaponMaxAggregateOutputType | null
  }

  type GetWeaponGroupByPayload<T extends WeaponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeaponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeaponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeaponGroupByOutputType[P]>
            : GetScalarType<T[P], WeaponGroupByOutputType[P]>
        }
      >
    >


  export type WeaponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    weaponId?: boolean
    name?: boolean
    damage?: boolean
    damageType?: boolean
    weaponType?: boolean
    properties?: boolean
    versatileDamage?: boolean
    normalRange?: boolean
    longRange?: boolean
    persWeapons?: boolean | Weapon$persWeaponsArgs<ExtArgs>
    classStartingEquipmentOption?: boolean | Weapon$classStartingEquipmentOptionArgs<ExtArgs>
    _count?: boolean | WeaponCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weapon"]>

  export type WeaponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    weaponId?: boolean
    name?: boolean
    damage?: boolean
    damageType?: boolean
    weaponType?: boolean
    properties?: boolean
    versatileDamage?: boolean
    normalRange?: boolean
    longRange?: boolean
  }, ExtArgs["result"]["weapon"]>

  export type WeaponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    weaponId?: boolean
    name?: boolean
    damage?: boolean
    damageType?: boolean
    weaponType?: boolean
    properties?: boolean
    versatileDamage?: boolean
    normalRange?: boolean
    longRange?: boolean
  }, ExtArgs["result"]["weapon"]>

  export type WeaponSelectScalar = {
    weaponId?: boolean
    name?: boolean
    damage?: boolean
    damageType?: boolean
    weaponType?: boolean
    properties?: boolean
    versatileDamage?: boolean
    normalRange?: boolean
    longRange?: boolean
  }

  export type WeaponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"weaponId" | "name" | "damage" | "damageType" | "weaponType" | "properties" | "versatileDamage" | "normalRange" | "longRange", ExtArgs["result"]["weapon"]>
  export type WeaponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    persWeapons?: boolean | Weapon$persWeaponsArgs<ExtArgs>
    classStartingEquipmentOption?: boolean | Weapon$classStartingEquipmentOptionArgs<ExtArgs>
    _count?: boolean | WeaponCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WeaponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WeaponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WeaponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Weapon"
    objects: {
      persWeapons: Prisma.$PersWeaponPayload<ExtArgs>[]
      classStartingEquipmentOption: Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      weaponId: number
      name: $Enums.WeaponCategory
      damage: string
      damageType: $Enums.DamageType
      weaponType: $Enums.WeaponType
      properties: $Enums.WeaponProperty[]
      versatileDamage: string | null
      normalRange: number | null
      longRange: number | null
    }, ExtArgs["result"]["weapon"]>
    composites: {}
  }

  type WeaponGetPayload<S extends boolean | null | undefined | WeaponDefaultArgs> = $Result.GetResult<Prisma.$WeaponPayload, S>

  type WeaponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeaponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeaponCountAggregateInputType | true
    }

  export interface WeaponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Weapon'], meta: { name: 'Weapon' } }
    /**
     * Find zero or one Weapon that matches the filter.
     * @param {WeaponFindUniqueArgs} args - Arguments to find a Weapon
     * @example
     * // Get one Weapon
     * const weapon = await prisma.weapon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeaponFindUniqueArgs>(args: SelectSubset<T, WeaponFindUniqueArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Weapon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeaponFindUniqueOrThrowArgs} args - Arguments to find a Weapon
     * @example
     * // Get one Weapon
     * const weapon = await prisma.weapon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeaponFindUniqueOrThrowArgs>(args: SelectSubset<T, WeaponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weapon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponFindFirstArgs} args - Arguments to find a Weapon
     * @example
     * // Get one Weapon
     * const weapon = await prisma.weapon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeaponFindFirstArgs>(args?: SelectSubset<T, WeaponFindFirstArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weapon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponFindFirstOrThrowArgs} args - Arguments to find a Weapon
     * @example
     * // Get one Weapon
     * const weapon = await prisma.weapon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeaponFindFirstOrThrowArgs>(args?: SelectSubset<T, WeaponFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Weapons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weapons
     * const weapons = await prisma.weapon.findMany()
     * 
     * // Get first 10 Weapons
     * const weapons = await prisma.weapon.findMany({ take: 10 })
     * 
     * // Only select the `weaponId`
     * const weaponWithWeaponIdOnly = await prisma.weapon.findMany({ select: { weaponId: true } })
     * 
     */
    findMany<T extends WeaponFindManyArgs>(args?: SelectSubset<T, WeaponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Weapon.
     * @param {WeaponCreateArgs} args - Arguments to create a Weapon.
     * @example
     * // Create one Weapon
     * const Weapon = await prisma.weapon.create({
     *   data: {
     *     // ... data to create a Weapon
     *   }
     * })
     * 
     */
    create<T extends WeaponCreateArgs>(args: SelectSubset<T, WeaponCreateArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Weapons.
     * @param {WeaponCreateManyArgs} args - Arguments to create many Weapons.
     * @example
     * // Create many Weapons
     * const weapon = await prisma.weapon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeaponCreateManyArgs>(args?: SelectSubset<T, WeaponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Weapons and returns the data saved in the database.
     * @param {WeaponCreateManyAndReturnArgs} args - Arguments to create many Weapons.
     * @example
     * // Create many Weapons
     * const weapon = await prisma.weapon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Weapons and only return the `weaponId`
     * const weaponWithWeaponIdOnly = await prisma.weapon.createManyAndReturn({
     *   select: { weaponId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeaponCreateManyAndReturnArgs>(args?: SelectSubset<T, WeaponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Weapon.
     * @param {WeaponDeleteArgs} args - Arguments to delete one Weapon.
     * @example
     * // Delete one Weapon
     * const Weapon = await prisma.weapon.delete({
     *   where: {
     *     // ... filter to delete one Weapon
     *   }
     * })
     * 
     */
    delete<T extends WeaponDeleteArgs>(args: SelectSubset<T, WeaponDeleteArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Weapon.
     * @param {WeaponUpdateArgs} args - Arguments to update one Weapon.
     * @example
     * // Update one Weapon
     * const weapon = await prisma.weapon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeaponUpdateArgs>(args: SelectSubset<T, WeaponUpdateArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Weapons.
     * @param {WeaponDeleteManyArgs} args - Arguments to filter Weapons to delete.
     * @example
     * // Delete a few Weapons
     * const { count } = await prisma.weapon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeaponDeleteManyArgs>(args?: SelectSubset<T, WeaponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weapons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weapons
     * const weapon = await prisma.weapon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeaponUpdateManyArgs>(args: SelectSubset<T, WeaponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weapons and returns the data updated in the database.
     * @param {WeaponUpdateManyAndReturnArgs} args - Arguments to update many Weapons.
     * @example
     * // Update many Weapons
     * const weapon = await prisma.weapon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Weapons and only return the `weaponId`
     * const weaponWithWeaponIdOnly = await prisma.weapon.updateManyAndReturn({
     *   select: { weaponId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeaponUpdateManyAndReturnArgs>(args: SelectSubset<T, WeaponUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Weapon.
     * @param {WeaponUpsertArgs} args - Arguments to update or create a Weapon.
     * @example
     * // Update or create a Weapon
     * const weapon = await prisma.weapon.upsert({
     *   create: {
     *     // ... data to create a Weapon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weapon we want to update
     *   }
     * })
     */
    upsert<T extends WeaponUpsertArgs>(args: SelectSubset<T, WeaponUpsertArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Weapons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponCountArgs} args - Arguments to filter Weapons to count.
     * @example
     * // Count the number of Weapons
     * const count = await prisma.weapon.count({
     *   where: {
     *     // ... the filter for the Weapons we want to count
     *   }
     * })
    **/
    count<T extends WeaponCountArgs>(
      args?: Subset<T, WeaponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeaponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weapon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeaponAggregateArgs>(args: Subset<T, WeaponAggregateArgs>): Prisma.PrismaPromise<GetWeaponAggregateType<T>>

    /**
     * Group by Weapon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeaponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeaponGroupByArgs['orderBy'] }
        : { orderBy?: WeaponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeaponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeaponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Weapon model
   */
  readonly fields: WeaponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Weapon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeaponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    persWeapons<T extends Weapon$persWeaponsArgs<ExtArgs> = {}>(args?: Subset<T, Weapon$persWeaponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersWeaponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classStartingEquipmentOption<T extends Weapon$classStartingEquipmentOptionArgs<ExtArgs> = {}>(args?: Subset<T, Weapon$classStartingEquipmentOptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Weapon model
   */
  interface WeaponFieldRefs {
    readonly weaponId: FieldRef<"Weapon", 'Int'>
    readonly name: FieldRef<"Weapon", 'WeaponCategory'>
    readonly damage: FieldRef<"Weapon", 'String'>
    readonly damageType: FieldRef<"Weapon", 'DamageType'>
    readonly weaponType: FieldRef<"Weapon", 'WeaponType'>
    readonly properties: FieldRef<"Weapon", 'WeaponProperty[]'>
    readonly versatileDamage: FieldRef<"Weapon", 'String'>
    readonly normalRange: FieldRef<"Weapon", 'Int'>
    readonly longRange: FieldRef<"Weapon", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Weapon findUnique
   */
  export type WeaponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * Filter, which Weapon to fetch.
     */
    where: WeaponWhereUniqueInput
  }

  /**
   * Weapon findUniqueOrThrow
   */
  export type WeaponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * Filter, which Weapon to fetch.
     */
    where: WeaponWhereUniqueInput
  }

  /**
   * Weapon findFirst
   */
  export type WeaponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * Filter, which Weapon to fetch.
     */
    where?: WeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weapons to fetch.
     */
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weapons.
     */
    cursor?: WeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weapons.
     */
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * Weapon findFirstOrThrow
   */
  export type WeaponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * Filter, which Weapon to fetch.
     */
    where?: WeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weapons to fetch.
     */
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weapons.
     */
    cursor?: WeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weapons.
     */
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * Weapon findMany
   */
  export type WeaponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * Filter, which Weapons to fetch.
     */
    where?: WeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weapons to fetch.
     */
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weapons.
     */
    cursor?: WeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weapons.
     */
    skip?: number
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * Weapon create
   */
  export type WeaponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * The data needed to create a Weapon.
     */
    data: XOR<WeaponCreateInput, WeaponUncheckedCreateInput>
  }

  /**
   * Weapon createMany
   */
  export type WeaponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Weapons.
     */
    data: WeaponCreateManyInput | WeaponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Weapon createManyAndReturn
   */
  export type WeaponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * The data used to create many Weapons.
     */
    data: WeaponCreateManyInput | WeaponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Weapon update
   */
  export type WeaponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * The data needed to update a Weapon.
     */
    data: XOR<WeaponUpdateInput, WeaponUncheckedUpdateInput>
    /**
     * Choose, which Weapon to update.
     */
    where: WeaponWhereUniqueInput
  }

  /**
   * Weapon updateMany
   */
  export type WeaponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Weapons.
     */
    data: XOR<WeaponUpdateManyMutationInput, WeaponUncheckedUpdateManyInput>
    /**
     * Filter which Weapons to update
     */
    where?: WeaponWhereInput
    /**
     * Limit how many Weapons to update.
     */
    limit?: number
  }

  /**
   * Weapon updateManyAndReturn
   */
  export type WeaponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * The data used to update Weapons.
     */
    data: XOR<WeaponUpdateManyMutationInput, WeaponUncheckedUpdateManyInput>
    /**
     * Filter which Weapons to update
     */
    where?: WeaponWhereInput
    /**
     * Limit how many Weapons to update.
     */
    limit?: number
  }

  /**
   * Weapon upsert
   */
  export type WeaponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * The filter to search for the Weapon to update in case it exists.
     */
    where: WeaponWhereUniqueInput
    /**
     * In case the Weapon found by the `where` argument doesn't exist, create a new Weapon with this data.
     */
    create: XOR<WeaponCreateInput, WeaponUncheckedCreateInput>
    /**
     * In case the Weapon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeaponUpdateInput, WeaponUncheckedUpdateInput>
  }

  /**
   * Weapon delete
   */
  export type WeaponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * Filter which Weapon to delete.
     */
    where: WeaponWhereUniqueInput
  }

  /**
   * Weapon deleteMany
   */
  export type WeaponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weapons to delete
     */
    where?: WeaponWhereInput
    /**
     * Limit how many Weapons to delete.
     */
    limit?: number
  }

  /**
   * Weapon.persWeapons
   */
  export type Weapon$persWeaponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersWeapon
     */
    select?: PersWeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersWeapon
     */
    omit?: PersWeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersWeaponInclude<ExtArgs> | null
    where?: PersWeaponWhereInput
    orderBy?: PersWeaponOrderByWithRelationInput | PersWeaponOrderByWithRelationInput[]
    cursor?: PersWeaponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersWeaponScalarFieldEnum | PersWeaponScalarFieldEnum[]
  }

  /**
   * Weapon.classStartingEquipmentOption
   */
  export type Weapon$classStartingEquipmentOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionInclude<ExtArgs> | null
    where?: ClassStartingEquipmentOptionWhereInput
    orderBy?: ClassStartingEquipmentOptionOrderByWithRelationInput | ClassStartingEquipmentOptionOrderByWithRelationInput[]
    cursor?: ClassStartingEquipmentOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassStartingEquipmentOptionScalarFieldEnum | ClassStartingEquipmentOptionScalarFieldEnum[]
  }

  /**
   * Weapon without action
   */
  export type WeaponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
  }


  /**
   * Model Armor
   */

  export type AggregateArmor = {
    _count: ArmorCountAggregateOutputType | null
    _avg: ArmorAvgAggregateOutputType | null
    _sum: ArmorSumAggregateOutputType | null
    _min: ArmorMinAggregateOutputType | null
    _max: ArmorMaxAggregateOutputType | null
  }

  export type ArmorAvgAggregateOutputType = {
    armorId: number | null
    baseAC: number | null
    strengthReq: number | null
  }

  export type ArmorSumAggregateOutputType = {
    armorId: number | null
    baseAC: number | null
    strengthReq: number | null
  }

  export type ArmorMinAggregateOutputType = {
    armorId: number | null
    name: $Enums.ArmorCategory | null
    armorType: $Enums.ArmorType | null
    baseAC: number | null
    strengthReq: number | null
    stealthDisadvantage: boolean | null
  }

  export type ArmorMaxAggregateOutputType = {
    armorId: number | null
    name: $Enums.ArmorCategory | null
    armorType: $Enums.ArmorType | null
    baseAC: number | null
    strengthReq: number | null
    stealthDisadvantage: boolean | null
  }

  export type ArmorCountAggregateOutputType = {
    armorId: number
    name: number
    armorType: number
    baseAC: number
    strengthReq: number
    stealthDisadvantage: number
    _all: number
  }


  export type ArmorAvgAggregateInputType = {
    armorId?: true
    baseAC?: true
    strengthReq?: true
  }

  export type ArmorSumAggregateInputType = {
    armorId?: true
    baseAC?: true
    strengthReq?: true
  }

  export type ArmorMinAggregateInputType = {
    armorId?: true
    name?: true
    armorType?: true
    baseAC?: true
    strengthReq?: true
    stealthDisadvantage?: true
  }

  export type ArmorMaxAggregateInputType = {
    armorId?: true
    name?: true
    armorType?: true
    baseAC?: true
    strengthReq?: true
    stealthDisadvantage?: true
  }

  export type ArmorCountAggregateInputType = {
    armorId?: true
    name?: true
    armorType?: true
    baseAC?: true
    strengthReq?: true
    stealthDisadvantage?: true
    _all?: true
  }

  export type ArmorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Armor to aggregate.
     */
    where?: ArmorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Armors to fetch.
     */
    orderBy?: ArmorOrderByWithRelationInput | ArmorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArmorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Armors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Armors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Armors
    **/
    _count?: true | ArmorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArmorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArmorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArmorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArmorMaxAggregateInputType
  }

  export type GetArmorAggregateType<T extends ArmorAggregateArgs> = {
        [P in keyof T & keyof AggregateArmor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArmor[P]>
      : GetScalarType<T[P], AggregateArmor[P]>
  }




  export type ArmorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArmorWhereInput
    orderBy?: ArmorOrderByWithAggregationInput | ArmorOrderByWithAggregationInput[]
    by: ArmorScalarFieldEnum[] | ArmorScalarFieldEnum
    having?: ArmorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArmorCountAggregateInputType | true
    _avg?: ArmorAvgAggregateInputType
    _sum?: ArmorSumAggregateInputType
    _min?: ArmorMinAggregateInputType
    _max?: ArmorMaxAggregateInputType
  }

  export type ArmorGroupByOutputType = {
    armorId: number
    name: $Enums.ArmorCategory
    armorType: $Enums.ArmorType
    baseAC: number
    strengthReq: number | null
    stealthDisadvantage: boolean
    _count: ArmorCountAggregateOutputType | null
    _avg: ArmorAvgAggregateOutputType | null
    _sum: ArmorSumAggregateOutputType | null
    _min: ArmorMinAggregateOutputType | null
    _max: ArmorMaxAggregateOutputType | null
  }

  type GetArmorGroupByPayload<T extends ArmorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArmorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArmorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArmorGroupByOutputType[P]>
            : GetScalarType<T[P], ArmorGroupByOutputType[P]>
        }
      >
    >


  export type ArmorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    armorId?: boolean
    name?: boolean
    armorType?: boolean
    baseAC?: boolean
    strengthReq?: boolean
    stealthDisadvantage?: boolean
    persArmor?: boolean | Armor$persArmorArgs<ExtArgs>
    classStartingEquipmentOption?: boolean | Armor$classStartingEquipmentOptionArgs<ExtArgs>
    _count?: boolean | ArmorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["armor"]>

  export type ArmorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    armorId?: boolean
    name?: boolean
    armorType?: boolean
    baseAC?: boolean
    strengthReq?: boolean
    stealthDisadvantage?: boolean
  }, ExtArgs["result"]["armor"]>

  export type ArmorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    armorId?: boolean
    name?: boolean
    armorType?: boolean
    baseAC?: boolean
    strengthReq?: boolean
    stealthDisadvantage?: boolean
  }, ExtArgs["result"]["armor"]>

  export type ArmorSelectScalar = {
    armorId?: boolean
    name?: boolean
    armorType?: boolean
    baseAC?: boolean
    strengthReq?: boolean
    stealthDisadvantage?: boolean
  }

  export type ArmorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"armorId" | "name" | "armorType" | "baseAC" | "strengthReq" | "stealthDisadvantage", ExtArgs["result"]["armor"]>
  export type ArmorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    persArmor?: boolean | Armor$persArmorArgs<ExtArgs>
    classStartingEquipmentOption?: boolean | Armor$classStartingEquipmentOptionArgs<ExtArgs>
    _count?: boolean | ArmorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArmorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ArmorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ArmorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Armor"
    objects: {
      persArmor: Prisma.$PersArmorPayload<ExtArgs>[]
      classStartingEquipmentOption: Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      armorId: number
      name: $Enums.ArmorCategory
      armorType: $Enums.ArmorType
      baseAC: number
      strengthReq: number | null
      stealthDisadvantage: boolean
    }, ExtArgs["result"]["armor"]>
    composites: {}
  }

  type ArmorGetPayload<S extends boolean | null | undefined | ArmorDefaultArgs> = $Result.GetResult<Prisma.$ArmorPayload, S>

  type ArmorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArmorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArmorCountAggregateInputType | true
    }

  export interface ArmorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Armor'], meta: { name: 'Armor' } }
    /**
     * Find zero or one Armor that matches the filter.
     * @param {ArmorFindUniqueArgs} args - Arguments to find a Armor
     * @example
     * // Get one Armor
     * const armor = await prisma.armor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArmorFindUniqueArgs>(args: SelectSubset<T, ArmorFindUniqueArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Armor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArmorFindUniqueOrThrowArgs} args - Arguments to find a Armor
     * @example
     * // Get one Armor
     * const armor = await prisma.armor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArmorFindUniqueOrThrowArgs>(args: SelectSubset<T, ArmorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Armor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmorFindFirstArgs} args - Arguments to find a Armor
     * @example
     * // Get one Armor
     * const armor = await prisma.armor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArmorFindFirstArgs>(args?: SelectSubset<T, ArmorFindFirstArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Armor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmorFindFirstOrThrowArgs} args - Arguments to find a Armor
     * @example
     * // Get one Armor
     * const armor = await prisma.armor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArmorFindFirstOrThrowArgs>(args?: SelectSubset<T, ArmorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Armors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Armors
     * const armors = await prisma.armor.findMany()
     * 
     * // Get first 10 Armors
     * const armors = await prisma.armor.findMany({ take: 10 })
     * 
     * // Only select the `armorId`
     * const armorWithArmorIdOnly = await prisma.armor.findMany({ select: { armorId: true } })
     * 
     */
    findMany<T extends ArmorFindManyArgs>(args?: SelectSubset<T, ArmorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Armor.
     * @param {ArmorCreateArgs} args - Arguments to create a Armor.
     * @example
     * // Create one Armor
     * const Armor = await prisma.armor.create({
     *   data: {
     *     // ... data to create a Armor
     *   }
     * })
     * 
     */
    create<T extends ArmorCreateArgs>(args: SelectSubset<T, ArmorCreateArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Armors.
     * @param {ArmorCreateManyArgs} args - Arguments to create many Armors.
     * @example
     * // Create many Armors
     * const armor = await prisma.armor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArmorCreateManyArgs>(args?: SelectSubset<T, ArmorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Armors and returns the data saved in the database.
     * @param {ArmorCreateManyAndReturnArgs} args - Arguments to create many Armors.
     * @example
     * // Create many Armors
     * const armor = await prisma.armor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Armors and only return the `armorId`
     * const armorWithArmorIdOnly = await prisma.armor.createManyAndReturn({
     *   select: { armorId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArmorCreateManyAndReturnArgs>(args?: SelectSubset<T, ArmorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Armor.
     * @param {ArmorDeleteArgs} args - Arguments to delete one Armor.
     * @example
     * // Delete one Armor
     * const Armor = await prisma.armor.delete({
     *   where: {
     *     // ... filter to delete one Armor
     *   }
     * })
     * 
     */
    delete<T extends ArmorDeleteArgs>(args: SelectSubset<T, ArmorDeleteArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Armor.
     * @param {ArmorUpdateArgs} args - Arguments to update one Armor.
     * @example
     * // Update one Armor
     * const armor = await prisma.armor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArmorUpdateArgs>(args: SelectSubset<T, ArmorUpdateArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Armors.
     * @param {ArmorDeleteManyArgs} args - Arguments to filter Armors to delete.
     * @example
     * // Delete a few Armors
     * const { count } = await prisma.armor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArmorDeleteManyArgs>(args?: SelectSubset<T, ArmorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Armors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Armors
     * const armor = await prisma.armor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArmorUpdateManyArgs>(args: SelectSubset<T, ArmorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Armors and returns the data updated in the database.
     * @param {ArmorUpdateManyAndReturnArgs} args - Arguments to update many Armors.
     * @example
     * // Update many Armors
     * const armor = await prisma.armor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Armors and only return the `armorId`
     * const armorWithArmorIdOnly = await prisma.armor.updateManyAndReturn({
     *   select: { armorId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArmorUpdateManyAndReturnArgs>(args: SelectSubset<T, ArmorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Armor.
     * @param {ArmorUpsertArgs} args - Arguments to update or create a Armor.
     * @example
     * // Update or create a Armor
     * const armor = await prisma.armor.upsert({
     *   create: {
     *     // ... data to create a Armor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Armor we want to update
     *   }
     * })
     */
    upsert<T extends ArmorUpsertArgs>(args: SelectSubset<T, ArmorUpsertArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Armors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmorCountArgs} args - Arguments to filter Armors to count.
     * @example
     * // Count the number of Armors
     * const count = await prisma.armor.count({
     *   where: {
     *     // ... the filter for the Armors we want to count
     *   }
     * })
    **/
    count<T extends ArmorCountArgs>(
      args?: Subset<T, ArmorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArmorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Armor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArmorAggregateArgs>(args: Subset<T, ArmorAggregateArgs>): Prisma.PrismaPromise<GetArmorAggregateType<T>>

    /**
     * Group by Armor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArmorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArmorGroupByArgs['orderBy'] }
        : { orderBy?: ArmorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArmorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArmorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Armor model
   */
  readonly fields: ArmorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Armor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArmorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    persArmor<T extends Armor$persArmorArgs<ExtArgs> = {}>(args?: Subset<T, Armor$persArmorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersArmorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classStartingEquipmentOption<T extends Armor$classStartingEquipmentOptionArgs<ExtArgs> = {}>(args?: Subset<T, Armor$classStartingEquipmentOptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Armor model
   */
  interface ArmorFieldRefs {
    readonly armorId: FieldRef<"Armor", 'Int'>
    readonly name: FieldRef<"Armor", 'ArmorCategory'>
    readonly armorType: FieldRef<"Armor", 'ArmorType'>
    readonly baseAC: FieldRef<"Armor", 'Int'>
    readonly strengthReq: FieldRef<"Armor", 'Int'>
    readonly stealthDisadvantage: FieldRef<"Armor", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Armor findUnique
   */
  export type ArmorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmorInclude<ExtArgs> | null
    /**
     * Filter, which Armor to fetch.
     */
    where: ArmorWhereUniqueInput
  }

  /**
   * Armor findUniqueOrThrow
   */
  export type ArmorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmorInclude<ExtArgs> | null
    /**
     * Filter, which Armor to fetch.
     */
    where: ArmorWhereUniqueInput
  }

  /**
   * Armor findFirst
   */
  export type ArmorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmorInclude<ExtArgs> | null
    /**
     * Filter, which Armor to fetch.
     */
    where?: ArmorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Armors to fetch.
     */
    orderBy?: ArmorOrderByWithRelationInput | ArmorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Armors.
     */
    cursor?: ArmorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Armors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Armors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Armors.
     */
    distinct?: ArmorScalarFieldEnum | ArmorScalarFieldEnum[]
  }

  /**
   * Armor findFirstOrThrow
   */
  export type ArmorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmorInclude<ExtArgs> | null
    /**
     * Filter, which Armor to fetch.
     */
    where?: ArmorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Armors to fetch.
     */
    orderBy?: ArmorOrderByWithRelationInput | ArmorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Armors.
     */
    cursor?: ArmorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Armors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Armors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Armors.
     */
    distinct?: ArmorScalarFieldEnum | ArmorScalarFieldEnum[]
  }

  /**
   * Armor findMany
   */
  export type ArmorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmorInclude<ExtArgs> | null
    /**
     * Filter, which Armors to fetch.
     */
    where?: ArmorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Armors to fetch.
     */
    orderBy?: ArmorOrderByWithRelationInput | ArmorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Armors.
     */
    cursor?: ArmorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Armors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Armors.
     */
    skip?: number
    distinct?: ArmorScalarFieldEnum | ArmorScalarFieldEnum[]
  }

  /**
   * Armor create
   */
  export type ArmorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmorInclude<ExtArgs> | null
    /**
     * The data needed to create a Armor.
     */
    data: XOR<ArmorCreateInput, ArmorUncheckedCreateInput>
  }

  /**
   * Armor createMany
   */
  export type ArmorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Armors.
     */
    data: ArmorCreateManyInput | ArmorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Armor createManyAndReturn
   */
  export type ArmorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * The data used to create many Armors.
     */
    data: ArmorCreateManyInput | ArmorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Armor update
   */
  export type ArmorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmorInclude<ExtArgs> | null
    /**
     * The data needed to update a Armor.
     */
    data: XOR<ArmorUpdateInput, ArmorUncheckedUpdateInput>
    /**
     * Choose, which Armor to update.
     */
    where: ArmorWhereUniqueInput
  }

  /**
   * Armor updateMany
   */
  export type ArmorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Armors.
     */
    data: XOR<ArmorUpdateManyMutationInput, ArmorUncheckedUpdateManyInput>
    /**
     * Filter which Armors to update
     */
    where?: ArmorWhereInput
    /**
     * Limit how many Armors to update.
     */
    limit?: number
  }

  /**
   * Armor updateManyAndReturn
   */
  export type ArmorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * The data used to update Armors.
     */
    data: XOR<ArmorUpdateManyMutationInput, ArmorUncheckedUpdateManyInput>
    /**
     * Filter which Armors to update
     */
    where?: ArmorWhereInput
    /**
     * Limit how many Armors to update.
     */
    limit?: number
  }

  /**
   * Armor upsert
   */
  export type ArmorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmorInclude<ExtArgs> | null
    /**
     * The filter to search for the Armor to update in case it exists.
     */
    where: ArmorWhereUniqueInput
    /**
     * In case the Armor found by the `where` argument doesn't exist, create a new Armor with this data.
     */
    create: XOR<ArmorCreateInput, ArmorUncheckedCreateInput>
    /**
     * In case the Armor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArmorUpdateInput, ArmorUncheckedUpdateInput>
  }

  /**
   * Armor delete
   */
  export type ArmorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmorInclude<ExtArgs> | null
    /**
     * Filter which Armor to delete.
     */
    where: ArmorWhereUniqueInput
  }

  /**
   * Armor deleteMany
   */
  export type ArmorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Armors to delete
     */
    where?: ArmorWhereInput
    /**
     * Limit how many Armors to delete.
     */
    limit?: number
  }

  /**
   * Armor.persArmor
   */
  export type Armor$persArmorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersArmor
     */
    select?: PersArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersArmor
     */
    omit?: PersArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersArmorInclude<ExtArgs> | null
    where?: PersArmorWhereInput
    orderBy?: PersArmorOrderByWithRelationInput | PersArmorOrderByWithRelationInput[]
    cursor?: PersArmorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersArmorScalarFieldEnum | PersArmorScalarFieldEnum[]
  }

  /**
   * Armor.classStartingEquipmentOption
   */
  export type Armor$classStartingEquipmentOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionInclude<ExtArgs> | null
    where?: ClassStartingEquipmentOptionWhereInput
    orderBy?: ClassStartingEquipmentOptionOrderByWithRelationInput | ClassStartingEquipmentOptionOrderByWithRelationInput[]
    cursor?: ClassStartingEquipmentOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassStartingEquipmentOptionScalarFieldEnum | ClassStartingEquipmentOptionScalarFieldEnum[]
  }

  /**
   * Armor without action
   */
  export type ArmorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmorInclude<ExtArgs> | null
  }


  /**
   * Model PersSkill
   */

  export type AggregatePersSkill = {
    _count: PersSkillCountAggregateOutputType | null
    _avg: PersSkillAvgAggregateOutputType | null
    _sum: PersSkillSumAggregateOutputType | null
    _min: PersSkillMinAggregateOutputType | null
    _max: PersSkillMaxAggregateOutputType | null
  }

  export type PersSkillAvgAggregateOutputType = {
    persSkillId: number | null
    skillId: number | null
    persId: number | null
    customModifier: number | null
  }

  export type PersSkillSumAggregateOutputType = {
    persSkillId: number | null
    skillId: number | null
    persId: number | null
    customModifier: number | null
  }

  export type PersSkillMinAggregateOutputType = {
    persSkillId: number | null
    skillId: number | null
    persId: number | null
    proficiencyType: $Enums.SkillProficiencyType | null
    customModifier: number | null
    name: $Enums.Skills | null
  }

  export type PersSkillMaxAggregateOutputType = {
    persSkillId: number | null
    skillId: number | null
    persId: number | null
    proficiencyType: $Enums.SkillProficiencyType | null
    customModifier: number | null
    name: $Enums.Skills | null
  }

  export type PersSkillCountAggregateOutputType = {
    persSkillId: number
    skillId: number
    persId: number
    proficiencyType: number
    customModifier: number
    name: number
    _all: number
  }


  export type PersSkillAvgAggregateInputType = {
    persSkillId?: true
    skillId?: true
    persId?: true
    customModifier?: true
  }

  export type PersSkillSumAggregateInputType = {
    persSkillId?: true
    skillId?: true
    persId?: true
    customModifier?: true
  }

  export type PersSkillMinAggregateInputType = {
    persSkillId?: true
    skillId?: true
    persId?: true
    proficiencyType?: true
    customModifier?: true
    name?: true
  }

  export type PersSkillMaxAggregateInputType = {
    persSkillId?: true
    skillId?: true
    persId?: true
    proficiencyType?: true
    customModifier?: true
    name?: true
  }

  export type PersSkillCountAggregateInputType = {
    persSkillId?: true
    skillId?: true
    persId?: true
    proficiencyType?: true
    customModifier?: true
    name?: true
    _all?: true
  }

  export type PersSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersSkill to aggregate.
     */
    where?: PersSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersSkills to fetch.
     */
    orderBy?: PersSkillOrderByWithRelationInput | PersSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersSkills
    **/
    _count?: true | PersSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersSkillMaxAggregateInputType
  }

  export type GetPersSkillAggregateType<T extends PersSkillAggregateArgs> = {
        [P in keyof T & keyof AggregatePersSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersSkill[P]>
      : GetScalarType<T[P], AggregatePersSkill[P]>
  }




  export type PersSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersSkillWhereInput
    orderBy?: PersSkillOrderByWithAggregationInput | PersSkillOrderByWithAggregationInput[]
    by: PersSkillScalarFieldEnum[] | PersSkillScalarFieldEnum
    having?: PersSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersSkillCountAggregateInputType | true
    _avg?: PersSkillAvgAggregateInputType
    _sum?: PersSkillSumAggregateInputType
    _min?: PersSkillMinAggregateInputType
    _max?: PersSkillMaxAggregateInputType
  }

  export type PersSkillGroupByOutputType = {
    persSkillId: number
    skillId: number
    persId: number
    proficiencyType: $Enums.SkillProficiencyType
    customModifier: number | null
    name: $Enums.Skills
    _count: PersSkillCountAggregateOutputType | null
    _avg: PersSkillAvgAggregateOutputType | null
    _sum: PersSkillSumAggregateOutputType | null
    _min: PersSkillMinAggregateOutputType | null
    _max: PersSkillMaxAggregateOutputType | null
  }

  type GetPersSkillGroupByPayload<T extends PersSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersSkillGroupByOutputType[P]>
            : GetScalarType<T[P], PersSkillGroupByOutputType[P]>
        }
      >
    >


  export type PersSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persSkillId?: boolean
    skillId?: boolean
    persId?: boolean
    proficiencyType?: boolean
    customModifier?: boolean
    name?: boolean
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persSkill"]>

  export type PersSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persSkillId?: boolean
    skillId?: boolean
    persId?: boolean
    proficiencyType?: boolean
    customModifier?: boolean
    name?: boolean
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persSkill"]>

  export type PersSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persSkillId?: boolean
    skillId?: boolean
    persId?: boolean
    proficiencyType?: boolean
    customModifier?: boolean
    name?: boolean
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persSkill"]>

  export type PersSkillSelectScalar = {
    persSkillId?: boolean
    skillId?: boolean
    persId?: boolean
    proficiencyType?: boolean
    customModifier?: boolean
    name?: boolean
  }

  export type PersSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"persSkillId" | "skillId" | "persId" | "proficiencyType" | "customModifier" | "name", ExtArgs["result"]["persSkill"]>
  export type PersSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }
  export type PersSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }
  export type PersSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pers?: boolean | PersDefaultArgs<ExtArgs>
  }

  export type $PersSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersSkill"
    objects: {
      pers: Prisma.$PersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      persSkillId: number
      skillId: number
      persId: number
      proficiencyType: $Enums.SkillProficiencyType
      customModifier: number | null
      name: $Enums.Skills
    }, ExtArgs["result"]["persSkill"]>
    composites: {}
  }

  type PersSkillGetPayload<S extends boolean | null | undefined | PersSkillDefaultArgs> = $Result.GetResult<Prisma.$PersSkillPayload, S>

  type PersSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersSkillCountAggregateInputType | true
    }

  export interface PersSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersSkill'], meta: { name: 'PersSkill' } }
    /**
     * Find zero or one PersSkill that matches the filter.
     * @param {PersSkillFindUniqueArgs} args - Arguments to find a PersSkill
     * @example
     * // Get one PersSkill
     * const persSkill = await prisma.persSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersSkillFindUniqueArgs>(args: SelectSubset<T, PersSkillFindUniqueArgs<ExtArgs>>): Prisma__PersSkillClient<$Result.GetResult<Prisma.$PersSkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersSkillFindUniqueOrThrowArgs} args - Arguments to find a PersSkill
     * @example
     * // Get one PersSkill
     * const persSkill = await prisma.persSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, PersSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersSkillClient<$Result.GetResult<Prisma.$PersSkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersSkillFindFirstArgs} args - Arguments to find a PersSkill
     * @example
     * // Get one PersSkill
     * const persSkill = await prisma.persSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersSkillFindFirstArgs>(args?: SelectSubset<T, PersSkillFindFirstArgs<ExtArgs>>): Prisma__PersSkillClient<$Result.GetResult<Prisma.$PersSkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersSkillFindFirstOrThrowArgs} args - Arguments to find a PersSkill
     * @example
     * // Get one PersSkill
     * const persSkill = await prisma.persSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, PersSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersSkillClient<$Result.GetResult<Prisma.$PersSkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersSkills
     * const persSkills = await prisma.persSkill.findMany()
     * 
     * // Get first 10 PersSkills
     * const persSkills = await prisma.persSkill.findMany({ take: 10 })
     * 
     * // Only select the `persSkillId`
     * const persSkillWithPersSkillIdOnly = await prisma.persSkill.findMany({ select: { persSkillId: true } })
     * 
     */
    findMany<T extends PersSkillFindManyArgs>(args?: SelectSubset<T, PersSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersSkill.
     * @param {PersSkillCreateArgs} args - Arguments to create a PersSkill.
     * @example
     * // Create one PersSkill
     * const PersSkill = await prisma.persSkill.create({
     *   data: {
     *     // ... data to create a PersSkill
     *   }
     * })
     * 
     */
    create<T extends PersSkillCreateArgs>(args: SelectSubset<T, PersSkillCreateArgs<ExtArgs>>): Prisma__PersSkillClient<$Result.GetResult<Prisma.$PersSkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersSkills.
     * @param {PersSkillCreateManyArgs} args - Arguments to create many PersSkills.
     * @example
     * // Create many PersSkills
     * const persSkill = await prisma.persSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersSkillCreateManyArgs>(args?: SelectSubset<T, PersSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersSkills and returns the data saved in the database.
     * @param {PersSkillCreateManyAndReturnArgs} args - Arguments to create many PersSkills.
     * @example
     * // Create many PersSkills
     * const persSkill = await prisma.persSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersSkills and only return the `persSkillId`
     * const persSkillWithPersSkillIdOnly = await prisma.persSkill.createManyAndReturn({
     *   select: { persSkillId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, PersSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersSkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersSkill.
     * @param {PersSkillDeleteArgs} args - Arguments to delete one PersSkill.
     * @example
     * // Delete one PersSkill
     * const PersSkill = await prisma.persSkill.delete({
     *   where: {
     *     // ... filter to delete one PersSkill
     *   }
     * })
     * 
     */
    delete<T extends PersSkillDeleteArgs>(args: SelectSubset<T, PersSkillDeleteArgs<ExtArgs>>): Prisma__PersSkillClient<$Result.GetResult<Prisma.$PersSkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersSkill.
     * @param {PersSkillUpdateArgs} args - Arguments to update one PersSkill.
     * @example
     * // Update one PersSkill
     * const persSkill = await prisma.persSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersSkillUpdateArgs>(args: SelectSubset<T, PersSkillUpdateArgs<ExtArgs>>): Prisma__PersSkillClient<$Result.GetResult<Prisma.$PersSkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersSkills.
     * @param {PersSkillDeleteManyArgs} args - Arguments to filter PersSkills to delete.
     * @example
     * // Delete a few PersSkills
     * const { count } = await prisma.persSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersSkillDeleteManyArgs>(args?: SelectSubset<T, PersSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersSkills
     * const persSkill = await prisma.persSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersSkillUpdateManyArgs>(args: SelectSubset<T, PersSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersSkills and returns the data updated in the database.
     * @param {PersSkillUpdateManyAndReturnArgs} args - Arguments to update many PersSkills.
     * @example
     * // Update many PersSkills
     * const persSkill = await prisma.persSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersSkills and only return the `persSkillId`
     * const persSkillWithPersSkillIdOnly = await prisma.persSkill.updateManyAndReturn({
     *   select: { persSkillId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, PersSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersSkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersSkill.
     * @param {PersSkillUpsertArgs} args - Arguments to update or create a PersSkill.
     * @example
     * // Update or create a PersSkill
     * const persSkill = await prisma.persSkill.upsert({
     *   create: {
     *     // ... data to create a PersSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersSkill we want to update
     *   }
     * })
     */
    upsert<T extends PersSkillUpsertArgs>(args: SelectSubset<T, PersSkillUpsertArgs<ExtArgs>>): Prisma__PersSkillClient<$Result.GetResult<Prisma.$PersSkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersSkillCountArgs} args - Arguments to filter PersSkills to count.
     * @example
     * // Count the number of PersSkills
     * const count = await prisma.persSkill.count({
     *   where: {
     *     // ... the filter for the PersSkills we want to count
     *   }
     * })
    **/
    count<T extends PersSkillCountArgs>(
      args?: Subset<T, PersSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersSkillAggregateArgs>(args: Subset<T, PersSkillAggregateArgs>): Prisma.PrismaPromise<GetPersSkillAggregateType<T>>

    /**
     * Group by PersSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersSkillGroupByArgs['orderBy'] }
        : { orderBy?: PersSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersSkill model
   */
  readonly fields: PersSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pers<T extends PersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersDefaultArgs<ExtArgs>>): Prisma__PersClient<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersSkill model
   */
  interface PersSkillFieldRefs {
    readonly persSkillId: FieldRef<"PersSkill", 'Int'>
    readonly skillId: FieldRef<"PersSkill", 'Int'>
    readonly persId: FieldRef<"PersSkill", 'Int'>
    readonly proficiencyType: FieldRef<"PersSkill", 'SkillProficiencyType'>
    readonly customModifier: FieldRef<"PersSkill", 'Int'>
    readonly name: FieldRef<"PersSkill", 'Skills'>
  }
    

  // Custom InputTypes
  /**
   * PersSkill findUnique
   */
  export type PersSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersSkill
     */
    select?: PersSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersSkill
     */
    omit?: PersSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersSkillInclude<ExtArgs> | null
    /**
     * Filter, which PersSkill to fetch.
     */
    where: PersSkillWhereUniqueInput
  }

  /**
   * PersSkill findUniqueOrThrow
   */
  export type PersSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersSkill
     */
    select?: PersSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersSkill
     */
    omit?: PersSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersSkillInclude<ExtArgs> | null
    /**
     * Filter, which PersSkill to fetch.
     */
    where: PersSkillWhereUniqueInput
  }

  /**
   * PersSkill findFirst
   */
  export type PersSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersSkill
     */
    select?: PersSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersSkill
     */
    omit?: PersSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersSkillInclude<ExtArgs> | null
    /**
     * Filter, which PersSkill to fetch.
     */
    where?: PersSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersSkills to fetch.
     */
    orderBy?: PersSkillOrderByWithRelationInput | PersSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersSkills.
     */
    cursor?: PersSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersSkills.
     */
    distinct?: PersSkillScalarFieldEnum | PersSkillScalarFieldEnum[]
  }

  /**
   * PersSkill findFirstOrThrow
   */
  export type PersSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersSkill
     */
    select?: PersSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersSkill
     */
    omit?: PersSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersSkillInclude<ExtArgs> | null
    /**
     * Filter, which PersSkill to fetch.
     */
    where?: PersSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersSkills to fetch.
     */
    orderBy?: PersSkillOrderByWithRelationInput | PersSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersSkills.
     */
    cursor?: PersSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersSkills.
     */
    distinct?: PersSkillScalarFieldEnum | PersSkillScalarFieldEnum[]
  }

  /**
   * PersSkill findMany
   */
  export type PersSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersSkill
     */
    select?: PersSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersSkill
     */
    omit?: PersSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersSkillInclude<ExtArgs> | null
    /**
     * Filter, which PersSkills to fetch.
     */
    where?: PersSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersSkills to fetch.
     */
    orderBy?: PersSkillOrderByWithRelationInput | PersSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersSkills.
     */
    cursor?: PersSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersSkills.
     */
    skip?: number
    distinct?: PersSkillScalarFieldEnum | PersSkillScalarFieldEnum[]
  }

  /**
   * PersSkill create
   */
  export type PersSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersSkill
     */
    select?: PersSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersSkill
     */
    omit?: PersSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a PersSkill.
     */
    data: XOR<PersSkillCreateInput, PersSkillUncheckedCreateInput>
  }

  /**
   * PersSkill createMany
   */
  export type PersSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersSkills.
     */
    data: PersSkillCreateManyInput | PersSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersSkill createManyAndReturn
   */
  export type PersSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersSkill
     */
    select?: PersSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersSkill
     */
    omit?: PersSkillOmit<ExtArgs> | null
    /**
     * The data used to create many PersSkills.
     */
    data: PersSkillCreateManyInput | PersSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersSkill update
   */
  export type PersSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersSkill
     */
    select?: PersSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersSkill
     */
    omit?: PersSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a PersSkill.
     */
    data: XOR<PersSkillUpdateInput, PersSkillUncheckedUpdateInput>
    /**
     * Choose, which PersSkill to update.
     */
    where: PersSkillWhereUniqueInput
  }

  /**
   * PersSkill updateMany
   */
  export type PersSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersSkills.
     */
    data: XOR<PersSkillUpdateManyMutationInput, PersSkillUncheckedUpdateManyInput>
    /**
     * Filter which PersSkills to update
     */
    where?: PersSkillWhereInput
    /**
     * Limit how many PersSkills to update.
     */
    limit?: number
  }

  /**
   * PersSkill updateManyAndReturn
   */
  export type PersSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersSkill
     */
    select?: PersSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersSkill
     */
    omit?: PersSkillOmit<ExtArgs> | null
    /**
     * The data used to update PersSkills.
     */
    data: XOR<PersSkillUpdateManyMutationInput, PersSkillUncheckedUpdateManyInput>
    /**
     * Filter which PersSkills to update
     */
    where?: PersSkillWhereInput
    /**
     * Limit how many PersSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersSkill upsert
   */
  export type PersSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersSkill
     */
    select?: PersSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersSkill
     */
    omit?: PersSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the PersSkill to update in case it exists.
     */
    where: PersSkillWhereUniqueInput
    /**
     * In case the PersSkill found by the `where` argument doesn't exist, create a new PersSkill with this data.
     */
    create: XOR<PersSkillCreateInput, PersSkillUncheckedCreateInput>
    /**
     * In case the PersSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersSkillUpdateInput, PersSkillUncheckedUpdateInput>
  }

  /**
   * PersSkill delete
   */
  export type PersSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersSkill
     */
    select?: PersSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersSkill
     */
    omit?: PersSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersSkillInclude<ExtArgs> | null
    /**
     * Filter which PersSkill to delete.
     */
    where: PersSkillWhereUniqueInput
  }

  /**
   * PersSkill deleteMany
   */
  export type PersSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersSkills to delete
     */
    where?: PersSkillWhereInput
    /**
     * Limit how many PersSkills to delete.
     */
    limit?: number
  }

  /**
   * PersSkill without action
   */
  export type PersSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersSkill
     */
    select?: PersSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersSkill
     */
    omit?: PersSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersSkillInclude<ExtArgs> | null
  }


  /**
   * Model PersWeapon
   */

  export type AggregatePersWeapon = {
    _count: PersWeaponCountAggregateOutputType | null
    _avg: PersWeaponAvgAggregateOutputType | null
    _sum: PersWeaponSumAggregateOutputType | null
    _min: PersWeaponMinAggregateOutputType | null
    _max: PersWeaponMaxAggregateOutputType | null
  }

  export type PersWeaponAvgAggregateOutputType = {
    persWeaponId: number | null
    persId: number | null
    weaponId: number | null
    attackBonus: number | null
    overrideNormalRange: number | null
    overrideLongRange: number | null
  }

  export type PersWeaponSumAggregateOutputType = {
    persWeaponId: number | null
    persId: number | null
    weaponId: number | null
    attackBonus: number | null
    overrideNormalRange: number | null
    overrideLongRange: number | null
  }

  export type PersWeaponMinAggregateOutputType = {
    persWeaponId: number | null
    persId: number | null
    weaponId: number | null
    overrideDamage: string | null
    attackBonus: number | null
    overrideName: string | null
    overrideNormalRange: number | null
    overrideLongRange: number | null
    overrideDamageType: $Enums.DamageType | null
    overrideAttackAbility: $Enums.Ability | null
    isProficient: boolean | null
  }

  export type PersWeaponMaxAggregateOutputType = {
    persWeaponId: number | null
    persId: number | null
    weaponId: number | null
    overrideDamage: string | null
    attackBonus: number | null
    overrideName: string | null
    overrideNormalRange: number | null
    overrideLongRange: number | null
    overrideDamageType: $Enums.DamageType | null
    overrideAttackAbility: $Enums.Ability | null
    isProficient: boolean | null
  }

  export type PersWeaponCountAggregateOutputType = {
    persWeaponId: number
    persId: number
    weaponId: number
    overrideDamage: number
    attackBonus: number
    overrideName: number
    overrideNormalRange: number
    overrideLongRange: number
    overrideDamageType: number
    overrideAttackAbility: number
    isProficient: number
    _all: number
  }


  export type PersWeaponAvgAggregateInputType = {
    persWeaponId?: true
    persId?: true
    weaponId?: true
    attackBonus?: true
    overrideNormalRange?: true
    overrideLongRange?: true
  }

  export type PersWeaponSumAggregateInputType = {
    persWeaponId?: true
    persId?: true
    weaponId?: true
    attackBonus?: true
    overrideNormalRange?: true
    overrideLongRange?: true
  }

  export type PersWeaponMinAggregateInputType = {
    persWeaponId?: true
    persId?: true
    weaponId?: true
    overrideDamage?: true
    attackBonus?: true
    overrideName?: true
    overrideNormalRange?: true
    overrideLongRange?: true
    overrideDamageType?: true
    overrideAttackAbility?: true
    isProficient?: true
  }

  export type PersWeaponMaxAggregateInputType = {
    persWeaponId?: true
    persId?: true
    weaponId?: true
    overrideDamage?: true
    attackBonus?: true
    overrideName?: true
    overrideNormalRange?: true
    overrideLongRange?: true
    overrideDamageType?: true
    overrideAttackAbility?: true
    isProficient?: true
  }

  export type PersWeaponCountAggregateInputType = {
    persWeaponId?: true
    persId?: true
    weaponId?: true
    overrideDamage?: true
    attackBonus?: true
    overrideName?: true
    overrideNormalRange?: true
    overrideLongRange?: true
    overrideDamageType?: true
    overrideAttackAbility?: true
    isProficient?: true
    _all?: true
  }

  export type PersWeaponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersWeapon to aggregate.
     */
    where?: PersWeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersWeapons to fetch.
     */
    orderBy?: PersWeaponOrderByWithRelationInput | PersWeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersWeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersWeapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersWeapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersWeapons
    **/
    _count?: true | PersWeaponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersWeaponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersWeaponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersWeaponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersWeaponMaxAggregateInputType
  }

  export type GetPersWeaponAggregateType<T extends PersWeaponAggregateArgs> = {
        [P in keyof T & keyof AggregatePersWeapon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersWeapon[P]>
      : GetScalarType<T[P], AggregatePersWeapon[P]>
  }




  export type PersWeaponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersWeaponWhereInput
    orderBy?: PersWeaponOrderByWithAggregationInput | PersWeaponOrderByWithAggregationInput[]
    by: PersWeaponScalarFieldEnum[] | PersWeaponScalarFieldEnum
    having?: PersWeaponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersWeaponCountAggregateInputType | true
    _avg?: PersWeaponAvgAggregateInputType
    _sum?: PersWeaponSumAggregateInputType
    _min?: PersWeaponMinAggregateInputType
    _max?: PersWeaponMaxAggregateInputType
  }

  export type PersWeaponGroupByOutputType = {
    persWeaponId: number
    persId: number
    weaponId: number
    overrideDamage: string | null
    attackBonus: number | null
    overrideName: string | null
    overrideNormalRange: number | null
    overrideLongRange: number | null
    overrideDamageType: $Enums.DamageType | null
    overrideAttackAbility: $Enums.Ability | null
    isProficient: boolean
    _count: PersWeaponCountAggregateOutputType | null
    _avg: PersWeaponAvgAggregateOutputType | null
    _sum: PersWeaponSumAggregateOutputType | null
    _min: PersWeaponMinAggregateOutputType | null
    _max: PersWeaponMaxAggregateOutputType | null
  }

  type GetPersWeaponGroupByPayload<T extends PersWeaponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersWeaponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersWeaponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersWeaponGroupByOutputType[P]>
            : GetScalarType<T[P], PersWeaponGroupByOutputType[P]>
        }
      >
    >


  export type PersWeaponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persWeaponId?: boolean
    persId?: boolean
    weaponId?: boolean
    overrideDamage?: boolean
    attackBonus?: boolean
    overrideName?: boolean
    overrideNormalRange?: boolean
    overrideLongRange?: boolean
    overrideDamageType?: boolean
    overrideAttackAbility?: boolean
    isProficient?: boolean
    pers?: boolean | PersDefaultArgs<ExtArgs>
    weapon?: boolean | WeaponDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persWeapon"]>

  export type PersWeaponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persWeaponId?: boolean
    persId?: boolean
    weaponId?: boolean
    overrideDamage?: boolean
    attackBonus?: boolean
    overrideName?: boolean
    overrideNormalRange?: boolean
    overrideLongRange?: boolean
    overrideDamageType?: boolean
    overrideAttackAbility?: boolean
    isProficient?: boolean
    pers?: boolean | PersDefaultArgs<ExtArgs>
    weapon?: boolean | WeaponDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persWeapon"]>

  export type PersWeaponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persWeaponId?: boolean
    persId?: boolean
    weaponId?: boolean
    overrideDamage?: boolean
    attackBonus?: boolean
    overrideName?: boolean
    overrideNormalRange?: boolean
    overrideLongRange?: boolean
    overrideDamageType?: boolean
    overrideAttackAbility?: boolean
    isProficient?: boolean
    pers?: boolean | PersDefaultArgs<ExtArgs>
    weapon?: boolean | WeaponDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persWeapon"]>

  export type PersWeaponSelectScalar = {
    persWeaponId?: boolean
    persId?: boolean
    weaponId?: boolean
    overrideDamage?: boolean
    attackBonus?: boolean
    overrideName?: boolean
    overrideNormalRange?: boolean
    overrideLongRange?: boolean
    overrideDamageType?: boolean
    overrideAttackAbility?: boolean
    isProficient?: boolean
  }

  export type PersWeaponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"persWeaponId" | "persId" | "weaponId" | "overrideDamage" | "attackBonus" | "overrideName" | "overrideNormalRange" | "overrideLongRange" | "overrideDamageType" | "overrideAttackAbility" | "isProficient", ExtArgs["result"]["persWeapon"]>
  export type PersWeaponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pers?: boolean | PersDefaultArgs<ExtArgs>
    weapon?: boolean | WeaponDefaultArgs<ExtArgs>
  }
  export type PersWeaponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pers?: boolean | PersDefaultArgs<ExtArgs>
    weapon?: boolean | WeaponDefaultArgs<ExtArgs>
  }
  export type PersWeaponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pers?: boolean | PersDefaultArgs<ExtArgs>
    weapon?: boolean | WeaponDefaultArgs<ExtArgs>
  }

  export type $PersWeaponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersWeapon"
    objects: {
      pers: Prisma.$PersPayload<ExtArgs>
      weapon: Prisma.$WeaponPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      persWeaponId: number
      persId: number
      weaponId: number
      overrideDamage: string | null
      attackBonus: number | null
      overrideName: string | null
      overrideNormalRange: number | null
      overrideLongRange: number | null
      overrideDamageType: $Enums.DamageType | null
      overrideAttackAbility: $Enums.Ability | null
      isProficient: boolean
    }, ExtArgs["result"]["persWeapon"]>
    composites: {}
  }

  type PersWeaponGetPayload<S extends boolean | null | undefined | PersWeaponDefaultArgs> = $Result.GetResult<Prisma.$PersWeaponPayload, S>

  type PersWeaponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersWeaponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersWeaponCountAggregateInputType | true
    }

  export interface PersWeaponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersWeapon'], meta: { name: 'PersWeapon' } }
    /**
     * Find zero or one PersWeapon that matches the filter.
     * @param {PersWeaponFindUniqueArgs} args - Arguments to find a PersWeapon
     * @example
     * // Get one PersWeapon
     * const persWeapon = await prisma.persWeapon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersWeaponFindUniqueArgs>(args: SelectSubset<T, PersWeaponFindUniqueArgs<ExtArgs>>): Prisma__PersWeaponClient<$Result.GetResult<Prisma.$PersWeaponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersWeapon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersWeaponFindUniqueOrThrowArgs} args - Arguments to find a PersWeapon
     * @example
     * // Get one PersWeapon
     * const persWeapon = await prisma.persWeapon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersWeaponFindUniqueOrThrowArgs>(args: SelectSubset<T, PersWeaponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersWeaponClient<$Result.GetResult<Prisma.$PersWeaponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersWeapon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersWeaponFindFirstArgs} args - Arguments to find a PersWeapon
     * @example
     * // Get one PersWeapon
     * const persWeapon = await prisma.persWeapon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersWeaponFindFirstArgs>(args?: SelectSubset<T, PersWeaponFindFirstArgs<ExtArgs>>): Prisma__PersWeaponClient<$Result.GetResult<Prisma.$PersWeaponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersWeapon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersWeaponFindFirstOrThrowArgs} args - Arguments to find a PersWeapon
     * @example
     * // Get one PersWeapon
     * const persWeapon = await prisma.persWeapon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersWeaponFindFirstOrThrowArgs>(args?: SelectSubset<T, PersWeaponFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersWeaponClient<$Result.GetResult<Prisma.$PersWeaponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersWeapons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersWeaponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersWeapons
     * const persWeapons = await prisma.persWeapon.findMany()
     * 
     * // Get first 10 PersWeapons
     * const persWeapons = await prisma.persWeapon.findMany({ take: 10 })
     * 
     * // Only select the `persWeaponId`
     * const persWeaponWithPersWeaponIdOnly = await prisma.persWeapon.findMany({ select: { persWeaponId: true } })
     * 
     */
    findMany<T extends PersWeaponFindManyArgs>(args?: SelectSubset<T, PersWeaponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersWeaponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersWeapon.
     * @param {PersWeaponCreateArgs} args - Arguments to create a PersWeapon.
     * @example
     * // Create one PersWeapon
     * const PersWeapon = await prisma.persWeapon.create({
     *   data: {
     *     // ... data to create a PersWeapon
     *   }
     * })
     * 
     */
    create<T extends PersWeaponCreateArgs>(args: SelectSubset<T, PersWeaponCreateArgs<ExtArgs>>): Prisma__PersWeaponClient<$Result.GetResult<Prisma.$PersWeaponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersWeapons.
     * @param {PersWeaponCreateManyArgs} args - Arguments to create many PersWeapons.
     * @example
     * // Create many PersWeapons
     * const persWeapon = await prisma.persWeapon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersWeaponCreateManyArgs>(args?: SelectSubset<T, PersWeaponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersWeapons and returns the data saved in the database.
     * @param {PersWeaponCreateManyAndReturnArgs} args - Arguments to create many PersWeapons.
     * @example
     * // Create many PersWeapons
     * const persWeapon = await prisma.persWeapon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersWeapons and only return the `persWeaponId`
     * const persWeaponWithPersWeaponIdOnly = await prisma.persWeapon.createManyAndReturn({
     *   select: { persWeaponId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersWeaponCreateManyAndReturnArgs>(args?: SelectSubset<T, PersWeaponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersWeaponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersWeapon.
     * @param {PersWeaponDeleteArgs} args - Arguments to delete one PersWeapon.
     * @example
     * // Delete one PersWeapon
     * const PersWeapon = await prisma.persWeapon.delete({
     *   where: {
     *     // ... filter to delete one PersWeapon
     *   }
     * })
     * 
     */
    delete<T extends PersWeaponDeleteArgs>(args: SelectSubset<T, PersWeaponDeleteArgs<ExtArgs>>): Prisma__PersWeaponClient<$Result.GetResult<Prisma.$PersWeaponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersWeapon.
     * @param {PersWeaponUpdateArgs} args - Arguments to update one PersWeapon.
     * @example
     * // Update one PersWeapon
     * const persWeapon = await prisma.persWeapon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersWeaponUpdateArgs>(args: SelectSubset<T, PersWeaponUpdateArgs<ExtArgs>>): Prisma__PersWeaponClient<$Result.GetResult<Prisma.$PersWeaponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersWeapons.
     * @param {PersWeaponDeleteManyArgs} args - Arguments to filter PersWeapons to delete.
     * @example
     * // Delete a few PersWeapons
     * const { count } = await prisma.persWeapon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersWeaponDeleteManyArgs>(args?: SelectSubset<T, PersWeaponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersWeapons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersWeaponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersWeapons
     * const persWeapon = await prisma.persWeapon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersWeaponUpdateManyArgs>(args: SelectSubset<T, PersWeaponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersWeapons and returns the data updated in the database.
     * @param {PersWeaponUpdateManyAndReturnArgs} args - Arguments to update many PersWeapons.
     * @example
     * // Update many PersWeapons
     * const persWeapon = await prisma.persWeapon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersWeapons and only return the `persWeaponId`
     * const persWeaponWithPersWeaponIdOnly = await prisma.persWeapon.updateManyAndReturn({
     *   select: { persWeaponId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersWeaponUpdateManyAndReturnArgs>(args: SelectSubset<T, PersWeaponUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersWeaponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersWeapon.
     * @param {PersWeaponUpsertArgs} args - Arguments to update or create a PersWeapon.
     * @example
     * // Update or create a PersWeapon
     * const persWeapon = await prisma.persWeapon.upsert({
     *   create: {
     *     // ... data to create a PersWeapon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersWeapon we want to update
     *   }
     * })
     */
    upsert<T extends PersWeaponUpsertArgs>(args: SelectSubset<T, PersWeaponUpsertArgs<ExtArgs>>): Prisma__PersWeaponClient<$Result.GetResult<Prisma.$PersWeaponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersWeapons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersWeaponCountArgs} args - Arguments to filter PersWeapons to count.
     * @example
     * // Count the number of PersWeapons
     * const count = await prisma.persWeapon.count({
     *   where: {
     *     // ... the filter for the PersWeapons we want to count
     *   }
     * })
    **/
    count<T extends PersWeaponCountArgs>(
      args?: Subset<T, PersWeaponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersWeaponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersWeapon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersWeaponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersWeaponAggregateArgs>(args: Subset<T, PersWeaponAggregateArgs>): Prisma.PrismaPromise<GetPersWeaponAggregateType<T>>

    /**
     * Group by PersWeapon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersWeaponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersWeaponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersWeaponGroupByArgs['orderBy'] }
        : { orderBy?: PersWeaponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersWeaponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersWeaponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersWeapon model
   */
  readonly fields: PersWeaponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersWeapon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersWeaponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pers<T extends PersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersDefaultArgs<ExtArgs>>): Prisma__PersClient<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    weapon<T extends WeaponDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WeaponDefaultArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersWeapon model
   */
  interface PersWeaponFieldRefs {
    readonly persWeaponId: FieldRef<"PersWeapon", 'Int'>
    readonly persId: FieldRef<"PersWeapon", 'Int'>
    readonly weaponId: FieldRef<"PersWeapon", 'Int'>
    readonly overrideDamage: FieldRef<"PersWeapon", 'String'>
    readonly attackBonus: FieldRef<"PersWeapon", 'Int'>
    readonly overrideName: FieldRef<"PersWeapon", 'String'>
    readonly overrideNormalRange: FieldRef<"PersWeapon", 'Int'>
    readonly overrideLongRange: FieldRef<"PersWeapon", 'Int'>
    readonly overrideDamageType: FieldRef<"PersWeapon", 'DamageType'>
    readonly overrideAttackAbility: FieldRef<"PersWeapon", 'Ability'>
    readonly isProficient: FieldRef<"PersWeapon", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PersWeapon findUnique
   */
  export type PersWeaponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersWeapon
     */
    select?: PersWeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersWeapon
     */
    omit?: PersWeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersWeaponInclude<ExtArgs> | null
    /**
     * Filter, which PersWeapon to fetch.
     */
    where: PersWeaponWhereUniqueInput
  }

  /**
   * PersWeapon findUniqueOrThrow
   */
  export type PersWeaponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersWeapon
     */
    select?: PersWeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersWeapon
     */
    omit?: PersWeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersWeaponInclude<ExtArgs> | null
    /**
     * Filter, which PersWeapon to fetch.
     */
    where: PersWeaponWhereUniqueInput
  }

  /**
   * PersWeapon findFirst
   */
  export type PersWeaponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersWeapon
     */
    select?: PersWeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersWeapon
     */
    omit?: PersWeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersWeaponInclude<ExtArgs> | null
    /**
     * Filter, which PersWeapon to fetch.
     */
    where?: PersWeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersWeapons to fetch.
     */
    orderBy?: PersWeaponOrderByWithRelationInput | PersWeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersWeapons.
     */
    cursor?: PersWeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersWeapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersWeapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersWeapons.
     */
    distinct?: PersWeaponScalarFieldEnum | PersWeaponScalarFieldEnum[]
  }

  /**
   * PersWeapon findFirstOrThrow
   */
  export type PersWeaponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersWeapon
     */
    select?: PersWeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersWeapon
     */
    omit?: PersWeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersWeaponInclude<ExtArgs> | null
    /**
     * Filter, which PersWeapon to fetch.
     */
    where?: PersWeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersWeapons to fetch.
     */
    orderBy?: PersWeaponOrderByWithRelationInput | PersWeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersWeapons.
     */
    cursor?: PersWeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersWeapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersWeapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersWeapons.
     */
    distinct?: PersWeaponScalarFieldEnum | PersWeaponScalarFieldEnum[]
  }

  /**
   * PersWeapon findMany
   */
  export type PersWeaponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersWeapon
     */
    select?: PersWeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersWeapon
     */
    omit?: PersWeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersWeaponInclude<ExtArgs> | null
    /**
     * Filter, which PersWeapons to fetch.
     */
    where?: PersWeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersWeapons to fetch.
     */
    orderBy?: PersWeaponOrderByWithRelationInput | PersWeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersWeapons.
     */
    cursor?: PersWeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersWeapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersWeapons.
     */
    skip?: number
    distinct?: PersWeaponScalarFieldEnum | PersWeaponScalarFieldEnum[]
  }

  /**
   * PersWeapon create
   */
  export type PersWeaponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersWeapon
     */
    select?: PersWeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersWeapon
     */
    omit?: PersWeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersWeaponInclude<ExtArgs> | null
    /**
     * The data needed to create a PersWeapon.
     */
    data: XOR<PersWeaponCreateInput, PersWeaponUncheckedCreateInput>
  }

  /**
   * PersWeapon createMany
   */
  export type PersWeaponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersWeapons.
     */
    data: PersWeaponCreateManyInput | PersWeaponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersWeapon createManyAndReturn
   */
  export type PersWeaponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersWeapon
     */
    select?: PersWeaponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersWeapon
     */
    omit?: PersWeaponOmit<ExtArgs> | null
    /**
     * The data used to create many PersWeapons.
     */
    data: PersWeaponCreateManyInput | PersWeaponCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersWeaponIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersWeapon update
   */
  export type PersWeaponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersWeapon
     */
    select?: PersWeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersWeapon
     */
    omit?: PersWeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersWeaponInclude<ExtArgs> | null
    /**
     * The data needed to update a PersWeapon.
     */
    data: XOR<PersWeaponUpdateInput, PersWeaponUncheckedUpdateInput>
    /**
     * Choose, which PersWeapon to update.
     */
    where: PersWeaponWhereUniqueInput
  }

  /**
   * PersWeapon updateMany
   */
  export type PersWeaponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersWeapons.
     */
    data: XOR<PersWeaponUpdateManyMutationInput, PersWeaponUncheckedUpdateManyInput>
    /**
     * Filter which PersWeapons to update
     */
    where?: PersWeaponWhereInput
    /**
     * Limit how many PersWeapons to update.
     */
    limit?: number
  }

  /**
   * PersWeapon updateManyAndReturn
   */
  export type PersWeaponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersWeapon
     */
    select?: PersWeaponSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersWeapon
     */
    omit?: PersWeaponOmit<ExtArgs> | null
    /**
     * The data used to update PersWeapons.
     */
    data: XOR<PersWeaponUpdateManyMutationInput, PersWeaponUncheckedUpdateManyInput>
    /**
     * Filter which PersWeapons to update
     */
    where?: PersWeaponWhereInput
    /**
     * Limit how many PersWeapons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersWeaponIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersWeapon upsert
   */
  export type PersWeaponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersWeapon
     */
    select?: PersWeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersWeapon
     */
    omit?: PersWeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersWeaponInclude<ExtArgs> | null
    /**
     * The filter to search for the PersWeapon to update in case it exists.
     */
    where: PersWeaponWhereUniqueInput
    /**
     * In case the PersWeapon found by the `where` argument doesn't exist, create a new PersWeapon with this data.
     */
    create: XOR<PersWeaponCreateInput, PersWeaponUncheckedCreateInput>
    /**
     * In case the PersWeapon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersWeaponUpdateInput, PersWeaponUncheckedUpdateInput>
  }

  /**
   * PersWeapon delete
   */
  export type PersWeaponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersWeapon
     */
    select?: PersWeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersWeapon
     */
    omit?: PersWeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersWeaponInclude<ExtArgs> | null
    /**
     * Filter which PersWeapon to delete.
     */
    where: PersWeaponWhereUniqueInput
  }

  /**
   * PersWeapon deleteMany
   */
  export type PersWeaponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersWeapons to delete
     */
    where?: PersWeaponWhereInput
    /**
     * Limit how many PersWeapons to delete.
     */
    limit?: number
  }

  /**
   * PersWeapon without action
   */
  export type PersWeaponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersWeapon
     */
    select?: PersWeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersWeapon
     */
    omit?: PersWeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersWeaponInclude<ExtArgs> | null
  }


  /**
   * Model PersArmor
   */

  export type AggregatePersArmor = {
    _count: PersArmorCountAggregateOutputType | null
    _avg: PersArmorAvgAggregateOutputType | null
    _sum: PersArmorSumAggregateOutputType | null
    _min: PersArmorMinAggregateOutputType | null
    _max: PersArmorMaxAggregateOutputType | null
  }

  export type PersArmorAvgAggregateOutputType = {
    persArmorId: number | null
    armorId: number | null
    persId: number | null
    overrideBaseAC: number | null
    miscACBonus: number | null
  }

  export type PersArmorSumAggregateOutputType = {
    persArmorId: number | null
    armorId: number | null
    persId: number | null
    overrideBaseAC: number | null
    miscACBonus: number | null
  }

  export type PersArmorMinAggregateOutputType = {
    persArmorId: number | null
    armorId: number | null
    persId: number | null
    overrideBaseAC: number | null
    miscACBonus: number | null
    isProficient: boolean | null
    equipped: boolean | null
  }

  export type PersArmorMaxAggregateOutputType = {
    persArmorId: number | null
    armorId: number | null
    persId: number | null
    overrideBaseAC: number | null
    miscACBonus: number | null
    isProficient: boolean | null
    equipped: boolean | null
  }

  export type PersArmorCountAggregateOutputType = {
    persArmorId: number
    armorId: number
    persId: number
    overrideBaseAC: number
    miscACBonus: number
    isProficient: number
    equipped: number
    _all: number
  }


  export type PersArmorAvgAggregateInputType = {
    persArmorId?: true
    armorId?: true
    persId?: true
    overrideBaseAC?: true
    miscACBonus?: true
  }

  export type PersArmorSumAggregateInputType = {
    persArmorId?: true
    armorId?: true
    persId?: true
    overrideBaseAC?: true
    miscACBonus?: true
  }

  export type PersArmorMinAggregateInputType = {
    persArmorId?: true
    armorId?: true
    persId?: true
    overrideBaseAC?: true
    miscACBonus?: true
    isProficient?: true
    equipped?: true
  }

  export type PersArmorMaxAggregateInputType = {
    persArmorId?: true
    armorId?: true
    persId?: true
    overrideBaseAC?: true
    miscACBonus?: true
    isProficient?: true
    equipped?: true
  }

  export type PersArmorCountAggregateInputType = {
    persArmorId?: true
    armorId?: true
    persId?: true
    overrideBaseAC?: true
    miscACBonus?: true
    isProficient?: true
    equipped?: true
    _all?: true
  }

  export type PersArmorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersArmor to aggregate.
     */
    where?: PersArmorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersArmors to fetch.
     */
    orderBy?: PersArmorOrderByWithRelationInput | PersArmorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersArmorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersArmors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersArmors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersArmors
    **/
    _count?: true | PersArmorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersArmorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersArmorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersArmorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersArmorMaxAggregateInputType
  }

  export type GetPersArmorAggregateType<T extends PersArmorAggregateArgs> = {
        [P in keyof T & keyof AggregatePersArmor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersArmor[P]>
      : GetScalarType<T[P], AggregatePersArmor[P]>
  }




  export type PersArmorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersArmorWhereInput
    orderBy?: PersArmorOrderByWithAggregationInput | PersArmorOrderByWithAggregationInput[]
    by: PersArmorScalarFieldEnum[] | PersArmorScalarFieldEnum
    having?: PersArmorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersArmorCountAggregateInputType | true
    _avg?: PersArmorAvgAggregateInputType
    _sum?: PersArmorSumAggregateInputType
    _min?: PersArmorMinAggregateInputType
    _max?: PersArmorMaxAggregateInputType
  }

  export type PersArmorGroupByOutputType = {
    persArmorId: number
    armorId: number
    persId: number
    overrideBaseAC: number | null
    miscACBonus: number | null
    isProficient: boolean
    equipped: boolean
    _count: PersArmorCountAggregateOutputType | null
    _avg: PersArmorAvgAggregateOutputType | null
    _sum: PersArmorSumAggregateOutputType | null
    _min: PersArmorMinAggregateOutputType | null
    _max: PersArmorMaxAggregateOutputType | null
  }

  type GetPersArmorGroupByPayload<T extends PersArmorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersArmorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersArmorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersArmorGroupByOutputType[P]>
            : GetScalarType<T[P], PersArmorGroupByOutputType[P]>
        }
      >
    >


  export type PersArmorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persArmorId?: boolean
    armorId?: boolean
    persId?: boolean
    overrideBaseAC?: boolean
    miscACBonus?: boolean
    isProficient?: boolean
    equipped?: boolean
    pers?: boolean | PersDefaultArgs<ExtArgs>
    armor?: boolean | ArmorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persArmor"]>

  export type PersArmorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persArmorId?: boolean
    armorId?: boolean
    persId?: boolean
    overrideBaseAC?: boolean
    miscACBonus?: boolean
    isProficient?: boolean
    equipped?: boolean
    pers?: boolean | PersDefaultArgs<ExtArgs>
    armor?: boolean | ArmorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persArmor"]>

  export type PersArmorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persArmorId?: boolean
    armorId?: boolean
    persId?: boolean
    overrideBaseAC?: boolean
    miscACBonus?: boolean
    isProficient?: boolean
    equipped?: boolean
    pers?: boolean | PersDefaultArgs<ExtArgs>
    armor?: boolean | ArmorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persArmor"]>

  export type PersArmorSelectScalar = {
    persArmorId?: boolean
    armorId?: boolean
    persId?: boolean
    overrideBaseAC?: boolean
    miscACBonus?: boolean
    isProficient?: boolean
    equipped?: boolean
  }

  export type PersArmorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"persArmorId" | "armorId" | "persId" | "overrideBaseAC" | "miscACBonus" | "isProficient" | "equipped", ExtArgs["result"]["persArmor"]>
  export type PersArmorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pers?: boolean | PersDefaultArgs<ExtArgs>
    armor?: boolean | ArmorDefaultArgs<ExtArgs>
  }
  export type PersArmorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pers?: boolean | PersDefaultArgs<ExtArgs>
    armor?: boolean | ArmorDefaultArgs<ExtArgs>
  }
  export type PersArmorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pers?: boolean | PersDefaultArgs<ExtArgs>
    armor?: boolean | ArmorDefaultArgs<ExtArgs>
  }

  export type $PersArmorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersArmor"
    objects: {
      pers: Prisma.$PersPayload<ExtArgs>
      armor: Prisma.$ArmorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      persArmorId: number
      armorId: number
      persId: number
      overrideBaseAC: number | null
      miscACBonus: number | null
      isProficient: boolean
      equipped: boolean
    }, ExtArgs["result"]["persArmor"]>
    composites: {}
  }

  type PersArmorGetPayload<S extends boolean | null | undefined | PersArmorDefaultArgs> = $Result.GetResult<Prisma.$PersArmorPayload, S>

  type PersArmorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersArmorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersArmorCountAggregateInputType | true
    }

  export interface PersArmorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersArmor'], meta: { name: 'PersArmor' } }
    /**
     * Find zero or one PersArmor that matches the filter.
     * @param {PersArmorFindUniqueArgs} args - Arguments to find a PersArmor
     * @example
     * // Get one PersArmor
     * const persArmor = await prisma.persArmor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersArmorFindUniqueArgs>(args: SelectSubset<T, PersArmorFindUniqueArgs<ExtArgs>>): Prisma__PersArmorClient<$Result.GetResult<Prisma.$PersArmorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersArmor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersArmorFindUniqueOrThrowArgs} args - Arguments to find a PersArmor
     * @example
     * // Get one PersArmor
     * const persArmor = await prisma.persArmor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersArmorFindUniqueOrThrowArgs>(args: SelectSubset<T, PersArmorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersArmorClient<$Result.GetResult<Prisma.$PersArmorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersArmor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersArmorFindFirstArgs} args - Arguments to find a PersArmor
     * @example
     * // Get one PersArmor
     * const persArmor = await prisma.persArmor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersArmorFindFirstArgs>(args?: SelectSubset<T, PersArmorFindFirstArgs<ExtArgs>>): Prisma__PersArmorClient<$Result.GetResult<Prisma.$PersArmorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersArmor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersArmorFindFirstOrThrowArgs} args - Arguments to find a PersArmor
     * @example
     * // Get one PersArmor
     * const persArmor = await prisma.persArmor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersArmorFindFirstOrThrowArgs>(args?: SelectSubset<T, PersArmorFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersArmorClient<$Result.GetResult<Prisma.$PersArmorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersArmors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersArmorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersArmors
     * const persArmors = await prisma.persArmor.findMany()
     * 
     * // Get first 10 PersArmors
     * const persArmors = await prisma.persArmor.findMany({ take: 10 })
     * 
     * // Only select the `persArmorId`
     * const persArmorWithPersArmorIdOnly = await prisma.persArmor.findMany({ select: { persArmorId: true } })
     * 
     */
    findMany<T extends PersArmorFindManyArgs>(args?: SelectSubset<T, PersArmorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersArmorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersArmor.
     * @param {PersArmorCreateArgs} args - Arguments to create a PersArmor.
     * @example
     * // Create one PersArmor
     * const PersArmor = await prisma.persArmor.create({
     *   data: {
     *     // ... data to create a PersArmor
     *   }
     * })
     * 
     */
    create<T extends PersArmorCreateArgs>(args: SelectSubset<T, PersArmorCreateArgs<ExtArgs>>): Prisma__PersArmorClient<$Result.GetResult<Prisma.$PersArmorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersArmors.
     * @param {PersArmorCreateManyArgs} args - Arguments to create many PersArmors.
     * @example
     * // Create many PersArmors
     * const persArmor = await prisma.persArmor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersArmorCreateManyArgs>(args?: SelectSubset<T, PersArmorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersArmors and returns the data saved in the database.
     * @param {PersArmorCreateManyAndReturnArgs} args - Arguments to create many PersArmors.
     * @example
     * // Create many PersArmors
     * const persArmor = await prisma.persArmor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersArmors and only return the `persArmorId`
     * const persArmorWithPersArmorIdOnly = await prisma.persArmor.createManyAndReturn({
     *   select: { persArmorId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersArmorCreateManyAndReturnArgs>(args?: SelectSubset<T, PersArmorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersArmorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersArmor.
     * @param {PersArmorDeleteArgs} args - Arguments to delete one PersArmor.
     * @example
     * // Delete one PersArmor
     * const PersArmor = await prisma.persArmor.delete({
     *   where: {
     *     // ... filter to delete one PersArmor
     *   }
     * })
     * 
     */
    delete<T extends PersArmorDeleteArgs>(args: SelectSubset<T, PersArmorDeleteArgs<ExtArgs>>): Prisma__PersArmorClient<$Result.GetResult<Prisma.$PersArmorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersArmor.
     * @param {PersArmorUpdateArgs} args - Arguments to update one PersArmor.
     * @example
     * // Update one PersArmor
     * const persArmor = await prisma.persArmor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersArmorUpdateArgs>(args: SelectSubset<T, PersArmorUpdateArgs<ExtArgs>>): Prisma__PersArmorClient<$Result.GetResult<Prisma.$PersArmorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersArmors.
     * @param {PersArmorDeleteManyArgs} args - Arguments to filter PersArmors to delete.
     * @example
     * // Delete a few PersArmors
     * const { count } = await prisma.persArmor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersArmorDeleteManyArgs>(args?: SelectSubset<T, PersArmorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersArmors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersArmorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersArmors
     * const persArmor = await prisma.persArmor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersArmorUpdateManyArgs>(args: SelectSubset<T, PersArmorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersArmors and returns the data updated in the database.
     * @param {PersArmorUpdateManyAndReturnArgs} args - Arguments to update many PersArmors.
     * @example
     * // Update many PersArmors
     * const persArmor = await prisma.persArmor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersArmors and only return the `persArmorId`
     * const persArmorWithPersArmorIdOnly = await prisma.persArmor.updateManyAndReturn({
     *   select: { persArmorId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersArmorUpdateManyAndReturnArgs>(args: SelectSubset<T, PersArmorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersArmorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersArmor.
     * @param {PersArmorUpsertArgs} args - Arguments to update or create a PersArmor.
     * @example
     * // Update or create a PersArmor
     * const persArmor = await prisma.persArmor.upsert({
     *   create: {
     *     // ... data to create a PersArmor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersArmor we want to update
     *   }
     * })
     */
    upsert<T extends PersArmorUpsertArgs>(args: SelectSubset<T, PersArmorUpsertArgs<ExtArgs>>): Prisma__PersArmorClient<$Result.GetResult<Prisma.$PersArmorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersArmors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersArmorCountArgs} args - Arguments to filter PersArmors to count.
     * @example
     * // Count the number of PersArmors
     * const count = await prisma.persArmor.count({
     *   where: {
     *     // ... the filter for the PersArmors we want to count
     *   }
     * })
    **/
    count<T extends PersArmorCountArgs>(
      args?: Subset<T, PersArmorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersArmorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersArmor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersArmorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersArmorAggregateArgs>(args: Subset<T, PersArmorAggregateArgs>): Prisma.PrismaPromise<GetPersArmorAggregateType<T>>

    /**
     * Group by PersArmor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersArmorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersArmorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersArmorGroupByArgs['orderBy'] }
        : { orderBy?: PersArmorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersArmorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersArmorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersArmor model
   */
  readonly fields: PersArmorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersArmor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersArmorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pers<T extends PersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersDefaultArgs<ExtArgs>>): Prisma__PersClient<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    armor<T extends ArmorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArmorDefaultArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersArmor model
   */
  interface PersArmorFieldRefs {
    readonly persArmorId: FieldRef<"PersArmor", 'Int'>
    readonly armorId: FieldRef<"PersArmor", 'Int'>
    readonly persId: FieldRef<"PersArmor", 'Int'>
    readonly overrideBaseAC: FieldRef<"PersArmor", 'Int'>
    readonly miscACBonus: FieldRef<"PersArmor", 'Int'>
    readonly isProficient: FieldRef<"PersArmor", 'Boolean'>
    readonly equipped: FieldRef<"PersArmor", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PersArmor findUnique
   */
  export type PersArmorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersArmor
     */
    select?: PersArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersArmor
     */
    omit?: PersArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersArmorInclude<ExtArgs> | null
    /**
     * Filter, which PersArmor to fetch.
     */
    where: PersArmorWhereUniqueInput
  }

  /**
   * PersArmor findUniqueOrThrow
   */
  export type PersArmorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersArmor
     */
    select?: PersArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersArmor
     */
    omit?: PersArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersArmorInclude<ExtArgs> | null
    /**
     * Filter, which PersArmor to fetch.
     */
    where: PersArmorWhereUniqueInput
  }

  /**
   * PersArmor findFirst
   */
  export type PersArmorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersArmor
     */
    select?: PersArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersArmor
     */
    omit?: PersArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersArmorInclude<ExtArgs> | null
    /**
     * Filter, which PersArmor to fetch.
     */
    where?: PersArmorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersArmors to fetch.
     */
    orderBy?: PersArmorOrderByWithRelationInput | PersArmorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersArmors.
     */
    cursor?: PersArmorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersArmors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersArmors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersArmors.
     */
    distinct?: PersArmorScalarFieldEnum | PersArmorScalarFieldEnum[]
  }

  /**
   * PersArmor findFirstOrThrow
   */
  export type PersArmorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersArmor
     */
    select?: PersArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersArmor
     */
    omit?: PersArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersArmorInclude<ExtArgs> | null
    /**
     * Filter, which PersArmor to fetch.
     */
    where?: PersArmorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersArmors to fetch.
     */
    orderBy?: PersArmorOrderByWithRelationInput | PersArmorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersArmors.
     */
    cursor?: PersArmorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersArmors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersArmors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersArmors.
     */
    distinct?: PersArmorScalarFieldEnum | PersArmorScalarFieldEnum[]
  }

  /**
   * PersArmor findMany
   */
  export type PersArmorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersArmor
     */
    select?: PersArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersArmor
     */
    omit?: PersArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersArmorInclude<ExtArgs> | null
    /**
     * Filter, which PersArmors to fetch.
     */
    where?: PersArmorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersArmors to fetch.
     */
    orderBy?: PersArmorOrderByWithRelationInput | PersArmorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersArmors.
     */
    cursor?: PersArmorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersArmors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersArmors.
     */
    skip?: number
    distinct?: PersArmorScalarFieldEnum | PersArmorScalarFieldEnum[]
  }

  /**
   * PersArmor create
   */
  export type PersArmorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersArmor
     */
    select?: PersArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersArmor
     */
    omit?: PersArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersArmorInclude<ExtArgs> | null
    /**
     * The data needed to create a PersArmor.
     */
    data: XOR<PersArmorCreateInput, PersArmorUncheckedCreateInput>
  }

  /**
   * PersArmor createMany
   */
  export type PersArmorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersArmors.
     */
    data: PersArmorCreateManyInput | PersArmorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersArmor createManyAndReturn
   */
  export type PersArmorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersArmor
     */
    select?: PersArmorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersArmor
     */
    omit?: PersArmorOmit<ExtArgs> | null
    /**
     * The data used to create many PersArmors.
     */
    data: PersArmorCreateManyInput | PersArmorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersArmorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersArmor update
   */
  export type PersArmorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersArmor
     */
    select?: PersArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersArmor
     */
    omit?: PersArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersArmorInclude<ExtArgs> | null
    /**
     * The data needed to update a PersArmor.
     */
    data: XOR<PersArmorUpdateInput, PersArmorUncheckedUpdateInput>
    /**
     * Choose, which PersArmor to update.
     */
    where: PersArmorWhereUniqueInput
  }

  /**
   * PersArmor updateMany
   */
  export type PersArmorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersArmors.
     */
    data: XOR<PersArmorUpdateManyMutationInput, PersArmorUncheckedUpdateManyInput>
    /**
     * Filter which PersArmors to update
     */
    where?: PersArmorWhereInput
    /**
     * Limit how many PersArmors to update.
     */
    limit?: number
  }

  /**
   * PersArmor updateManyAndReturn
   */
  export type PersArmorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersArmor
     */
    select?: PersArmorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersArmor
     */
    omit?: PersArmorOmit<ExtArgs> | null
    /**
     * The data used to update PersArmors.
     */
    data: XOR<PersArmorUpdateManyMutationInput, PersArmorUncheckedUpdateManyInput>
    /**
     * Filter which PersArmors to update
     */
    where?: PersArmorWhereInput
    /**
     * Limit how many PersArmors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersArmorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersArmor upsert
   */
  export type PersArmorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersArmor
     */
    select?: PersArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersArmor
     */
    omit?: PersArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersArmorInclude<ExtArgs> | null
    /**
     * The filter to search for the PersArmor to update in case it exists.
     */
    where: PersArmorWhereUniqueInput
    /**
     * In case the PersArmor found by the `where` argument doesn't exist, create a new PersArmor with this data.
     */
    create: XOR<PersArmorCreateInput, PersArmorUncheckedCreateInput>
    /**
     * In case the PersArmor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersArmorUpdateInput, PersArmorUncheckedUpdateInput>
  }

  /**
   * PersArmor delete
   */
  export type PersArmorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersArmor
     */
    select?: PersArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersArmor
     */
    omit?: PersArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersArmorInclude<ExtArgs> | null
    /**
     * Filter which PersArmor to delete.
     */
    where: PersArmorWhereUniqueInput
  }

  /**
   * PersArmor deleteMany
   */
  export type PersArmorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersArmors to delete
     */
    where?: PersArmorWhereInput
    /**
     * Limit how many PersArmors to delete.
     */
    limit?: number
  }

  /**
   * PersArmor without action
   */
  export type PersArmorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersArmor
     */
    select?: PersArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersArmor
     */
    omit?: PersArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersArmorInclude<ExtArgs> | null
  }


  /**
   * Model PersMagicItem
   */

  export type AggregatePersMagicItem = {
    _count: PersMagicItemCountAggregateOutputType | null
    _avg: PersMagicItemAvgAggregateOutputType | null
    _sum: PersMagicItemSumAggregateOutputType | null
    _min: PersMagicItemMinAggregateOutputType | null
    _max: PersMagicItemMaxAggregateOutputType | null
  }

  export type PersMagicItemAvgAggregateOutputType = {
    persMagicItemId: number | null
    persId: number | null
    magicItemId: number | null
  }

  export type PersMagicItemSumAggregateOutputType = {
    persMagicItemId: number | null
    persId: number | null
    magicItemId: number | null
  }

  export type PersMagicItemMinAggregateOutputType = {
    persMagicItemId: number | null
    persId: number | null
    magicItemId: number | null
  }

  export type PersMagicItemMaxAggregateOutputType = {
    persMagicItemId: number | null
    persId: number | null
    magicItemId: number | null
  }

  export type PersMagicItemCountAggregateOutputType = {
    persMagicItemId: number
    persId: number
    magicItemId: number
    _all: number
  }


  export type PersMagicItemAvgAggregateInputType = {
    persMagicItemId?: true
    persId?: true
    magicItemId?: true
  }

  export type PersMagicItemSumAggregateInputType = {
    persMagicItemId?: true
    persId?: true
    magicItemId?: true
  }

  export type PersMagicItemMinAggregateInputType = {
    persMagicItemId?: true
    persId?: true
    magicItemId?: true
  }

  export type PersMagicItemMaxAggregateInputType = {
    persMagicItemId?: true
    persId?: true
    magicItemId?: true
  }

  export type PersMagicItemCountAggregateInputType = {
    persMagicItemId?: true
    persId?: true
    magicItemId?: true
    _all?: true
  }

  export type PersMagicItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersMagicItem to aggregate.
     */
    where?: PersMagicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersMagicItems to fetch.
     */
    orderBy?: PersMagicItemOrderByWithRelationInput | PersMagicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersMagicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersMagicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersMagicItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersMagicItems
    **/
    _count?: true | PersMagicItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersMagicItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersMagicItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersMagicItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersMagicItemMaxAggregateInputType
  }

  export type GetPersMagicItemAggregateType<T extends PersMagicItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePersMagicItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersMagicItem[P]>
      : GetScalarType<T[P], AggregatePersMagicItem[P]>
  }




  export type PersMagicItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersMagicItemWhereInput
    orderBy?: PersMagicItemOrderByWithAggregationInput | PersMagicItemOrderByWithAggregationInput[]
    by: PersMagicItemScalarFieldEnum[] | PersMagicItemScalarFieldEnum
    having?: PersMagicItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersMagicItemCountAggregateInputType | true
    _avg?: PersMagicItemAvgAggregateInputType
    _sum?: PersMagicItemSumAggregateInputType
    _min?: PersMagicItemMinAggregateInputType
    _max?: PersMagicItemMaxAggregateInputType
  }

  export type PersMagicItemGroupByOutputType = {
    persMagicItemId: number
    persId: number
    magicItemId: number
    _count: PersMagicItemCountAggregateOutputType | null
    _avg: PersMagicItemAvgAggregateOutputType | null
    _sum: PersMagicItemSumAggregateOutputType | null
    _min: PersMagicItemMinAggregateOutputType | null
    _max: PersMagicItemMaxAggregateOutputType | null
  }

  type GetPersMagicItemGroupByPayload<T extends PersMagicItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersMagicItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersMagicItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersMagicItemGroupByOutputType[P]>
            : GetScalarType<T[P], PersMagicItemGroupByOutputType[P]>
        }
      >
    >


  export type PersMagicItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persMagicItemId?: boolean
    persId?: boolean
    magicItemId?: boolean
    pers?: boolean | PersDefaultArgs<ExtArgs>
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persMagicItem"]>

  export type PersMagicItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persMagicItemId?: boolean
    persId?: boolean
    magicItemId?: boolean
    pers?: boolean | PersDefaultArgs<ExtArgs>
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persMagicItem"]>

  export type PersMagicItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    persMagicItemId?: boolean
    persId?: boolean
    magicItemId?: boolean
    pers?: boolean | PersDefaultArgs<ExtArgs>
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persMagicItem"]>

  export type PersMagicItemSelectScalar = {
    persMagicItemId?: boolean
    persId?: boolean
    magicItemId?: boolean
  }

  export type PersMagicItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"persMagicItemId" | "persId" | "magicItemId", ExtArgs["result"]["persMagicItem"]>
  export type PersMagicItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pers?: boolean | PersDefaultArgs<ExtArgs>
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
  }
  export type PersMagicItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pers?: boolean | PersDefaultArgs<ExtArgs>
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
  }
  export type PersMagicItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pers?: boolean | PersDefaultArgs<ExtArgs>
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
  }

  export type $PersMagicItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersMagicItem"
    objects: {
      pers: Prisma.$PersPayload<ExtArgs>
      magicItem: Prisma.$MagicItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      persMagicItemId: number
      persId: number
      magicItemId: number
    }, ExtArgs["result"]["persMagicItem"]>
    composites: {}
  }

  type PersMagicItemGetPayload<S extends boolean | null | undefined | PersMagicItemDefaultArgs> = $Result.GetResult<Prisma.$PersMagicItemPayload, S>

  type PersMagicItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersMagicItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersMagicItemCountAggregateInputType | true
    }

  export interface PersMagicItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersMagicItem'], meta: { name: 'PersMagicItem' } }
    /**
     * Find zero or one PersMagicItem that matches the filter.
     * @param {PersMagicItemFindUniqueArgs} args - Arguments to find a PersMagicItem
     * @example
     * // Get one PersMagicItem
     * const persMagicItem = await prisma.persMagicItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersMagicItemFindUniqueArgs>(args: SelectSubset<T, PersMagicItemFindUniqueArgs<ExtArgs>>): Prisma__PersMagicItemClient<$Result.GetResult<Prisma.$PersMagicItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersMagicItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersMagicItemFindUniqueOrThrowArgs} args - Arguments to find a PersMagicItem
     * @example
     * // Get one PersMagicItem
     * const persMagicItem = await prisma.persMagicItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersMagicItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PersMagicItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersMagicItemClient<$Result.GetResult<Prisma.$PersMagicItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersMagicItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersMagicItemFindFirstArgs} args - Arguments to find a PersMagicItem
     * @example
     * // Get one PersMagicItem
     * const persMagicItem = await prisma.persMagicItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersMagicItemFindFirstArgs>(args?: SelectSubset<T, PersMagicItemFindFirstArgs<ExtArgs>>): Prisma__PersMagicItemClient<$Result.GetResult<Prisma.$PersMagicItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersMagicItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersMagicItemFindFirstOrThrowArgs} args - Arguments to find a PersMagicItem
     * @example
     * // Get one PersMagicItem
     * const persMagicItem = await prisma.persMagicItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersMagicItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PersMagicItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersMagicItemClient<$Result.GetResult<Prisma.$PersMagicItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersMagicItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersMagicItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersMagicItems
     * const persMagicItems = await prisma.persMagicItem.findMany()
     * 
     * // Get first 10 PersMagicItems
     * const persMagicItems = await prisma.persMagicItem.findMany({ take: 10 })
     * 
     * // Only select the `persMagicItemId`
     * const persMagicItemWithPersMagicItemIdOnly = await prisma.persMagicItem.findMany({ select: { persMagicItemId: true } })
     * 
     */
    findMany<T extends PersMagicItemFindManyArgs>(args?: SelectSubset<T, PersMagicItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersMagicItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersMagicItem.
     * @param {PersMagicItemCreateArgs} args - Arguments to create a PersMagicItem.
     * @example
     * // Create one PersMagicItem
     * const PersMagicItem = await prisma.persMagicItem.create({
     *   data: {
     *     // ... data to create a PersMagicItem
     *   }
     * })
     * 
     */
    create<T extends PersMagicItemCreateArgs>(args: SelectSubset<T, PersMagicItemCreateArgs<ExtArgs>>): Prisma__PersMagicItemClient<$Result.GetResult<Prisma.$PersMagicItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersMagicItems.
     * @param {PersMagicItemCreateManyArgs} args - Arguments to create many PersMagicItems.
     * @example
     * // Create many PersMagicItems
     * const persMagicItem = await prisma.persMagicItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersMagicItemCreateManyArgs>(args?: SelectSubset<T, PersMagicItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersMagicItems and returns the data saved in the database.
     * @param {PersMagicItemCreateManyAndReturnArgs} args - Arguments to create many PersMagicItems.
     * @example
     * // Create many PersMagicItems
     * const persMagicItem = await prisma.persMagicItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersMagicItems and only return the `persMagicItemId`
     * const persMagicItemWithPersMagicItemIdOnly = await prisma.persMagicItem.createManyAndReturn({
     *   select: { persMagicItemId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersMagicItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PersMagicItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersMagicItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersMagicItem.
     * @param {PersMagicItemDeleteArgs} args - Arguments to delete one PersMagicItem.
     * @example
     * // Delete one PersMagicItem
     * const PersMagicItem = await prisma.persMagicItem.delete({
     *   where: {
     *     // ... filter to delete one PersMagicItem
     *   }
     * })
     * 
     */
    delete<T extends PersMagicItemDeleteArgs>(args: SelectSubset<T, PersMagicItemDeleteArgs<ExtArgs>>): Prisma__PersMagicItemClient<$Result.GetResult<Prisma.$PersMagicItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersMagicItem.
     * @param {PersMagicItemUpdateArgs} args - Arguments to update one PersMagicItem.
     * @example
     * // Update one PersMagicItem
     * const persMagicItem = await prisma.persMagicItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersMagicItemUpdateArgs>(args: SelectSubset<T, PersMagicItemUpdateArgs<ExtArgs>>): Prisma__PersMagicItemClient<$Result.GetResult<Prisma.$PersMagicItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersMagicItems.
     * @param {PersMagicItemDeleteManyArgs} args - Arguments to filter PersMagicItems to delete.
     * @example
     * // Delete a few PersMagicItems
     * const { count } = await prisma.persMagicItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersMagicItemDeleteManyArgs>(args?: SelectSubset<T, PersMagicItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersMagicItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersMagicItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersMagicItems
     * const persMagicItem = await prisma.persMagicItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersMagicItemUpdateManyArgs>(args: SelectSubset<T, PersMagicItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersMagicItems and returns the data updated in the database.
     * @param {PersMagicItemUpdateManyAndReturnArgs} args - Arguments to update many PersMagicItems.
     * @example
     * // Update many PersMagicItems
     * const persMagicItem = await prisma.persMagicItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersMagicItems and only return the `persMagicItemId`
     * const persMagicItemWithPersMagicItemIdOnly = await prisma.persMagicItem.updateManyAndReturn({
     *   select: { persMagicItemId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersMagicItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PersMagicItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersMagicItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersMagicItem.
     * @param {PersMagicItemUpsertArgs} args - Arguments to update or create a PersMagicItem.
     * @example
     * // Update or create a PersMagicItem
     * const persMagicItem = await prisma.persMagicItem.upsert({
     *   create: {
     *     // ... data to create a PersMagicItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersMagicItem we want to update
     *   }
     * })
     */
    upsert<T extends PersMagicItemUpsertArgs>(args: SelectSubset<T, PersMagicItemUpsertArgs<ExtArgs>>): Prisma__PersMagicItemClient<$Result.GetResult<Prisma.$PersMagicItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersMagicItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersMagicItemCountArgs} args - Arguments to filter PersMagicItems to count.
     * @example
     * // Count the number of PersMagicItems
     * const count = await prisma.persMagicItem.count({
     *   where: {
     *     // ... the filter for the PersMagicItems we want to count
     *   }
     * })
    **/
    count<T extends PersMagicItemCountArgs>(
      args?: Subset<T, PersMagicItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersMagicItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersMagicItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersMagicItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersMagicItemAggregateArgs>(args: Subset<T, PersMagicItemAggregateArgs>): Prisma.PrismaPromise<GetPersMagicItemAggregateType<T>>

    /**
     * Group by PersMagicItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersMagicItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersMagicItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersMagicItemGroupByArgs['orderBy'] }
        : { orderBy?: PersMagicItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersMagicItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersMagicItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersMagicItem model
   */
  readonly fields: PersMagicItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersMagicItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersMagicItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pers<T extends PersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersDefaultArgs<ExtArgs>>): Prisma__PersClient<$Result.GetResult<Prisma.$PersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    magicItem<T extends MagicItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MagicItemDefaultArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersMagicItem model
   */
  interface PersMagicItemFieldRefs {
    readonly persMagicItemId: FieldRef<"PersMagicItem", 'Int'>
    readonly persId: FieldRef<"PersMagicItem", 'Int'>
    readonly magicItemId: FieldRef<"PersMagicItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PersMagicItem findUnique
   */
  export type PersMagicItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMagicItem
     */
    select?: PersMagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMagicItem
     */
    omit?: PersMagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMagicItemInclude<ExtArgs> | null
    /**
     * Filter, which PersMagicItem to fetch.
     */
    where: PersMagicItemWhereUniqueInput
  }

  /**
   * PersMagicItem findUniqueOrThrow
   */
  export type PersMagicItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMagicItem
     */
    select?: PersMagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMagicItem
     */
    omit?: PersMagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMagicItemInclude<ExtArgs> | null
    /**
     * Filter, which PersMagicItem to fetch.
     */
    where: PersMagicItemWhereUniqueInput
  }

  /**
   * PersMagicItem findFirst
   */
  export type PersMagicItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMagicItem
     */
    select?: PersMagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMagicItem
     */
    omit?: PersMagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMagicItemInclude<ExtArgs> | null
    /**
     * Filter, which PersMagicItem to fetch.
     */
    where?: PersMagicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersMagicItems to fetch.
     */
    orderBy?: PersMagicItemOrderByWithRelationInput | PersMagicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersMagicItems.
     */
    cursor?: PersMagicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersMagicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersMagicItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersMagicItems.
     */
    distinct?: PersMagicItemScalarFieldEnum | PersMagicItemScalarFieldEnum[]
  }

  /**
   * PersMagicItem findFirstOrThrow
   */
  export type PersMagicItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMagicItem
     */
    select?: PersMagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMagicItem
     */
    omit?: PersMagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMagicItemInclude<ExtArgs> | null
    /**
     * Filter, which PersMagicItem to fetch.
     */
    where?: PersMagicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersMagicItems to fetch.
     */
    orderBy?: PersMagicItemOrderByWithRelationInput | PersMagicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersMagicItems.
     */
    cursor?: PersMagicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersMagicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersMagicItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersMagicItems.
     */
    distinct?: PersMagicItemScalarFieldEnum | PersMagicItemScalarFieldEnum[]
  }

  /**
   * PersMagicItem findMany
   */
  export type PersMagicItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMagicItem
     */
    select?: PersMagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMagicItem
     */
    omit?: PersMagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMagicItemInclude<ExtArgs> | null
    /**
     * Filter, which PersMagicItems to fetch.
     */
    where?: PersMagicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersMagicItems to fetch.
     */
    orderBy?: PersMagicItemOrderByWithRelationInput | PersMagicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersMagicItems.
     */
    cursor?: PersMagicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersMagicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersMagicItems.
     */
    skip?: number
    distinct?: PersMagicItemScalarFieldEnum | PersMagicItemScalarFieldEnum[]
  }

  /**
   * PersMagicItem create
   */
  export type PersMagicItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMagicItem
     */
    select?: PersMagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMagicItem
     */
    omit?: PersMagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMagicItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PersMagicItem.
     */
    data: XOR<PersMagicItemCreateInput, PersMagicItemUncheckedCreateInput>
  }

  /**
   * PersMagicItem createMany
   */
  export type PersMagicItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersMagicItems.
     */
    data: PersMagicItemCreateManyInput | PersMagicItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersMagicItem createManyAndReturn
   */
  export type PersMagicItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMagicItem
     */
    select?: PersMagicItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersMagicItem
     */
    omit?: PersMagicItemOmit<ExtArgs> | null
    /**
     * The data used to create many PersMagicItems.
     */
    data: PersMagicItemCreateManyInput | PersMagicItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMagicItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersMagicItem update
   */
  export type PersMagicItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMagicItem
     */
    select?: PersMagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMagicItem
     */
    omit?: PersMagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMagicItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PersMagicItem.
     */
    data: XOR<PersMagicItemUpdateInput, PersMagicItemUncheckedUpdateInput>
    /**
     * Choose, which PersMagicItem to update.
     */
    where: PersMagicItemWhereUniqueInput
  }

  /**
   * PersMagicItem updateMany
   */
  export type PersMagicItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersMagicItems.
     */
    data: XOR<PersMagicItemUpdateManyMutationInput, PersMagicItemUncheckedUpdateManyInput>
    /**
     * Filter which PersMagicItems to update
     */
    where?: PersMagicItemWhereInput
    /**
     * Limit how many PersMagicItems to update.
     */
    limit?: number
  }

  /**
   * PersMagicItem updateManyAndReturn
   */
  export type PersMagicItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMagicItem
     */
    select?: PersMagicItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersMagicItem
     */
    omit?: PersMagicItemOmit<ExtArgs> | null
    /**
     * The data used to update PersMagicItems.
     */
    data: XOR<PersMagicItemUpdateManyMutationInput, PersMagicItemUncheckedUpdateManyInput>
    /**
     * Filter which PersMagicItems to update
     */
    where?: PersMagicItemWhereInput
    /**
     * Limit how many PersMagicItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMagicItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersMagicItem upsert
   */
  export type PersMagicItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMagicItem
     */
    select?: PersMagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMagicItem
     */
    omit?: PersMagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMagicItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PersMagicItem to update in case it exists.
     */
    where: PersMagicItemWhereUniqueInput
    /**
     * In case the PersMagicItem found by the `where` argument doesn't exist, create a new PersMagicItem with this data.
     */
    create: XOR<PersMagicItemCreateInput, PersMagicItemUncheckedCreateInput>
    /**
     * In case the PersMagicItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersMagicItemUpdateInput, PersMagicItemUncheckedUpdateInput>
  }

  /**
   * PersMagicItem delete
   */
  export type PersMagicItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMagicItem
     */
    select?: PersMagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMagicItem
     */
    omit?: PersMagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMagicItemInclude<ExtArgs> | null
    /**
     * Filter which PersMagicItem to delete.
     */
    where: PersMagicItemWhereUniqueInput
  }

  /**
   * PersMagicItem deleteMany
   */
  export type PersMagicItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersMagicItems to delete
     */
    where?: PersMagicItemWhereInput
    /**
     * Limit how many PersMagicItems to delete.
     */
    limit?: number
  }

  /**
   * PersMagicItem without action
   */
  export type PersMagicItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersMagicItem
     */
    select?: PersMagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersMagicItem
     */
    omit?: PersMagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersMagicItemInclude<ExtArgs> | null
  }


  /**
   * Model EquipmentPack
   */

  export type AggregateEquipmentPack = {
    _count: EquipmentPackCountAggregateOutputType | null
    _avg: EquipmentPackAvgAggregateOutputType | null
    _sum: EquipmentPackSumAggregateOutputType | null
    _min: EquipmentPackMinAggregateOutputType | null
    _max: EquipmentPackMaxAggregateOutputType | null
  }

  export type EquipmentPackAvgAggregateOutputType = {
    equipmentPackId: number | null
  }

  export type EquipmentPackSumAggregateOutputType = {
    equipmentPackId: number | null
  }

  export type EquipmentPackMinAggregateOutputType = {
    equipmentPackId: number | null
    name: $Enums.EquipmentPackCategory | null
    description: string | null
  }

  export type EquipmentPackMaxAggregateOutputType = {
    equipmentPackId: number | null
    name: $Enums.EquipmentPackCategory | null
    description: string | null
  }

  export type EquipmentPackCountAggregateOutputType = {
    equipmentPackId: number
    name: number
    description: number
    items: number
    _all: number
  }


  export type EquipmentPackAvgAggregateInputType = {
    equipmentPackId?: true
  }

  export type EquipmentPackSumAggregateInputType = {
    equipmentPackId?: true
  }

  export type EquipmentPackMinAggregateInputType = {
    equipmentPackId?: true
    name?: true
    description?: true
  }

  export type EquipmentPackMaxAggregateInputType = {
    equipmentPackId?: true
    name?: true
    description?: true
  }

  export type EquipmentPackCountAggregateInputType = {
    equipmentPackId?: true
    name?: true
    description?: true
    items?: true
    _all?: true
  }

  export type EquipmentPackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentPack to aggregate.
     */
    where?: EquipmentPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentPacks to fetch.
     */
    orderBy?: EquipmentPackOrderByWithRelationInput | EquipmentPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentPacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentPacks
    **/
    _count?: true | EquipmentPackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentPackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentPackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentPackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentPackMaxAggregateInputType
  }

  export type GetEquipmentPackAggregateType<T extends EquipmentPackAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentPack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentPack[P]>
      : GetScalarType<T[P], AggregateEquipmentPack[P]>
  }




  export type EquipmentPackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentPackWhereInput
    orderBy?: EquipmentPackOrderByWithAggregationInput | EquipmentPackOrderByWithAggregationInput[]
    by: EquipmentPackScalarFieldEnum[] | EquipmentPackScalarFieldEnum
    having?: EquipmentPackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentPackCountAggregateInputType | true
    _avg?: EquipmentPackAvgAggregateInputType
    _sum?: EquipmentPackSumAggregateInputType
    _min?: EquipmentPackMinAggregateInputType
    _max?: EquipmentPackMaxAggregateInputType
  }

  export type EquipmentPackGroupByOutputType = {
    equipmentPackId: number
    name: $Enums.EquipmentPackCategory
    description: string
    items: JsonValue
    _count: EquipmentPackCountAggregateOutputType | null
    _avg: EquipmentPackAvgAggregateOutputType | null
    _sum: EquipmentPackSumAggregateOutputType | null
    _min: EquipmentPackMinAggregateOutputType | null
    _max: EquipmentPackMaxAggregateOutputType | null
  }

  type GetEquipmentPackGroupByPayload<T extends EquipmentPackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentPackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentPackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentPackGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentPackGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentPackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipmentPackId?: boolean
    name?: boolean
    description?: boolean
    items?: boolean
    classStartingEquipmentOptions?: boolean | EquipmentPack$classStartingEquipmentOptionsArgs<ExtArgs>
    _count?: boolean | EquipmentPackCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentPack"]>

  export type EquipmentPackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipmentPackId?: boolean
    name?: boolean
    description?: boolean
    items?: boolean
  }, ExtArgs["result"]["equipmentPack"]>

  export type EquipmentPackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipmentPackId?: boolean
    name?: boolean
    description?: boolean
    items?: boolean
  }, ExtArgs["result"]["equipmentPack"]>

  export type EquipmentPackSelectScalar = {
    equipmentPackId?: boolean
    name?: boolean
    description?: boolean
    items?: boolean
  }

  export type EquipmentPackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"equipmentPackId" | "name" | "description" | "items", ExtArgs["result"]["equipmentPack"]>
  export type EquipmentPackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classStartingEquipmentOptions?: boolean | EquipmentPack$classStartingEquipmentOptionsArgs<ExtArgs>
    _count?: boolean | EquipmentPackCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipmentPackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EquipmentPackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EquipmentPackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentPack"
    objects: {
      classStartingEquipmentOptions: Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      equipmentPackId: number
      name: $Enums.EquipmentPackCategory
      description: string
      items: Prisma.JsonValue
    }, ExtArgs["result"]["equipmentPack"]>
    composites: {}
  }

  type EquipmentPackGetPayload<S extends boolean | null | undefined | EquipmentPackDefaultArgs> = $Result.GetResult<Prisma.$EquipmentPackPayload, S>

  type EquipmentPackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentPackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentPackCountAggregateInputType | true
    }

  export interface EquipmentPackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentPack'], meta: { name: 'EquipmentPack' } }
    /**
     * Find zero or one EquipmentPack that matches the filter.
     * @param {EquipmentPackFindUniqueArgs} args - Arguments to find a EquipmentPack
     * @example
     * // Get one EquipmentPack
     * const equipmentPack = await prisma.equipmentPack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentPackFindUniqueArgs>(args: SelectSubset<T, EquipmentPackFindUniqueArgs<ExtArgs>>): Prisma__EquipmentPackClient<$Result.GetResult<Prisma.$EquipmentPackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipmentPack that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentPackFindUniqueOrThrowArgs} args - Arguments to find a EquipmentPack
     * @example
     * // Get one EquipmentPack
     * const equipmentPack = await prisma.equipmentPack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentPackFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentPackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentPackClient<$Result.GetResult<Prisma.$EquipmentPackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentPack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentPackFindFirstArgs} args - Arguments to find a EquipmentPack
     * @example
     * // Get one EquipmentPack
     * const equipmentPack = await prisma.equipmentPack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentPackFindFirstArgs>(args?: SelectSubset<T, EquipmentPackFindFirstArgs<ExtArgs>>): Prisma__EquipmentPackClient<$Result.GetResult<Prisma.$EquipmentPackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentPack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentPackFindFirstOrThrowArgs} args - Arguments to find a EquipmentPack
     * @example
     * // Get one EquipmentPack
     * const equipmentPack = await prisma.equipmentPack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentPackFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentPackFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentPackClient<$Result.GetResult<Prisma.$EquipmentPackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipmentPacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentPackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentPacks
     * const equipmentPacks = await prisma.equipmentPack.findMany()
     * 
     * // Get first 10 EquipmentPacks
     * const equipmentPacks = await prisma.equipmentPack.findMany({ take: 10 })
     * 
     * // Only select the `equipmentPackId`
     * const equipmentPackWithEquipmentPackIdOnly = await prisma.equipmentPack.findMany({ select: { equipmentPackId: true } })
     * 
     */
    findMany<T extends EquipmentPackFindManyArgs>(args?: SelectSubset<T, EquipmentPackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipmentPack.
     * @param {EquipmentPackCreateArgs} args - Arguments to create a EquipmentPack.
     * @example
     * // Create one EquipmentPack
     * const EquipmentPack = await prisma.equipmentPack.create({
     *   data: {
     *     // ... data to create a EquipmentPack
     *   }
     * })
     * 
     */
    create<T extends EquipmentPackCreateArgs>(args: SelectSubset<T, EquipmentPackCreateArgs<ExtArgs>>): Prisma__EquipmentPackClient<$Result.GetResult<Prisma.$EquipmentPackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipmentPacks.
     * @param {EquipmentPackCreateManyArgs} args - Arguments to create many EquipmentPacks.
     * @example
     * // Create many EquipmentPacks
     * const equipmentPack = await prisma.equipmentPack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentPackCreateManyArgs>(args?: SelectSubset<T, EquipmentPackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipmentPacks and returns the data saved in the database.
     * @param {EquipmentPackCreateManyAndReturnArgs} args - Arguments to create many EquipmentPacks.
     * @example
     * // Create many EquipmentPacks
     * const equipmentPack = await prisma.equipmentPack.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipmentPacks and only return the `equipmentPackId`
     * const equipmentPackWithEquipmentPackIdOnly = await prisma.equipmentPack.createManyAndReturn({
     *   select: { equipmentPackId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentPackCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentPackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EquipmentPack.
     * @param {EquipmentPackDeleteArgs} args - Arguments to delete one EquipmentPack.
     * @example
     * // Delete one EquipmentPack
     * const EquipmentPack = await prisma.equipmentPack.delete({
     *   where: {
     *     // ... filter to delete one EquipmentPack
     *   }
     * })
     * 
     */
    delete<T extends EquipmentPackDeleteArgs>(args: SelectSubset<T, EquipmentPackDeleteArgs<ExtArgs>>): Prisma__EquipmentPackClient<$Result.GetResult<Prisma.$EquipmentPackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipmentPack.
     * @param {EquipmentPackUpdateArgs} args - Arguments to update one EquipmentPack.
     * @example
     * // Update one EquipmentPack
     * const equipmentPack = await prisma.equipmentPack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentPackUpdateArgs>(args: SelectSubset<T, EquipmentPackUpdateArgs<ExtArgs>>): Prisma__EquipmentPackClient<$Result.GetResult<Prisma.$EquipmentPackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipmentPacks.
     * @param {EquipmentPackDeleteManyArgs} args - Arguments to filter EquipmentPacks to delete.
     * @example
     * // Delete a few EquipmentPacks
     * const { count } = await prisma.equipmentPack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentPackDeleteManyArgs>(args?: SelectSubset<T, EquipmentPackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentPacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentPackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentPacks
     * const equipmentPack = await prisma.equipmentPack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentPackUpdateManyArgs>(args: SelectSubset<T, EquipmentPackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentPacks and returns the data updated in the database.
     * @param {EquipmentPackUpdateManyAndReturnArgs} args - Arguments to update many EquipmentPacks.
     * @example
     * // Update many EquipmentPacks
     * const equipmentPack = await prisma.equipmentPack.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EquipmentPacks and only return the `equipmentPackId`
     * const equipmentPackWithEquipmentPackIdOnly = await prisma.equipmentPack.updateManyAndReturn({
     *   select: { equipmentPackId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentPackUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentPackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EquipmentPack.
     * @param {EquipmentPackUpsertArgs} args - Arguments to update or create a EquipmentPack.
     * @example
     * // Update or create a EquipmentPack
     * const equipmentPack = await prisma.equipmentPack.upsert({
     *   create: {
     *     // ... data to create a EquipmentPack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentPack we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentPackUpsertArgs>(args: SelectSubset<T, EquipmentPackUpsertArgs<ExtArgs>>): Prisma__EquipmentPackClient<$Result.GetResult<Prisma.$EquipmentPackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EquipmentPacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentPackCountArgs} args - Arguments to filter EquipmentPacks to count.
     * @example
     * // Count the number of EquipmentPacks
     * const count = await prisma.equipmentPack.count({
     *   where: {
     *     // ... the filter for the EquipmentPacks we want to count
     *   }
     * })
    **/
    count<T extends EquipmentPackCountArgs>(
      args?: Subset<T, EquipmentPackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentPackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentPack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentPackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentPackAggregateArgs>(args: Subset<T, EquipmentPackAggregateArgs>): Prisma.PrismaPromise<GetEquipmentPackAggregateType<T>>

    /**
     * Group by EquipmentPack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentPackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentPackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentPackGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentPackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentPackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentPackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentPack model
   */
  readonly fields: EquipmentPackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentPack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentPackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classStartingEquipmentOptions<T extends EquipmentPack$classStartingEquipmentOptionsArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentPack$classStartingEquipmentOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipmentPack model
   */
  interface EquipmentPackFieldRefs {
    readonly equipmentPackId: FieldRef<"EquipmentPack", 'Int'>
    readonly name: FieldRef<"EquipmentPack", 'EquipmentPackCategory'>
    readonly description: FieldRef<"EquipmentPack", 'String'>
    readonly items: FieldRef<"EquipmentPack", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * EquipmentPack findUnique
   */
  export type EquipmentPackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentPack
     */
    select?: EquipmentPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentPack
     */
    omit?: EquipmentPackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentPackInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentPack to fetch.
     */
    where: EquipmentPackWhereUniqueInput
  }

  /**
   * EquipmentPack findUniqueOrThrow
   */
  export type EquipmentPackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentPack
     */
    select?: EquipmentPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentPack
     */
    omit?: EquipmentPackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentPackInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentPack to fetch.
     */
    where: EquipmentPackWhereUniqueInput
  }

  /**
   * EquipmentPack findFirst
   */
  export type EquipmentPackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentPack
     */
    select?: EquipmentPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentPack
     */
    omit?: EquipmentPackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentPackInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentPack to fetch.
     */
    where?: EquipmentPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentPacks to fetch.
     */
    orderBy?: EquipmentPackOrderByWithRelationInput | EquipmentPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentPacks.
     */
    cursor?: EquipmentPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentPacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentPacks.
     */
    distinct?: EquipmentPackScalarFieldEnum | EquipmentPackScalarFieldEnum[]
  }

  /**
   * EquipmentPack findFirstOrThrow
   */
  export type EquipmentPackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentPack
     */
    select?: EquipmentPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentPack
     */
    omit?: EquipmentPackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentPackInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentPack to fetch.
     */
    where?: EquipmentPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentPacks to fetch.
     */
    orderBy?: EquipmentPackOrderByWithRelationInput | EquipmentPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentPacks.
     */
    cursor?: EquipmentPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentPacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentPacks.
     */
    distinct?: EquipmentPackScalarFieldEnum | EquipmentPackScalarFieldEnum[]
  }

  /**
   * EquipmentPack findMany
   */
  export type EquipmentPackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentPack
     */
    select?: EquipmentPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentPack
     */
    omit?: EquipmentPackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentPackInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentPacks to fetch.
     */
    where?: EquipmentPackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentPacks to fetch.
     */
    orderBy?: EquipmentPackOrderByWithRelationInput | EquipmentPackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentPacks.
     */
    cursor?: EquipmentPackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentPacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentPacks.
     */
    skip?: number
    distinct?: EquipmentPackScalarFieldEnum | EquipmentPackScalarFieldEnum[]
  }

  /**
   * EquipmentPack create
   */
  export type EquipmentPackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentPack
     */
    select?: EquipmentPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentPack
     */
    omit?: EquipmentPackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentPackInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentPack.
     */
    data: XOR<EquipmentPackCreateInput, EquipmentPackUncheckedCreateInput>
  }

  /**
   * EquipmentPack createMany
   */
  export type EquipmentPackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentPacks.
     */
    data: EquipmentPackCreateManyInput | EquipmentPackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipmentPack createManyAndReturn
   */
  export type EquipmentPackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentPack
     */
    select?: EquipmentPackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentPack
     */
    omit?: EquipmentPackOmit<ExtArgs> | null
    /**
     * The data used to create many EquipmentPacks.
     */
    data: EquipmentPackCreateManyInput | EquipmentPackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipmentPack update
   */
  export type EquipmentPackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentPack
     */
    select?: EquipmentPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentPack
     */
    omit?: EquipmentPackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentPackInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentPack.
     */
    data: XOR<EquipmentPackUpdateInput, EquipmentPackUncheckedUpdateInput>
    /**
     * Choose, which EquipmentPack to update.
     */
    where: EquipmentPackWhereUniqueInput
  }

  /**
   * EquipmentPack updateMany
   */
  export type EquipmentPackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentPacks.
     */
    data: XOR<EquipmentPackUpdateManyMutationInput, EquipmentPackUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentPacks to update
     */
    where?: EquipmentPackWhereInput
    /**
     * Limit how many EquipmentPacks to update.
     */
    limit?: number
  }

  /**
   * EquipmentPack updateManyAndReturn
   */
  export type EquipmentPackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentPack
     */
    select?: EquipmentPackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentPack
     */
    omit?: EquipmentPackOmit<ExtArgs> | null
    /**
     * The data used to update EquipmentPacks.
     */
    data: XOR<EquipmentPackUpdateManyMutationInput, EquipmentPackUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentPacks to update
     */
    where?: EquipmentPackWhereInput
    /**
     * Limit how many EquipmentPacks to update.
     */
    limit?: number
  }

  /**
   * EquipmentPack upsert
   */
  export type EquipmentPackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentPack
     */
    select?: EquipmentPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentPack
     */
    omit?: EquipmentPackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentPackInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentPack to update in case it exists.
     */
    where: EquipmentPackWhereUniqueInput
    /**
     * In case the EquipmentPack found by the `where` argument doesn't exist, create a new EquipmentPack with this data.
     */
    create: XOR<EquipmentPackCreateInput, EquipmentPackUncheckedCreateInput>
    /**
     * In case the EquipmentPack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentPackUpdateInput, EquipmentPackUncheckedUpdateInput>
  }

  /**
   * EquipmentPack delete
   */
  export type EquipmentPackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentPack
     */
    select?: EquipmentPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentPack
     */
    omit?: EquipmentPackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentPackInclude<ExtArgs> | null
    /**
     * Filter which EquipmentPack to delete.
     */
    where: EquipmentPackWhereUniqueInput
  }

  /**
   * EquipmentPack deleteMany
   */
  export type EquipmentPackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentPacks to delete
     */
    where?: EquipmentPackWhereInput
    /**
     * Limit how many EquipmentPacks to delete.
     */
    limit?: number
  }

  /**
   * EquipmentPack.classStartingEquipmentOptions
   */
  export type EquipmentPack$classStartingEquipmentOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionInclude<ExtArgs> | null
    where?: ClassStartingEquipmentOptionWhereInput
    orderBy?: ClassStartingEquipmentOptionOrderByWithRelationInput | ClassStartingEquipmentOptionOrderByWithRelationInput[]
    cursor?: ClassStartingEquipmentOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassStartingEquipmentOptionScalarFieldEnum | ClassStartingEquipmentOptionScalarFieldEnum[]
  }

  /**
   * EquipmentPack without action
   */
  export type EquipmentPackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentPack
     */
    select?: EquipmentPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentPack
     */
    omit?: EquipmentPackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentPackInclude<ExtArgs> | null
  }


  /**
   * Model ClassStartingEquipmentOption
   */

  export type AggregateClassStartingEquipmentOption = {
    _count: ClassStartingEquipmentOptionCountAggregateOutputType | null
    _avg: ClassStartingEquipmentOptionAvgAggregateOutputType | null
    _sum: ClassStartingEquipmentOptionSumAggregateOutputType | null
    _min: ClassStartingEquipmentOptionMinAggregateOutputType | null
    _max: ClassStartingEquipmentOptionMaxAggregateOutputType | null
  }

  export type ClassStartingEquipmentOptionAvgAggregateOutputType = {
    optionId: number | null
    classId: number | null
    choiceGroup: number | null
    weaponId: number | null
    armorId: number | null
    equipmentPackId: number | null
    quantity: number | null
    weaponCount: number | null
  }

  export type ClassStartingEquipmentOptionSumAggregateOutputType = {
    optionId: number | null
    classId: number | null
    choiceGroup: number | null
    weaponId: number | null
    armorId: number | null
    equipmentPackId: number | null
    quantity: number | null
    weaponCount: number | null
  }

  export type ClassStartingEquipmentOptionMinAggregateOutputType = {
    optionId: number | null
    classId: number | null
    choiceGroup: number | null
    option: string | null
    weaponId: number | null
    armorId: number | null
    equipmentPackId: number | null
    quantity: number | null
    chooseAnyArmor: boolean | null
    armorType: $Enums.ArmorType | null
    chooseAnyWeapon: boolean | null
    weaponType: $Enums.WeaponType | null
    weaponCount: number | null
    description: string | null
  }

  export type ClassStartingEquipmentOptionMaxAggregateOutputType = {
    optionId: number | null
    classId: number | null
    choiceGroup: number | null
    option: string | null
    weaponId: number | null
    armorId: number | null
    equipmentPackId: number | null
    quantity: number | null
    chooseAnyArmor: boolean | null
    armorType: $Enums.ArmorType | null
    chooseAnyWeapon: boolean | null
    weaponType: $Enums.WeaponType | null
    weaponCount: number | null
    description: string | null
  }

  export type ClassStartingEquipmentOptionCountAggregateOutputType = {
    optionId: number
    classId: number
    choiceGroup: number
    option: number
    weaponId: number
    armorId: number
    equipmentPackId: number
    quantity: number
    chooseAnyArmor: number
    armorType: number
    chooseAnyWeapon: number
    weaponType: number
    weaponCount: number
    description: number
    _all: number
  }


  export type ClassStartingEquipmentOptionAvgAggregateInputType = {
    optionId?: true
    classId?: true
    choiceGroup?: true
    weaponId?: true
    armorId?: true
    equipmentPackId?: true
    quantity?: true
    weaponCount?: true
  }

  export type ClassStartingEquipmentOptionSumAggregateInputType = {
    optionId?: true
    classId?: true
    choiceGroup?: true
    weaponId?: true
    armorId?: true
    equipmentPackId?: true
    quantity?: true
    weaponCount?: true
  }

  export type ClassStartingEquipmentOptionMinAggregateInputType = {
    optionId?: true
    classId?: true
    choiceGroup?: true
    option?: true
    weaponId?: true
    armorId?: true
    equipmentPackId?: true
    quantity?: true
    chooseAnyArmor?: true
    armorType?: true
    chooseAnyWeapon?: true
    weaponType?: true
    weaponCount?: true
    description?: true
  }

  export type ClassStartingEquipmentOptionMaxAggregateInputType = {
    optionId?: true
    classId?: true
    choiceGroup?: true
    option?: true
    weaponId?: true
    armorId?: true
    equipmentPackId?: true
    quantity?: true
    chooseAnyArmor?: true
    armorType?: true
    chooseAnyWeapon?: true
    weaponType?: true
    weaponCount?: true
    description?: true
  }

  export type ClassStartingEquipmentOptionCountAggregateInputType = {
    optionId?: true
    classId?: true
    choiceGroup?: true
    option?: true
    weaponId?: true
    armorId?: true
    equipmentPackId?: true
    quantity?: true
    chooseAnyArmor?: true
    armorType?: true
    chooseAnyWeapon?: true
    weaponType?: true
    weaponCount?: true
    description?: true
    _all?: true
  }

  export type ClassStartingEquipmentOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassStartingEquipmentOption to aggregate.
     */
    where?: ClassStartingEquipmentOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassStartingEquipmentOptions to fetch.
     */
    orderBy?: ClassStartingEquipmentOptionOrderByWithRelationInput | ClassStartingEquipmentOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassStartingEquipmentOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassStartingEquipmentOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassStartingEquipmentOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassStartingEquipmentOptions
    **/
    _count?: true | ClassStartingEquipmentOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassStartingEquipmentOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassStartingEquipmentOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassStartingEquipmentOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassStartingEquipmentOptionMaxAggregateInputType
  }

  export type GetClassStartingEquipmentOptionAggregateType<T extends ClassStartingEquipmentOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateClassStartingEquipmentOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassStartingEquipmentOption[P]>
      : GetScalarType<T[P], AggregateClassStartingEquipmentOption[P]>
  }




  export type ClassStartingEquipmentOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassStartingEquipmentOptionWhereInput
    orderBy?: ClassStartingEquipmentOptionOrderByWithAggregationInput | ClassStartingEquipmentOptionOrderByWithAggregationInput[]
    by: ClassStartingEquipmentOptionScalarFieldEnum[] | ClassStartingEquipmentOptionScalarFieldEnum
    having?: ClassStartingEquipmentOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassStartingEquipmentOptionCountAggregateInputType | true
    _avg?: ClassStartingEquipmentOptionAvgAggregateInputType
    _sum?: ClassStartingEquipmentOptionSumAggregateInputType
    _min?: ClassStartingEquipmentOptionMinAggregateInputType
    _max?: ClassStartingEquipmentOptionMaxAggregateInputType
  }

  export type ClassStartingEquipmentOptionGroupByOutputType = {
    optionId: number
    classId: number
    choiceGroup: number
    option: string
    weaponId: number | null
    armorId: number | null
    equipmentPackId: number | null
    quantity: number
    chooseAnyArmor: boolean
    armorType: $Enums.ArmorType | null
    chooseAnyWeapon: boolean
    weaponType: $Enums.WeaponType | null
    weaponCount: number
    description: string | null
    _count: ClassStartingEquipmentOptionCountAggregateOutputType | null
    _avg: ClassStartingEquipmentOptionAvgAggregateOutputType | null
    _sum: ClassStartingEquipmentOptionSumAggregateOutputType | null
    _min: ClassStartingEquipmentOptionMinAggregateOutputType | null
    _max: ClassStartingEquipmentOptionMaxAggregateOutputType | null
  }

  type GetClassStartingEquipmentOptionGroupByPayload<T extends ClassStartingEquipmentOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassStartingEquipmentOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassStartingEquipmentOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassStartingEquipmentOptionGroupByOutputType[P]>
            : GetScalarType<T[P], ClassStartingEquipmentOptionGroupByOutputType[P]>
        }
      >
    >


  export type ClassStartingEquipmentOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    optionId?: boolean
    classId?: boolean
    choiceGroup?: boolean
    option?: boolean
    weaponId?: boolean
    armorId?: boolean
    equipmentPackId?: boolean
    quantity?: boolean
    chooseAnyArmor?: boolean
    armorType?: boolean
    chooseAnyWeapon?: boolean
    weaponType?: boolean
    weaponCount?: boolean
    description?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    weapon?: boolean | ClassStartingEquipmentOption$weaponArgs<ExtArgs>
    armor?: boolean | ClassStartingEquipmentOption$armorArgs<ExtArgs>
    equipmentPack?: boolean | ClassStartingEquipmentOption$equipmentPackArgs<ExtArgs>
  }, ExtArgs["result"]["classStartingEquipmentOption"]>

  export type ClassStartingEquipmentOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    optionId?: boolean
    classId?: boolean
    choiceGroup?: boolean
    option?: boolean
    weaponId?: boolean
    armorId?: boolean
    equipmentPackId?: boolean
    quantity?: boolean
    chooseAnyArmor?: boolean
    armorType?: boolean
    chooseAnyWeapon?: boolean
    weaponType?: boolean
    weaponCount?: boolean
    description?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    weapon?: boolean | ClassStartingEquipmentOption$weaponArgs<ExtArgs>
    armor?: boolean | ClassStartingEquipmentOption$armorArgs<ExtArgs>
    equipmentPack?: boolean | ClassStartingEquipmentOption$equipmentPackArgs<ExtArgs>
  }, ExtArgs["result"]["classStartingEquipmentOption"]>

  export type ClassStartingEquipmentOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    optionId?: boolean
    classId?: boolean
    choiceGroup?: boolean
    option?: boolean
    weaponId?: boolean
    armorId?: boolean
    equipmentPackId?: boolean
    quantity?: boolean
    chooseAnyArmor?: boolean
    armorType?: boolean
    chooseAnyWeapon?: boolean
    weaponType?: boolean
    weaponCount?: boolean
    description?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    weapon?: boolean | ClassStartingEquipmentOption$weaponArgs<ExtArgs>
    armor?: boolean | ClassStartingEquipmentOption$armorArgs<ExtArgs>
    equipmentPack?: boolean | ClassStartingEquipmentOption$equipmentPackArgs<ExtArgs>
  }, ExtArgs["result"]["classStartingEquipmentOption"]>

  export type ClassStartingEquipmentOptionSelectScalar = {
    optionId?: boolean
    classId?: boolean
    choiceGroup?: boolean
    option?: boolean
    weaponId?: boolean
    armorId?: boolean
    equipmentPackId?: boolean
    quantity?: boolean
    chooseAnyArmor?: boolean
    armorType?: boolean
    chooseAnyWeapon?: boolean
    weaponType?: boolean
    weaponCount?: boolean
    description?: boolean
  }

  export type ClassStartingEquipmentOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"optionId" | "classId" | "choiceGroup" | "option" | "weaponId" | "armorId" | "equipmentPackId" | "quantity" | "chooseAnyArmor" | "armorType" | "chooseAnyWeapon" | "weaponType" | "weaponCount" | "description", ExtArgs["result"]["classStartingEquipmentOption"]>
  export type ClassStartingEquipmentOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    weapon?: boolean | ClassStartingEquipmentOption$weaponArgs<ExtArgs>
    armor?: boolean | ClassStartingEquipmentOption$armorArgs<ExtArgs>
    equipmentPack?: boolean | ClassStartingEquipmentOption$equipmentPackArgs<ExtArgs>
  }
  export type ClassStartingEquipmentOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    weapon?: boolean | ClassStartingEquipmentOption$weaponArgs<ExtArgs>
    armor?: boolean | ClassStartingEquipmentOption$armorArgs<ExtArgs>
    equipmentPack?: boolean | ClassStartingEquipmentOption$equipmentPackArgs<ExtArgs>
  }
  export type ClassStartingEquipmentOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    weapon?: boolean | ClassStartingEquipmentOption$weaponArgs<ExtArgs>
    armor?: boolean | ClassStartingEquipmentOption$armorArgs<ExtArgs>
    equipmentPack?: boolean | ClassStartingEquipmentOption$equipmentPackArgs<ExtArgs>
  }

  export type $ClassStartingEquipmentOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassStartingEquipmentOption"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      weapon: Prisma.$WeaponPayload<ExtArgs> | null
      armor: Prisma.$ArmorPayload<ExtArgs> | null
      equipmentPack: Prisma.$EquipmentPackPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      optionId: number
      classId: number
      choiceGroup: number
      option: string
      weaponId: number | null
      armorId: number | null
      equipmentPackId: number | null
      quantity: number
      chooseAnyArmor: boolean
      armorType: $Enums.ArmorType | null
      chooseAnyWeapon: boolean
      weaponType: $Enums.WeaponType | null
      weaponCount: number
      description: string | null
    }, ExtArgs["result"]["classStartingEquipmentOption"]>
    composites: {}
  }

  type ClassStartingEquipmentOptionGetPayload<S extends boolean | null | undefined | ClassStartingEquipmentOptionDefaultArgs> = $Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload, S>

  type ClassStartingEquipmentOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassStartingEquipmentOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassStartingEquipmentOptionCountAggregateInputType | true
    }

  export interface ClassStartingEquipmentOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassStartingEquipmentOption'], meta: { name: 'ClassStartingEquipmentOption' } }
    /**
     * Find zero or one ClassStartingEquipmentOption that matches the filter.
     * @param {ClassStartingEquipmentOptionFindUniqueArgs} args - Arguments to find a ClassStartingEquipmentOption
     * @example
     * // Get one ClassStartingEquipmentOption
     * const classStartingEquipmentOption = await prisma.classStartingEquipmentOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassStartingEquipmentOptionFindUniqueArgs>(args: SelectSubset<T, ClassStartingEquipmentOptionFindUniqueArgs<ExtArgs>>): Prisma__ClassStartingEquipmentOptionClient<$Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassStartingEquipmentOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassStartingEquipmentOptionFindUniqueOrThrowArgs} args - Arguments to find a ClassStartingEquipmentOption
     * @example
     * // Get one ClassStartingEquipmentOption
     * const classStartingEquipmentOption = await prisma.classStartingEquipmentOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassStartingEquipmentOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassStartingEquipmentOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassStartingEquipmentOptionClient<$Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassStartingEquipmentOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassStartingEquipmentOptionFindFirstArgs} args - Arguments to find a ClassStartingEquipmentOption
     * @example
     * // Get one ClassStartingEquipmentOption
     * const classStartingEquipmentOption = await prisma.classStartingEquipmentOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassStartingEquipmentOptionFindFirstArgs>(args?: SelectSubset<T, ClassStartingEquipmentOptionFindFirstArgs<ExtArgs>>): Prisma__ClassStartingEquipmentOptionClient<$Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassStartingEquipmentOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassStartingEquipmentOptionFindFirstOrThrowArgs} args - Arguments to find a ClassStartingEquipmentOption
     * @example
     * // Get one ClassStartingEquipmentOption
     * const classStartingEquipmentOption = await prisma.classStartingEquipmentOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassStartingEquipmentOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassStartingEquipmentOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassStartingEquipmentOptionClient<$Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassStartingEquipmentOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassStartingEquipmentOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassStartingEquipmentOptions
     * const classStartingEquipmentOptions = await prisma.classStartingEquipmentOption.findMany()
     * 
     * // Get first 10 ClassStartingEquipmentOptions
     * const classStartingEquipmentOptions = await prisma.classStartingEquipmentOption.findMany({ take: 10 })
     * 
     * // Only select the `optionId`
     * const classStartingEquipmentOptionWithOptionIdOnly = await prisma.classStartingEquipmentOption.findMany({ select: { optionId: true } })
     * 
     */
    findMany<T extends ClassStartingEquipmentOptionFindManyArgs>(args?: SelectSubset<T, ClassStartingEquipmentOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassStartingEquipmentOption.
     * @param {ClassStartingEquipmentOptionCreateArgs} args - Arguments to create a ClassStartingEquipmentOption.
     * @example
     * // Create one ClassStartingEquipmentOption
     * const ClassStartingEquipmentOption = await prisma.classStartingEquipmentOption.create({
     *   data: {
     *     // ... data to create a ClassStartingEquipmentOption
     *   }
     * })
     * 
     */
    create<T extends ClassStartingEquipmentOptionCreateArgs>(args: SelectSubset<T, ClassStartingEquipmentOptionCreateArgs<ExtArgs>>): Prisma__ClassStartingEquipmentOptionClient<$Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassStartingEquipmentOptions.
     * @param {ClassStartingEquipmentOptionCreateManyArgs} args - Arguments to create many ClassStartingEquipmentOptions.
     * @example
     * // Create many ClassStartingEquipmentOptions
     * const classStartingEquipmentOption = await prisma.classStartingEquipmentOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassStartingEquipmentOptionCreateManyArgs>(args?: SelectSubset<T, ClassStartingEquipmentOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassStartingEquipmentOptions and returns the data saved in the database.
     * @param {ClassStartingEquipmentOptionCreateManyAndReturnArgs} args - Arguments to create many ClassStartingEquipmentOptions.
     * @example
     * // Create many ClassStartingEquipmentOptions
     * const classStartingEquipmentOption = await prisma.classStartingEquipmentOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassStartingEquipmentOptions and only return the `optionId`
     * const classStartingEquipmentOptionWithOptionIdOnly = await prisma.classStartingEquipmentOption.createManyAndReturn({
     *   select: { optionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassStartingEquipmentOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassStartingEquipmentOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClassStartingEquipmentOption.
     * @param {ClassStartingEquipmentOptionDeleteArgs} args - Arguments to delete one ClassStartingEquipmentOption.
     * @example
     * // Delete one ClassStartingEquipmentOption
     * const ClassStartingEquipmentOption = await prisma.classStartingEquipmentOption.delete({
     *   where: {
     *     // ... filter to delete one ClassStartingEquipmentOption
     *   }
     * })
     * 
     */
    delete<T extends ClassStartingEquipmentOptionDeleteArgs>(args: SelectSubset<T, ClassStartingEquipmentOptionDeleteArgs<ExtArgs>>): Prisma__ClassStartingEquipmentOptionClient<$Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassStartingEquipmentOption.
     * @param {ClassStartingEquipmentOptionUpdateArgs} args - Arguments to update one ClassStartingEquipmentOption.
     * @example
     * // Update one ClassStartingEquipmentOption
     * const classStartingEquipmentOption = await prisma.classStartingEquipmentOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassStartingEquipmentOptionUpdateArgs>(args: SelectSubset<T, ClassStartingEquipmentOptionUpdateArgs<ExtArgs>>): Prisma__ClassStartingEquipmentOptionClient<$Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassStartingEquipmentOptions.
     * @param {ClassStartingEquipmentOptionDeleteManyArgs} args - Arguments to filter ClassStartingEquipmentOptions to delete.
     * @example
     * // Delete a few ClassStartingEquipmentOptions
     * const { count } = await prisma.classStartingEquipmentOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassStartingEquipmentOptionDeleteManyArgs>(args?: SelectSubset<T, ClassStartingEquipmentOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassStartingEquipmentOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassStartingEquipmentOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassStartingEquipmentOptions
     * const classStartingEquipmentOption = await prisma.classStartingEquipmentOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassStartingEquipmentOptionUpdateManyArgs>(args: SelectSubset<T, ClassStartingEquipmentOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassStartingEquipmentOptions and returns the data updated in the database.
     * @param {ClassStartingEquipmentOptionUpdateManyAndReturnArgs} args - Arguments to update many ClassStartingEquipmentOptions.
     * @example
     * // Update many ClassStartingEquipmentOptions
     * const classStartingEquipmentOption = await prisma.classStartingEquipmentOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClassStartingEquipmentOptions and only return the `optionId`
     * const classStartingEquipmentOptionWithOptionIdOnly = await prisma.classStartingEquipmentOption.updateManyAndReturn({
     *   select: { optionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassStartingEquipmentOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassStartingEquipmentOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClassStartingEquipmentOption.
     * @param {ClassStartingEquipmentOptionUpsertArgs} args - Arguments to update or create a ClassStartingEquipmentOption.
     * @example
     * // Update or create a ClassStartingEquipmentOption
     * const classStartingEquipmentOption = await prisma.classStartingEquipmentOption.upsert({
     *   create: {
     *     // ... data to create a ClassStartingEquipmentOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassStartingEquipmentOption we want to update
     *   }
     * })
     */
    upsert<T extends ClassStartingEquipmentOptionUpsertArgs>(args: SelectSubset<T, ClassStartingEquipmentOptionUpsertArgs<ExtArgs>>): Prisma__ClassStartingEquipmentOptionClient<$Result.GetResult<Prisma.$ClassStartingEquipmentOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassStartingEquipmentOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassStartingEquipmentOptionCountArgs} args - Arguments to filter ClassStartingEquipmentOptions to count.
     * @example
     * // Count the number of ClassStartingEquipmentOptions
     * const count = await prisma.classStartingEquipmentOption.count({
     *   where: {
     *     // ... the filter for the ClassStartingEquipmentOptions we want to count
     *   }
     * })
    **/
    count<T extends ClassStartingEquipmentOptionCountArgs>(
      args?: Subset<T, ClassStartingEquipmentOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassStartingEquipmentOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassStartingEquipmentOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassStartingEquipmentOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassStartingEquipmentOptionAggregateArgs>(args: Subset<T, ClassStartingEquipmentOptionAggregateArgs>): Prisma.PrismaPromise<GetClassStartingEquipmentOptionAggregateType<T>>

    /**
     * Group by ClassStartingEquipmentOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassStartingEquipmentOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassStartingEquipmentOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassStartingEquipmentOptionGroupByArgs['orderBy'] }
        : { orderBy?: ClassStartingEquipmentOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassStartingEquipmentOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassStartingEquipmentOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassStartingEquipmentOption model
   */
  readonly fields: ClassStartingEquipmentOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassStartingEquipmentOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassStartingEquipmentOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    weapon<T extends ClassStartingEquipmentOption$weaponArgs<ExtArgs> = {}>(args?: Subset<T, ClassStartingEquipmentOption$weaponArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    armor<T extends ClassStartingEquipmentOption$armorArgs<ExtArgs> = {}>(args?: Subset<T, ClassStartingEquipmentOption$armorArgs<ExtArgs>>): Prisma__ArmorClient<$Result.GetResult<Prisma.$ArmorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    equipmentPack<T extends ClassStartingEquipmentOption$equipmentPackArgs<ExtArgs> = {}>(args?: Subset<T, ClassStartingEquipmentOption$equipmentPackArgs<ExtArgs>>): Prisma__EquipmentPackClient<$Result.GetResult<Prisma.$EquipmentPackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassStartingEquipmentOption model
   */
  interface ClassStartingEquipmentOptionFieldRefs {
    readonly optionId: FieldRef<"ClassStartingEquipmentOption", 'Int'>
    readonly classId: FieldRef<"ClassStartingEquipmentOption", 'Int'>
    readonly choiceGroup: FieldRef<"ClassStartingEquipmentOption", 'Int'>
    readonly option: FieldRef<"ClassStartingEquipmentOption", 'String'>
    readonly weaponId: FieldRef<"ClassStartingEquipmentOption", 'Int'>
    readonly armorId: FieldRef<"ClassStartingEquipmentOption", 'Int'>
    readonly equipmentPackId: FieldRef<"ClassStartingEquipmentOption", 'Int'>
    readonly quantity: FieldRef<"ClassStartingEquipmentOption", 'Int'>
    readonly chooseAnyArmor: FieldRef<"ClassStartingEquipmentOption", 'Boolean'>
    readonly armorType: FieldRef<"ClassStartingEquipmentOption", 'ArmorType'>
    readonly chooseAnyWeapon: FieldRef<"ClassStartingEquipmentOption", 'Boolean'>
    readonly weaponType: FieldRef<"ClassStartingEquipmentOption", 'WeaponType'>
    readonly weaponCount: FieldRef<"ClassStartingEquipmentOption", 'Int'>
    readonly description: FieldRef<"ClassStartingEquipmentOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClassStartingEquipmentOption findUnique
   */
  export type ClassStartingEquipmentOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionInclude<ExtArgs> | null
    /**
     * Filter, which ClassStartingEquipmentOption to fetch.
     */
    where: ClassStartingEquipmentOptionWhereUniqueInput
  }

  /**
   * ClassStartingEquipmentOption findUniqueOrThrow
   */
  export type ClassStartingEquipmentOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionInclude<ExtArgs> | null
    /**
     * Filter, which ClassStartingEquipmentOption to fetch.
     */
    where: ClassStartingEquipmentOptionWhereUniqueInput
  }

  /**
   * ClassStartingEquipmentOption findFirst
   */
  export type ClassStartingEquipmentOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionInclude<ExtArgs> | null
    /**
     * Filter, which ClassStartingEquipmentOption to fetch.
     */
    where?: ClassStartingEquipmentOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassStartingEquipmentOptions to fetch.
     */
    orderBy?: ClassStartingEquipmentOptionOrderByWithRelationInput | ClassStartingEquipmentOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassStartingEquipmentOptions.
     */
    cursor?: ClassStartingEquipmentOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassStartingEquipmentOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassStartingEquipmentOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassStartingEquipmentOptions.
     */
    distinct?: ClassStartingEquipmentOptionScalarFieldEnum | ClassStartingEquipmentOptionScalarFieldEnum[]
  }

  /**
   * ClassStartingEquipmentOption findFirstOrThrow
   */
  export type ClassStartingEquipmentOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionInclude<ExtArgs> | null
    /**
     * Filter, which ClassStartingEquipmentOption to fetch.
     */
    where?: ClassStartingEquipmentOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassStartingEquipmentOptions to fetch.
     */
    orderBy?: ClassStartingEquipmentOptionOrderByWithRelationInput | ClassStartingEquipmentOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassStartingEquipmentOptions.
     */
    cursor?: ClassStartingEquipmentOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassStartingEquipmentOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassStartingEquipmentOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassStartingEquipmentOptions.
     */
    distinct?: ClassStartingEquipmentOptionScalarFieldEnum | ClassStartingEquipmentOptionScalarFieldEnum[]
  }

  /**
   * ClassStartingEquipmentOption findMany
   */
  export type ClassStartingEquipmentOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionInclude<ExtArgs> | null
    /**
     * Filter, which ClassStartingEquipmentOptions to fetch.
     */
    where?: ClassStartingEquipmentOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassStartingEquipmentOptions to fetch.
     */
    orderBy?: ClassStartingEquipmentOptionOrderByWithRelationInput | ClassStartingEquipmentOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassStartingEquipmentOptions.
     */
    cursor?: ClassStartingEquipmentOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassStartingEquipmentOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassStartingEquipmentOptions.
     */
    skip?: number
    distinct?: ClassStartingEquipmentOptionScalarFieldEnum | ClassStartingEquipmentOptionScalarFieldEnum[]
  }

  /**
   * ClassStartingEquipmentOption create
   */
  export type ClassStartingEquipmentOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassStartingEquipmentOption.
     */
    data: XOR<ClassStartingEquipmentOptionCreateInput, ClassStartingEquipmentOptionUncheckedCreateInput>
  }

  /**
   * ClassStartingEquipmentOption createMany
   */
  export type ClassStartingEquipmentOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassStartingEquipmentOptions.
     */
    data: ClassStartingEquipmentOptionCreateManyInput | ClassStartingEquipmentOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassStartingEquipmentOption createManyAndReturn
   */
  export type ClassStartingEquipmentOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * The data used to create many ClassStartingEquipmentOptions.
     */
    data: ClassStartingEquipmentOptionCreateManyInput | ClassStartingEquipmentOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassStartingEquipmentOption update
   */
  export type ClassStartingEquipmentOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassStartingEquipmentOption.
     */
    data: XOR<ClassStartingEquipmentOptionUpdateInput, ClassStartingEquipmentOptionUncheckedUpdateInput>
    /**
     * Choose, which ClassStartingEquipmentOption to update.
     */
    where: ClassStartingEquipmentOptionWhereUniqueInput
  }

  /**
   * ClassStartingEquipmentOption updateMany
   */
  export type ClassStartingEquipmentOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassStartingEquipmentOptions.
     */
    data: XOR<ClassStartingEquipmentOptionUpdateManyMutationInput, ClassStartingEquipmentOptionUncheckedUpdateManyInput>
    /**
     * Filter which ClassStartingEquipmentOptions to update
     */
    where?: ClassStartingEquipmentOptionWhereInput
    /**
     * Limit how many ClassStartingEquipmentOptions to update.
     */
    limit?: number
  }

  /**
   * ClassStartingEquipmentOption updateManyAndReturn
   */
  export type ClassStartingEquipmentOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * The data used to update ClassStartingEquipmentOptions.
     */
    data: XOR<ClassStartingEquipmentOptionUpdateManyMutationInput, ClassStartingEquipmentOptionUncheckedUpdateManyInput>
    /**
     * Filter which ClassStartingEquipmentOptions to update
     */
    where?: ClassStartingEquipmentOptionWhereInput
    /**
     * Limit how many ClassStartingEquipmentOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassStartingEquipmentOption upsert
   */
  export type ClassStartingEquipmentOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassStartingEquipmentOption to update in case it exists.
     */
    where: ClassStartingEquipmentOptionWhereUniqueInput
    /**
     * In case the ClassStartingEquipmentOption found by the `where` argument doesn't exist, create a new ClassStartingEquipmentOption with this data.
     */
    create: XOR<ClassStartingEquipmentOptionCreateInput, ClassStartingEquipmentOptionUncheckedCreateInput>
    /**
     * In case the ClassStartingEquipmentOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassStartingEquipmentOptionUpdateInput, ClassStartingEquipmentOptionUncheckedUpdateInput>
  }

  /**
   * ClassStartingEquipmentOption delete
   */
  export type ClassStartingEquipmentOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionInclude<ExtArgs> | null
    /**
     * Filter which ClassStartingEquipmentOption to delete.
     */
    where: ClassStartingEquipmentOptionWhereUniqueInput
  }

  /**
   * ClassStartingEquipmentOption deleteMany
   */
  export type ClassStartingEquipmentOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassStartingEquipmentOptions to delete
     */
    where?: ClassStartingEquipmentOptionWhereInput
    /**
     * Limit how many ClassStartingEquipmentOptions to delete.
     */
    limit?: number
  }

  /**
   * ClassStartingEquipmentOption.weapon
   */
  export type ClassStartingEquipmentOption$weaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    where?: WeaponWhereInput
  }

  /**
   * ClassStartingEquipmentOption.armor
   */
  export type ClassStartingEquipmentOption$armorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armor
     */
    select?: ArmorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Armor
     */
    omit?: ArmorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmorInclude<ExtArgs> | null
    where?: ArmorWhereInput
  }

  /**
   * ClassStartingEquipmentOption.equipmentPack
   */
  export type ClassStartingEquipmentOption$equipmentPackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentPack
     */
    select?: EquipmentPackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentPack
     */
    omit?: EquipmentPackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentPackInclude<ExtArgs> | null
    where?: EquipmentPackWhereInput
  }

  /**
   * ClassStartingEquipmentOption without action
   */
  export type ClassStartingEquipmentOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassStartingEquipmentOption
     */
    select?: ClassStartingEquipmentOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassStartingEquipmentOption
     */
    omit?: ClassStartingEquipmentOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassStartingEquipmentOptionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CharacterScalarFieldEnum: {
    characterId: 'characterId',
    name: 'name',
    userId: 'userId'
  };

  export type CharacterScalarFieldEnum = (typeof CharacterScalarFieldEnum)[keyof typeof CharacterScalarFieldEnum]


  export const CharacterSpellsScalarFieldEnum: {
    characterSpellId: 'characterSpellId',
    characterId: 'characterId',
    spellId: 'spellId'
  };

  export type CharacterSpellsScalarFieldEnum = (typeof CharacterSpellsScalarFieldEnum)[keyof typeof CharacterSpellsScalarFieldEnum]


  export const CreatureScalarFieldEnum: {
    creatureId: 'creatureId',
    name: 'name',
    nameEng: 'nameEng',
    size: 'size',
    type: 'type',
    alignment: 'alignment',
    source: 'source',
    ac: 'ac',
    hp: 'hp',
    speed: 'speed',
    strength: 'strength',
    dexterity: 'dexterity',
    constitution: 'constitution',
    intelligence: 'intelligence',
    wisdom: 'wisdom',
    charisma: 'charisma',
    skills: 'skills',
    senses: 'senses',
    languages: 'languages',
    challenge: 'challenge',
    damageImmunity: 'damageImmunity',
    damageResistance: 'damageResistance',
    conditionImmunity: 'conditionImmunity',
    savingThrows: 'savingThrows',
    specialAbilities: 'specialAbilities',
    actions: 'actions',
    reactions: 'reactions',
    legendaryActions: 'legendaryActions',
    proficiencyBonus: 'proficiencyBonus',
    description: 'description',
    lairActions: 'lairActions',
    lairInfo: 'lairInfo',
    regionEffects: 'regionEffects',
    xp: 'xp'
  };

  export type CreatureScalarFieldEnum = (typeof CreatureScalarFieldEnum)[keyof typeof CreatureScalarFieldEnum]


  export const SpellScalarFieldEnum: {
    spellId: 'spellId',
    name: 'name',
    level: 'level',
    school: 'school',
    castingTime: 'castingTime',
    range: 'range',
    components: 'components',
    duration: 'duration',
    description: 'description',
    hasRitual: 'hasRitual',
    hasConcentration: 'hasConcentration',
    source: 'source'
  };

  export type SpellScalarFieldEnum = (typeof SpellScalarFieldEnum)[keyof typeof SpellScalarFieldEnum]


  export const SpellClassesScalarFieldEnum: {
    classId: 'classId',
    spellId: 'spellId',
    className: 'className'
  };

  export type SpellClassesScalarFieldEnum = (typeof SpellClassesScalarFieldEnum)[keyof typeof SpellClassesScalarFieldEnum]


  export const SpellRacesScalarFieldEnum: {
    spellId: 'spellId',
    raceId: 'raceId',
    raceName: 'raceName'
  };

  export type SpellRacesScalarFieldEnum = (typeof SpellRacesScalarFieldEnum)[keyof typeof SpellRacesScalarFieldEnum]


  export const SpellbookScalarFieldEnum: {
    spellbookId: 'spellbookId',
    userId: 'userId'
  };

  export type SpellbookScalarFieldEnum = (typeof SpellbookScalarFieldEnum)[keyof typeof SpellbookScalarFieldEnum]


  export const SpellbookSpellsScalarFieldEnum: {
    spellbookSpellId: 'spellbookSpellId',
    spellId: 'spellId',
    spellbookId: 'spellbookId'
  };

  export type SpellbookSpellsScalarFieldEnum = (typeof SpellbookSpellsScalarFieldEnum)[keyof typeof SpellbookSpellsScalarFieldEnum]


  export const UserScalarFieldEnum: {
    userId: 'userId',
    login: 'login',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    classId: 'classId',
    name: 'name',
    hitDie: 'hitDie',
    primaryCastingStat: 'primaryCastingStat',
    spellcastingType: 'spellcastingType',
    abilityScoreUpLevels: 'abilityScoreUpLevels',
    subclassLevel: 'subclassLevel',
    multiclassStrReq: 'multiclassStrReq',
    multiclassDexReq: 'multiclassDexReq',
    multiclassConReq: 'multiclassConReq',
    multiclassIntReq: 'multiclassIntReq',
    multiclassWisReq: 'multiclassWisReq',
    multiclassChaReq: 'multiclassChaReq',
    armorProficiencies: 'armorProficiencies',
    weaponProficiencies: 'weaponProficiencies',
    savingThrows: 'savingThrows',
    skillProficiencies: 'skillProficiencies',
    toolProficiencies: 'toolProficiencies',
    languagesToChooseCount: 'languagesToChooseCount',
    languages: 'languages',
    specialSpellSlotProgression: 'specialSpellSlotProgression',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const SubclassScalarFieldEnum: {
    subclassId: 'subclassId',
    classId: 'classId',
    name: 'name',
    description: 'description',
    grantsSpells: 'grantsSpells',
    languagesToChooseCount: 'languagesToChooseCount',
    languages: 'languages',
    toolProficiencies: 'toolProficiencies'
  };

  export type SubclassScalarFieldEnum = (typeof SubclassScalarFieldEnum)[keyof typeof SubclassScalarFieldEnum]


  export const PersScalarFieldEnum: {
    persId: 'persId',
    userId: 'userId',
    name: 'name',
    level: 'level',
    currentSpellSlots: 'currentSpellSlots',
    classId: 'classId',
    subclassId: 'subclassId',
    backgroundId: 'backgroundId',
    raceId: 'raceId',
    subraceId: 'subraceId',
    currentHp: 'currentHp',
    maxHp: 'maxHp',
    tempHp: 'tempHp',
    raceCustom: 'raceCustom',
    classCustom: 'classCustom',
    alignment: 'alignment',
    xp: 'xp',
    customBackground: 'customBackground',
    customFeatures: 'customFeatures',
    customLanguagesKnown: 'customLanguagesKnown',
    customEquipment: 'customEquipment',
    personalityTraits: 'personalityTraits',
    ideals: 'ideals',
    bonds: 'bonds',
    flaws: 'flaws',
    backstory: 'backstory',
    notes: 'notes',
    str: 'str',
    dex: 'dex',
    con: 'con',
    int: 'int',
    wis: 'wis',
    cha: 'cha',
    cp: 'cp',
    sp: 'sp',
    ep: 'ep',
    gp: 'gp',
    pp: 'pp',
    additionalSaveProficiencies: 'additionalSaveProficiencies',
    miscSaveBonuses: 'miscSaveBonuses',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PersScalarFieldEnum = (typeof PersScalarFieldEnum)[keyof typeof PersScalarFieldEnum]


  export const PersMulticlassScalarFieldEnum: {
    persMulticlassId: 'persMulticlassId',
    persId: 'persId',
    classId: 'classId',
    subclassId: 'subclassId',
    classLevel: 'classLevel'
  };

  export type PersMulticlassScalarFieldEnum = (typeof PersMulticlassScalarFieldEnum)[keyof typeof PersMulticlassScalarFieldEnum]


  export const PersFeatureScalarFieldEnum: {
    persFeatureId: 'persFeatureId',
    persId: 'persId',
    featureId: 'featureId',
    usesRemaining: 'usesRemaining'
  };

  export type PersFeatureScalarFieldEnum = (typeof PersFeatureScalarFieldEnum)[keyof typeof PersFeatureScalarFieldEnum]


  export const FeatureScalarFieldEnum: {
    featureId: 'featureId',
    name: 'name',
    description: 'description',
    shortDescription: 'shortDescription',
    modifiesStats: 'modifiesStats',
    limitedUsesPer: 'limitedUsesPer',
    usesCount: 'usesCount',
    displayType: 'displayType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeatureScalarFieldEnum = (typeof FeatureScalarFieldEnum)[keyof typeof FeatureScalarFieldEnum]


  export const ClassFeatureScalarFieldEnum: {
    classFeatureId: 'classFeatureId',
    classId: 'classId',
    featureId: 'featureId',
    levelGranted: 'levelGranted',
    grantsSpellSlots: 'grantsSpellSlots'
  };

  export type ClassFeatureScalarFieldEnum = (typeof ClassFeatureScalarFieldEnum)[keyof typeof ClassFeatureScalarFieldEnum]


  export const SubclassFeatureScalarFieldEnum: {
    subclassFeatureId: 'subclassFeatureId',
    subclassId: 'subclassId',
    featureId: 'featureId',
    levelGranted: 'levelGranted',
    grantsSpellSlots: 'grantsSpellSlots'
  };

  export type SubclassFeatureScalarFieldEnum = (typeof SubclassFeatureScalarFieldEnum)[keyof typeof SubclassFeatureScalarFieldEnum]


  export const RaceTraitScalarFieldEnum: {
    raceTraitId: 'raceTraitId',
    raceId: 'raceId',
    featureId: 'featureId'
  };

  export type RaceTraitScalarFieldEnum = (typeof RaceTraitScalarFieldEnum)[keyof typeof RaceTraitScalarFieldEnum]


  export const SubraceTraitScalarFieldEnum: {
    subraceTraitId: 'subraceTraitId',
    subraceId: 'subraceId',
    featureId: 'featureId'
  };

  export type SubraceTraitScalarFieldEnum = (typeof SubraceTraitScalarFieldEnum)[keyof typeof SubraceTraitScalarFieldEnum]


  export const RaceVariantTraitScalarFieldEnum: {
    raceVariantTraitId: 'raceVariantTraitId',
    raceVariantId: 'raceVariantId',
    featureId: 'featureId'
  };

  export type RaceVariantTraitScalarFieldEnum = (typeof RaceVariantTraitScalarFieldEnum)[keyof typeof RaceVariantTraitScalarFieldEnum]


  export const RaceChoiceOptionTraitScalarFieldEnum: {
    raceChoiceOptionTraitId: 'raceChoiceOptionTraitId',
    optionId: 'optionId',
    featureId: 'featureId'
  };

  export type RaceChoiceOptionTraitScalarFieldEnum = (typeof RaceChoiceOptionTraitScalarFieldEnum)[keyof typeof RaceChoiceOptionTraitScalarFieldEnum]


  export const FeatFeatureScalarFieldEnum: {
    featFeatureId: 'featFeatureId',
    featId: 'featId',
    featureId: 'featureId'
  };

  export type FeatFeatureScalarFieldEnum = (typeof FeatFeatureScalarFieldEnum)[keyof typeof FeatFeatureScalarFieldEnum]


  export const MagicItemFeatureScalarFieldEnum: {
    magicItemFeatureId: 'magicItemFeatureId',
    magicItemId: 'magicItemId',
    featureId: 'featureId'
  };

  export type MagicItemFeatureScalarFieldEnum = (typeof MagicItemFeatureScalarFieldEnum)[keyof typeof MagicItemFeatureScalarFieldEnum]


  export const RaceScalarFieldEnum: {
    raceId: 'raceId',
    name: 'name',
    size: 'size',
    speed: 'speed',
    burrowSpeed: 'burrowSpeed',
    flightSpeed: 'flightSpeed',
    swimSpeed: 'swimSpeed',
    climbSpeed: 'climbSpeed',
    ac: 'ac',
    source: 'source',
    languages: 'languages',
    languagesToChooseCount: 'languagesToChooseCount',
    ASI: 'ASI',
    toolProficiencies: 'toolProficiencies',
    skillProficiencies: 'skillProficiencies',
    weaponProficiencies: 'weaponProficiencies',
    armorProficiencies: 'armorProficiencies'
  };

  export type RaceScalarFieldEnum = (typeof RaceScalarFieldEnum)[keyof typeof RaceScalarFieldEnum]


  export const SubraceScalarFieldEnum: {
    subraceId: 'subraceId',
    raceId: 'raceId',
    name: 'name',
    speedModifier: 'speedModifier',
    source: 'source',
    replacesASI: 'replacesASI',
    additionalASI: 'additionalASI',
    additionalLanguages: 'additionalLanguages',
    languagesToChooseCount: 'languagesToChooseCount',
    toolProficiencies: 'toolProficiencies',
    skillProficiencies: 'skillProficiencies',
    weaponProficiencies: 'weaponProficiencies',
    armorProficiencies: 'armorProficiencies'
  };

  export type SubraceScalarFieldEnum = (typeof SubraceScalarFieldEnum)[keyof typeof SubraceScalarFieldEnum]


  export const RaceVariantScalarFieldEnum: {
    raceVariantId: 'raceVariantId',
    raceId: 'raceId',
    name: 'name',
    source: 'source',
    exclusivityGroup: 'exclusivityGroup',
    overridesRaceASI: 'overridesRaceASI',
    overridesRaceSpeed: 'overridesRaceSpeed',
    overridesFlightSpeed: 'overridesFlightSpeed'
  };

  export type RaceVariantScalarFieldEnum = (typeof RaceVariantScalarFieldEnum)[keyof typeof RaceVariantScalarFieldEnum]


  export const RaceChoiceOptionScalarFieldEnum: {
    optionId: 'optionId',
    raceId: 'raceId',
    subraceId: 'subraceId',
    choiceGroupName: 'choiceGroupName',
    optionName: 'optionName',
    description: 'description',
    selectMultiple: 'selectMultiple',
    maxSelection: 'maxSelection',
    grantsASI: 'grantsASI',
    grantsSkillProficiencies: 'grantsSkillProficiencies',
    grantsLanguages: 'grantsLanguages',
    languagesToChooseCount: 'languagesToChooseCount',
    modifiesSpeed: 'modifiesSpeed',
    draconicDamageType: 'draconicDamageType',
    breathWeaponShape: 'breathWeaponShape',
    breathWeaponAOE: 'breathWeaponAOE'
  };

  export type RaceChoiceOptionScalarFieldEnum = (typeof RaceChoiceOptionScalarFieldEnum)[keyof typeof RaceChoiceOptionScalarFieldEnum]


  export const BackgroundScalarFieldEnum: {
    backgroundId: 'backgroundId',
    name: 'name',
    source: 'source',
    toolProficiencies: 'toolProficiencies',
    skillProficiencies: 'skillProficiencies',
    languagesToChooseCount: 'languagesToChooseCount',
    items: 'items'
  };

  export type BackgroundScalarFieldEnum = (typeof BackgroundScalarFieldEnum)[keyof typeof BackgroundScalarFieldEnum]


  export const FeatScalarFieldEnum: {
    featId: 'featId',
    name: 'name',
    category: 'category',
    shortDescription: 'shortDescription',
    longDescription: 'longDescription',
    languagesToChooseCount: 'languagesToChooseCount',
    languages: 'languages',
    prerequisites: 'prerequisites'
  };

  export type FeatScalarFieldEnum = (typeof FeatScalarFieldEnum)[keyof typeof FeatScalarFieldEnum]


  export const FeatAbilityBoostScalarFieldEnum: {
    boostId: 'boostId',
    featId: 'featId',
    ability: 'ability',
    increaseValue: 'increaseValue',
    abilitiesToChoose: 'abilitiesToChoose',
    maxValue: 'maxValue'
  };

  export type FeatAbilityBoostScalarFieldEnum = (typeof FeatAbilityBoostScalarFieldEnum)[keyof typeof FeatAbilityBoostScalarFieldEnum]


  export const PersFeatScalarFieldEnum: {
    persFeatId: 'persFeatId',
    featId: 'featId',
    persId: 'persId'
  };

  export type PersFeatScalarFieldEnum = (typeof PersFeatScalarFieldEnum)[keyof typeof PersFeatScalarFieldEnum]


  export const MagicItemScalarFieldEnum: {
    magicItemId: 'magicItemId',
    name: 'name',
    itemType: 'itemType',
    rarity: 'rarity',
    description: 'description',
    bonusToAC: 'bonusToAC',
    bonusToAttackRoll: 'bonusToAttackRoll',
    bonusToDamage: 'bonusToDamage'
  };

  export type MagicItemScalarFieldEnum = (typeof MagicItemScalarFieldEnum)[keyof typeof MagicItemScalarFieldEnum]


  export const WeaponScalarFieldEnum: {
    weaponId: 'weaponId',
    name: 'name',
    damage: 'damage',
    damageType: 'damageType',
    weaponType: 'weaponType',
    properties: 'properties',
    versatileDamage: 'versatileDamage',
    normalRange: 'normalRange',
    longRange: 'longRange'
  };

  export type WeaponScalarFieldEnum = (typeof WeaponScalarFieldEnum)[keyof typeof WeaponScalarFieldEnum]


  export const ArmorScalarFieldEnum: {
    armorId: 'armorId',
    name: 'name',
    armorType: 'armorType',
    baseAC: 'baseAC',
    strengthReq: 'strengthReq',
    stealthDisadvantage: 'stealthDisadvantage'
  };

  export type ArmorScalarFieldEnum = (typeof ArmorScalarFieldEnum)[keyof typeof ArmorScalarFieldEnum]


  export const PersSkillScalarFieldEnum: {
    persSkillId: 'persSkillId',
    skillId: 'skillId',
    persId: 'persId',
    proficiencyType: 'proficiencyType',
    customModifier: 'customModifier',
    name: 'name'
  };

  export type PersSkillScalarFieldEnum = (typeof PersSkillScalarFieldEnum)[keyof typeof PersSkillScalarFieldEnum]


  export const PersWeaponScalarFieldEnum: {
    persWeaponId: 'persWeaponId',
    persId: 'persId',
    weaponId: 'weaponId',
    overrideDamage: 'overrideDamage',
    attackBonus: 'attackBonus',
    overrideName: 'overrideName',
    overrideNormalRange: 'overrideNormalRange',
    overrideLongRange: 'overrideLongRange',
    overrideDamageType: 'overrideDamageType',
    overrideAttackAbility: 'overrideAttackAbility',
    isProficient: 'isProficient'
  };

  export type PersWeaponScalarFieldEnum = (typeof PersWeaponScalarFieldEnum)[keyof typeof PersWeaponScalarFieldEnum]


  export const PersArmorScalarFieldEnum: {
    persArmorId: 'persArmorId',
    armorId: 'armorId',
    persId: 'persId',
    overrideBaseAC: 'overrideBaseAC',
    miscACBonus: 'miscACBonus',
    isProficient: 'isProficient',
    equipped: 'equipped'
  };

  export type PersArmorScalarFieldEnum = (typeof PersArmorScalarFieldEnum)[keyof typeof PersArmorScalarFieldEnum]


  export const PersMagicItemScalarFieldEnum: {
    persMagicItemId: 'persMagicItemId',
    persId: 'persId',
    magicItemId: 'magicItemId'
  };

  export type PersMagicItemScalarFieldEnum = (typeof PersMagicItemScalarFieldEnum)[keyof typeof PersMagicItemScalarFieldEnum]


  export const EquipmentPackScalarFieldEnum: {
    equipmentPackId: 'equipmentPackId',
    name: 'name',
    description: 'description',
    items: 'items'
  };

  export type EquipmentPackScalarFieldEnum = (typeof EquipmentPackScalarFieldEnum)[keyof typeof EquipmentPackScalarFieldEnum]


  export const ClassStartingEquipmentOptionScalarFieldEnum: {
    optionId: 'optionId',
    classId: 'classId',
    choiceGroup: 'choiceGroup',
    option: 'option',
    weaponId: 'weaponId',
    armorId: 'armorId',
    equipmentPackId: 'equipmentPackId',
    quantity: 'quantity',
    chooseAnyArmor: 'chooseAnyArmor',
    armorType: 'armorType',
    chooseAnyWeapon: 'chooseAnyWeapon',
    weaponType: 'weaponType',
    weaponCount: 'weaponCount',
    description: 'description'
  };

  export type ClassStartingEquipmentOptionScalarFieldEnum = (typeof ClassStartingEquipmentOptionScalarFieldEnum)[keyof typeof ClassStartingEquipmentOptionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Source'
   */
  export type EnumSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Source'>
    


  /**
   * Reference to a field of type 'Source[]'
   */
  export type ListEnumSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Source[]'>
    


  /**
   * Reference to a field of type 'Ability'
   */
  export type EnumAbilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Ability'>
    


  /**
   * Reference to a field of type 'Ability[]'
   */
  export type ListEnumAbilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Ability[]'>
    


  /**
   * Reference to a field of type 'SpellcastingType'
   */
  export type EnumSpellcastingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpellcastingType'>
    


  /**
   * Reference to a field of type 'SpellcastingType[]'
   */
  export type ListEnumSpellcastingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpellcastingType[]'>
    


  /**
   * Reference to a field of type 'ArmorType[]'
   */
  export type ListEnumArmorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArmorType[]'>
    


  /**
   * Reference to a field of type 'ArmorType'
   */
  export type EnumArmorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArmorType'>
    


  /**
   * Reference to a field of type 'WeaponType[]'
   */
  export type ListEnumWeaponTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeaponType[]'>
    


  /**
   * Reference to a field of type 'WeaponType'
   */
  export type EnumWeaponTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeaponType'>
    


  /**
   * Reference to a field of type 'ToolCategory[]'
   */
  export type ListEnumToolCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ToolCategory[]'>
    


  /**
   * Reference to a field of type 'ToolCategory'
   */
  export type EnumToolCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ToolCategory'>
    


  /**
   * Reference to a field of type 'Language[]'
   */
  export type ListEnumLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Language[]'>
    


  /**
   * Reference to a field of type 'Language'
   */
  export type EnumLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Language'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'RestType'
   */
  export type EnumRestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RestType'>
    


  /**
   * Reference to a field of type 'RestType[]'
   */
  export type ListEnumRestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RestType[]'>
    


  /**
   * Reference to a field of type 'FeatureDisplayType'
   */
  export type EnumFeatureDisplayTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeatureDisplayType'>
    


  /**
   * Reference to a field of type 'FeatureDisplayType[]'
   */
  export type ListEnumFeatureDisplayTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeatureDisplayType[]'>
    


  /**
   * Reference to a field of type 'Races'
   */
  export type EnumRacesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Races'>
    


  /**
   * Reference to a field of type 'Races[]'
   */
  export type ListEnumRacesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Races[]'>
    


  /**
   * Reference to a field of type 'Size[]'
   */
  export type ListEnumSizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Size[]'>
    


  /**
   * Reference to a field of type 'Size'
   */
  export type EnumSizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Size'>
    


  /**
   * Reference to a field of type 'Skills[]'
   */
  export type ListEnumSkillsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Skills[]'>
    


  /**
   * Reference to a field of type 'Skills'
   */
  export type EnumSkillsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Skills'>
    


  /**
   * Reference to a field of type 'WeaponCategory[]'
   */
  export type ListEnumWeaponCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeaponCategory[]'>
    


  /**
   * Reference to a field of type 'WeaponCategory'
   */
  export type EnumWeaponCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeaponCategory'>
    


  /**
   * Reference to a field of type 'Subraces'
   */
  export type EnumSubracesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Subraces'>
    


  /**
   * Reference to a field of type 'Subraces[]'
   */
  export type ListEnumSubracesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Subraces[]'>
    


  /**
   * Reference to a field of type 'Variants'
   */
  export type EnumVariantsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Variants'>
    


  /**
   * Reference to a field of type 'Variants[]'
   */
  export type ListEnumVariantsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Variants[]'>
    


  /**
   * Reference to a field of type 'DamageType'
   */
  export type EnumDamageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DamageType'>
    


  /**
   * Reference to a field of type 'DamageType[]'
   */
  export type ListEnumDamageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DamageType[]'>
    


  /**
   * Reference to a field of type 'AOEShapes'
   */
  export type EnumAOEShapesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AOEShapes'>
    


  /**
   * Reference to a field of type 'AOEShapes[]'
   */
  export type ListEnumAOEShapesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AOEShapes[]'>
    


  /**
   * Reference to a field of type 'BackgroundCategory'
   */
  export type EnumBackgroundCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BackgroundCategory'>
    


  /**
   * Reference to a field of type 'BackgroundCategory[]'
   */
  export type ListEnumBackgroundCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BackgroundCategory[]'>
    


  /**
   * Reference to a field of type 'FeatCategory'
   */
  export type EnumFeatCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeatCategory'>
    


  /**
   * Reference to a field of type 'FeatCategory[]'
   */
  export type ListEnumFeatCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeatCategory[]'>
    


  /**
   * Reference to a field of type 'MagicItemType'
   */
  export type EnumMagicItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MagicItemType'>
    


  /**
   * Reference to a field of type 'MagicItemType[]'
   */
  export type ListEnumMagicItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MagicItemType[]'>
    


  /**
   * Reference to a field of type 'ItemRarity'
   */
  export type EnumItemRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemRarity'>
    


  /**
   * Reference to a field of type 'ItemRarity[]'
   */
  export type ListEnumItemRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemRarity[]'>
    


  /**
   * Reference to a field of type 'WeaponProperty[]'
   */
  export type ListEnumWeaponPropertyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeaponProperty[]'>
    


  /**
   * Reference to a field of type 'WeaponProperty'
   */
  export type EnumWeaponPropertyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeaponProperty'>
    


  /**
   * Reference to a field of type 'ArmorCategory'
   */
  export type EnumArmorCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArmorCategory'>
    


  /**
   * Reference to a field of type 'ArmorCategory[]'
   */
  export type ListEnumArmorCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArmorCategory[]'>
    


  /**
   * Reference to a field of type 'SkillProficiencyType'
   */
  export type EnumSkillProficiencyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillProficiencyType'>
    


  /**
   * Reference to a field of type 'SkillProficiencyType[]'
   */
  export type ListEnumSkillProficiencyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillProficiencyType[]'>
    


  /**
   * Reference to a field of type 'EquipmentPackCategory'
   */
  export type EnumEquipmentPackCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentPackCategory'>
    


  /**
   * Reference to a field of type 'EquipmentPackCategory[]'
   */
  export type ListEnumEquipmentPackCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentPackCategory[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CharacterWhereInput = {
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    characterId?: IntFilter<"Character"> | number
    name?: StringNullableFilter<"Character"> | string | null
    userId?: IntNullableFilter<"Character"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    characterSpells?: CharacterSpellsListRelationFilter
  }

  export type CharacterOrderByWithRelationInput = {
    characterId?: SortOrder
    name?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    characterSpells?: CharacterSpellsOrderByRelationAggregateInput
  }

  export type CharacterWhereUniqueInput = Prisma.AtLeast<{
    characterId?: number
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    name?: StringNullableFilter<"Character"> | string | null
    userId?: IntNullableFilter<"Character"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    characterSpells?: CharacterSpellsListRelationFilter
  }, "characterId">

  export type CharacterOrderByWithAggregationInput = {
    characterId?: SortOrder
    name?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: CharacterCountOrderByAggregateInput
    _avg?: CharacterAvgOrderByAggregateInput
    _max?: CharacterMaxOrderByAggregateInput
    _min?: CharacterMinOrderByAggregateInput
    _sum?: CharacterSumOrderByAggregateInput
  }

  export type CharacterScalarWhereWithAggregatesInput = {
    AND?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    OR?: CharacterScalarWhereWithAggregatesInput[]
    NOT?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    characterId?: IntWithAggregatesFilter<"Character"> | number
    name?: StringNullableWithAggregatesFilter<"Character"> | string | null
    userId?: IntNullableWithAggregatesFilter<"Character"> | number | null
  }

  export type CharacterSpellsWhereInput = {
    AND?: CharacterSpellsWhereInput | CharacterSpellsWhereInput[]
    OR?: CharacterSpellsWhereInput[]
    NOT?: CharacterSpellsWhereInput | CharacterSpellsWhereInput[]
    characterSpellId?: IntFilter<"CharacterSpells"> | number
    characterId?: IntNullableFilter<"CharacterSpells"> | number | null
    spellId?: IntNullableFilter<"CharacterSpells"> | number | null
    character?: XOR<CharacterNullableScalarRelationFilter, CharacterWhereInput> | null
    spell?: XOR<SpellNullableScalarRelationFilter, SpellWhereInput> | null
  }

  export type CharacterSpellsOrderByWithRelationInput = {
    characterSpellId?: SortOrder
    characterId?: SortOrderInput | SortOrder
    spellId?: SortOrderInput | SortOrder
    character?: CharacterOrderByWithRelationInput
    spell?: SpellOrderByWithRelationInput
  }

  export type CharacterSpellsWhereUniqueInput = Prisma.AtLeast<{
    characterSpellId?: number
    AND?: CharacterSpellsWhereInput | CharacterSpellsWhereInput[]
    OR?: CharacterSpellsWhereInput[]
    NOT?: CharacterSpellsWhereInput | CharacterSpellsWhereInput[]
    characterId?: IntNullableFilter<"CharacterSpells"> | number | null
    spellId?: IntNullableFilter<"CharacterSpells"> | number | null
    character?: XOR<CharacterNullableScalarRelationFilter, CharacterWhereInput> | null
    spell?: XOR<SpellNullableScalarRelationFilter, SpellWhereInput> | null
  }, "characterSpellId">

  export type CharacterSpellsOrderByWithAggregationInput = {
    characterSpellId?: SortOrder
    characterId?: SortOrderInput | SortOrder
    spellId?: SortOrderInput | SortOrder
    _count?: CharacterSpellsCountOrderByAggregateInput
    _avg?: CharacterSpellsAvgOrderByAggregateInput
    _max?: CharacterSpellsMaxOrderByAggregateInput
    _min?: CharacterSpellsMinOrderByAggregateInput
    _sum?: CharacterSpellsSumOrderByAggregateInput
  }

  export type CharacterSpellsScalarWhereWithAggregatesInput = {
    AND?: CharacterSpellsScalarWhereWithAggregatesInput | CharacterSpellsScalarWhereWithAggregatesInput[]
    OR?: CharacterSpellsScalarWhereWithAggregatesInput[]
    NOT?: CharacterSpellsScalarWhereWithAggregatesInput | CharacterSpellsScalarWhereWithAggregatesInput[]
    characterSpellId?: IntWithAggregatesFilter<"CharacterSpells"> | number
    characterId?: IntNullableWithAggregatesFilter<"CharacterSpells"> | number | null
    spellId?: IntNullableWithAggregatesFilter<"CharacterSpells"> | number | null
  }

  export type CreatureWhereInput = {
    AND?: CreatureWhereInput | CreatureWhereInput[]
    OR?: CreatureWhereInput[]
    NOT?: CreatureWhereInput | CreatureWhereInput[]
    creatureId?: IntFilter<"Creature"> | number
    name?: StringNullableFilter<"Creature"> | string | null
    nameEng?: StringNullableFilter<"Creature"> | string | null
    size?: StringNullableFilter<"Creature"> | string | null
    type?: StringNullableFilter<"Creature"> | string | null
    alignment?: StringNullableFilter<"Creature"> | string | null
    source?: EnumSourceFilter<"Creature"> | $Enums.Source
    ac?: StringNullableFilter<"Creature"> | string | null
    hp?: StringNullableFilter<"Creature"> | string | null
    speed?: StringNullableFilter<"Creature"> | string | null
    strength?: StringNullableFilter<"Creature"> | string | null
    dexterity?: StringNullableFilter<"Creature"> | string | null
    constitution?: StringNullableFilter<"Creature"> | string | null
    intelligence?: StringNullableFilter<"Creature"> | string | null
    wisdom?: StringNullableFilter<"Creature"> | string | null
    charisma?: StringNullableFilter<"Creature"> | string | null
    skills?: StringNullableFilter<"Creature"> | string | null
    senses?: StringNullableFilter<"Creature"> | string | null
    languages?: StringNullableFilter<"Creature"> | string | null
    challenge?: StringNullableFilter<"Creature"> | string | null
    damageImmunity?: StringNullableFilter<"Creature"> | string | null
    damageResistance?: StringNullableFilter<"Creature"> | string | null
    conditionImmunity?: StringNullableFilter<"Creature"> | string | null
    savingThrows?: StringNullableFilter<"Creature"> | string | null
    specialAbilities?: StringNullableFilter<"Creature"> | string | null
    actions?: StringNullableFilter<"Creature"> | string | null
    reactions?: StringNullableFilter<"Creature"> | string | null
    legendaryActions?: StringNullableFilter<"Creature"> | string | null
    proficiencyBonus?: StringNullableFilter<"Creature"> | string | null
    description?: StringNullableFilter<"Creature"> | string | null
    lairActions?: StringNullableFilter<"Creature"> | string | null
    lairInfo?: StringNullableFilter<"Creature"> | string | null
    regionEffects?: StringNullableFilter<"Creature"> | string | null
    xp?: StringNullableFilter<"Creature"> | string | null
  }

  export type CreatureOrderByWithRelationInput = {
    creatureId?: SortOrder
    name?: SortOrderInput | SortOrder
    nameEng?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    alignment?: SortOrderInput | SortOrder
    source?: SortOrder
    ac?: SortOrderInput | SortOrder
    hp?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    strength?: SortOrderInput | SortOrder
    dexterity?: SortOrderInput | SortOrder
    constitution?: SortOrderInput | SortOrder
    intelligence?: SortOrderInput | SortOrder
    wisdom?: SortOrderInput | SortOrder
    charisma?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    senses?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    challenge?: SortOrderInput | SortOrder
    damageImmunity?: SortOrderInput | SortOrder
    damageResistance?: SortOrderInput | SortOrder
    conditionImmunity?: SortOrderInput | SortOrder
    savingThrows?: SortOrderInput | SortOrder
    specialAbilities?: SortOrderInput | SortOrder
    actions?: SortOrderInput | SortOrder
    reactions?: SortOrderInput | SortOrder
    legendaryActions?: SortOrderInput | SortOrder
    proficiencyBonus?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    lairActions?: SortOrderInput | SortOrder
    lairInfo?: SortOrderInput | SortOrder
    regionEffects?: SortOrderInput | SortOrder
    xp?: SortOrderInput | SortOrder
  }

  export type CreatureWhereUniqueInput = Prisma.AtLeast<{
    creatureId?: number
    AND?: CreatureWhereInput | CreatureWhereInput[]
    OR?: CreatureWhereInput[]
    NOT?: CreatureWhereInput | CreatureWhereInput[]
    name?: StringNullableFilter<"Creature"> | string | null
    nameEng?: StringNullableFilter<"Creature"> | string | null
    size?: StringNullableFilter<"Creature"> | string | null
    type?: StringNullableFilter<"Creature"> | string | null
    alignment?: StringNullableFilter<"Creature"> | string | null
    source?: EnumSourceFilter<"Creature"> | $Enums.Source
    ac?: StringNullableFilter<"Creature"> | string | null
    hp?: StringNullableFilter<"Creature"> | string | null
    speed?: StringNullableFilter<"Creature"> | string | null
    strength?: StringNullableFilter<"Creature"> | string | null
    dexterity?: StringNullableFilter<"Creature"> | string | null
    constitution?: StringNullableFilter<"Creature"> | string | null
    intelligence?: StringNullableFilter<"Creature"> | string | null
    wisdom?: StringNullableFilter<"Creature"> | string | null
    charisma?: StringNullableFilter<"Creature"> | string | null
    skills?: StringNullableFilter<"Creature"> | string | null
    senses?: StringNullableFilter<"Creature"> | string | null
    languages?: StringNullableFilter<"Creature"> | string | null
    challenge?: StringNullableFilter<"Creature"> | string | null
    damageImmunity?: StringNullableFilter<"Creature"> | string | null
    damageResistance?: StringNullableFilter<"Creature"> | string | null
    conditionImmunity?: StringNullableFilter<"Creature"> | string | null
    savingThrows?: StringNullableFilter<"Creature"> | string | null
    specialAbilities?: StringNullableFilter<"Creature"> | string | null
    actions?: StringNullableFilter<"Creature"> | string | null
    reactions?: StringNullableFilter<"Creature"> | string | null
    legendaryActions?: StringNullableFilter<"Creature"> | string | null
    proficiencyBonus?: StringNullableFilter<"Creature"> | string | null
    description?: StringNullableFilter<"Creature"> | string | null
    lairActions?: StringNullableFilter<"Creature"> | string | null
    lairInfo?: StringNullableFilter<"Creature"> | string | null
    regionEffects?: StringNullableFilter<"Creature"> | string | null
    xp?: StringNullableFilter<"Creature"> | string | null
  }, "creatureId">

  export type CreatureOrderByWithAggregationInput = {
    creatureId?: SortOrder
    name?: SortOrderInput | SortOrder
    nameEng?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    alignment?: SortOrderInput | SortOrder
    source?: SortOrder
    ac?: SortOrderInput | SortOrder
    hp?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    strength?: SortOrderInput | SortOrder
    dexterity?: SortOrderInput | SortOrder
    constitution?: SortOrderInput | SortOrder
    intelligence?: SortOrderInput | SortOrder
    wisdom?: SortOrderInput | SortOrder
    charisma?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    senses?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    challenge?: SortOrderInput | SortOrder
    damageImmunity?: SortOrderInput | SortOrder
    damageResistance?: SortOrderInput | SortOrder
    conditionImmunity?: SortOrderInput | SortOrder
    savingThrows?: SortOrderInput | SortOrder
    specialAbilities?: SortOrderInput | SortOrder
    actions?: SortOrderInput | SortOrder
    reactions?: SortOrderInput | SortOrder
    legendaryActions?: SortOrderInput | SortOrder
    proficiencyBonus?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    lairActions?: SortOrderInput | SortOrder
    lairInfo?: SortOrderInput | SortOrder
    regionEffects?: SortOrderInput | SortOrder
    xp?: SortOrderInput | SortOrder
    _count?: CreatureCountOrderByAggregateInput
    _avg?: CreatureAvgOrderByAggregateInput
    _max?: CreatureMaxOrderByAggregateInput
    _min?: CreatureMinOrderByAggregateInput
    _sum?: CreatureSumOrderByAggregateInput
  }

  export type CreatureScalarWhereWithAggregatesInput = {
    AND?: CreatureScalarWhereWithAggregatesInput | CreatureScalarWhereWithAggregatesInput[]
    OR?: CreatureScalarWhereWithAggregatesInput[]
    NOT?: CreatureScalarWhereWithAggregatesInput | CreatureScalarWhereWithAggregatesInput[]
    creatureId?: IntWithAggregatesFilter<"Creature"> | number
    name?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    nameEng?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    size?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    type?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    alignment?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    source?: EnumSourceWithAggregatesFilter<"Creature"> | $Enums.Source
    ac?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    hp?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    speed?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    strength?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    dexterity?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    constitution?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    intelligence?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    wisdom?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    charisma?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    skills?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    senses?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    languages?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    challenge?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    damageImmunity?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    damageResistance?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    conditionImmunity?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    savingThrows?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    specialAbilities?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    actions?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    reactions?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    legendaryActions?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    proficiencyBonus?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    description?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    lairActions?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    lairInfo?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    regionEffects?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    xp?: StringNullableWithAggregatesFilter<"Creature"> | string | null
  }

  export type SpellWhereInput = {
    AND?: SpellWhereInput | SpellWhereInput[]
    OR?: SpellWhereInput[]
    NOT?: SpellWhereInput | SpellWhereInput[]
    spellId?: IntFilter<"Spell"> | number
    name?: StringFilter<"Spell"> | string
    level?: IntFilter<"Spell"> | number
    school?: StringNullableFilter<"Spell"> | string | null
    castingTime?: StringFilter<"Spell"> | string
    range?: StringFilter<"Spell"> | string
    components?: StringNullableFilter<"Spell"> | string | null
    duration?: StringFilter<"Spell"> | string
    description?: StringFilter<"Spell"> | string
    hasRitual?: StringNullableFilter<"Spell"> | string | null
    hasConcentration?: StringNullableFilter<"Spell"> | string | null
    source?: EnumSourceFilter<"Spell"> | $Enums.Source
    characterSpells?: CharacterSpellsListRelationFilter
    spellClasses?: SpellClassesListRelationFilter
    spellRaces?: SpellRacesListRelationFilter
    spellbookSpells?: SpellbookSpellsListRelationFilter
    subclasses?: SubclassListRelationFilter
    perses?: PersListRelationFilter
    features?: FeatureListRelationFilter
  }

  export type SpellOrderByWithRelationInput = {
    spellId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    school?: SortOrderInput | SortOrder
    castingTime?: SortOrder
    range?: SortOrder
    components?: SortOrderInput | SortOrder
    duration?: SortOrder
    description?: SortOrder
    hasRitual?: SortOrderInput | SortOrder
    hasConcentration?: SortOrderInput | SortOrder
    source?: SortOrder
    characterSpells?: CharacterSpellsOrderByRelationAggregateInput
    spellClasses?: SpellClassesOrderByRelationAggregateInput
    spellRaces?: SpellRacesOrderByRelationAggregateInput
    spellbookSpells?: SpellbookSpellsOrderByRelationAggregateInput
    subclasses?: SubclassOrderByRelationAggregateInput
    perses?: PersOrderByRelationAggregateInput
    features?: FeatureOrderByRelationAggregateInput
  }

  export type SpellWhereUniqueInput = Prisma.AtLeast<{
    spellId?: number
    name?: string
    AND?: SpellWhereInput | SpellWhereInput[]
    OR?: SpellWhereInput[]
    NOT?: SpellWhereInput | SpellWhereInput[]
    level?: IntFilter<"Spell"> | number
    school?: StringNullableFilter<"Spell"> | string | null
    castingTime?: StringFilter<"Spell"> | string
    range?: StringFilter<"Spell"> | string
    components?: StringNullableFilter<"Spell"> | string | null
    duration?: StringFilter<"Spell"> | string
    description?: StringFilter<"Spell"> | string
    hasRitual?: StringNullableFilter<"Spell"> | string | null
    hasConcentration?: StringNullableFilter<"Spell"> | string | null
    source?: EnumSourceFilter<"Spell"> | $Enums.Source
    characterSpells?: CharacterSpellsListRelationFilter
    spellClasses?: SpellClassesListRelationFilter
    spellRaces?: SpellRacesListRelationFilter
    spellbookSpells?: SpellbookSpellsListRelationFilter
    subclasses?: SubclassListRelationFilter
    perses?: PersListRelationFilter
    features?: FeatureListRelationFilter
  }, "spellId" | "name">

  export type SpellOrderByWithAggregationInput = {
    spellId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    school?: SortOrderInput | SortOrder
    castingTime?: SortOrder
    range?: SortOrder
    components?: SortOrderInput | SortOrder
    duration?: SortOrder
    description?: SortOrder
    hasRitual?: SortOrderInput | SortOrder
    hasConcentration?: SortOrderInput | SortOrder
    source?: SortOrder
    _count?: SpellCountOrderByAggregateInput
    _avg?: SpellAvgOrderByAggregateInput
    _max?: SpellMaxOrderByAggregateInput
    _min?: SpellMinOrderByAggregateInput
    _sum?: SpellSumOrderByAggregateInput
  }

  export type SpellScalarWhereWithAggregatesInput = {
    AND?: SpellScalarWhereWithAggregatesInput | SpellScalarWhereWithAggregatesInput[]
    OR?: SpellScalarWhereWithAggregatesInput[]
    NOT?: SpellScalarWhereWithAggregatesInput | SpellScalarWhereWithAggregatesInput[]
    spellId?: IntWithAggregatesFilter<"Spell"> | number
    name?: StringWithAggregatesFilter<"Spell"> | string
    level?: IntWithAggregatesFilter<"Spell"> | number
    school?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    castingTime?: StringWithAggregatesFilter<"Spell"> | string
    range?: StringWithAggregatesFilter<"Spell"> | string
    components?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    duration?: StringWithAggregatesFilter<"Spell"> | string
    description?: StringWithAggregatesFilter<"Spell"> | string
    hasRitual?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    hasConcentration?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    source?: EnumSourceWithAggregatesFilter<"Spell"> | $Enums.Source
  }

  export type SpellClassesWhereInput = {
    AND?: SpellClassesWhereInput | SpellClassesWhereInput[]
    OR?: SpellClassesWhereInput[]
    NOT?: SpellClassesWhereInput | SpellClassesWhereInput[]
    classId?: IntFilter<"SpellClasses"> | number
    spellId?: IntFilter<"SpellClasses"> | number
    className?: StringFilter<"SpellClasses"> | string
    spell?: XOR<SpellScalarRelationFilter, SpellWhereInput>
  }

  export type SpellClassesOrderByWithRelationInput = {
    classId?: SortOrder
    spellId?: SortOrder
    className?: SortOrder
    spell?: SpellOrderByWithRelationInput
  }

  export type SpellClassesWhereUniqueInput = Prisma.AtLeast<{
    classId?: number
    AND?: SpellClassesWhereInput | SpellClassesWhereInput[]
    OR?: SpellClassesWhereInput[]
    NOT?: SpellClassesWhereInput | SpellClassesWhereInput[]
    spellId?: IntFilter<"SpellClasses"> | number
    className?: StringFilter<"SpellClasses"> | string
    spell?: XOR<SpellScalarRelationFilter, SpellWhereInput>
  }, "classId">

  export type SpellClassesOrderByWithAggregationInput = {
    classId?: SortOrder
    spellId?: SortOrder
    className?: SortOrder
    _count?: SpellClassesCountOrderByAggregateInput
    _avg?: SpellClassesAvgOrderByAggregateInput
    _max?: SpellClassesMaxOrderByAggregateInput
    _min?: SpellClassesMinOrderByAggregateInput
    _sum?: SpellClassesSumOrderByAggregateInput
  }

  export type SpellClassesScalarWhereWithAggregatesInput = {
    AND?: SpellClassesScalarWhereWithAggregatesInput | SpellClassesScalarWhereWithAggregatesInput[]
    OR?: SpellClassesScalarWhereWithAggregatesInput[]
    NOT?: SpellClassesScalarWhereWithAggregatesInput | SpellClassesScalarWhereWithAggregatesInput[]
    classId?: IntWithAggregatesFilter<"SpellClasses"> | number
    spellId?: IntWithAggregatesFilter<"SpellClasses"> | number
    className?: StringWithAggregatesFilter<"SpellClasses"> | string
  }

  export type SpellRacesWhereInput = {
    AND?: SpellRacesWhereInput | SpellRacesWhereInput[]
    OR?: SpellRacesWhereInput[]
    NOT?: SpellRacesWhereInput | SpellRacesWhereInput[]
    spellId?: IntNullableFilter<"SpellRaces"> | number | null
    raceId?: IntFilter<"SpellRaces"> | number
    raceName?: StringNullableFilter<"SpellRaces"> | string | null
    spell?: XOR<SpellNullableScalarRelationFilter, SpellWhereInput> | null
  }

  export type SpellRacesOrderByWithRelationInput = {
    spellId?: SortOrderInput | SortOrder
    raceId?: SortOrder
    raceName?: SortOrderInput | SortOrder
    spell?: SpellOrderByWithRelationInput
  }

  export type SpellRacesWhereUniqueInput = Prisma.AtLeast<{
    raceId?: number
    AND?: SpellRacesWhereInput | SpellRacesWhereInput[]
    OR?: SpellRacesWhereInput[]
    NOT?: SpellRacesWhereInput | SpellRacesWhereInput[]
    spellId?: IntNullableFilter<"SpellRaces"> | number | null
    raceName?: StringNullableFilter<"SpellRaces"> | string | null
    spell?: XOR<SpellNullableScalarRelationFilter, SpellWhereInput> | null
  }, "raceId">

  export type SpellRacesOrderByWithAggregationInput = {
    spellId?: SortOrderInput | SortOrder
    raceId?: SortOrder
    raceName?: SortOrderInput | SortOrder
    _count?: SpellRacesCountOrderByAggregateInput
    _avg?: SpellRacesAvgOrderByAggregateInput
    _max?: SpellRacesMaxOrderByAggregateInput
    _min?: SpellRacesMinOrderByAggregateInput
    _sum?: SpellRacesSumOrderByAggregateInput
  }

  export type SpellRacesScalarWhereWithAggregatesInput = {
    AND?: SpellRacesScalarWhereWithAggregatesInput | SpellRacesScalarWhereWithAggregatesInput[]
    OR?: SpellRacesScalarWhereWithAggregatesInput[]
    NOT?: SpellRacesScalarWhereWithAggregatesInput | SpellRacesScalarWhereWithAggregatesInput[]
    spellId?: IntNullableWithAggregatesFilter<"SpellRaces"> | number | null
    raceId?: IntWithAggregatesFilter<"SpellRaces"> | number
    raceName?: StringNullableWithAggregatesFilter<"SpellRaces"> | string | null
  }

  export type SpellbookWhereInput = {
    AND?: SpellbookWhereInput | SpellbookWhereInput[]
    OR?: SpellbookWhereInput[]
    NOT?: SpellbookWhereInput | SpellbookWhereInput[]
    spellbookId?: IntFilter<"Spellbook"> | number
    userId?: IntNullableFilter<"Spellbook"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    spellbookSpells?: SpellbookSpellsListRelationFilter
  }

  export type SpellbookOrderByWithRelationInput = {
    spellbookId?: SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    spellbookSpells?: SpellbookSpellsOrderByRelationAggregateInput
  }

  export type SpellbookWhereUniqueInput = Prisma.AtLeast<{
    spellbookId?: number
    AND?: SpellbookWhereInput | SpellbookWhereInput[]
    OR?: SpellbookWhereInput[]
    NOT?: SpellbookWhereInput | SpellbookWhereInput[]
    userId?: IntNullableFilter<"Spellbook"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    spellbookSpells?: SpellbookSpellsListRelationFilter
  }, "spellbookId">

  export type SpellbookOrderByWithAggregationInput = {
    spellbookId?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: SpellbookCountOrderByAggregateInput
    _avg?: SpellbookAvgOrderByAggregateInput
    _max?: SpellbookMaxOrderByAggregateInput
    _min?: SpellbookMinOrderByAggregateInput
    _sum?: SpellbookSumOrderByAggregateInput
  }

  export type SpellbookScalarWhereWithAggregatesInput = {
    AND?: SpellbookScalarWhereWithAggregatesInput | SpellbookScalarWhereWithAggregatesInput[]
    OR?: SpellbookScalarWhereWithAggregatesInput[]
    NOT?: SpellbookScalarWhereWithAggregatesInput | SpellbookScalarWhereWithAggregatesInput[]
    spellbookId?: IntWithAggregatesFilter<"Spellbook"> | number
    userId?: IntNullableWithAggregatesFilter<"Spellbook"> | number | null
  }

  export type SpellbookSpellsWhereInput = {
    AND?: SpellbookSpellsWhereInput | SpellbookSpellsWhereInput[]
    OR?: SpellbookSpellsWhereInput[]
    NOT?: SpellbookSpellsWhereInput | SpellbookSpellsWhereInput[]
    spellbookSpellId?: IntFilter<"SpellbookSpells"> | number
    spellId?: IntNullableFilter<"SpellbookSpells"> | number | null
    spellbookId?: IntNullableFilter<"SpellbookSpells"> | number | null
    spell?: XOR<SpellNullableScalarRelationFilter, SpellWhereInput> | null
    spellbook?: XOR<SpellbookNullableScalarRelationFilter, SpellbookWhereInput> | null
  }

  export type SpellbookSpellsOrderByWithRelationInput = {
    spellbookSpellId?: SortOrder
    spellId?: SortOrderInput | SortOrder
    spellbookId?: SortOrderInput | SortOrder
    spell?: SpellOrderByWithRelationInput
    spellbook?: SpellbookOrderByWithRelationInput
  }

  export type SpellbookSpellsWhereUniqueInput = Prisma.AtLeast<{
    spellbookSpellId?: number
    AND?: SpellbookSpellsWhereInput | SpellbookSpellsWhereInput[]
    OR?: SpellbookSpellsWhereInput[]
    NOT?: SpellbookSpellsWhereInput | SpellbookSpellsWhereInput[]
    spellId?: IntNullableFilter<"SpellbookSpells"> | number | null
    spellbookId?: IntNullableFilter<"SpellbookSpells"> | number | null
    spell?: XOR<SpellNullableScalarRelationFilter, SpellWhereInput> | null
    spellbook?: XOR<SpellbookNullableScalarRelationFilter, SpellbookWhereInput> | null
  }, "spellbookSpellId">

  export type SpellbookSpellsOrderByWithAggregationInput = {
    spellbookSpellId?: SortOrder
    spellId?: SortOrderInput | SortOrder
    spellbookId?: SortOrderInput | SortOrder
    _count?: SpellbookSpellsCountOrderByAggregateInput
    _avg?: SpellbookSpellsAvgOrderByAggregateInput
    _max?: SpellbookSpellsMaxOrderByAggregateInput
    _min?: SpellbookSpellsMinOrderByAggregateInput
    _sum?: SpellbookSpellsSumOrderByAggregateInput
  }

  export type SpellbookSpellsScalarWhereWithAggregatesInput = {
    AND?: SpellbookSpellsScalarWhereWithAggregatesInput | SpellbookSpellsScalarWhereWithAggregatesInput[]
    OR?: SpellbookSpellsScalarWhereWithAggregatesInput[]
    NOT?: SpellbookSpellsScalarWhereWithAggregatesInput | SpellbookSpellsScalarWhereWithAggregatesInput[]
    spellbookSpellId?: IntWithAggregatesFilter<"SpellbookSpells"> | number
    spellId?: IntNullableWithAggregatesFilter<"SpellbookSpells"> | number | null
    spellbookId?: IntNullableWithAggregatesFilter<"SpellbookSpells"> | number | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    userId?: IntFilter<"User"> | number
    login?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    character?: CharacterListRelationFilter
    spellbook?: SpellbookListRelationFilter
    pers?: PersListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    userId?: SortOrder
    login?: SortOrder
    password?: SortOrderInput | SortOrder
    character?: CharacterOrderByRelationAggregateInput
    spellbook?: SpellbookOrderByRelationAggregateInput
    pers?: PersOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    userId?: number
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    login?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    character?: CharacterListRelationFilter
    spellbook?: SpellbookListRelationFilter
    pers?: PersListRelationFilter
  }, "userId">

  export type UserOrderByWithAggregationInput = {
    userId?: SortOrder
    login?: SortOrder
    password?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"User"> | number
    login?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    classId?: IntFilter<"Class"> | number
    name?: StringFilter<"Class"> | string
    hitDie?: IntFilter<"Class"> | number
    primaryCastingStat?: EnumAbilityNullableFilter<"Class"> | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFilter<"Class"> | $Enums.SpellcastingType
    abilityScoreUpLevels?: IntNullableListFilter<"Class">
    subclassLevel?: IntFilter<"Class"> | number
    multiclassStrReq?: IntFilter<"Class"> | number
    multiclassDexReq?: IntFilter<"Class"> | number
    multiclassConReq?: IntFilter<"Class"> | number
    multiclassIntReq?: IntFilter<"Class"> | number
    multiclassWisReq?: IntFilter<"Class"> | number
    multiclassChaReq?: IntFilter<"Class"> | number
    armorProficiencies?: EnumArmorTypeNullableListFilter<"Class">
    weaponProficiencies?: EnumWeaponTypeNullableListFilter<"Class">
    savingThrows?: EnumAbilityNullableListFilter<"Class">
    skillProficiencies?: EnumAbilityNullableListFilter<"Class">
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Class">
    languagesToChooseCount?: IntFilter<"Class"> | number
    languages?: EnumLanguageNullableListFilter<"Class">
    specialSpellSlotProgression?: JsonNullableFilter<"Class">
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    subclasses?: SubclassListRelationFilter
    classFeatures?: ClassFeatureListRelationFilter
    perses?: PersListRelationFilter
    persMulticlasses?: PersMulticlassListRelationFilter
    startingEquipmentOption?: ClassStartingEquipmentOptionListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    classId?: SortOrder
    name?: SortOrder
    hitDie?: SortOrder
    primaryCastingStat?: SortOrderInput | SortOrder
    spellcastingType?: SortOrder
    abilityScoreUpLevels?: SortOrder
    subclassLevel?: SortOrder
    multiclassStrReq?: SortOrder
    multiclassDexReq?: SortOrder
    multiclassConReq?: SortOrder
    multiclassIntReq?: SortOrder
    multiclassWisReq?: SortOrder
    multiclassChaReq?: SortOrder
    armorProficiencies?: SortOrder
    weaponProficiencies?: SortOrder
    savingThrows?: SortOrder
    skillProficiencies?: SortOrder
    toolProficiencies?: SortOrder
    languagesToChooseCount?: SortOrder
    languages?: SortOrder
    specialSpellSlotProgression?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subclasses?: SubclassOrderByRelationAggregateInput
    classFeatures?: ClassFeatureOrderByRelationAggregateInput
    perses?: PersOrderByRelationAggregateInput
    persMulticlasses?: PersMulticlassOrderByRelationAggregateInput
    startingEquipmentOption?: ClassStartingEquipmentOptionOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    classId?: number
    name?: string
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    hitDie?: IntFilter<"Class"> | number
    primaryCastingStat?: EnumAbilityNullableFilter<"Class"> | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFilter<"Class"> | $Enums.SpellcastingType
    abilityScoreUpLevels?: IntNullableListFilter<"Class">
    subclassLevel?: IntFilter<"Class"> | number
    multiclassStrReq?: IntFilter<"Class"> | number
    multiclassDexReq?: IntFilter<"Class"> | number
    multiclassConReq?: IntFilter<"Class"> | number
    multiclassIntReq?: IntFilter<"Class"> | number
    multiclassWisReq?: IntFilter<"Class"> | number
    multiclassChaReq?: IntFilter<"Class"> | number
    armorProficiencies?: EnumArmorTypeNullableListFilter<"Class">
    weaponProficiencies?: EnumWeaponTypeNullableListFilter<"Class">
    savingThrows?: EnumAbilityNullableListFilter<"Class">
    skillProficiencies?: EnumAbilityNullableListFilter<"Class">
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Class">
    languagesToChooseCount?: IntFilter<"Class"> | number
    languages?: EnumLanguageNullableListFilter<"Class">
    specialSpellSlotProgression?: JsonNullableFilter<"Class">
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    subclasses?: SubclassListRelationFilter
    classFeatures?: ClassFeatureListRelationFilter
    perses?: PersListRelationFilter
    persMulticlasses?: PersMulticlassListRelationFilter
    startingEquipmentOption?: ClassStartingEquipmentOptionListRelationFilter
  }, "classId" | "name">

  export type ClassOrderByWithAggregationInput = {
    classId?: SortOrder
    name?: SortOrder
    hitDie?: SortOrder
    primaryCastingStat?: SortOrderInput | SortOrder
    spellcastingType?: SortOrder
    abilityScoreUpLevels?: SortOrder
    subclassLevel?: SortOrder
    multiclassStrReq?: SortOrder
    multiclassDexReq?: SortOrder
    multiclassConReq?: SortOrder
    multiclassIntReq?: SortOrder
    multiclassWisReq?: SortOrder
    multiclassChaReq?: SortOrder
    armorProficiencies?: SortOrder
    weaponProficiencies?: SortOrder
    savingThrows?: SortOrder
    skillProficiencies?: SortOrder
    toolProficiencies?: SortOrder
    languagesToChooseCount?: SortOrder
    languages?: SortOrder
    specialSpellSlotProgression?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _avg?: ClassAvgOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
    _sum?: ClassSumOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    classId?: IntWithAggregatesFilter<"Class"> | number
    name?: StringWithAggregatesFilter<"Class"> | string
    hitDie?: IntWithAggregatesFilter<"Class"> | number
    primaryCastingStat?: EnumAbilityNullableWithAggregatesFilter<"Class"> | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeWithAggregatesFilter<"Class"> | $Enums.SpellcastingType
    abilityScoreUpLevels?: IntNullableListFilter<"Class">
    subclassLevel?: IntWithAggregatesFilter<"Class"> | number
    multiclassStrReq?: IntWithAggregatesFilter<"Class"> | number
    multiclassDexReq?: IntWithAggregatesFilter<"Class"> | number
    multiclassConReq?: IntWithAggregatesFilter<"Class"> | number
    multiclassIntReq?: IntWithAggregatesFilter<"Class"> | number
    multiclassWisReq?: IntWithAggregatesFilter<"Class"> | number
    multiclassChaReq?: IntWithAggregatesFilter<"Class"> | number
    armorProficiencies?: EnumArmorTypeNullableListFilter<"Class">
    weaponProficiencies?: EnumWeaponTypeNullableListFilter<"Class">
    savingThrows?: EnumAbilityNullableListFilter<"Class">
    skillProficiencies?: EnumAbilityNullableListFilter<"Class">
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Class">
    languagesToChooseCount?: IntWithAggregatesFilter<"Class"> | number
    languages?: EnumLanguageNullableListFilter<"Class">
    specialSpellSlotProgression?: JsonNullableWithAggregatesFilter<"Class">
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
  }

  export type SubclassWhereInput = {
    AND?: SubclassWhereInput | SubclassWhereInput[]
    OR?: SubclassWhereInput[]
    NOT?: SubclassWhereInput | SubclassWhereInput[]
    subclassId?: IntFilter<"Subclass"> | number
    classId?: IntFilter<"Subclass"> | number
    name?: StringFilter<"Subclass"> | string
    description?: StringNullableFilter<"Subclass"> | string | null
    grantsSpells?: BoolFilter<"Subclass"> | boolean
    languagesToChooseCount?: IntFilter<"Subclass"> | number
    languages?: EnumLanguageNullableListFilter<"Subclass">
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Subclass">
    expandedSpells?: SpellListRelationFilter
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    features?: SubclassFeatureListRelationFilter
    perses?: PersListRelationFilter
    persMulticlasses?: PersMulticlassListRelationFilter
  }

  export type SubclassOrderByWithRelationInput = {
    subclassId?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    grantsSpells?: SortOrder
    languagesToChooseCount?: SortOrder
    languages?: SortOrder
    toolProficiencies?: SortOrder
    expandedSpells?: SpellOrderByRelationAggregateInput
    class?: ClassOrderByWithRelationInput
    features?: SubclassFeatureOrderByRelationAggregateInput
    perses?: PersOrderByRelationAggregateInput
    persMulticlasses?: PersMulticlassOrderByRelationAggregateInput
  }

  export type SubclassWhereUniqueInput = Prisma.AtLeast<{
    subclassId?: number
    classId_name?: SubclassClassIdNameCompoundUniqueInput
    AND?: SubclassWhereInput | SubclassWhereInput[]
    OR?: SubclassWhereInput[]
    NOT?: SubclassWhereInput | SubclassWhereInput[]
    classId?: IntFilter<"Subclass"> | number
    name?: StringFilter<"Subclass"> | string
    description?: StringNullableFilter<"Subclass"> | string | null
    grantsSpells?: BoolFilter<"Subclass"> | boolean
    languagesToChooseCount?: IntFilter<"Subclass"> | number
    languages?: EnumLanguageNullableListFilter<"Subclass">
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Subclass">
    expandedSpells?: SpellListRelationFilter
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    features?: SubclassFeatureListRelationFilter
    perses?: PersListRelationFilter
    persMulticlasses?: PersMulticlassListRelationFilter
  }, "subclassId" | "classId_name">

  export type SubclassOrderByWithAggregationInput = {
    subclassId?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    grantsSpells?: SortOrder
    languagesToChooseCount?: SortOrder
    languages?: SortOrder
    toolProficiencies?: SortOrder
    _count?: SubclassCountOrderByAggregateInput
    _avg?: SubclassAvgOrderByAggregateInput
    _max?: SubclassMaxOrderByAggregateInput
    _min?: SubclassMinOrderByAggregateInput
    _sum?: SubclassSumOrderByAggregateInput
  }

  export type SubclassScalarWhereWithAggregatesInput = {
    AND?: SubclassScalarWhereWithAggregatesInput | SubclassScalarWhereWithAggregatesInput[]
    OR?: SubclassScalarWhereWithAggregatesInput[]
    NOT?: SubclassScalarWhereWithAggregatesInput | SubclassScalarWhereWithAggregatesInput[]
    subclassId?: IntWithAggregatesFilter<"Subclass"> | number
    classId?: IntWithAggregatesFilter<"Subclass"> | number
    name?: StringWithAggregatesFilter<"Subclass"> | string
    description?: StringNullableWithAggregatesFilter<"Subclass"> | string | null
    grantsSpells?: BoolWithAggregatesFilter<"Subclass"> | boolean
    languagesToChooseCount?: IntWithAggregatesFilter<"Subclass"> | number
    languages?: EnumLanguageNullableListFilter<"Subclass">
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Subclass">
  }

  export type PersWhereInput = {
    AND?: PersWhereInput | PersWhereInput[]
    OR?: PersWhereInput[]
    NOT?: PersWhereInput | PersWhereInput[]
    persId?: IntFilter<"Pers"> | number
    userId?: IntFilter<"Pers"> | number
    name?: StringFilter<"Pers"> | string
    level?: IntFilter<"Pers"> | number
    currentSpellSlots?: IntNullableListFilter<"Pers">
    classId?: IntFilter<"Pers"> | number
    subclassId?: IntNullableFilter<"Pers"> | number | null
    backgroundId?: IntFilter<"Pers"> | number
    raceId?: IntFilter<"Pers"> | number
    subraceId?: IntNullableFilter<"Pers"> | number | null
    currentHp?: IntFilter<"Pers"> | number
    maxHp?: IntFilter<"Pers"> | number
    tempHp?: IntFilter<"Pers"> | number
    raceCustom?: StringFilter<"Pers"> | string
    classCustom?: StringFilter<"Pers"> | string
    alignment?: StringFilter<"Pers"> | string
    xp?: IntFilter<"Pers"> | number
    customBackground?: StringFilter<"Pers"> | string
    customFeatures?: StringFilter<"Pers"> | string
    customLanguagesKnown?: StringFilter<"Pers"> | string
    customEquipment?: StringFilter<"Pers"> | string
    personalityTraits?: StringFilter<"Pers"> | string
    ideals?: StringFilter<"Pers"> | string
    bonds?: StringFilter<"Pers"> | string
    flaws?: StringFilter<"Pers"> | string
    backstory?: StringFilter<"Pers"> | string
    notes?: StringFilter<"Pers"> | string
    str?: IntFilter<"Pers"> | number
    dex?: IntFilter<"Pers"> | number
    con?: IntFilter<"Pers"> | number
    int?: IntFilter<"Pers"> | number
    wis?: IntFilter<"Pers"> | number
    cha?: IntFilter<"Pers"> | number
    cp?: IntFilter<"Pers"> | number
    sp?: IntFilter<"Pers"> | number
    ep?: IntFilter<"Pers"> | number
    gp?: IntFilter<"Pers"> | number
    pp?: IntFilter<"Pers"> | number
    additionalSaveProficiencies?: EnumAbilityNullableListFilter<"Pers">
    miscSaveBonuses?: JsonNullableFilter<"Pers">
    createdAt?: DateTimeFilter<"Pers"> | Date | string
    updatedAt?: DateTimeFilter<"Pers"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subclass?: XOR<SubclassNullableScalarRelationFilter, SubclassWhereInput> | null
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    subrace?: XOR<SubraceNullableScalarRelationFilter, SubraceWhereInput> | null
    background?: XOR<BackgroundScalarRelationFilter, BackgroundWhereInput>
    skills?: PersSkillListRelationFilter
    multiclasses?: PersMulticlassListRelationFilter
    features?: PersFeatureListRelationFilter
    spells?: SpellListRelationFilter
    feats?: PersFeatListRelationFilter
    armors?: PersArmorListRelationFilter
    weapons?: PersWeaponListRelationFilter
    magicItems?: PersMagicItemListRelationFilter
    raceVariants?: RaceVariantListRelationFilter
    raceChoiceOptions?: RaceChoiceOptionListRelationFilter
  }

  export type PersOrderByWithRelationInput = {
    persId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    currentSpellSlots?: SortOrder
    classId?: SortOrder
    subclassId?: SortOrderInput | SortOrder
    backgroundId?: SortOrder
    raceId?: SortOrder
    subraceId?: SortOrderInput | SortOrder
    currentHp?: SortOrder
    maxHp?: SortOrder
    tempHp?: SortOrder
    raceCustom?: SortOrder
    classCustom?: SortOrder
    alignment?: SortOrder
    xp?: SortOrder
    customBackground?: SortOrder
    customFeatures?: SortOrder
    customLanguagesKnown?: SortOrder
    customEquipment?: SortOrder
    personalityTraits?: SortOrder
    ideals?: SortOrder
    bonds?: SortOrder
    flaws?: SortOrder
    backstory?: SortOrder
    notes?: SortOrder
    str?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    int?: SortOrder
    wis?: SortOrder
    cha?: SortOrder
    cp?: SortOrder
    sp?: SortOrder
    ep?: SortOrder
    gp?: SortOrder
    pp?: SortOrder
    additionalSaveProficiencies?: SortOrder
    miscSaveBonuses?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    subclass?: SubclassOrderByWithRelationInput
    race?: RaceOrderByWithRelationInput
    subrace?: SubraceOrderByWithRelationInput
    background?: BackgroundOrderByWithRelationInput
    skills?: PersSkillOrderByRelationAggregateInput
    multiclasses?: PersMulticlassOrderByRelationAggregateInput
    features?: PersFeatureOrderByRelationAggregateInput
    spells?: SpellOrderByRelationAggregateInput
    feats?: PersFeatOrderByRelationAggregateInput
    armors?: PersArmorOrderByRelationAggregateInput
    weapons?: PersWeaponOrderByRelationAggregateInput
    magicItems?: PersMagicItemOrderByRelationAggregateInput
    raceVariants?: RaceVariantOrderByRelationAggregateInput
    raceChoiceOptions?: RaceChoiceOptionOrderByRelationAggregateInput
  }

  export type PersWhereUniqueInput = Prisma.AtLeast<{
    persId?: number
    AND?: PersWhereInput | PersWhereInput[]
    OR?: PersWhereInput[]
    NOT?: PersWhereInput | PersWhereInput[]
    userId?: IntFilter<"Pers"> | number
    name?: StringFilter<"Pers"> | string
    level?: IntFilter<"Pers"> | number
    currentSpellSlots?: IntNullableListFilter<"Pers">
    classId?: IntFilter<"Pers"> | number
    subclassId?: IntNullableFilter<"Pers"> | number | null
    backgroundId?: IntFilter<"Pers"> | number
    raceId?: IntFilter<"Pers"> | number
    subraceId?: IntNullableFilter<"Pers"> | number | null
    currentHp?: IntFilter<"Pers"> | number
    maxHp?: IntFilter<"Pers"> | number
    tempHp?: IntFilter<"Pers"> | number
    raceCustom?: StringFilter<"Pers"> | string
    classCustom?: StringFilter<"Pers"> | string
    alignment?: StringFilter<"Pers"> | string
    xp?: IntFilter<"Pers"> | number
    customBackground?: StringFilter<"Pers"> | string
    customFeatures?: StringFilter<"Pers"> | string
    customLanguagesKnown?: StringFilter<"Pers"> | string
    customEquipment?: StringFilter<"Pers"> | string
    personalityTraits?: StringFilter<"Pers"> | string
    ideals?: StringFilter<"Pers"> | string
    bonds?: StringFilter<"Pers"> | string
    flaws?: StringFilter<"Pers"> | string
    backstory?: StringFilter<"Pers"> | string
    notes?: StringFilter<"Pers"> | string
    str?: IntFilter<"Pers"> | number
    dex?: IntFilter<"Pers"> | number
    con?: IntFilter<"Pers"> | number
    int?: IntFilter<"Pers"> | number
    wis?: IntFilter<"Pers"> | number
    cha?: IntFilter<"Pers"> | number
    cp?: IntFilter<"Pers"> | number
    sp?: IntFilter<"Pers"> | number
    ep?: IntFilter<"Pers"> | number
    gp?: IntFilter<"Pers"> | number
    pp?: IntFilter<"Pers"> | number
    additionalSaveProficiencies?: EnumAbilityNullableListFilter<"Pers">
    miscSaveBonuses?: JsonNullableFilter<"Pers">
    createdAt?: DateTimeFilter<"Pers"> | Date | string
    updatedAt?: DateTimeFilter<"Pers"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subclass?: XOR<SubclassNullableScalarRelationFilter, SubclassWhereInput> | null
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    subrace?: XOR<SubraceNullableScalarRelationFilter, SubraceWhereInput> | null
    background?: XOR<BackgroundScalarRelationFilter, BackgroundWhereInput>
    skills?: PersSkillListRelationFilter
    multiclasses?: PersMulticlassListRelationFilter
    features?: PersFeatureListRelationFilter
    spells?: SpellListRelationFilter
    feats?: PersFeatListRelationFilter
    armors?: PersArmorListRelationFilter
    weapons?: PersWeaponListRelationFilter
    magicItems?: PersMagicItemListRelationFilter
    raceVariants?: RaceVariantListRelationFilter
    raceChoiceOptions?: RaceChoiceOptionListRelationFilter
  }, "persId">

  export type PersOrderByWithAggregationInput = {
    persId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    currentSpellSlots?: SortOrder
    classId?: SortOrder
    subclassId?: SortOrderInput | SortOrder
    backgroundId?: SortOrder
    raceId?: SortOrder
    subraceId?: SortOrderInput | SortOrder
    currentHp?: SortOrder
    maxHp?: SortOrder
    tempHp?: SortOrder
    raceCustom?: SortOrder
    classCustom?: SortOrder
    alignment?: SortOrder
    xp?: SortOrder
    customBackground?: SortOrder
    customFeatures?: SortOrder
    customLanguagesKnown?: SortOrder
    customEquipment?: SortOrder
    personalityTraits?: SortOrder
    ideals?: SortOrder
    bonds?: SortOrder
    flaws?: SortOrder
    backstory?: SortOrder
    notes?: SortOrder
    str?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    int?: SortOrder
    wis?: SortOrder
    cha?: SortOrder
    cp?: SortOrder
    sp?: SortOrder
    ep?: SortOrder
    gp?: SortOrder
    pp?: SortOrder
    additionalSaveProficiencies?: SortOrder
    miscSaveBonuses?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PersCountOrderByAggregateInput
    _avg?: PersAvgOrderByAggregateInput
    _max?: PersMaxOrderByAggregateInput
    _min?: PersMinOrderByAggregateInput
    _sum?: PersSumOrderByAggregateInput
  }

  export type PersScalarWhereWithAggregatesInput = {
    AND?: PersScalarWhereWithAggregatesInput | PersScalarWhereWithAggregatesInput[]
    OR?: PersScalarWhereWithAggregatesInput[]
    NOT?: PersScalarWhereWithAggregatesInput | PersScalarWhereWithAggregatesInput[]
    persId?: IntWithAggregatesFilter<"Pers"> | number
    userId?: IntWithAggregatesFilter<"Pers"> | number
    name?: StringWithAggregatesFilter<"Pers"> | string
    level?: IntWithAggregatesFilter<"Pers"> | number
    currentSpellSlots?: IntNullableListFilter<"Pers">
    classId?: IntWithAggregatesFilter<"Pers"> | number
    subclassId?: IntNullableWithAggregatesFilter<"Pers"> | number | null
    backgroundId?: IntWithAggregatesFilter<"Pers"> | number
    raceId?: IntWithAggregatesFilter<"Pers"> | number
    subraceId?: IntNullableWithAggregatesFilter<"Pers"> | number | null
    currentHp?: IntWithAggregatesFilter<"Pers"> | number
    maxHp?: IntWithAggregatesFilter<"Pers"> | number
    tempHp?: IntWithAggregatesFilter<"Pers"> | number
    raceCustom?: StringWithAggregatesFilter<"Pers"> | string
    classCustom?: StringWithAggregatesFilter<"Pers"> | string
    alignment?: StringWithAggregatesFilter<"Pers"> | string
    xp?: IntWithAggregatesFilter<"Pers"> | number
    customBackground?: StringWithAggregatesFilter<"Pers"> | string
    customFeatures?: StringWithAggregatesFilter<"Pers"> | string
    customLanguagesKnown?: StringWithAggregatesFilter<"Pers"> | string
    customEquipment?: StringWithAggregatesFilter<"Pers"> | string
    personalityTraits?: StringWithAggregatesFilter<"Pers"> | string
    ideals?: StringWithAggregatesFilter<"Pers"> | string
    bonds?: StringWithAggregatesFilter<"Pers"> | string
    flaws?: StringWithAggregatesFilter<"Pers"> | string
    backstory?: StringWithAggregatesFilter<"Pers"> | string
    notes?: StringWithAggregatesFilter<"Pers"> | string
    str?: IntWithAggregatesFilter<"Pers"> | number
    dex?: IntWithAggregatesFilter<"Pers"> | number
    con?: IntWithAggregatesFilter<"Pers"> | number
    int?: IntWithAggregatesFilter<"Pers"> | number
    wis?: IntWithAggregatesFilter<"Pers"> | number
    cha?: IntWithAggregatesFilter<"Pers"> | number
    cp?: IntWithAggregatesFilter<"Pers"> | number
    sp?: IntWithAggregatesFilter<"Pers"> | number
    ep?: IntWithAggregatesFilter<"Pers"> | number
    gp?: IntWithAggregatesFilter<"Pers"> | number
    pp?: IntWithAggregatesFilter<"Pers"> | number
    additionalSaveProficiencies?: EnumAbilityNullableListFilter<"Pers">
    miscSaveBonuses?: JsonNullableWithAggregatesFilter<"Pers">
    createdAt?: DateTimeWithAggregatesFilter<"Pers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pers"> | Date | string
  }

  export type PersMulticlassWhereInput = {
    AND?: PersMulticlassWhereInput | PersMulticlassWhereInput[]
    OR?: PersMulticlassWhereInput[]
    NOT?: PersMulticlassWhereInput | PersMulticlassWhereInput[]
    persMulticlassId?: IntFilter<"PersMulticlass"> | number
    persId?: IntFilter<"PersMulticlass"> | number
    classId?: IntFilter<"PersMulticlass"> | number
    subclassId?: IntNullableFilter<"PersMulticlass"> | number | null
    classLevel?: IntFilter<"PersMulticlass"> | number
    pers?: XOR<PersScalarRelationFilter, PersWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subclass?: XOR<SubclassNullableScalarRelationFilter, SubclassWhereInput> | null
  }

  export type PersMulticlassOrderByWithRelationInput = {
    persMulticlassId?: SortOrder
    persId?: SortOrder
    classId?: SortOrder
    subclassId?: SortOrderInput | SortOrder
    classLevel?: SortOrder
    pers?: PersOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    subclass?: SubclassOrderByWithRelationInput
  }

  export type PersMulticlassWhereUniqueInput = Prisma.AtLeast<{
    persMulticlassId?: number
    persId_classId?: PersMulticlassPersIdClassIdCompoundUniqueInput
    AND?: PersMulticlassWhereInput | PersMulticlassWhereInput[]
    OR?: PersMulticlassWhereInput[]
    NOT?: PersMulticlassWhereInput | PersMulticlassWhereInput[]
    persId?: IntFilter<"PersMulticlass"> | number
    classId?: IntFilter<"PersMulticlass"> | number
    subclassId?: IntNullableFilter<"PersMulticlass"> | number | null
    classLevel?: IntFilter<"PersMulticlass"> | number
    pers?: XOR<PersScalarRelationFilter, PersWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subclass?: XOR<SubclassNullableScalarRelationFilter, SubclassWhereInput> | null
  }, "persMulticlassId" | "persId_classId">

  export type PersMulticlassOrderByWithAggregationInput = {
    persMulticlassId?: SortOrder
    persId?: SortOrder
    classId?: SortOrder
    subclassId?: SortOrderInput | SortOrder
    classLevel?: SortOrder
    _count?: PersMulticlassCountOrderByAggregateInput
    _avg?: PersMulticlassAvgOrderByAggregateInput
    _max?: PersMulticlassMaxOrderByAggregateInput
    _min?: PersMulticlassMinOrderByAggregateInput
    _sum?: PersMulticlassSumOrderByAggregateInput
  }

  export type PersMulticlassScalarWhereWithAggregatesInput = {
    AND?: PersMulticlassScalarWhereWithAggregatesInput | PersMulticlassScalarWhereWithAggregatesInput[]
    OR?: PersMulticlassScalarWhereWithAggregatesInput[]
    NOT?: PersMulticlassScalarWhereWithAggregatesInput | PersMulticlassScalarWhereWithAggregatesInput[]
    persMulticlassId?: IntWithAggregatesFilter<"PersMulticlass"> | number
    persId?: IntWithAggregatesFilter<"PersMulticlass"> | number
    classId?: IntWithAggregatesFilter<"PersMulticlass"> | number
    subclassId?: IntNullableWithAggregatesFilter<"PersMulticlass"> | number | null
    classLevel?: IntWithAggregatesFilter<"PersMulticlass"> | number
  }

  export type PersFeatureWhereInput = {
    AND?: PersFeatureWhereInput | PersFeatureWhereInput[]
    OR?: PersFeatureWhereInput[]
    NOT?: PersFeatureWhereInput | PersFeatureWhereInput[]
    persFeatureId?: IntFilter<"PersFeature"> | number
    persId?: IntFilter<"PersFeature"> | number
    featureId?: IntFilter<"PersFeature"> | number
    usesRemaining?: IntNullableFilter<"PersFeature"> | number | null
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    pers?: XOR<PersScalarRelationFilter, PersWhereInput>
  }

  export type PersFeatureOrderByWithRelationInput = {
    persFeatureId?: SortOrder
    persId?: SortOrder
    featureId?: SortOrder
    usesRemaining?: SortOrderInput | SortOrder
    feature?: FeatureOrderByWithRelationInput
    pers?: PersOrderByWithRelationInput
  }

  export type PersFeatureWhereUniqueInput = Prisma.AtLeast<{
    persFeatureId?: number
    persId_featureId?: PersFeaturePersIdFeatureIdCompoundUniqueInput
    AND?: PersFeatureWhereInput | PersFeatureWhereInput[]
    OR?: PersFeatureWhereInput[]
    NOT?: PersFeatureWhereInput | PersFeatureWhereInput[]
    persId?: IntFilter<"PersFeature"> | number
    featureId?: IntFilter<"PersFeature"> | number
    usesRemaining?: IntNullableFilter<"PersFeature"> | number | null
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    pers?: XOR<PersScalarRelationFilter, PersWhereInput>
  }, "persFeatureId" | "persId_featureId">

  export type PersFeatureOrderByWithAggregationInput = {
    persFeatureId?: SortOrder
    persId?: SortOrder
    featureId?: SortOrder
    usesRemaining?: SortOrderInput | SortOrder
    _count?: PersFeatureCountOrderByAggregateInput
    _avg?: PersFeatureAvgOrderByAggregateInput
    _max?: PersFeatureMaxOrderByAggregateInput
    _min?: PersFeatureMinOrderByAggregateInput
    _sum?: PersFeatureSumOrderByAggregateInput
  }

  export type PersFeatureScalarWhereWithAggregatesInput = {
    AND?: PersFeatureScalarWhereWithAggregatesInput | PersFeatureScalarWhereWithAggregatesInput[]
    OR?: PersFeatureScalarWhereWithAggregatesInput[]
    NOT?: PersFeatureScalarWhereWithAggregatesInput | PersFeatureScalarWhereWithAggregatesInput[]
    persFeatureId?: IntWithAggregatesFilter<"PersFeature"> | number
    persId?: IntWithAggregatesFilter<"PersFeature"> | number
    featureId?: IntWithAggregatesFilter<"PersFeature"> | number
    usesRemaining?: IntNullableWithAggregatesFilter<"PersFeature"> | number | null
  }

  export type FeatureWhereInput = {
    AND?: FeatureWhereInput | FeatureWhereInput[]
    OR?: FeatureWhereInput[]
    NOT?: FeatureWhereInput | FeatureWhereInput[]
    featureId?: IntFilter<"Feature"> | number
    name?: StringFilter<"Feature"> | string
    description?: StringFilter<"Feature"> | string
    shortDescription?: StringNullableFilter<"Feature"> | string | null
    modifiesStats?: JsonNullableFilter<"Feature">
    limitedUsesPer?: EnumRestTypeNullableFilter<"Feature"> | $Enums.RestType | null
    usesCount?: IntNullableFilter<"Feature"> | number | null
    displayType?: EnumFeatureDisplayTypeFilter<"Feature"> | $Enums.FeatureDisplayType
    createdAt?: DateTimeFilter<"Feature"> | Date | string
    updatedAt?: DateTimeFilter<"Feature"> | Date | string
    givesSpells?: SpellListRelationFilter
    classFeatures?: ClassFeatureListRelationFilter
    subclassFeatures?: SubclassFeatureListRelationFilter
    raceTraits?: RaceTraitListRelationFilter
    subraceTraits?: SubraceTraitListRelationFilter
    raceVariantTraits?: RaceVariantTraitListRelationFilter
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitListRelationFilter
    featFeatures?: FeatFeatureListRelationFilter
    magicItemFeatures?: MagicItemFeatureListRelationFilter
    persFeatures?: PersFeatureListRelationFilter
  }

  export type FeatureOrderByWithRelationInput = {
    featureId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    modifiesStats?: SortOrderInput | SortOrder
    limitedUsesPer?: SortOrderInput | SortOrder
    usesCount?: SortOrderInput | SortOrder
    displayType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    givesSpells?: SpellOrderByRelationAggregateInput
    classFeatures?: ClassFeatureOrderByRelationAggregateInput
    subclassFeatures?: SubclassFeatureOrderByRelationAggregateInput
    raceTraits?: RaceTraitOrderByRelationAggregateInput
    subraceTraits?: SubraceTraitOrderByRelationAggregateInput
    raceVariantTraits?: RaceVariantTraitOrderByRelationAggregateInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitOrderByRelationAggregateInput
    featFeatures?: FeatFeatureOrderByRelationAggregateInput
    magicItemFeatures?: MagicItemFeatureOrderByRelationAggregateInput
    persFeatures?: PersFeatureOrderByRelationAggregateInput
  }

  export type FeatureWhereUniqueInput = Prisma.AtLeast<{
    featureId?: number
    AND?: FeatureWhereInput | FeatureWhereInput[]
    OR?: FeatureWhereInput[]
    NOT?: FeatureWhereInput | FeatureWhereInput[]
    name?: StringFilter<"Feature"> | string
    description?: StringFilter<"Feature"> | string
    shortDescription?: StringNullableFilter<"Feature"> | string | null
    modifiesStats?: JsonNullableFilter<"Feature">
    limitedUsesPer?: EnumRestTypeNullableFilter<"Feature"> | $Enums.RestType | null
    usesCount?: IntNullableFilter<"Feature"> | number | null
    displayType?: EnumFeatureDisplayTypeFilter<"Feature"> | $Enums.FeatureDisplayType
    createdAt?: DateTimeFilter<"Feature"> | Date | string
    updatedAt?: DateTimeFilter<"Feature"> | Date | string
    givesSpells?: SpellListRelationFilter
    classFeatures?: ClassFeatureListRelationFilter
    subclassFeatures?: SubclassFeatureListRelationFilter
    raceTraits?: RaceTraitListRelationFilter
    subraceTraits?: SubraceTraitListRelationFilter
    raceVariantTraits?: RaceVariantTraitListRelationFilter
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitListRelationFilter
    featFeatures?: FeatFeatureListRelationFilter
    magicItemFeatures?: MagicItemFeatureListRelationFilter
    persFeatures?: PersFeatureListRelationFilter
  }, "featureId" | "featureId">

  export type FeatureOrderByWithAggregationInput = {
    featureId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    modifiesStats?: SortOrderInput | SortOrder
    limitedUsesPer?: SortOrderInput | SortOrder
    usesCount?: SortOrderInput | SortOrder
    displayType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeatureCountOrderByAggregateInput
    _avg?: FeatureAvgOrderByAggregateInput
    _max?: FeatureMaxOrderByAggregateInput
    _min?: FeatureMinOrderByAggregateInput
    _sum?: FeatureSumOrderByAggregateInput
  }

  export type FeatureScalarWhereWithAggregatesInput = {
    AND?: FeatureScalarWhereWithAggregatesInput | FeatureScalarWhereWithAggregatesInput[]
    OR?: FeatureScalarWhereWithAggregatesInput[]
    NOT?: FeatureScalarWhereWithAggregatesInput | FeatureScalarWhereWithAggregatesInput[]
    featureId?: IntWithAggregatesFilter<"Feature"> | number
    name?: StringWithAggregatesFilter<"Feature"> | string
    description?: StringWithAggregatesFilter<"Feature"> | string
    shortDescription?: StringNullableWithAggregatesFilter<"Feature"> | string | null
    modifiesStats?: JsonNullableWithAggregatesFilter<"Feature">
    limitedUsesPer?: EnumRestTypeNullableWithAggregatesFilter<"Feature"> | $Enums.RestType | null
    usesCount?: IntNullableWithAggregatesFilter<"Feature"> | number | null
    displayType?: EnumFeatureDisplayTypeWithAggregatesFilter<"Feature"> | $Enums.FeatureDisplayType
    createdAt?: DateTimeWithAggregatesFilter<"Feature"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Feature"> | Date | string
  }

  export type ClassFeatureWhereInput = {
    AND?: ClassFeatureWhereInput | ClassFeatureWhereInput[]
    OR?: ClassFeatureWhereInput[]
    NOT?: ClassFeatureWhereInput | ClassFeatureWhereInput[]
    classFeatureId?: IntFilter<"ClassFeature"> | number
    classId?: IntFilter<"ClassFeature"> | number
    featureId?: IntFilter<"ClassFeature"> | number
    levelGranted?: IntFilter<"ClassFeature"> | number
    grantsSpellSlots?: BoolFilter<"ClassFeature"> | boolean
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }

  export type ClassFeatureOrderByWithRelationInput = {
    classFeatureId?: SortOrder
    classId?: SortOrder
    featureId?: SortOrder
    levelGranted?: SortOrder
    grantsSpellSlots?: SortOrder
    feature?: FeatureOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type ClassFeatureWhereUniqueInput = Prisma.AtLeast<{
    classFeatureId?: number
    AND?: ClassFeatureWhereInput | ClassFeatureWhereInput[]
    OR?: ClassFeatureWhereInput[]
    NOT?: ClassFeatureWhereInput | ClassFeatureWhereInput[]
    classId?: IntFilter<"ClassFeature"> | number
    featureId?: IntFilter<"ClassFeature"> | number
    levelGranted?: IntFilter<"ClassFeature"> | number
    grantsSpellSlots?: BoolFilter<"ClassFeature"> | boolean
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }, "classFeatureId">

  export type ClassFeatureOrderByWithAggregationInput = {
    classFeatureId?: SortOrder
    classId?: SortOrder
    featureId?: SortOrder
    levelGranted?: SortOrder
    grantsSpellSlots?: SortOrder
    _count?: ClassFeatureCountOrderByAggregateInput
    _avg?: ClassFeatureAvgOrderByAggregateInput
    _max?: ClassFeatureMaxOrderByAggregateInput
    _min?: ClassFeatureMinOrderByAggregateInput
    _sum?: ClassFeatureSumOrderByAggregateInput
  }

  export type ClassFeatureScalarWhereWithAggregatesInput = {
    AND?: ClassFeatureScalarWhereWithAggregatesInput | ClassFeatureScalarWhereWithAggregatesInput[]
    OR?: ClassFeatureScalarWhereWithAggregatesInput[]
    NOT?: ClassFeatureScalarWhereWithAggregatesInput | ClassFeatureScalarWhereWithAggregatesInput[]
    classFeatureId?: IntWithAggregatesFilter<"ClassFeature"> | number
    classId?: IntWithAggregatesFilter<"ClassFeature"> | number
    featureId?: IntWithAggregatesFilter<"ClassFeature"> | number
    levelGranted?: IntWithAggregatesFilter<"ClassFeature"> | number
    grantsSpellSlots?: BoolWithAggregatesFilter<"ClassFeature"> | boolean
  }

  export type SubclassFeatureWhereInput = {
    AND?: SubclassFeatureWhereInput | SubclassFeatureWhereInput[]
    OR?: SubclassFeatureWhereInput[]
    NOT?: SubclassFeatureWhereInput | SubclassFeatureWhereInput[]
    subclassFeatureId?: IntFilter<"SubclassFeature"> | number
    subclassId?: IntFilter<"SubclassFeature"> | number
    featureId?: IntFilter<"SubclassFeature"> | number
    levelGranted?: IntFilter<"SubclassFeature"> | number
    grantsSpellSlots?: BoolFilter<"SubclassFeature"> | boolean
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    subclass?: XOR<SubclassScalarRelationFilter, SubclassWhereInput>
  }

  export type SubclassFeatureOrderByWithRelationInput = {
    subclassFeatureId?: SortOrder
    subclassId?: SortOrder
    featureId?: SortOrder
    levelGranted?: SortOrder
    grantsSpellSlots?: SortOrder
    feature?: FeatureOrderByWithRelationInput
    subclass?: SubclassOrderByWithRelationInput
  }

  export type SubclassFeatureWhereUniqueInput = Prisma.AtLeast<{
    subclassFeatureId?: number
    AND?: SubclassFeatureWhereInput | SubclassFeatureWhereInput[]
    OR?: SubclassFeatureWhereInput[]
    NOT?: SubclassFeatureWhereInput | SubclassFeatureWhereInput[]
    subclassId?: IntFilter<"SubclassFeature"> | number
    featureId?: IntFilter<"SubclassFeature"> | number
    levelGranted?: IntFilter<"SubclassFeature"> | number
    grantsSpellSlots?: BoolFilter<"SubclassFeature"> | boolean
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    subclass?: XOR<SubclassScalarRelationFilter, SubclassWhereInput>
  }, "subclassFeatureId">

  export type SubclassFeatureOrderByWithAggregationInput = {
    subclassFeatureId?: SortOrder
    subclassId?: SortOrder
    featureId?: SortOrder
    levelGranted?: SortOrder
    grantsSpellSlots?: SortOrder
    _count?: SubclassFeatureCountOrderByAggregateInput
    _avg?: SubclassFeatureAvgOrderByAggregateInput
    _max?: SubclassFeatureMaxOrderByAggregateInput
    _min?: SubclassFeatureMinOrderByAggregateInput
    _sum?: SubclassFeatureSumOrderByAggregateInput
  }

  export type SubclassFeatureScalarWhereWithAggregatesInput = {
    AND?: SubclassFeatureScalarWhereWithAggregatesInput | SubclassFeatureScalarWhereWithAggregatesInput[]
    OR?: SubclassFeatureScalarWhereWithAggregatesInput[]
    NOT?: SubclassFeatureScalarWhereWithAggregatesInput | SubclassFeatureScalarWhereWithAggregatesInput[]
    subclassFeatureId?: IntWithAggregatesFilter<"SubclassFeature"> | number
    subclassId?: IntWithAggregatesFilter<"SubclassFeature"> | number
    featureId?: IntWithAggregatesFilter<"SubclassFeature"> | number
    levelGranted?: IntWithAggregatesFilter<"SubclassFeature"> | number
    grantsSpellSlots?: BoolWithAggregatesFilter<"SubclassFeature"> | boolean
  }

  export type RaceTraitWhereInput = {
    AND?: RaceTraitWhereInput | RaceTraitWhereInput[]
    OR?: RaceTraitWhereInput[]
    NOT?: RaceTraitWhereInput | RaceTraitWhereInput[]
    raceTraitId?: IntFilter<"RaceTrait"> | number
    raceId?: IntFilter<"RaceTrait"> | number
    featureId?: IntFilter<"RaceTrait"> | number
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    subraces?: SubraceListRelationFilter
    raceVariants?: RaceVariantListRelationFilter
  }

  export type RaceTraitOrderByWithRelationInput = {
    raceTraitId?: SortOrder
    raceId?: SortOrder
    featureId?: SortOrder
    feature?: FeatureOrderByWithRelationInput
    race?: RaceOrderByWithRelationInput
    subraces?: SubraceOrderByRelationAggregateInput
    raceVariants?: RaceVariantOrderByRelationAggregateInput
  }

  export type RaceTraitWhereUniqueInput = Prisma.AtLeast<{
    raceTraitId?: number
    AND?: RaceTraitWhereInput | RaceTraitWhereInput[]
    OR?: RaceTraitWhereInput[]
    NOT?: RaceTraitWhereInput | RaceTraitWhereInput[]
    raceId?: IntFilter<"RaceTrait"> | number
    featureId?: IntFilter<"RaceTrait"> | number
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    subraces?: SubraceListRelationFilter
    raceVariants?: RaceVariantListRelationFilter
  }, "raceTraitId">

  export type RaceTraitOrderByWithAggregationInput = {
    raceTraitId?: SortOrder
    raceId?: SortOrder
    featureId?: SortOrder
    _count?: RaceTraitCountOrderByAggregateInput
    _avg?: RaceTraitAvgOrderByAggregateInput
    _max?: RaceTraitMaxOrderByAggregateInput
    _min?: RaceTraitMinOrderByAggregateInput
    _sum?: RaceTraitSumOrderByAggregateInput
  }

  export type RaceTraitScalarWhereWithAggregatesInput = {
    AND?: RaceTraitScalarWhereWithAggregatesInput | RaceTraitScalarWhereWithAggregatesInput[]
    OR?: RaceTraitScalarWhereWithAggregatesInput[]
    NOT?: RaceTraitScalarWhereWithAggregatesInput | RaceTraitScalarWhereWithAggregatesInput[]
    raceTraitId?: IntWithAggregatesFilter<"RaceTrait"> | number
    raceId?: IntWithAggregatesFilter<"RaceTrait"> | number
    featureId?: IntWithAggregatesFilter<"RaceTrait"> | number
  }

  export type SubraceTraitWhereInput = {
    AND?: SubraceTraitWhereInput | SubraceTraitWhereInput[]
    OR?: SubraceTraitWhereInput[]
    NOT?: SubraceTraitWhereInput | SubraceTraitWhereInput[]
    subraceTraitId?: IntFilter<"SubraceTrait"> | number
    subraceId?: IntFilter<"SubraceTrait"> | number
    featureId?: IntFilter<"SubraceTrait"> | number
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    subrace?: XOR<SubraceScalarRelationFilter, SubraceWhereInput>
  }

  export type SubraceTraitOrderByWithRelationInput = {
    subraceTraitId?: SortOrder
    subraceId?: SortOrder
    featureId?: SortOrder
    feature?: FeatureOrderByWithRelationInput
    subrace?: SubraceOrderByWithRelationInput
  }

  export type SubraceTraitWhereUniqueInput = Prisma.AtLeast<{
    subraceTraitId?: number
    AND?: SubraceTraitWhereInput | SubraceTraitWhereInput[]
    OR?: SubraceTraitWhereInput[]
    NOT?: SubraceTraitWhereInput | SubraceTraitWhereInput[]
    subraceId?: IntFilter<"SubraceTrait"> | number
    featureId?: IntFilter<"SubraceTrait"> | number
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    subrace?: XOR<SubraceScalarRelationFilter, SubraceWhereInput>
  }, "subraceTraitId">

  export type SubraceTraitOrderByWithAggregationInput = {
    subraceTraitId?: SortOrder
    subraceId?: SortOrder
    featureId?: SortOrder
    _count?: SubraceTraitCountOrderByAggregateInput
    _avg?: SubraceTraitAvgOrderByAggregateInput
    _max?: SubraceTraitMaxOrderByAggregateInput
    _min?: SubraceTraitMinOrderByAggregateInput
    _sum?: SubraceTraitSumOrderByAggregateInput
  }

  export type SubraceTraitScalarWhereWithAggregatesInput = {
    AND?: SubraceTraitScalarWhereWithAggregatesInput | SubraceTraitScalarWhereWithAggregatesInput[]
    OR?: SubraceTraitScalarWhereWithAggregatesInput[]
    NOT?: SubraceTraitScalarWhereWithAggregatesInput | SubraceTraitScalarWhereWithAggregatesInput[]
    subraceTraitId?: IntWithAggregatesFilter<"SubraceTrait"> | number
    subraceId?: IntWithAggregatesFilter<"SubraceTrait"> | number
    featureId?: IntWithAggregatesFilter<"SubraceTrait"> | number
  }

  export type RaceVariantTraitWhereInput = {
    AND?: RaceVariantTraitWhereInput | RaceVariantTraitWhereInput[]
    OR?: RaceVariantTraitWhereInput[]
    NOT?: RaceVariantTraitWhereInput | RaceVariantTraitWhereInput[]
    raceVariantTraitId?: IntFilter<"RaceVariantTrait"> | number
    raceVariantId?: IntFilter<"RaceVariantTrait"> | number
    featureId?: IntFilter<"RaceVariantTrait"> | number
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    raceVariant?: XOR<RaceVariantScalarRelationFilter, RaceVariantWhereInput>
  }

  export type RaceVariantTraitOrderByWithRelationInput = {
    raceVariantTraitId?: SortOrder
    raceVariantId?: SortOrder
    featureId?: SortOrder
    feature?: FeatureOrderByWithRelationInput
    raceVariant?: RaceVariantOrderByWithRelationInput
  }

  export type RaceVariantTraitWhereUniqueInput = Prisma.AtLeast<{
    raceVariantTraitId?: number
    AND?: RaceVariantTraitWhereInput | RaceVariantTraitWhereInput[]
    OR?: RaceVariantTraitWhereInput[]
    NOT?: RaceVariantTraitWhereInput | RaceVariantTraitWhereInput[]
    raceVariantId?: IntFilter<"RaceVariantTrait"> | number
    featureId?: IntFilter<"RaceVariantTrait"> | number
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    raceVariant?: XOR<RaceVariantScalarRelationFilter, RaceVariantWhereInput>
  }, "raceVariantTraitId">

  export type RaceVariantTraitOrderByWithAggregationInput = {
    raceVariantTraitId?: SortOrder
    raceVariantId?: SortOrder
    featureId?: SortOrder
    _count?: RaceVariantTraitCountOrderByAggregateInput
    _avg?: RaceVariantTraitAvgOrderByAggregateInput
    _max?: RaceVariantTraitMaxOrderByAggregateInput
    _min?: RaceVariantTraitMinOrderByAggregateInput
    _sum?: RaceVariantTraitSumOrderByAggregateInput
  }

  export type RaceVariantTraitScalarWhereWithAggregatesInput = {
    AND?: RaceVariantTraitScalarWhereWithAggregatesInput | RaceVariantTraitScalarWhereWithAggregatesInput[]
    OR?: RaceVariantTraitScalarWhereWithAggregatesInput[]
    NOT?: RaceVariantTraitScalarWhereWithAggregatesInput | RaceVariantTraitScalarWhereWithAggregatesInput[]
    raceVariantTraitId?: IntWithAggregatesFilter<"RaceVariantTrait"> | number
    raceVariantId?: IntWithAggregatesFilter<"RaceVariantTrait"> | number
    featureId?: IntWithAggregatesFilter<"RaceVariantTrait"> | number
  }

  export type RaceChoiceOptionTraitWhereInput = {
    AND?: RaceChoiceOptionTraitWhereInput | RaceChoiceOptionTraitWhereInput[]
    OR?: RaceChoiceOptionTraitWhereInput[]
    NOT?: RaceChoiceOptionTraitWhereInput | RaceChoiceOptionTraitWhereInput[]
    raceChoiceOptionTraitId?: IntFilter<"RaceChoiceOptionTrait"> | number
    optionId?: IntFilter<"RaceChoiceOptionTrait"> | number
    featureId?: IntFilter<"RaceChoiceOptionTrait"> | number
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    raceChoiceOption?: XOR<RaceChoiceOptionScalarRelationFilter, RaceChoiceOptionWhereInput>
  }

  export type RaceChoiceOptionTraitOrderByWithRelationInput = {
    raceChoiceOptionTraitId?: SortOrder
    optionId?: SortOrder
    featureId?: SortOrder
    feature?: FeatureOrderByWithRelationInput
    raceChoiceOption?: RaceChoiceOptionOrderByWithRelationInput
  }

  export type RaceChoiceOptionTraitWhereUniqueInput = Prisma.AtLeast<{
    raceChoiceOptionTraitId?: number
    AND?: RaceChoiceOptionTraitWhereInput | RaceChoiceOptionTraitWhereInput[]
    OR?: RaceChoiceOptionTraitWhereInput[]
    NOT?: RaceChoiceOptionTraitWhereInput | RaceChoiceOptionTraitWhereInput[]
    optionId?: IntFilter<"RaceChoiceOptionTrait"> | number
    featureId?: IntFilter<"RaceChoiceOptionTrait"> | number
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    raceChoiceOption?: XOR<RaceChoiceOptionScalarRelationFilter, RaceChoiceOptionWhereInput>
  }, "raceChoiceOptionTraitId">

  export type RaceChoiceOptionTraitOrderByWithAggregationInput = {
    raceChoiceOptionTraitId?: SortOrder
    optionId?: SortOrder
    featureId?: SortOrder
    _count?: RaceChoiceOptionTraitCountOrderByAggregateInput
    _avg?: RaceChoiceOptionTraitAvgOrderByAggregateInput
    _max?: RaceChoiceOptionTraitMaxOrderByAggregateInput
    _min?: RaceChoiceOptionTraitMinOrderByAggregateInput
    _sum?: RaceChoiceOptionTraitSumOrderByAggregateInput
  }

  export type RaceChoiceOptionTraitScalarWhereWithAggregatesInput = {
    AND?: RaceChoiceOptionTraitScalarWhereWithAggregatesInput | RaceChoiceOptionTraitScalarWhereWithAggregatesInput[]
    OR?: RaceChoiceOptionTraitScalarWhereWithAggregatesInput[]
    NOT?: RaceChoiceOptionTraitScalarWhereWithAggregatesInput | RaceChoiceOptionTraitScalarWhereWithAggregatesInput[]
    raceChoiceOptionTraitId?: IntWithAggregatesFilter<"RaceChoiceOptionTrait"> | number
    optionId?: IntWithAggregatesFilter<"RaceChoiceOptionTrait"> | number
    featureId?: IntWithAggregatesFilter<"RaceChoiceOptionTrait"> | number
  }

  export type FeatFeatureWhereInput = {
    AND?: FeatFeatureWhereInput | FeatFeatureWhereInput[]
    OR?: FeatFeatureWhereInput[]
    NOT?: FeatFeatureWhereInput | FeatFeatureWhereInput[]
    featFeatureId?: IntFilter<"FeatFeature"> | number
    featId?: IntFilter<"FeatFeature"> | number
    featureId?: IntFilter<"FeatFeature"> | number
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    feat?: XOR<FeatScalarRelationFilter, FeatWhereInput>
  }

  export type FeatFeatureOrderByWithRelationInput = {
    featFeatureId?: SortOrder
    featId?: SortOrder
    featureId?: SortOrder
    feature?: FeatureOrderByWithRelationInput
    feat?: FeatOrderByWithRelationInput
  }

  export type FeatFeatureWhereUniqueInput = Prisma.AtLeast<{
    featFeatureId?: number
    featId_featureId?: FeatFeatureFeatIdFeatureIdCompoundUniqueInput
    AND?: FeatFeatureWhereInput | FeatFeatureWhereInput[]
    OR?: FeatFeatureWhereInput[]
    NOT?: FeatFeatureWhereInput | FeatFeatureWhereInput[]
    featId?: IntFilter<"FeatFeature"> | number
    featureId?: IntFilter<"FeatFeature"> | number
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    feat?: XOR<FeatScalarRelationFilter, FeatWhereInput>
  }, "featFeatureId" | "featId_featureId">

  export type FeatFeatureOrderByWithAggregationInput = {
    featFeatureId?: SortOrder
    featId?: SortOrder
    featureId?: SortOrder
    _count?: FeatFeatureCountOrderByAggregateInput
    _avg?: FeatFeatureAvgOrderByAggregateInput
    _max?: FeatFeatureMaxOrderByAggregateInput
    _min?: FeatFeatureMinOrderByAggregateInput
    _sum?: FeatFeatureSumOrderByAggregateInput
  }

  export type FeatFeatureScalarWhereWithAggregatesInput = {
    AND?: FeatFeatureScalarWhereWithAggregatesInput | FeatFeatureScalarWhereWithAggregatesInput[]
    OR?: FeatFeatureScalarWhereWithAggregatesInput[]
    NOT?: FeatFeatureScalarWhereWithAggregatesInput | FeatFeatureScalarWhereWithAggregatesInput[]
    featFeatureId?: IntWithAggregatesFilter<"FeatFeature"> | number
    featId?: IntWithAggregatesFilter<"FeatFeature"> | number
    featureId?: IntWithAggregatesFilter<"FeatFeature"> | number
  }

  export type MagicItemFeatureWhereInput = {
    AND?: MagicItemFeatureWhereInput | MagicItemFeatureWhereInput[]
    OR?: MagicItemFeatureWhereInput[]
    NOT?: MagicItemFeatureWhereInput | MagicItemFeatureWhereInput[]
    magicItemFeatureId?: IntFilter<"MagicItemFeature"> | number
    magicItemId?: IntFilter<"MagicItemFeature"> | number
    featureId?: IntFilter<"MagicItemFeature"> | number
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    magicItem?: XOR<MagicItemScalarRelationFilter, MagicItemWhereInput>
  }

  export type MagicItemFeatureOrderByWithRelationInput = {
    magicItemFeatureId?: SortOrder
    magicItemId?: SortOrder
    featureId?: SortOrder
    feature?: FeatureOrderByWithRelationInput
    magicItem?: MagicItemOrderByWithRelationInput
  }

  export type MagicItemFeatureWhereUniqueInput = Prisma.AtLeast<{
    magicItemFeatureId?: number
    AND?: MagicItemFeatureWhereInput | MagicItemFeatureWhereInput[]
    OR?: MagicItemFeatureWhereInput[]
    NOT?: MagicItemFeatureWhereInput | MagicItemFeatureWhereInput[]
    magicItemId?: IntFilter<"MagicItemFeature"> | number
    featureId?: IntFilter<"MagicItemFeature"> | number
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    magicItem?: XOR<MagicItemScalarRelationFilter, MagicItemWhereInput>
  }, "magicItemFeatureId">

  export type MagicItemFeatureOrderByWithAggregationInput = {
    magicItemFeatureId?: SortOrder
    magicItemId?: SortOrder
    featureId?: SortOrder
    _count?: MagicItemFeatureCountOrderByAggregateInput
    _avg?: MagicItemFeatureAvgOrderByAggregateInput
    _max?: MagicItemFeatureMaxOrderByAggregateInput
    _min?: MagicItemFeatureMinOrderByAggregateInput
    _sum?: MagicItemFeatureSumOrderByAggregateInput
  }

  export type MagicItemFeatureScalarWhereWithAggregatesInput = {
    AND?: MagicItemFeatureScalarWhereWithAggregatesInput | MagicItemFeatureScalarWhereWithAggregatesInput[]
    OR?: MagicItemFeatureScalarWhereWithAggregatesInput[]
    NOT?: MagicItemFeatureScalarWhereWithAggregatesInput | MagicItemFeatureScalarWhereWithAggregatesInput[]
    magicItemFeatureId?: IntWithAggregatesFilter<"MagicItemFeature"> | number
    magicItemId?: IntWithAggregatesFilter<"MagicItemFeature"> | number
    featureId?: IntWithAggregatesFilter<"MagicItemFeature"> | number
  }

  export type RaceWhereInput = {
    AND?: RaceWhereInput | RaceWhereInput[]
    OR?: RaceWhereInput[]
    NOT?: RaceWhereInput | RaceWhereInput[]
    raceId?: IntFilter<"Race"> | number
    name?: EnumRacesFilter<"Race"> | $Enums.Races
    size?: EnumSizeNullableListFilter<"Race">
    speed?: IntFilter<"Race"> | number
    burrowSpeed?: IntFilter<"Race"> | number
    flightSpeed?: IntFilter<"Race"> | number
    swimSpeed?: IntFilter<"Race"> | number
    climbSpeed?: IntFilter<"Race"> | number
    ac?: IntFilter<"Race"> | number
    source?: EnumSourceFilter<"Race"> | $Enums.Source
    languages?: EnumLanguageNullableListFilter<"Race">
    languagesToChooseCount?: IntFilter<"Race"> | number
    ASI?: JsonFilter<"Race">
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Race">
    skillProficiencies?: EnumSkillsNullableListFilter<"Race">
    weaponProficiencies?: EnumWeaponCategoryNullableListFilter<"Race">
    armorProficiencies?: EnumArmorTypeNullableListFilter<"Race">
    subraces?: SubraceListRelationFilter
    perses?: PersListRelationFilter
    raceChoiceOptions?: RaceChoiceOptionListRelationFilter
    raceVariants?: RaceVariantListRelationFilter
    traits?: RaceTraitListRelationFilter
  }

  export type RaceOrderByWithRelationInput = {
    raceId?: SortOrder
    name?: SortOrder
    size?: SortOrder
    speed?: SortOrder
    burrowSpeed?: SortOrder
    flightSpeed?: SortOrder
    swimSpeed?: SortOrder
    climbSpeed?: SortOrder
    ac?: SortOrder
    source?: SortOrder
    languages?: SortOrder
    languagesToChooseCount?: SortOrder
    ASI?: SortOrder
    toolProficiencies?: SortOrder
    skillProficiencies?: SortOrder
    weaponProficiencies?: SortOrder
    armorProficiencies?: SortOrder
    subraces?: SubraceOrderByRelationAggregateInput
    perses?: PersOrderByRelationAggregateInput
    raceChoiceOptions?: RaceChoiceOptionOrderByRelationAggregateInput
    raceVariants?: RaceVariantOrderByRelationAggregateInput
    traits?: RaceTraitOrderByRelationAggregateInput
  }

  export type RaceWhereUniqueInput = Prisma.AtLeast<{
    raceId?: number
    name?: $Enums.Races
    AND?: RaceWhereInput | RaceWhereInput[]
    OR?: RaceWhereInput[]
    NOT?: RaceWhereInput | RaceWhereInput[]
    size?: EnumSizeNullableListFilter<"Race">
    speed?: IntFilter<"Race"> | number
    burrowSpeed?: IntFilter<"Race"> | number
    flightSpeed?: IntFilter<"Race"> | number
    swimSpeed?: IntFilter<"Race"> | number
    climbSpeed?: IntFilter<"Race"> | number
    ac?: IntFilter<"Race"> | number
    source?: EnumSourceFilter<"Race"> | $Enums.Source
    languages?: EnumLanguageNullableListFilter<"Race">
    languagesToChooseCount?: IntFilter<"Race"> | number
    ASI?: JsonFilter<"Race">
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Race">
    skillProficiencies?: EnumSkillsNullableListFilter<"Race">
    weaponProficiencies?: EnumWeaponCategoryNullableListFilter<"Race">
    armorProficiencies?: EnumArmorTypeNullableListFilter<"Race">
    subraces?: SubraceListRelationFilter
    perses?: PersListRelationFilter
    raceChoiceOptions?: RaceChoiceOptionListRelationFilter
    raceVariants?: RaceVariantListRelationFilter
    traits?: RaceTraitListRelationFilter
  }, "raceId" | "name">

  export type RaceOrderByWithAggregationInput = {
    raceId?: SortOrder
    name?: SortOrder
    size?: SortOrder
    speed?: SortOrder
    burrowSpeed?: SortOrder
    flightSpeed?: SortOrder
    swimSpeed?: SortOrder
    climbSpeed?: SortOrder
    ac?: SortOrder
    source?: SortOrder
    languages?: SortOrder
    languagesToChooseCount?: SortOrder
    ASI?: SortOrder
    toolProficiencies?: SortOrder
    skillProficiencies?: SortOrder
    weaponProficiencies?: SortOrder
    armorProficiencies?: SortOrder
    _count?: RaceCountOrderByAggregateInput
    _avg?: RaceAvgOrderByAggregateInput
    _max?: RaceMaxOrderByAggregateInput
    _min?: RaceMinOrderByAggregateInput
    _sum?: RaceSumOrderByAggregateInput
  }

  export type RaceScalarWhereWithAggregatesInput = {
    AND?: RaceScalarWhereWithAggregatesInput | RaceScalarWhereWithAggregatesInput[]
    OR?: RaceScalarWhereWithAggregatesInput[]
    NOT?: RaceScalarWhereWithAggregatesInput | RaceScalarWhereWithAggregatesInput[]
    raceId?: IntWithAggregatesFilter<"Race"> | number
    name?: EnumRacesWithAggregatesFilter<"Race"> | $Enums.Races
    size?: EnumSizeNullableListFilter<"Race">
    speed?: IntWithAggregatesFilter<"Race"> | number
    burrowSpeed?: IntWithAggregatesFilter<"Race"> | number
    flightSpeed?: IntWithAggregatesFilter<"Race"> | number
    swimSpeed?: IntWithAggregatesFilter<"Race"> | number
    climbSpeed?: IntWithAggregatesFilter<"Race"> | number
    ac?: IntWithAggregatesFilter<"Race"> | number
    source?: EnumSourceWithAggregatesFilter<"Race"> | $Enums.Source
    languages?: EnumLanguageNullableListFilter<"Race">
    languagesToChooseCount?: IntWithAggregatesFilter<"Race"> | number
    ASI?: JsonWithAggregatesFilter<"Race">
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Race">
    skillProficiencies?: EnumSkillsNullableListFilter<"Race">
    weaponProficiencies?: EnumWeaponCategoryNullableListFilter<"Race">
    armorProficiencies?: EnumArmorTypeNullableListFilter<"Race">
  }

  export type SubraceWhereInput = {
    AND?: SubraceWhereInput | SubraceWhereInput[]
    OR?: SubraceWhereInput[]
    NOT?: SubraceWhereInput | SubraceWhereInput[]
    subraceId?: IntFilter<"Subrace"> | number
    raceId?: IntFilter<"Subrace"> | number
    name?: EnumSubracesFilter<"Subrace"> | $Enums.Subraces
    speedModifier?: IntNullableFilter<"Subrace"> | number | null
    source?: EnumSourceFilter<"Subrace"> | $Enums.Source
    replacesASI?: BoolFilter<"Subrace"> | boolean
    additionalASI?: JsonNullableFilter<"Subrace">
    additionalLanguages?: EnumLanguageNullableListFilter<"Subrace">
    languagesToChooseCount?: IntFilter<"Subrace"> | number
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Subrace">
    skillProficiencies?: JsonNullableFilter<"Subrace">
    weaponProficiencies?: EnumWeaponCategoryNullableListFilter<"Subrace">
    armorProficiencies?: EnumArmorTypeNullableListFilter<"Subrace">
    replacesTraits?: RaceTraitListRelationFilter
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    perses?: PersListRelationFilter
    raceChoiceOptions?: RaceChoiceOptionListRelationFilter
    traits?: SubraceTraitListRelationFilter
  }

  export type SubraceOrderByWithRelationInput = {
    subraceId?: SortOrder
    raceId?: SortOrder
    name?: SortOrder
    speedModifier?: SortOrderInput | SortOrder
    source?: SortOrder
    replacesASI?: SortOrder
    additionalASI?: SortOrderInput | SortOrder
    additionalLanguages?: SortOrder
    languagesToChooseCount?: SortOrder
    toolProficiencies?: SortOrder
    skillProficiencies?: SortOrderInput | SortOrder
    weaponProficiencies?: SortOrder
    armorProficiencies?: SortOrder
    replacesTraits?: RaceTraitOrderByRelationAggregateInput
    race?: RaceOrderByWithRelationInput
    perses?: PersOrderByRelationAggregateInput
    raceChoiceOptions?: RaceChoiceOptionOrderByRelationAggregateInput
    traits?: SubraceTraitOrderByRelationAggregateInput
  }

  export type SubraceWhereUniqueInput = Prisma.AtLeast<{
    subraceId?: number
    name?: $Enums.Subraces
    AND?: SubraceWhereInput | SubraceWhereInput[]
    OR?: SubraceWhereInput[]
    NOT?: SubraceWhereInput | SubraceWhereInput[]
    raceId?: IntFilter<"Subrace"> | number
    speedModifier?: IntNullableFilter<"Subrace"> | number | null
    source?: EnumSourceFilter<"Subrace"> | $Enums.Source
    replacesASI?: BoolFilter<"Subrace"> | boolean
    additionalASI?: JsonNullableFilter<"Subrace">
    additionalLanguages?: EnumLanguageNullableListFilter<"Subrace">
    languagesToChooseCount?: IntFilter<"Subrace"> | number
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Subrace">
    skillProficiencies?: JsonNullableFilter<"Subrace">
    weaponProficiencies?: EnumWeaponCategoryNullableListFilter<"Subrace">
    armorProficiencies?: EnumArmorTypeNullableListFilter<"Subrace">
    replacesTraits?: RaceTraitListRelationFilter
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    perses?: PersListRelationFilter
    raceChoiceOptions?: RaceChoiceOptionListRelationFilter
    traits?: SubraceTraitListRelationFilter
  }, "subraceId" | "name">

  export type SubraceOrderByWithAggregationInput = {
    subraceId?: SortOrder
    raceId?: SortOrder
    name?: SortOrder
    speedModifier?: SortOrderInput | SortOrder
    source?: SortOrder
    replacesASI?: SortOrder
    additionalASI?: SortOrderInput | SortOrder
    additionalLanguages?: SortOrder
    languagesToChooseCount?: SortOrder
    toolProficiencies?: SortOrder
    skillProficiencies?: SortOrderInput | SortOrder
    weaponProficiencies?: SortOrder
    armorProficiencies?: SortOrder
    _count?: SubraceCountOrderByAggregateInput
    _avg?: SubraceAvgOrderByAggregateInput
    _max?: SubraceMaxOrderByAggregateInput
    _min?: SubraceMinOrderByAggregateInput
    _sum?: SubraceSumOrderByAggregateInput
  }

  export type SubraceScalarWhereWithAggregatesInput = {
    AND?: SubraceScalarWhereWithAggregatesInput | SubraceScalarWhereWithAggregatesInput[]
    OR?: SubraceScalarWhereWithAggregatesInput[]
    NOT?: SubraceScalarWhereWithAggregatesInput | SubraceScalarWhereWithAggregatesInput[]
    subraceId?: IntWithAggregatesFilter<"Subrace"> | number
    raceId?: IntWithAggregatesFilter<"Subrace"> | number
    name?: EnumSubracesWithAggregatesFilter<"Subrace"> | $Enums.Subraces
    speedModifier?: IntNullableWithAggregatesFilter<"Subrace"> | number | null
    source?: EnumSourceWithAggregatesFilter<"Subrace"> | $Enums.Source
    replacesASI?: BoolWithAggregatesFilter<"Subrace"> | boolean
    additionalASI?: JsonNullableWithAggregatesFilter<"Subrace">
    additionalLanguages?: EnumLanguageNullableListFilter<"Subrace">
    languagesToChooseCount?: IntWithAggregatesFilter<"Subrace"> | number
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Subrace">
    skillProficiencies?: JsonNullableWithAggregatesFilter<"Subrace">
    weaponProficiencies?: EnumWeaponCategoryNullableListFilter<"Subrace">
    armorProficiencies?: EnumArmorTypeNullableListFilter<"Subrace">
  }

  export type RaceVariantWhereInput = {
    AND?: RaceVariantWhereInput | RaceVariantWhereInput[]
    OR?: RaceVariantWhereInput[]
    NOT?: RaceVariantWhereInput | RaceVariantWhereInput[]
    raceVariantId?: IntFilter<"RaceVariant"> | number
    raceId?: IntFilter<"RaceVariant"> | number
    name?: EnumVariantsFilter<"RaceVariant"> | $Enums.Variants
    source?: EnumSourceFilter<"RaceVariant"> | $Enums.Source
    exclusivityGroup?: StringNullableFilter<"RaceVariant"> | string | null
    overridesRaceASI?: JsonFilter<"RaceVariant">
    overridesRaceSpeed?: IntNullableFilter<"RaceVariant"> | number | null
    overridesFlightSpeed?: IntNullableFilter<"RaceVariant"> | number | null
    replacesTraits?: RaceTraitListRelationFilter
    traits?: RaceVariantTraitListRelationFilter
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    perses?: PersListRelationFilter
  }

  export type RaceVariantOrderByWithRelationInput = {
    raceVariantId?: SortOrder
    raceId?: SortOrder
    name?: SortOrder
    source?: SortOrder
    exclusivityGroup?: SortOrderInput | SortOrder
    overridesRaceASI?: SortOrder
    overridesRaceSpeed?: SortOrderInput | SortOrder
    overridesFlightSpeed?: SortOrderInput | SortOrder
    replacesTraits?: RaceTraitOrderByRelationAggregateInput
    traits?: RaceVariantTraitOrderByRelationAggregateInput
    race?: RaceOrderByWithRelationInput
    perses?: PersOrderByRelationAggregateInput
  }

  export type RaceVariantWhereUniqueInput = Prisma.AtLeast<{
    raceVariantId?: number
    AND?: RaceVariantWhereInput | RaceVariantWhereInput[]
    OR?: RaceVariantWhereInput[]
    NOT?: RaceVariantWhereInput | RaceVariantWhereInput[]
    raceId?: IntFilter<"RaceVariant"> | number
    name?: EnumVariantsFilter<"RaceVariant"> | $Enums.Variants
    source?: EnumSourceFilter<"RaceVariant"> | $Enums.Source
    exclusivityGroup?: StringNullableFilter<"RaceVariant"> | string | null
    overridesRaceASI?: JsonFilter<"RaceVariant">
    overridesRaceSpeed?: IntNullableFilter<"RaceVariant"> | number | null
    overridesFlightSpeed?: IntNullableFilter<"RaceVariant"> | number | null
    replacesTraits?: RaceTraitListRelationFilter
    traits?: RaceVariantTraitListRelationFilter
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    perses?: PersListRelationFilter
  }, "raceVariantId">

  export type RaceVariantOrderByWithAggregationInput = {
    raceVariantId?: SortOrder
    raceId?: SortOrder
    name?: SortOrder
    source?: SortOrder
    exclusivityGroup?: SortOrderInput | SortOrder
    overridesRaceASI?: SortOrder
    overridesRaceSpeed?: SortOrderInput | SortOrder
    overridesFlightSpeed?: SortOrderInput | SortOrder
    _count?: RaceVariantCountOrderByAggregateInput
    _avg?: RaceVariantAvgOrderByAggregateInput
    _max?: RaceVariantMaxOrderByAggregateInput
    _min?: RaceVariantMinOrderByAggregateInput
    _sum?: RaceVariantSumOrderByAggregateInput
  }

  export type RaceVariantScalarWhereWithAggregatesInput = {
    AND?: RaceVariantScalarWhereWithAggregatesInput | RaceVariantScalarWhereWithAggregatesInput[]
    OR?: RaceVariantScalarWhereWithAggregatesInput[]
    NOT?: RaceVariantScalarWhereWithAggregatesInput | RaceVariantScalarWhereWithAggregatesInput[]
    raceVariantId?: IntWithAggregatesFilter<"RaceVariant"> | number
    raceId?: IntWithAggregatesFilter<"RaceVariant"> | number
    name?: EnumVariantsWithAggregatesFilter<"RaceVariant"> | $Enums.Variants
    source?: EnumSourceWithAggregatesFilter<"RaceVariant"> | $Enums.Source
    exclusivityGroup?: StringNullableWithAggregatesFilter<"RaceVariant"> | string | null
    overridesRaceASI?: JsonWithAggregatesFilter<"RaceVariant">
    overridesRaceSpeed?: IntNullableWithAggregatesFilter<"RaceVariant"> | number | null
    overridesFlightSpeed?: IntNullableWithAggregatesFilter<"RaceVariant"> | number | null
  }

  export type RaceChoiceOptionWhereInput = {
    AND?: RaceChoiceOptionWhereInput | RaceChoiceOptionWhereInput[]
    OR?: RaceChoiceOptionWhereInput[]
    NOT?: RaceChoiceOptionWhereInput | RaceChoiceOptionWhereInput[]
    optionId?: IntFilter<"RaceChoiceOption"> | number
    raceId?: IntFilter<"RaceChoiceOption"> | number
    subraceId?: IntNullableFilter<"RaceChoiceOption"> | number | null
    choiceGroupName?: StringFilter<"RaceChoiceOption"> | string
    optionName?: StringFilter<"RaceChoiceOption"> | string
    description?: StringNullableFilter<"RaceChoiceOption"> | string | null
    selectMultiple?: BoolFilter<"RaceChoiceOption"> | boolean
    maxSelection?: IntFilter<"RaceChoiceOption"> | number
    grantsASI?: JsonNullableFilter<"RaceChoiceOption">
    grantsSkillProficiencies?: EnumSkillsNullableListFilter<"RaceChoiceOption">
    grantsLanguages?: EnumLanguageNullableListFilter<"RaceChoiceOption">
    languagesToChooseCount?: IntFilter<"RaceChoiceOption"> | number
    modifiesSpeed?: IntNullableFilter<"RaceChoiceOption"> | number | null
    draconicDamageType?: EnumDamageTypeNullableFilter<"RaceChoiceOption"> | $Enums.DamageType | null
    breathWeaponShape?: EnumAOEShapesNullableFilter<"RaceChoiceOption"> | $Enums.AOEShapes | null
    breathWeaponAOE?: StringNullableFilter<"RaceChoiceOption"> | string | null
    grantsTraits?: RaceChoiceOptionTraitListRelationFilter
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    subrace?: XOR<SubraceNullableScalarRelationFilter, SubraceWhereInput> | null
    perses?: PersListRelationFilter
  }

  export type RaceChoiceOptionOrderByWithRelationInput = {
    optionId?: SortOrder
    raceId?: SortOrder
    subraceId?: SortOrderInput | SortOrder
    choiceGroupName?: SortOrder
    optionName?: SortOrder
    description?: SortOrderInput | SortOrder
    selectMultiple?: SortOrder
    maxSelection?: SortOrder
    grantsASI?: SortOrderInput | SortOrder
    grantsSkillProficiencies?: SortOrder
    grantsLanguages?: SortOrder
    languagesToChooseCount?: SortOrder
    modifiesSpeed?: SortOrderInput | SortOrder
    draconicDamageType?: SortOrderInput | SortOrder
    breathWeaponShape?: SortOrderInput | SortOrder
    breathWeaponAOE?: SortOrderInput | SortOrder
    grantsTraits?: RaceChoiceOptionTraitOrderByRelationAggregateInput
    race?: RaceOrderByWithRelationInput
    subrace?: SubraceOrderByWithRelationInput
    perses?: PersOrderByRelationAggregateInput
  }

  export type RaceChoiceOptionWhereUniqueInput = Prisma.AtLeast<{
    optionId?: number
    raceId_subraceId_choiceGroupName_optionName?: RaceChoiceOptionRaceIdSubraceIdChoiceGroupNameOptionNameCompoundUniqueInput
    AND?: RaceChoiceOptionWhereInput | RaceChoiceOptionWhereInput[]
    OR?: RaceChoiceOptionWhereInput[]
    NOT?: RaceChoiceOptionWhereInput | RaceChoiceOptionWhereInput[]
    raceId?: IntFilter<"RaceChoiceOption"> | number
    subraceId?: IntNullableFilter<"RaceChoiceOption"> | number | null
    choiceGroupName?: StringFilter<"RaceChoiceOption"> | string
    optionName?: StringFilter<"RaceChoiceOption"> | string
    description?: StringNullableFilter<"RaceChoiceOption"> | string | null
    selectMultiple?: BoolFilter<"RaceChoiceOption"> | boolean
    maxSelection?: IntFilter<"RaceChoiceOption"> | number
    grantsASI?: JsonNullableFilter<"RaceChoiceOption">
    grantsSkillProficiencies?: EnumSkillsNullableListFilter<"RaceChoiceOption">
    grantsLanguages?: EnumLanguageNullableListFilter<"RaceChoiceOption">
    languagesToChooseCount?: IntFilter<"RaceChoiceOption"> | number
    modifiesSpeed?: IntNullableFilter<"RaceChoiceOption"> | number | null
    draconicDamageType?: EnumDamageTypeNullableFilter<"RaceChoiceOption"> | $Enums.DamageType | null
    breathWeaponShape?: EnumAOEShapesNullableFilter<"RaceChoiceOption"> | $Enums.AOEShapes | null
    breathWeaponAOE?: StringNullableFilter<"RaceChoiceOption"> | string | null
    grantsTraits?: RaceChoiceOptionTraitListRelationFilter
    race?: XOR<RaceScalarRelationFilter, RaceWhereInput>
    subrace?: XOR<SubraceNullableScalarRelationFilter, SubraceWhereInput> | null
    perses?: PersListRelationFilter
  }, "optionId" | "raceId_subraceId_choiceGroupName_optionName">

  export type RaceChoiceOptionOrderByWithAggregationInput = {
    optionId?: SortOrder
    raceId?: SortOrder
    subraceId?: SortOrderInput | SortOrder
    choiceGroupName?: SortOrder
    optionName?: SortOrder
    description?: SortOrderInput | SortOrder
    selectMultiple?: SortOrder
    maxSelection?: SortOrder
    grantsASI?: SortOrderInput | SortOrder
    grantsSkillProficiencies?: SortOrder
    grantsLanguages?: SortOrder
    languagesToChooseCount?: SortOrder
    modifiesSpeed?: SortOrderInput | SortOrder
    draconicDamageType?: SortOrderInput | SortOrder
    breathWeaponShape?: SortOrderInput | SortOrder
    breathWeaponAOE?: SortOrderInput | SortOrder
    _count?: RaceChoiceOptionCountOrderByAggregateInput
    _avg?: RaceChoiceOptionAvgOrderByAggregateInput
    _max?: RaceChoiceOptionMaxOrderByAggregateInput
    _min?: RaceChoiceOptionMinOrderByAggregateInput
    _sum?: RaceChoiceOptionSumOrderByAggregateInput
  }

  export type RaceChoiceOptionScalarWhereWithAggregatesInput = {
    AND?: RaceChoiceOptionScalarWhereWithAggregatesInput | RaceChoiceOptionScalarWhereWithAggregatesInput[]
    OR?: RaceChoiceOptionScalarWhereWithAggregatesInput[]
    NOT?: RaceChoiceOptionScalarWhereWithAggregatesInput | RaceChoiceOptionScalarWhereWithAggregatesInput[]
    optionId?: IntWithAggregatesFilter<"RaceChoiceOption"> | number
    raceId?: IntWithAggregatesFilter<"RaceChoiceOption"> | number
    subraceId?: IntNullableWithAggregatesFilter<"RaceChoiceOption"> | number | null
    choiceGroupName?: StringWithAggregatesFilter<"RaceChoiceOption"> | string
    optionName?: StringWithAggregatesFilter<"RaceChoiceOption"> | string
    description?: StringNullableWithAggregatesFilter<"RaceChoiceOption"> | string | null
    selectMultiple?: BoolWithAggregatesFilter<"RaceChoiceOption"> | boolean
    maxSelection?: IntWithAggregatesFilter<"RaceChoiceOption"> | number
    grantsASI?: JsonNullableWithAggregatesFilter<"RaceChoiceOption">
    grantsSkillProficiencies?: EnumSkillsNullableListFilter<"RaceChoiceOption">
    grantsLanguages?: EnumLanguageNullableListFilter<"RaceChoiceOption">
    languagesToChooseCount?: IntWithAggregatesFilter<"RaceChoiceOption"> | number
    modifiesSpeed?: IntNullableWithAggregatesFilter<"RaceChoiceOption"> | number | null
    draconicDamageType?: EnumDamageTypeNullableWithAggregatesFilter<"RaceChoiceOption"> | $Enums.DamageType | null
    breathWeaponShape?: EnumAOEShapesNullableWithAggregatesFilter<"RaceChoiceOption"> | $Enums.AOEShapes | null
    breathWeaponAOE?: StringNullableWithAggregatesFilter<"RaceChoiceOption"> | string | null
  }

  export type BackgroundWhereInput = {
    AND?: BackgroundWhereInput | BackgroundWhereInput[]
    OR?: BackgroundWhereInput[]
    NOT?: BackgroundWhereInput | BackgroundWhereInput[]
    backgroundId?: IntFilter<"Background"> | number
    name?: EnumBackgroundCategoryFilter<"Background"> | $Enums.BackgroundCategory
    source?: EnumSourceFilter<"Background"> | $Enums.Source
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Background">
    skillProficiencies?: EnumSkillsNullableListFilter<"Background">
    languagesToChooseCount?: IntFilter<"Background"> | number
    items?: JsonNullableFilter<"Background">
    perses?: PersListRelationFilter
  }

  export type BackgroundOrderByWithRelationInput = {
    backgroundId?: SortOrder
    name?: SortOrder
    source?: SortOrder
    toolProficiencies?: SortOrder
    skillProficiencies?: SortOrder
    languagesToChooseCount?: SortOrder
    items?: SortOrderInput | SortOrder
    perses?: PersOrderByRelationAggregateInput
  }

  export type BackgroundWhereUniqueInput = Prisma.AtLeast<{
    backgroundId?: number
    name?: $Enums.BackgroundCategory
    AND?: BackgroundWhereInput | BackgroundWhereInput[]
    OR?: BackgroundWhereInput[]
    NOT?: BackgroundWhereInput | BackgroundWhereInput[]
    source?: EnumSourceFilter<"Background"> | $Enums.Source
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Background">
    skillProficiencies?: EnumSkillsNullableListFilter<"Background">
    languagesToChooseCount?: IntFilter<"Background"> | number
    items?: JsonNullableFilter<"Background">
    perses?: PersListRelationFilter
  }, "backgroundId" | "name">

  export type BackgroundOrderByWithAggregationInput = {
    backgroundId?: SortOrder
    name?: SortOrder
    source?: SortOrder
    toolProficiencies?: SortOrder
    skillProficiencies?: SortOrder
    languagesToChooseCount?: SortOrder
    items?: SortOrderInput | SortOrder
    _count?: BackgroundCountOrderByAggregateInput
    _avg?: BackgroundAvgOrderByAggregateInput
    _max?: BackgroundMaxOrderByAggregateInput
    _min?: BackgroundMinOrderByAggregateInput
    _sum?: BackgroundSumOrderByAggregateInput
  }

  export type BackgroundScalarWhereWithAggregatesInput = {
    AND?: BackgroundScalarWhereWithAggregatesInput | BackgroundScalarWhereWithAggregatesInput[]
    OR?: BackgroundScalarWhereWithAggregatesInput[]
    NOT?: BackgroundScalarWhereWithAggregatesInput | BackgroundScalarWhereWithAggregatesInput[]
    backgroundId?: IntWithAggregatesFilter<"Background"> | number
    name?: EnumBackgroundCategoryWithAggregatesFilter<"Background"> | $Enums.BackgroundCategory
    source?: EnumSourceWithAggregatesFilter<"Background"> | $Enums.Source
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Background">
    skillProficiencies?: EnumSkillsNullableListFilter<"Background">
    languagesToChooseCount?: IntWithAggregatesFilter<"Background"> | number
    items?: JsonNullableWithAggregatesFilter<"Background">
  }

  export type FeatWhereInput = {
    AND?: FeatWhereInput | FeatWhereInput[]
    OR?: FeatWhereInput[]
    NOT?: FeatWhereInput | FeatWhereInput[]
    featId?: IntFilter<"Feat"> | number
    name?: StringFilter<"Feat"> | string
    category?: EnumFeatCategoryFilter<"Feat"> | $Enums.FeatCategory
    shortDescription?: StringFilter<"Feat"> | string
    longDescription?: StringFilter<"Feat"> | string
    languagesToChooseCount?: IntFilter<"Feat"> | number
    languages?: EnumLanguageNullableListFilter<"Feat">
    prerequisites?: JsonNullableFilter<"Feat">
    featFeatures?: FeatFeatureListRelationFilter
    featAbilityBoost?: XOR<FeatAbilityBoostNullableScalarRelationFilter, FeatAbilityBoostWhereInput> | null
    persFeats?: PersFeatListRelationFilter
  }

  export type FeatOrderByWithRelationInput = {
    featId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    languagesToChooseCount?: SortOrder
    languages?: SortOrder
    prerequisites?: SortOrderInput | SortOrder
    featFeatures?: FeatFeatureOrderByRelationAggregateInput
    featAbilityBoost?: FeatAbilityBoostOrderByWithRelationInput
    persFeats?: PersFeatOrderByRelationAggregateInput
  }

  export type FeatWhereUniqueInput = Prisma.AtLeast<{
    featId?: number
    AND?: FeatWhereInput | FeatWhereInput[]
    OR?: FeatWhereInput[]
    NOT?: FeatWhereInput | FeatWhereInput[]
    name?: StringFilter<"Feat"> | string
    category?: EnumFeatCategoryFilter<"Feat"> | $Enums.FeatCategory
    shortDescription?: StringFilter<"Feat"> | string
    longDescription?: StringFilter<"Feat"> | string
    languagesToChooseCount?: IntFilter<"Feat"> | number
    languages?: EnumLanguageNullableListFilter<"Feat">
    prerequisites?: JsonNullableFilter<"Feat">
    featFeatures?: FeatFeatureListRelationFilter
    featAbilityBoost?: XOR<FeatAbilityBoostNullableScalarRelationFilter, FeatAbilityBoostWhereInput> | null
    persFeats?: PersFeatListRelationFilter
  }, "featId">

  export type FeatOrderByWithAggregationInput = {
    featId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    languagesToChooseCount?: SortOrder
    languages?: SortOrder
    prerequisites?: SortOrderInput | SortOrder
    _count?: FeatCountOrderByAggregateInput
    _avg?: FeatAvgOrderByAggregateInput
    _max?: FeatMaxOrderByAggregateInput
    _min?: FeatMinOrderByAggregateInput
    _sum?: FeatSumOrderByAggregateInput
  }

  export type FeatScalarWhereWithAggregatesInput = {
    AND?: FeatScalarWhereWithAggregatesInput | FeatScalarWhereWithAggregatesInput[]
    OR?: FeatScalarWhereWithAggregatesInput[]
    NOT?: FeatScalarWhereWithAggregatesInput | FeatScalarWhereWithAggregatesInput[]
    featId?: IntWithAggregatesFilter<"Feat"> | number
    name?: StringWithAggregatesFilter<"Feat"> | string
    category?: EnumFeatCategoryWithAggregatesFilter<"Feat"> | $Enums.FeatCategory
    shortDescription?: StringWithAggregatesFilter<"Feat"> | string
    longDescription?: StringWithAggregatesFilter<"Feat"> | string
    languagesToChooseCount?: IntWithAggregatesFilter<"Feat"> | number
    languages?: EnumLanguageNullableListFilter<"Feat">
    prerequisites?: JsonNullableWithAggregatesFilter<"Feat">
  }

  export type FeatAbilityBoostWhereInput = {
    AND?: FeatAbilityBoostWhereInput | FeatAbilityBoostWhereInput[]
    OR?: FeatAbilityBoostWhereInput[]
    NOT?: FeatAbilityBoostWhereInput | FeatAbilityBoostWhereInput[]
    boostId?: IntFilter<"FeatAbilityBoost"> | number
    featId?: IntFilter<"FeatAbilityBoost"> | number
    ability?: EnumAbilityNullableFilter<"FeatAbilityBoost"> | $Enums.Ability | null
    increaseValue?: IntFilter<"FeatAbilityBoost"> | number
    abilitiesToChoose?: EnumAbilityNullableListFilter<"FeatAbilityBoost">
    maxValue?: IntFilter<"FeatAbilityBoost"> | number
    feat?: XOR<FeatScalarRelationFilter, FeatWhereInput>
  }

  export type FeatAbilityBoostOrderByWithRelationInput = {
    boostId?: SortOrder
    featId?: SortOrder
    ability?: SortOrderInput | SortOrder
    increaseValue?: SortOrder
    abilitiesToChoose?: SortOrder
    maxValue?: SortOrder
    feat?: FeatOrderByWithRelationInput
  }

  export type FeatAbilityBoostWhereUniqueInput = Prisma.AtLeast<{
    boostId?: number
    featId?: number
    AND?: FeatAbilityBoostWhereInput | FeatAbilityBoostWhereInput[]
    OR?: FeatAbilityBoostWhereInput[]
    NOT?: FeatAbilityBoostWhereInput | FeatAbilityBoostWhereInput[]
    ability?: EnumAbilityNullableFilter<"FeatAbilityBoost"> | $Enums.Ability | null
    increaseValue?: IntFilter<"FeatAbilityBoost"> | number
    abilitiesToChoose?: EnumAbilityNullableListFilter<"FeatAbilityBoost">
    maxValue?: IntFilter<"FeatAbilityBoost"> | number
    feat?: XOR<FeatScalarRelationFilter, FeatWhereInput>
  }, "boostId" | "featId">

  export type FeatAbilityBoostOrderByWithAggregationInput = {
    boostId?: SortOrder
    featId?: SortOrder
    ability?: SortOrderInput | SortOrder
    increaseValue?: SortOrder
    abilitiesToChoose?: SortOrder
    maxValue?: SortOrder
    _count?: FeatAbilityBoostCountOrderByAggregateInput
    _avg?: FeatAbilityBoostAvgOrderByAggregateInput
    _max?: FeatAbilityBoostMaxOrderByAggregateInput
    _min?: FeatAbilityBoostMinOrderByAggregateInput
    _sum?: FeatAbilityBoostSumOrderByAggregateInput
  }

  export type FeatAbilityBoostScalarWhereWithAggregatesInput = {
    AND?: FeatAbilityBoostScalarWhereWithAggregatesInput | FeatAbilityBoostScalarWhereWithAggregatesInput[]
    OR?: FeatAbilityBoostScalarWhereWithAggregatesInput[]
    NOT?: FeatAbilityBoostScalarWhereWithAggregatesInput | FeatAbilityBoostScalarWhereWithAggregatesInput[]
    boostId?: IntWithAggregatesFilter<"FeatAbilityBoost"> | number
    featId?: IntWithAggregatesFilter<"FeatAbilityBoost"> | number
    ability?: EnumAbilityNullableWithAggregatesFilter<"FeatAbilityBoost"> | $Enums.Ability | null
    increaseValue?: IntWithAggregatesFilter<"FeatAbilityBoost"> | number
    abilitiesToChoose?: EnumAbilityNullableListFilter<"FeatAbilityBoost">
    maxValue?: IntWithAggregatesFilter<"FeatAbilityBoost"> | number
  }

  export type PersFeatWhereInput = {
    AND?: PersFeatWhereInput | PersFeatWhereInput[]
    OR?: PersFeatWhereInput[]
    NOT?: PersFeatWhereInput | PersFeatWhereInput[]
    persFeatId?: IntFilter<"PersFeat"> | number
    featId?: IntFilter<"PersFeat"> | number
    persId?: IntFilter<"PersFeat"> | number
    feat?: XOR<FeatScalarRelationFilter, FeatWhereInput>
    pers?: XOR<PersScalarRelationFilter, PersWhereInput>
  }

  export type PersFeatOrderByWithRelationInput = {
    persFeatId?: SortOrder
    featId?: SortOrder
    persId?: SortOrder
    feat?: FeatOrderByWithRelationInput
    pers?: PersOrderByWithRelationInput
  }

  export type PersFeatWhereUniqueInput = Prisma.AtLeast<{
    persFeatId?: number
    featId_persId?: PersFeatFeatIdPersIdCompoundUniqueInput
    AND?: PersFeatWhereInput | PersFeatWhereInput[]
    OR?: PersFeatWhereInput[]
    NOT?: PersFeatWhereInput | PersFeatWhereInput[]
    featId?: IntFilter<"PersFeat"> | number
    persId?: IntFilter<"PersFeat"> | number
    feat?: XOR<FeatScalarRelationFilter, FeatWhereInput>
    pers?: XOR<PersScalarRelationFilter, PersWhereInput>
  }, "persFeatId" | "featId_persId">

  export type PersFeatOrderByWithAggregationInput = {
    persFeatId?: SortOrder
    featId?: SortOrder
    persId?: SortOrder
    _count?: PersFeatCountOrderByAggregateInput
    _avg?: PersFeatAvgOrderByAggregateInput
    _max?: PersFeatMaxOrderByAggregateInput
    _min?: PersFeatMinOrderByAggregateInput
    _sum?: PersFeatSumOrderByAggregateInput
  }

  export type PersFeatScalarWhereWithAggregatesInput = {
    AND?: PersFeatScalarWhereWithAggregatesInput | PersFeatScalarWhereWithAggregatesInput[]
    OR?: PersFeatScalarWhereWithAggregatesInput[]
    NOT?: PersFeatScalarWhereWithAggregatesInput | PersFeatScalarWhereWithAggregatesInput[]
    persFeatId?: IntWithAggregatesFilter<"PersFeat"> | number
    featId?: IntWithAggregatesFilter<"PersFeat"> | number
    persId?: IntWithAggregatesFilter<"PersFeat"> | number
  }

  export type MagicItemWhereInput = {
    AND?: MagicItemWhereInput | MagicItemWhereInput[]
    OR?: MagicItemWhereInput[]
    NOT?: MagicItemWhereInput | MagicItemWhereInput[]
    magicItemId?: IntFilter<"MagicItem"> | number
    name?: StringFilter<"MagicItem"> | string
    itemType?: EnumMagicItemTypeFilter<"MagicItem"> | $Enums.MagicItemType
    rarity?: EnumItemRarityFilter<"MagicItem"> | $Enums.ItemRarity
    description?: StringFilter<"MagicItem"> | string
    bonusToAC?: IntNullableFilter<"MagicItem"> | number | null
    bonusToAttackRoll?: IntNullableFilter<"MagicItem"> | number | null
    bonusToDamage?: IntNullableFilter<"MagicItem"> | number | null
    features?: MagicItemFeatureListRelationFilter
    persMagicItems?: PersMagicItemListRelationFilter
  }

  export type MagicItemOrderByWithRelationInput = {
    magicItemId?: SortOrder
    name?: SortOrder
    itemType?: SortOrder
    rarity?: SortOrder
    description?: SortOrder
    bonusToAC?: SortOrderInput | SortOrder
    bonusToAttackRoll?: SortOrderInput | SortOrder
    bonusToDamage?: SortOrderInput | SortOrder
    features?: MagicItemFeatureOrderByRelationAggregateInput
    persMagicItems?: PersMagicItemOrderByRelationAggregateInput
  }

  export type MagicItemWhereUniqueInput = Prisma.AtLeast<{
    magicItemId?: number
    name?: string
    AND?: MagicItemWhereInput | MagicItemWhereInput[]
    OR?: MagicItemWhereInput[]
    NOT?: MagicItemWhereInput | MagicItemWhereInput[]
    itemType?: EnumMagicItemTypeFilter<"MagicItem"> | $Enums.MagicItemType
    rarity?: EnumItemRarityFilter<"MagicItem"> | $Enums.ItemRarity
    description?: StringFilter<"MagicItem"> | string
    bonusToAC?: IntNullableFilter<"MagicItem"> | number | null
    bonusToAttackRoll?: IntNullableFilter<"MagicItem"> | number | null
    bonusToDamage?: IntNullableFilter<"MagicItem"> | number | null
    features?: MagicItemFeatureListRelationFilter
    persMagicItems?: PersMagicItemListRelationFilter
  }, "magicItemId" | "name">

  export type MagicItemOrderByWithAggregationInput = {
    magicItemId?: SortOrder
    name?: SortOrder
    itemType?: SortOrder
    rarity?: SortOrder
    description?: SortOrder
    bonusToAC?: SortOrderInput | SortOrder
    bonusToAttackRoll?: SortOrderInput | SortOrder
    bonusToDamage?: SortOrderInput | SortOrder
    _count?: MagicItemCountOrderByAggregateInput
    _avg?: MagicItemAvgOrderByAggregateInput
    _max?: MagicItemMaxOrderByAggregateInput
    _min?: MagicItemMinOrderByAggregateInput
    _sum?: MagicItemSumOrderByAggregateInput
  }

  export type MagicItemScalarWhereWithAggregatesInput = {
    AND?: MagicItemScalarWhereWithAggregatesInput | MagicItemScalarWhereWithAggregatesInput[]
    OR?: MagicItemScalarWhereWithAggregatesInput[]
    NOT?: MagicItemScalarWhereWithAggregatesInput | MagicItemScalarWhereWithAggregatesInput[]
    magicItemId?: IntWithAggregatesFilter<"MagicItem"> | number
    name?: StringWithAggregatesFilter<"MagicItem"> | string
    itemType?: EnumMagicItemTypeWithAggregatesFilter<"MagicItem"> | $Enums.MagicItemType
    rarity?: EnumItemRarityWithAggregatesFilter<"MagicItem"> | $Enums.ItemRarity
    description?: StringWithAggregatesFilter<"MagicItem"> | string
    bonusToAC?: IntNullableWithAggregatesFilter<"MagicItem"> | number | null
    bonusToAttackRoll?: IntNullableWithAggregatesFilter<"MagicItem"> | number | null
    bonusToDamage?: IntNullableWithAggregatesFilter<"MagicItem"> | number | null
  }

  export type WeaponWhereInput = {
    AND?: WeaponWhereInput | WeaponWhereInput[]
    OR?: WeaponWhereInput[]
    NOT?: WeaponWhereInput | WeaponWhereInput[]
    weaponId?: IntFilter<"Weapon"> | number
    name?: EnumWeaponCategoryFilter<"Weapon"> | $Enums.WeaponCategory
    damage?: StringFilter<"Weapon"> | string
    damageType?: EnumDamageTypeFilter<"Weapon"> | $Enums.DamageType
    weaponType?: EnumWeaponTypeFilter<"Weapon"> | $Enums.WeaponType
    properties?: EnumWeaponPropertyNullableListFilter<"Weapon">
    versatileDamage?: StringNullableFilter<"Weapon"> | string | null
    normalRange?: IntNullableFilter<"Weapon"> | number | null
    longRange?: IntNullableFilter<"Weapon"> | number | null
    persWeapons?: PersWeaponListRelationFilter
    classStartingEquipmentOption?: ClassStartingEquipmentOptionListRelationFilter
  }

  export type WeaponOrderByWithRelationInput = {
    weaponId?: SortOrder
    name?: SortOrder
    damage?: SortOrder
    damageType?: SortOrder
    weaponType?: SortOrder
    properties?: SortOrder
    versatileDamage?: SortOrderInput | SortOrder
    normalRange?: SortOrderInput | SortOrder
    longRange?: SortOrderInput | SortOrder
    persWeapons?: PersWeaponOrderByRelationAggregateInput
    classStartingEquipmentOption?: ClassStartingEquipmentOptionOrderByRelationAggregateInput
  }

  export type WeaponWhereUniqueInput = Prisma.AtLeast<{
    weaponId?: number
    name?: $Enums.WeaponCategory
    AND?: WeaponWhereInput | WeaponWhereInput[]
    OR?: WeaponWhereInput[]
    NOT?: WeaponWhereInput | WeaponWhereInput[]
    damage?: StringFilter<"Weapon"> | string
    damageType?: EnumDamageTypeFilter<"Weapon"> | $Enums.DamageType
    weaponType?: EnumWeaponTypeFilter<"Weapon"> | $Enums.WeaponType
    properties?: EnumWeaponPropertyNullableListFilter<"Weapon">
    versatileDamage?: StringNullableFilter<"Weapon"> | string | null
    normalRange?: IntNullableFilter<"Weapon"> | number | null
    longRange?: IntNullableFilter<"Weapon"> | number | null
    persWeapons?: PersWeaponListRelationFilter
    classStartingEquipmentOption?: ClassStartingEquipmentOptionListRelationFilter
  }, "weaponId" | "name">

  export type WeaponOrderByWithAggregationInput = {
    weaponId?: SortOrder
    name?: SortOrder
    damage?: SortOrder
    damageType?: SortOrder
    weaponType?: SortOrder
    properties?: SortOrder
    versatileDamage?: SortOrderInput | SortOrder
    normalRange?: SortOrderInput | SortOrder
    longRange?: SortOrderInput | SortOrder
    _count?: WeaponCountOrderByAggregateInput
    _avg?: WeaponAvgOrderByAggregateInput
    _max?: WeaponMaxOrderByAggregateInput
    _min?: WeaponMinOrderByAggregateInput
    _sum?: WeaponSumOrderByAggregateInput
  }

  export type WeaponScalarWhereWithAggregatesInput = {
    AND?: WeaponScalarWhereWithAggregatesInput | WeaponScalarWhereWithAggregatesInput[]
    OR?: WeaponScalarWhereWithAggregatesInput[]
    NOT?: WeaponScalarWhereWithAggregatesInput | WeaponScalarWhereWithAggregatesInput[]
    weaponId?: IntWithAggregatesFilter<"Weapon"> | number
    name?: EnumWeaponCategoryWithAggregatesFilter<"Weapon"> | $Enums.WeaponCategory
    damage?: StringWithAggregatesFilter<"Weapon"> | string
    damageType?: EnumDamageTypeWithAggregatesFilter<"Weapon"> | $Enums.DamageType
    weaponType?: EnumWeaponTypeWithAggregatesFilter<"Weapon"> | $Enums.WeaponType
    properties?: EnumWeaponPropertyNullableListFilter<"Weapon">
    versatileDamage?: StringNullableWithAggregatesFilter<"Weapon"> | string | null
    normalRange?: IntNullableWithAggregatesFilter<"Weapon"> | number | null
    longRange?: IntNullableWithAggregatesFilter<"Weapon"> | number | null
  }

  export type ArmorWhereInput = {
    AND?: ArmorWhereInput | ArmorWhereInput[]
    OR?: ArmorWhereInput[]
    NOT?: ArmorWhereInput | ArmorWhereInput[]
    armorId?: IntFilter<"Armor"> | number
    name?: EnumArmorCategoryFilter<"Armor"> | $Enums.ArmorCategory
    armorType?: EnumArmorTypeFilter<"Armor"> | $Enums.ArmorType
    baseAC?: IntFilter<"Armor"> | number
    strengthReq?: IntNullableFilter<"Armor"> | number | null
    stealthDisadvantage?: BoolFilter<"Armor"> | boolean
    persArmor?: PersArmorListRelationFilter
    classStartingEquipmentOption?: ClassStartingEquipmentOptionListRelationFilter
  }

  export type ArmorOrderByWithRelationInput = {
    armorId?: SortOrder
    name?: SortOrder
    armorType?: SortOrder
    baseAC?: SortOrder
    strengthReq?: SortOrderInput | SortOrder
    stealthDisadvantage?: SortOrder
    persArmor?: PersArmorOrderByRelationAggregateInput
    classStartingEquipmentOption?: ClassStartingEquipmentOptionOrderByRelationAggregateInput
  }

  export type ArmorWhereUniqueInput = Prisma.AtLeast<{
    armorId?: number
    name?: $Enums.ArmorCategory
    AND?: ArmorWhereInput | ArmorWhereInput[]
    OR?: ArmorWhereInput[]
    NOT?: ArmorWhereInput | ArmorWhereInput[]
    armorType?: EnumArmorTypeFilter<"Armor"> | $Enums.ArmorType
    baseAC?: IntFilter<"Armor"> | number
    strengthReq?: IntNullableFilter<"Armor"> | number | null
    stealthDisadvantage?: BoolFilter<"Armor"> | boolean
    persArmor?: PersArmorListRelationFilter
    classStartingEquipmentOption?: ClassStartingEquipmentOptionListRelationFilter
  }, "armorId" | "name">

  export type ArmorOrderByWithAggregationInput = {
    armorId?: SortOrder
    name?: SortOrder
    armorType?: SortOrder
    baseAC?: SortOrder
    strengthReq?: SortOrderInput | SortOrder
    stealthDisadvantage?: SortOrder
    _count?: ArmorCountOrderByAggregateInput
    _avg?: ArmorAvgOrderByAggregateInput
    _max?: ArmorMaxOrderByAggregateInput
    _min?: ArmorMinOrderByAggregateInput
    _sum?: ArmorSumOrderByAggregateInput
  }

  export type ArmorScalarWhereWithAggregatesInput = {
    AND?: ArmorScalarWhereWithAggregatesInput | ArmorScalarWhereWithAggregatesInput[]
    OR?: ArmorScalarWhereWithAggregatesInput[]
    NOT?: ArmorScalarWhereWithAggregatesInput | ArmorScalarWhereWithAggregatesInput[]
    armorId?: IntWithAggregatesFilter<"Armor"> | number
    name?: EnumArmorCategoryWithAggregatesFilter<"Armor"> | $Enums.ArmorCategory
    armorType?: EnumArmorTypeWithAggregatesFilter<"Armor"> | $Enums.ArmorType
    baseAC?: IntWithAggregatesFilter<"Armor"> | number
    strengthReq?: IntNullableWithAggregatesFilter<"Armor"> | number | null
    stealthDisadvantage?: BoolWithAggregatesFilter<"Armor"> | boolean
  }

  export type PersSkillWhereInput = {
    AND?: PersSkillWhereInput | PersSkillWhereInput[]
    OR?: PersSkillWhereInput[]
    NOT?: PersSkillWhereInput | PersSkillWhereInput[]
    persSkillId?: IntFilter<"PersSkill"> | number
    skillId?: IntFilter<"PersSkill"> | number
    persId?: IntFilter<"PersSkill"> | number
    proficiencyType?: EnumSkillProficiencyTypeFilter<"PersSkill"> | $Enums.SkillProficiencyType
    customModifier?: IntNullableFilter<"PersSkill"> | number | null
    name?: EnumSkillsFilter<"PersSkill"> | $Enums.Skills
    pers?: XOR<PersScalarRelationFilter, PersWhereInput>
  }

  export type PersSkillOrderByWithRelationInput = {
    persSkillId?: SortOrder
    skillId?: SortOrder
    persId?: SortOrder
    proficiencyType?: SortOrder
    customModifier?: SortOrderInput | SortOrder
    name?: SortOrder
    pers?: PersOrderByWithRelationInput
  }

  export type PersSkillWhereUniqueInput = Prisma.AtLeast<{
    persSkillId?: number
    persId_name?: PersSkillPersIdNameCompoundUniqueInput
    AND?: PersSkillWhereInput | PersSkillWhereInput[]
    OR?: PersSkillWhereInput[]
    NOT?: PersSkillWhereInput | PersSkillWhereInput[]
    skillId?: IntFilter<"PersSkill"> | number
    persId?: IntFilter<"PersSkill"> | number
    proficiencyType?: EnumSkillProficiencyTypeFilter<"PersSkill"> | $Enums.SkillProficiencyType
    customModifier?: IntNullableFilter<"PersSkill"> | number | null
    name?: EnumSkillsFilter<"PersSkill"> | $Enums.Skills
    pers?: XOR<PersScalarRelationFilter, PersWhereInput>
  }, "persSkillId" | "persId_name">

  export type PersSkillOrderByWithAggregationInput = {
    persSkillId?: SortOrder
    skillId?: SortOrder
    persId?: SortOrder
    proficiencyType?: SortOrder
    customModifier?: SortOrderInput | SortOrder
    name?: SortOrder
    _count?: PersSkillCountOrderByAggregateInput
    _avg?: PersSkillAvgOrderByAggregateInput
    _max?: PersSkillMaxOrderByAggregateInput
    _min?: PersSkillMinOrderByAggregateInput
    _sum?: PersSkillSumOrderByAggregateInput
  }

  export type PersSkillScalarWhereWithAggregatesInput = {
    AND?: PersSkillScalarWhereWithAggregatesInput | PersSkillScalarWhereWithAggregatesInput[]
    OR?: PersSkillScalarWhereWithAggregatesInput[]
    NOT?: PersSkillScalarWhereWithAggregatesInput | PersSkillScalarWhereWithAggregatesInput[]
    persSkillId?: IntWithAggregatesFilter<"PersSkill"> | number
    skillId?: IntWithAggregatesFilter<"PersSkill"> | number
    persId?: IntWithAggregatesFilter<"PersSkill"> | number
    proficiencyType?: EnumSkillProficiencyTypeWithAggregatesFilter<"PersSkill"> | $Enums.SkillProficiencyType
    customModifier?: IntNullableWithAggregatesFilter<"PersSkill"> | number | null
    name?: EnumSkillsWithAggregatesFilter<"PersSkill"> | $Enums.Skills
  }

  export type PersWeaponWhereInput = {
    AND?: PersWeaponWhereInput | PersWeaponWhereInput[]
    OR?: PersWeaponWhereInput[]
    NOT?: PersWeaponWhereInput | PersWeaponWhereInput[]
    persWeaponId?: IntFilter<"PersWeapon"> | number
    persId?: IntFilter<"PersWeapon"> | number
    weaponId?: IntFilter<"PersWeapon"> | number
    overrideDamage?: StringNullableFilter<"PersWeapon"> | string | null
    attackBonus?: IntNullableFilter<"PersWeapon"> | number | null
    overrideName?: StringNullableFilter<"PersWeapon"> | string | null
    overrideNormalRange?: IntNullableFilter<"PersWeapon"> | number | null
    overrideLongRange?: IntNullableFilter<"PersWeapon"> | number | null
    overrideDamageType?: EnumDamageTypeNullableFilter<"PersWeapon"> | $Enums.DamageType | null
    overrideAttackAbility?: EnumAbilityNullableFilter<"PersWeapon"> | $Enums.Ability | null
    isProficient?: BoolFilter<"PersWeapon"> | boolean
    pers?: XOR<PersScalarRelationFilter, PersWhereInput>
    weapon?: XOR<WeaponScalarRelationFilter, WeaponWhereInput>
  }

  export type PersWeaponOrderByWithRelationInput = {
    persWeaponId?: SortOrder
    persId?: SortOrder
    weaponId?: SortOrder
    overrideDamage?: SortOrderInput | SortOrder
    attackBonus?: SortOrderInput | SortOrder
    overrideName?: SortOrderInput | SortOrder
    overrideNormalRange?: SortOrderInput | SortOrder
    overrideLongRange?: SortOrderInput | SortOrder
    overrideDamageType?: SortOrderInput | SortOrder
    overrideAttackAbility?: SortOrderInput | SortOrder
    isProficient?: SortOrder
    pers?: PersOrderByWithRelationInput
    weapon?: WeaponOrderByWithRelationInput
  }

  export type PersWeaponWhereUniqueInput = Prisma.AtLeast<{
    persWeaponId?: number
    AND?: PersWeaponWhereInput | PersWeaponWhereInput[]
    OR?: PersWeaponWhereInput[]
    NOT?: PersWeaponWhereInput | PersWeaponWhereInput[]
    persId?: IntFilter<"PersWeapon"> | number
    weaponId?: IntFilter<"PersWeapon"> | number
    overrideDamage?: StringNullableFilter<"PersWeapon"> | string | null
    attackBonus?: IntNullableFilter<"PersWeapon"> | number | null
    overrideName?: StringNullableFilter<"PersWeapon"> | string | null
    overrideNormalRange?: IntNullableFilter<"PersWeapon"> | number | null
    overrideLongRange?: IntNullableFilter<"PersWeapon"> | number | null
    overrideDamageType?: EnumDamageTypeNullableFilter<"PersWeapon"> | $Enums.DamageType | null
    overrideAttackAbility?: EnumAbilityNullableFilter<"PersWeapon"> | $Enums.Ability | null
    isProficient?: BoolFilter<"PersWeapon"> | boolean
    pers?: XOR<PersScalarRelationFilter, PersWhereInput>
    weapon?: XOR<WeaponScalarRelationFilter, WeaponWhereInput>
  }, "persWeaponId">

  export type PersWeaponOrderByWithAggregationInput = {
    persWeaponId?: SortOrder
    persId?: SortOrder
    weaponId?: SortOrder
    overrideDamage?: SortOrderInput | SortOrder
    attackBonus?: SortOrderInput | SortOrder
    overrideName?: SortOrderInput | SortOrder
    overrideNormalRange?: SortOrderInput | SortOrder
    overrideLongRange?: SortOrderInput | SortOrder
    overrideDamageType?: SortOrderInput | SortOrder
    overrideAttackAbility?: SortOrderInput | SortOrder
    isProficient?: SortOrder
    _count?: PersWeaponCountOrderByAggregateInput
    _avg?: PersWeaponAvgOrderByAggregateInput
    _max?: PersWeaponMaxOrderByAggregateInput
    _min?: PersWeaponMinOrderByAggregateInput
    _sum?: PersWeaponSumOrderByAggregateInput
  }

  export type PersWeaponScalarWhereWithAggregatesInput = {
    AND?: PersWeaponScalarWhereWithAggregatesInput | PersWeaponScalarWhereWithAggregatesInput[]
    OR?: PersWeaponScalarWhereWithAggregatesInput[]
    NOT?: PersWeaponScalarWhereWithAggregatesInput | PersWeaponScalarWhereWithAggregatesInput[]
    persWeaponId?: IntWithAggregatesFilter<"PersWeapon"> | number
    persId?: IntWithAggregatesFilter<"PersWeapon"> | number
    weaponId?: IntWithAggregatesFilter<"PersWeapon"> | number
    overrideDamage?: StringNullableWithAggregatesFilter<"PersWeapon"> | string | null
    attackBonus?: IntNullableWithAggregatesFilter<"PersWeapon"> | number | null
    overrideName?: StringNullableWithAggregatesFilter<"PersWeapon"> | string | null
    overrideNormalRange?: IntNullableWithAggregatesFilter<"PersWeapon"> | number | null
    overrideLongRange?: IntNullableWithAggregatesFilter<"PersWeapon"> | number | null
    overrideDamageType?: EnumDamageTypeNullableWithAggregatesFilter<"PersWeapon"> | $Enums.DamageType | null
    overrideAttackAbility?: EnumAbilityNullableWithAggregatesFilter<"PersWeapon"> | $Enums.Ability | null
    isProficient?: BoolWithAggregatesFilter<"PersWeapon"> | boolean
  }

  export type PersArmorWhereInput = {
    AND?: PersArmorWhereInput | PersArmorWhereInput[]
    OR?: PersArmorWhereInput[]
    NOT?: PersArmorWhereInput | PersArmorWhereInput[]
    persArmorId?: IntFilter<"PersArmor"> | number
    armorId?: IntFilter<"PersArmor"> | number
    persId?: IntFilter<"PersArmor"> | number
    overrideBaseAC?: IntNullableFilter<"PersArmor"> | number | null
    miscACBonus?: IntNullableFilter<"PersArmor"> | number | null
    isProficient?: BoolFilter<"PersArmor"> | boolean
    equipped?: BoolFilter<"PersArmor"> | boolean
    pers?: XOR<PersScalarRelationFilter, PersWhereInput>
    armor?: XOR<ArmorScalarRelationFilter, ArmorWhereInput>
  }

  export type PersArmorOrderByWithRelationInput = {
    persArmorId?: SortOrder
    armorId?: SortOrder
    persId?: SortOrder
    overrideBaseAC?: SortOrderInput | SortOrder
    miscACBonus?: SortOrderInput | SortOrder
    isProficient?: SortOrder
    equipped?: SortOrder
    pers?: PersOrderByWithRelationInput
    armor?: ArmorOrderByWithRelationInput
  }

  export type PersArmorWhereUniqueInput = Prisma.AtLeast<{
    persArmorId?: number
    AND?: PersArmorWhereInput | PersArmorWhereInput[]
    OR?: PersArmorWhereInput[]
    NOT?: PersArmorWhereInput | PersArmorWhereInput[]
    armorId?: IntFilter<"PersArmor"> | number
    persId?: IntFilter<"PersArmor"> | number
    overrideBaseAC?: IntNullableFilter<"PersArmor"> | number | null
    miscACBonus?: IntNullableFilter<"PersArmor"> | number | null
    isProficient?: BoolFilter<"PersArmor"> | boolean
    equipped?: BoolFilter<"PersArmor"> | boolean
    pers?: XOR<PersScalarRelationFilter, PersWhereInput>
    armor?: XOR<ArmorScalarRelationFilter, ArmorWhereInput>
  }, "persArmorId">

  export type PersArmorOrderByWithAggregationInput = {
    persArmorId?: SortOrder
    armorId?: SortOrder
    persId?: SortOrder
    overrideBaseAC?: SortOrderInput | SortOrder
    miscACBonus?: SortOrderInput | SortOrder
    isProficient?: SortOrder
    equipped?: SortOrder
    _count?: PersArmorCountOrderByAggregateInput
    _avg?: PersArmorAvgOrderByAggregateInput
    _max?: PersArmorMaxOrderByAggregateInput
    _min?: PersArmorMinOrderByAggregateInput
    _sum?: PersArmorSumOrderByAggregateInput
  }

  export type PersArmorScalarWhereWithAggregatesInput = {
    AND?: PersArmorScalarWhereWithAggregatesInput | PersArmorScalarWhereWithAggregatesInput[]
    OR?: PersArmorScalarWhereWithAggregatesInput[]
    NOT?: PersArmorScalarWhereWithAggregatesInput | PersArmorScalarWhereWithAggregatesInput[]
    persArmorId?: IntWithAggregatesFilter<"PersArmor"> | number
    armorId?: IntWithAggregatesFilter<"PersArmor"> | number
    persId?: IntWithAggregatesFilter<"PersArmor"> | number
    overrideBaseAC?: IntNullableWithAggregatesFilter<"PersArmor"> | number | null
    miscACBonus?: IntNullableWithAggregatesFilter<"PersArmor"> | number | null
    isProficient?: BoolWithAggregatesFilter<"PersArmor"> | boolean
    equipped?: BoolWithAggregatesFilter<"PersArmor"> | boolean
  }

  export type PersMagicItemWhereInput = {
    AND?: PersMagicItemWhereInput | PersMagicItemWhereInput[]
    OR?: PersMagicItemWhereInput[]
    NOT?: PersMagicItemWhereInput | PersMagicItemWhereInput[]
    persMagicItemId?: IntFilter<"PersMagicItem"> | number
    persId?: IntFilter<"PersMagicItem"> | number
    magicItemId?: IntFilter<"PersMagicItem"> | number
    pers?: XOR<PersScalarRelationFilter, PersWhereInput>
    magicItem?: XOR<MagicItemScalarRelationFilter, MagicItemWhereInput>
  }

  export type PersMagicItemOrderByWithRelationInput = {
    persMagicItemId?: SortOrder
    persId?: SortOrder
    magicItemId?: SortOrder
    pers?: PersOrderByWithRelationInput
    magicItem?: MagicItemOrderByWithRelationInput
  }

  export type PersMagicItemWhereUniqueInput = Prisma.AtLeast<{
    persMagicItemId?: number
    AND?: PersMagicItemWhereInput | PersMagicItemWhereInput[]
    OR?: PersMagicItemWhereInput[]
    NOT?: PersMagicItemWhereInput | PersMagicItemWhereInput[]
    persId?: IntFilter<"PersMagicItem"> | number
    magicItemId?: IntFilter<"PersMagicItem"> | number
    pers?: XOR<PersScalarRelationFilter, PersWhereInput>
    magicItem?: XOR<MagicItemScalarRelationFilter, MagicItemWhereInput>
  }, "persMagicItemId">

  export type PersMagicItemOrderByWithAggregationInput = {
    persMagicItemId?: SortOrder
    persId?: SortOrder
    magicItemId?: SortOrder
    _count?: PersMagicItemCountOrderByAggregateInput
    _avg?: PersMagicItemAvgOrderByAggregateInput
    _max?: PersMagicItemMaxOrderByAggregateInput
    _min?: PersMagicItemMinOrderByAggregateInput
    _sum?: PersMagicItemSumOrderByAggregateInput
  }

  export type PersMagicItemScalarWhereWithAggregatesInput = {
    AND?: PersMagicItemScalarWhereWithAggregatesInput | PersMagicItemScalarWhereWithAggregatesInput[]
    OR?: PersMagicItemScalarWhereWithAggregatesInput[]
    NOT?: PersMagicItemScalarWhereWithAggregatesInput | PersMagicItemScalarWhereWithAggregatesInput[]
    persMagicItemId?: IntWithAggregatesFilter<"PersMagicItem"> | number
    persId?: IntWithAggregatesFilter<"PersMagicItem"> | number
    magicItemId?: IntWithAggregatesFilter<"PersMagicItem"> | number
  }

  export type EquipmentPackWhereInput = {
    AND?: EquipmentPackWhereInput | EquipmentPackWhereInput[]
    OR?: EquipmentPackWhereInput[]
    NOT?: EquipmentPackWhereInput | EquipmentPackWhereInput[]
    equipmentPackId?: IntFilter<"EquipmentPack"> | number
    name?: EnumEquipmentPackCategoryFilter<"EquipmentPack"> | $Enums.EquipmentPackCategory
    description?: StringFilter<"EquipmentPack"> | string
    items?: JsonFilter<"EquipmentPack">
    classStartingEquipmentOptions?: ClassStartingEquipmentOptionListRelationFilter
  }

  export type EquipmentPackOrderByWithRelationInput = {
    equipmentPackId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    items?: SortOrder
    classStartingEquipmentOptions?: ClassStartingEquipmentOptionOrderByRelationAggregateInput
  }

  export type EquipmentPackWhereUniqueInput = Prisma.AtLeast<{
    equipmentPackId?: number
    name?: $Enums.EquipmentPackCategory
    AND?: EquipmentPackWhereInput | EquipmentPackWhereInput[]
    OR?: EquipmentPackWhereInput[]
    NOT?: EquipmentPackWhereInput | EquipmentPackWhereInput[]
    description?: StringFilter<"EquipmentPack"> | string
    items?: JsonFilter<"EquipmentPack">
    classStartingEquipmentOptions?: ClassStartingEquipmentOptionListRelationFilter
  }, "equipmentPackId" | "name">

  export type EquipmentPackOrderByWithAggregationInput = {
    equipmentPackId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    items?: SortOrder
    _count?: EquipmentPackCountOrderByAggregateInput
    _avg?: EquipmentPackAvgOrderByAggregateInput
    _max?: EquipmentPackMaxOrderByAggregateInput
    _min?: EquipmentPackMinOrderByAggregateInput
    _sum?: EquipmentPackSumOrderByAggregateInput
  }

  export type EquipmentPackScalarWhereWithAggregatesInput = {
    AND?: EquipmentPackScalarWhereWithAggregatesInput | EquipmentPackScalarWhereWithAggregatesInput[]
    OR?: EquipmentPackScalarWhereWithAggregatesInput[]
    NOT?: EquipmentPackScalarWhereWithAggregatesInput | EquipmentPackScalarWhereWithAggregatesInput[]
    equipmentPackId?: IntWithAggregatesFilter<"EquipmentPack"> | number
    name?: EnumEquipmentPackCategoryWithAggregatesFilter<"EquipmentPack"> | $Enums.EquipmentPackCategory
    description?: StringWithAggregatesFilter<"EquipmentPack"> | string
    items?: JsonWithAggregatesFilter<"EquipmentPack">
  }

  export type ClassStartingEquipmentOptionWhereInput = {
    AND?: ClassStartingEquipmentOptionWhereInput | ClassStartingEquipmentOptionWhereInput[]
    OR?: ClassStartingEquipmentOptionWhereInput[]
    NOT?: ClassStartingEquipmentOptionWhereInput | ClassStartingEquipmentOptionWhereInput[]
    optionId?: IntFilter<"ClassStartingEquipmentOption"> | number
    classId?: IntFilter<"ClassStartingEquipmentOption"> | number
    choiceGroup?: IntFilter<"ClassStartingEquipmentOption"> | number
    option?: StringFilter<"ClassStartingEquipmentOption"> | string
    weaponId?: IntNullableFilter<"ClassStartingEquipmentOption"> | number | null
    armorId?: IntNullableFilter<"ClassStartingEquipmentOption"> | number | null
    equipmentPackId?: IntNullableFilter<"ClassStartingEquipmentOption"> | number | null
    quantity?: IntFilter<"ClassStartingEquipmentOption"> | number
    chooseAnyArmor?: BoolFilter<"ClassStartingEquipmentOption"> | boolean
    armorType?: EnumArmorTypeNullableFilter<"ClassStartingEquipmentOption"> | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFilter<"ClassStartingEquipmentOption"> | boolean
    weaponType?: EnumWeaponTypeNullableFilter<"ClassStartingEquipmentOption"> | $Enums.WeaponType | null
    weaponCount?: IntFilter<"ClassStartingEquipmentOption"> | number
    description?: StringNullableFilter<"ClassStartingEquipmentOption"> | string | null
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    weapon?: XOR<WeaponNullableScalarRelationFilter, WeaponWhereInput> | null
    armor?: XOR<ArmorNullableScalarRelationFilter, ArmorWhereInput> | null
    equipmentPack?: XOR<EquipmentPackNullableScalarRelationFilter, EquipmentPackWhereInput> | null
  }

  export type ClassStartingEquipmentOptionOrderByWithRelationInput = {
    optionId?: SortOrder
    classId?: SortOrder
    choiceGroup?: SortOrder
    option?: SortOrder
    weaponId?: SortOrderInput | SortOrder
    armorId?: SortOrderInput | SortOrder
    equipmentPackId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    chooseAnyArmor?: SortOrder
    armorType?: SortOrderInput | SortOrder
    chooseAnyWeapon?: SortOrder
    weaponType?: SortOrderInput | SortOrder
    weaponCount?: SortOrder
    description?: SortOrderInput | SortOrder
    class?: ClassOrderByWithRelationInput
    weapon?: WeaponOrderByWithRelationInput
    armor?: ArmorOrderByWithRelationInput
    equipmentPack?: EquipmentPackOrderByWithRelationInput
  }

  export type ClassStartingEquipmentOptionWhereUniqueInput = Prisma.AtLeast<{
    optionId?: number
    AND?: ClassStartingEquipmentOptionWhereInput | ClassStartingEquipmentOptionWhereInput[]
    OR?: ClassStartingEquipmentOptionWhereInput[]
    NOT?: ClassStartingEquipmentOptionWhereInput | ClassStartingEquipmentOptionWhereInput[]
    classId?: IntFilter<"ClassStartingEquipmentOption"> | number
    choiceGroup?: IntFilter<"ClassStartingEquipmentOption"> | number
    option?: StringFilter<"ClassStartingEquipmentOption"> | string
    weaponId?: IntNullableFilter<"ClassStartingEquipmentOption"> | number | null
    armorId?: IntNullableFilter<"ClassStartingEquipmentOption"> | number | null
    equipmentPackId?: IntNullableFilter<"ClassStartingEquipmentOption"> | number | null
    quantity?: IntFilter<"ClassStartingEquipmentOption"> | number
    chooseAnyArmor?: BoolFilter<"ClassStartingEquipmentOption"> | boolean
    armorType?: EnumArmorTypeNullableFilter<"ClassStartingEquipmentOption"> | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFilter<"ClassStartingEquipmentOption"> | boolean
    weaponType?: EnumWeaponTypeNullableFilter<"ClassStartingEquipmentOption"> | $Enums.WeaponType | null
    weaponCount?: IntFilter<"ClassStartingEquipmentOption"> | number
    description?: StringNullableFilter<"ClassStartingEquipmentOption"> | string | null
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    weapon?: XOR<WeaponNullableScalarRelationFilter, WeaponWhereInput> | null
    armor?: XOR<ArmorNullableScalarRelationFilter, ArmorWhereInput> | null
    equipmentPack?: XOR<EquipmentPackNullableScalarRelationFilter, EquipmentPackWhereInput> | null
  }, "optionId">

  export type ClassStartingEquipmentOptionOrderByWithAggregationInput = {
    optionId?: SortOrder
    classId?: SortOrder
    choiceGroup?: SortOrder
    option?: SortOrder
    weaponId?: SortOrderInput | SortOrder
    armorId?: SortOrderInput | SortOrder
    equipmentPackId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    chooseAnyArmor?: SortOrder
    armorType?: SortOrderInput | SortOrder
    chooseAnyWeapon?: SortOrder
    weaponType?: SortOrderInput | SortOrder
    weaponCount?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ClassStartingEquipmentOptionCountOrderByAggregateInput
    _avg?: ClassStartingEquipmentOptionAvgOrderByAggregateInput
    _max?: ClassStartingEquipmentOptionMaxOrderByAggregateInput
    _min?: ClassStartingEquipmentOptionMinOrderByAggregateInput
    _sum?: ClassStartingEquipmentOptionSumOrderByAggregateInput
  }

  export type ClassStartingEquipmentOptionScalarWhereWithAggregatesInput = {
    AND?: ClassStartingEquipmentOptionScalarWhereWithAggregatesInput | ClassStartingEquipmentOptionScalarWhereWithAggregatesInput[]
    OR?: ClassStartingEquipmentOptionScalarWhereWithAggregatesInput[]
    NOT?: ClassStartingEquipmentOptionScalarWhereWithAggregatesInput | ClassStartingEquipmentOptionScalarWhereWithAggregatesInput[]
    optionId?: IntWithAggregatesFilter<"ClassStartingEquipmentOption"> | number
    classId?: IntWithAggregatesFilter<"ClassStartingEquipmentOption"> | number
    choiceGroup?: IntWithAggregatesFilter<"ClassStartingEquipmentOption"> | number
    option?: StringWithAggregatesFilter<"ClassStartingEquipmentOption"> | string
    weaponId?: IntNullableWithAggregatesFilter<"ClassStartingEquipmentOption"> | number | null
    armorId?: IntNullableWithAggregatesFilter<"ClassStartingEquipmentOption"> | number | null
    equipmentPackId?: IntNullableWithAggregatesFilter<"ClassStartingEquipmentOption"> | number | null
    quantity?: IntWithAggregatesFilter<"ClassStartingEquipmentOption"> | number
    chooseAnyArmor?: BoolWithAggregatesFilter<"ClassStartingEquipmentOption"> | boolean
    armorType?: EnumArmorTypeNullableWithAggregatesFilter<"ClassStartingEquipmentOption"> | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolWithAggregatesFilter<"ClassStartingEquipmentOption"> | boolean
    weaponType?: EnumWeaponTypeNullableWithAggregatesFilter<"ClassStartingEquipmentOption"> | $Enums.WeaponType | null
    weaponCount?: IntWithAggregatesFilter<"ClassStartingEquipmentOption"> | number
    description?: StringNullableWithAggregatesFilter<"ClassStartingEquipmentOption"> | string | null
  }

  export type CharacterCreateInput = {
    name?: string | null
    user?: UserCreateNestedOneWithoutCharacterInput
    characterSpells?: CharacterSpellsCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateInput = {
    characterId?: number
    name?: string | null
    userId?: number | null
    characterSpells?: CharacterSpellsUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCharacterNestedInput
    characterSpells?: CharacterSpellsUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateInput = {
    characterId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    characterSpells?: CharacterSpellsUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterCreateManyInput = {
    characterId?: number
    name?: string | null
    userId?: number | null
  }

  export type CharacterUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterUncheckedUpdateManyInput = {
    characterId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterSpellsCreateInput = {
    character?: CharacterCreateNestedOneWithoutCharacterSpellsInput
    spell?: SpellCreateNestedOneWithoutCharacterSpellsInput
  }

  export type CharacterSpellsUncheckedCreateInput = {
    characterSpellId?: number
    characterId?: number | null
    spellId?: number | null
  }

  export type CharacterSpellsUpdateInput = {
    character?: CharacterUpdateOneWithoutCharacterSpellsNestedInput
    spell?: SpellUpdateOneWithoutCharacterSpellsNestedInput
  }

  export type CharacterSpellsUncheckedUpdateInput = {
    characterSpellId?: IntFieldUpdateOperationsInput | number
    characterId?: NullableIntFieldUpdateOperationsInput | number | null
    spellId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterSpellsCreateManyInput = {
    characterSpellId?: number
    characterId?: number | null
    spellId?: number | null
  }

  export type CharacterSpellsUpdateManyMutationInput = {

  }

  export type CharacterSpellsUncheckedUpdateManyInput = {
    characterSpellId?: IntFieldUpdateOperationsInput | number
    characterId?: NullableIntFieldUpdateOperationsInput | number | null
    spellId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CreatureCreateInput = {
    name?: string | null
    nameEng?: string | null
    size?: string | null
    type?: string | null
    alignment?: string | null
    source?: $Enums.Source
    ac?: string | null
    hp?: string | null
    speed?: string | null
    strength?: string | null
    dexterity?: string | null
    constitution?: string | null
    intelligence?: string | null
    wisdom?: string | null
    charisma?: string | null
    skills?: string | null
    senses?: string | null
    languages?: string | null
    challenge?: string | null
    damageImmunity?: string | null
    damageResistance?: string | null
    conditionImmunity?: string | null
    savingThrows?: string | null
    specialAbilities?: string | null
    actions?: string | null
    reactions?: string | null
    legendaryActions?: string | null
    proficiencyBonus?: string | null
    description?: string | null
    lairActions?: string | null
    lairInfo?: string | null
    regionEffects?: string | null
    xp?: string | null
  }

  export type CreatureUncheckedCreateInput = {
    creatureId?: number
    name?: string | null
    nameEng?: string | null
    size?: string | null
    type?: string | null
    alignment?: string | null
    source?: $Enums.Source
    ac?: string | null
    hp?: string | null
    speed?: string | null
    strength?: string | null
    dexterity?: string | null
    constitution?: string | null
    intelligence?: string | null
    wisdom?: string | null
    charisma?: string | null
    skills?: string | null
    senses?: string | null
    languages?: string | null
    challenge?: string | null
    damageImmunity?: string | null
    damageResistance?: string | null
    conditionImmunity?: string | null
    savingThrows?: string | null
    specialAbilities?: string | null
    actions?: string | null
    reactions?: string | null
    legendaryActions?: string | null
    proficiencyBonus?: string | null
    description?: string | null
    lairActions?: string | null
    lairInfo?: string | null
    regionEffects?: string | null
    xp?: string | null
  }

  export type CreatureUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameEng?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    alignment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    ac?: NullableStringFieldUpdateOperationsInput | string | null
    hp?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    dexterity?: NullableStringFieldUpdateOperationsInput | string | null
    constitution?: NullableStringFieldUpdateOperationsInput | string | null
    intelligence?: NullableStringFieldUpdateOperationsInput | string | null
    wisdom?: NullableStringFieldUpdateOperationsInput | string | null
    charisma?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    senses?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: NullableStringFieldUpdateOperationsInput | string | null
    damageImmunity?: NullableStringFieldUpdateOperationsInput | string | null
    damageResistance?: NullableStringFieldUpdateOperationsInput | string | null
    conditionImmunity?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrows?: NullableStringFieldUpdateOperationsInput | string | null
    specialAbilities?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: NullableStringFieldUpdateOperationsInput | string | null
    reactions?: NullableStringFieldUpdateOperationsInput | string | null
    legendaryActions?: NullableStringFieldUpdateOperationsInput | string | null
    proficiencyBonus?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lairActions?: NullableStringFieldUpdateOperationsInput | string | null
    lairInfo?: NullableStringFieldUpdateOperationsInput | string | null
    regionEffects?: NullableStringFieldUpdateOperationsInput | string | null
    xp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatureUncheckedUpdateInput = {
    creatureId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameEng?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    alignment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    ac?: NullableStringFieldUpdateOperationsInput | string | null
    hp?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    dexterity?: NullableStringFieldUpdateOperationsInput | string | null
    constitution?: NullableStringFieldUpdateOperationsInput | string | null
    intelligence?: NullableStringFieldUpdateOperationsInput | string | null
    wisdom?: NullableStringFieldUpdateOperationsInput | string | null
    charisma?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    senses?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: NullableStringFieldUpdateOperationsInput | string | null
    damageImmunity?: NullableStringFieldUpdateOperationsInput | string | null
    damageResistance?: NullableStringFieldUpdateOperationsInput | string | null
    conditionImmunity?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrows?: NullableStringFieldUpdateOperationsInput | string | null
    specialAbilities?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: NullableStringFieldUpdateOperationsInput | string | null
    reactions?: NullableStringFieldUpdateOperationsInput | string | null
    legendaryActions?: NullableStringFieldUpdateOperationsInput | string | null
    proficiencyBonus?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lairActions?: NullableStringFieldUpdateOperationsInput | string | null
    lairInfo?: NullableStringFieldUpdateOperationsInput | string | null
    regionEffects?: NullableStringFieldUpdateOperationsInput | string | null
    xp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatureCreateManyInput = {
    creatureId?: number
    name?: string | null
    nameEng?: string | null
    size?: string | null
    type?: string | null
    alignment?: string | null
    source?: $Enums.Source
    ac?: string | null
    hp?: string | null
    speed?: string | null
    strength?: string | null
    dexterity?: string | null
    constitution?: string | null
    intelligence?: string | null
    wisdom?: string | null
    charisma?: string | null
    skills?: string | null
    senses?: string | null
    languages?: string | null
    challenge?: string | null
    damageImmunity?: string | null
    damageResistance?: string | null
    conditionImmunity?: string | null
    savingThrows?: string | null
    specialAbilities?: string | null
    actions?: string | null
    reactions?: string | null
    legendaryActions?: string | null
    proficiencyBonus?: string | null
    description?: string | null
    lairActions?: string | null
    lairInfo?: string | null
    regionEffects?: string | null
    xp?: string | null
  }

  export type CreatureUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameEng?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    alignment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    ac?: NullableStringFieldUpdateOperationsInput | string | null
    hp?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    dexterity?: NullableStringFieldUpdateOperationsInput | string | null
    constitution?: NullableStringFieldUpdateOperationsInput | string | null
    intelligence?: NullableStringFieldUpdateOperationsInput | string | null
    wisdom?: NullableStringFieldUpdateOperationsInput | string | null
    charisma?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    senses?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: NullableStringFieldUpdateOperationsInput | string | null
    damageImmunity?: NullableStringFieldUpdateOperationsInput | string | null
    damageResistance?: NullableStringFieldUpdateOperationsInput | string | null
    conditionImmunity?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrows?: NullableStringFieldUpdateOperationsInput | string | null
    specialAbilities?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: NullableStringFieldUpdateOperationsInput | string | null
    reactions?: NullableStringFieldUpdateOperationsInput | string | null
    legendaryActions?: NullableStringFieldUpdateOperationsInput | string | null
    proficiencyBonus?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lairActions?: NullableStringFieldUpdateOperationsInput | string | null
    lairInfo?: NullableStringFieldUpdateOperationsInput | string | null
    regionEffects?: NullableStringFieldUpdateOperationsInput | string | null
    xp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatureUncheckedUpdateManyInput = {
    creatureId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameEng?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    alignment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    ac?: NullableStringFieldUpdateOperationsInput | string | null
    hp?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    dexterity?: NullableStringFieldUpdateOperationsInput | string | null
    constitution?: NullableStringFieldUpdateOperationsInput | string | null
    intelligence?: NullableStringFieldUpdateOperationsInput | string | null
    wisdom?: NullableStringFieldUpdateOperationsInput | string | null
    charisma?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    senses?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: NullableStringFieldUpdateOperationsInput | string | null
    damageImmunity?: NullableStringFieldUpdateOperationsInput | string | null
    damageResistance?: NullableStringFieldUpdateOperationsInput | string | null
    conditionImmunity?: NullableStringFieldUpdateOperationsInput | string | null
    savingThrows?: NullableStringFieldUpdateOperationsInput | string | null
    specialAbilities?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: NullableStringFieldUpdateOperationsInput | string | null
    reactions?: NullableStringFieldUpdateOperationsInput | string | null
    legendaryActions?: NullableStringFieldUpdateOperationsInput | string | null
    proficiencyBonus?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lairActions?: NullableStringFieldUpdateOperationsInput | string | null
    lairInfo?: NullableStringFieldUpdateOperationsInput | string | null
    regionEffects?: NullableStringFieldUpdateOperationsInput | string | null
    xp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellCreateInput = {
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    characterSpells?: CharacterSpellsCreateNestedManyWithoutSpellInput
    spellClasses?: SpellClassesCreateNestedManyWithoutSpellInput
    spellRaces?: SpellRacesCreateNestedManyWithoutSpellInput
    spellbookSpells?: SpellbookSpellsCreateNestedManyWithoutSpellInput
    subclasses?: SubclassCreateNestedManyWithoutExpandedSpellsInput
    perses?: PersCreateNestedManyWithoutSpellsInput
    features?: FeatureCreateNestedManyWithoutGivesSpellsInput
  }

  export type SpellUncheckedCreateInput = {
    spellId?: number
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    characterSpells?: CharacterSpellsUncheckedCreateNestedManyWithoutSpellInput
    spellClasses?: SpellClassesUncheckedCreateNestedManyWithoutSpellInput
    spellRaces?: SpellRacesUncheckedCreateNestedManyWithoutSpellInput
    spellbookSpells?: SpellbookSpellsUncheckedCreateNestedManyWithoutSpellInput
    subclasses?: SubclassUncheckedCreateNestedManyWithoutExpandedSpellsInput
    perses?: PersUncheckedCreateNestedManyWithoutSpellsInput
    features?: FeatureUncheckedCreateNestedManyWithoutGivesSpellsInput
  }

  export type SpellUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    characterSpells?: CharacterSpellsUpdateManyWithoutSpellNestedInput
    spellClasses?: SpellClassesUpdateManyWithoutSpellNestedInput
    spellRaces?: SpellRacesUpdateManyWithoutSpellNestedInput
    spellbookSpells?: SpellbookSpellsUpdateManyWithoutSpellNestedInput
    subclasses?: SubclassUpdateManyWithoutExpandedSpellsNestedInput
    perses?: PersUpdateManyWithoutSpellsNestedInput
    features?: FeatureUpdateManyWithoutGivesSpellsNestedInput
  }

  export type SpellUncheckedUpdateInput = {
    spellId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    characterSpells?: CharacterSpellsUncheckedUpdateManyWithoutSpellNestedInput
    spellClasses?: SpellClassesUncheckedUpdateManyWithoutSpellNestedInput
    spellRaces?: SpellRacesUncheckedUpdateManyWithoutSpellNestedInput
    spellbookSpells?: SpellbookSpellsUncheckedUpdateManyWithoutSpellNestedInput
    subclasses?: SubclassUncheckedUpdateManyWithoutExpandedSpellsNestedInput
    perses?: PersUncheckedUpdateManyWithoutSpellsNestedInput
    features?: FeatureUncheckedUpdateManyWithoutGivesSpellsNestedInput
  }

  export type SpellCreateManyInput = {
    spellId?: number
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
  }

  export type SpellUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
  }

  export type SpellUncheckedUpdateManyInput = {
    spellId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
  }

  export type SpellClassesCreateInput = {
    className: string
    spell: SpellCreateNestedOneWithoutSpellClassesInput
  }

  export type SpellClassesUncheckedCreateInput = {
    classId?: number
    spellId: number
    className: string
  }

  export type SpellClassesUpdateInput = {
    className?: StringFieldUpdateOperationsInput | string
    spell?: SpellUpdateOneRequiredWithoutSpellClassesNestedInput
  }

  export type SpellClassesUncheckedUpdateInput = {
    classId?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
  }

  export type SpellClassesCreateManyInput = {
    classId?: number
    spellId: number
    className: string
  }

  export type SpellClassesUpdateManyMutationInput = {
    className?: StringFieldUpdateOperationsInput | string
  }

  export type SpellClassesUncheckedUpdateManyInput = {
    classId?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
  }

  export type SpellRacesCreateInput = {
    raceName?: string | null
    spell?: SpellCreateNestedOneWithoutSpellRacesInput
  }

  export type SpellRacesUncheckedCreateInput = {
    spellId?: number | null
    raceId?: number
    raceName?: string | null
  }

  export type SpellRacesUpdateInput = {
    raceName?: NullableStringFieldUpdateOperationsInput | string | null
    spell?: SpellUpdateOneWithoutSpellRacesNestedInput
  }

  export type SpellRacesUncheckedUpdateInput = {
    spellId?: NullableIntFieldUpdateOperationsInput | number | null
    raceId?: IntFieldUpdateOperationsInput | number
    raceName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellRacesCreateManyInput = {
    spellId?: number | null
    raceId?: number
    raceName?: string | null
  }

  export type SpellRacesUpdateManyMutationInput = {
    raceName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellRacesUncheckedUpdateManyInput = {
    spellId?: NullableIntFieldUpdateOperationsInput | number | null
    raceId?: IntFieldUpdateOperationsInput | number
    raceName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellbookCreateInput = {
    user?: UserCreateNestedOneWithoutSpellbookInput
    spellbookSpells?: SpellbookSpellsCreateNestedManyWithoutSpellbookInput
  }

  export type SpellbookUncheckedCreateInput = {
    spellbookId?: number
    userId?: number | null
    spellbookSpells?: SpellbookSpellsUncheckedCreateNestedManyWithoutSpellbookInput
  }

  export type SpellbookUpdateInput = {
    user?: UserUpdateOneWithoutSpellbookNestedInput
    spellbookSpells?: SpellbookSpellsUpdateManyWithoutSpellbookNestedInput
  }

  export type SpellbookUncheckedUpdateInput = {
    spellbookId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    spellbookSpells?: SpellbookSpellsUncheckedUpdateManyWithoutSpellbookNestedInput
  }

  export type SpellbookCreateManyInput = {
    spellbookId?: number
    userId?: number | null
  }

  export type SpellbookUpdateManyMutationInput = {

  }

  export type SpellbookUncheckedUpdateManyInput = {
    spellbookId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellbookSpellsCreateInput = {
    spell?: SpellCreateNestedOneWithoutSpellbookSpellsInput
    spellbook?: SpellbookCreateNestedOneWithoutSpellbookSpellsInput
  }

  export type SpellbookSpellsUncheckedCreateInput = {
    spellbookSpellId?: number
    spellId?: number | null
    spellbookId?: number | null
  }

  export type SpellbookSpellsUpdateInput = {
    spell?: SpellUpdateOneWithoutSpellbookSpellsNestedInput
    spellbook?: SpellbookUpdateOneWithoutSpellbookSpellsNestedInput
  }

  export type SpellbookSpellsUncheckedUpdateInput = {
    spellbookSpellId?: IntFieldUpdateOperationsInput | number
    spellId?: NullableIntFieldUpdateOperationsInput | number | null
    spellbookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellbookSpellsCreateManyInput = {
    spellbookSpellId?: number
    spellId?: number | null
    spellbookId?: number | null
  }

  export type SpellbookSpellsUpdateManyMutationInput = {

  }

  export type SpellbookSpellsUncheckedUpdateManyInput = {
    spellbookSpellId?: IntFieldUpdateOperationsInput | number
    spellId?: NullableIntFieldUpdateOperationsInput | number | null
    spellbookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateInput = {
    login: string
    password?: string | null
    character?: CharacterCreateNestedManyWithoutUserInput
    spellbook?: SpellbookCreateNestedManyWithoutUserInput
    pers?: PersCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    userId?: number
    login: string
    password?: string | null
    character?: CharacterUncheckedCreateNestedManyWithoutUserInput
    spellbook?: SpellbookUncheckedCreateNestedManyWithoutUserInput
    pers?: PersUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateManyWithoutUserNestedInput
    spellbook?: SpellbookUpdateManyWithoutUserNestedInput
    pers?: PersUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUncheckedUpdateManyWithoutUserNestedInput
    spellbook?: SpellbookUncheckedUpdateManyWithoutUserNestedInput
    pers?: PersUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    userId?: number
    login: string
    password?: string | null
  }

  export type UserUpdateManyMutationInput = {
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassCreateInput = {
    name: string
    hitDie: number
    primaryCastingStat?: $Enums.Ability | null
    spellcastingType?: $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassCreateabilityScoreUpLevelsInput | number[]
    subclassLevel?: number
    multiclassStrReq?: number
    multiclassDexReq?: number
    multiclassConReq?: number
    multiclassIntReq?: number
    multiclassWisReq?: number
    multiclassChaReq?: number
    armorProficiencies?: ClassCreatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassCreateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassCreatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassCreateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: number
    languages?: ClassCreatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subclasses?: SubclassCreateNestedManyWithoutClassInput
    classFeatures?: ClassFeatureCreateNestedManyWithoutClassInput
    perses?: PersCreateNestedManyWithoutClassInput
    persMulticlasses?: PersMulticlassCreateNestedManyWithoutClassInput
    startingEquipmentOption?: ClassStartingEquipmentOptionCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    classId?: number
    name: string
    hitDie: number
    primaryCastingStat?: $Enums.Ability | null
    spellcastingType?: $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassCreateabilityScoreUpLevelsInput | number[]
    subclassLevel?: number
    multiclassStrReq?: number
    multiclassDexReq?: number
    multiclassConReq?: number
    multiclassIntReq?: number
    multiclassWisReq?: number
    multiclassChaReq?: number
    armorProficiencies?: ClassCreatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassCreateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassCreatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassCreateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: number
    languages?: ClassCreatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subclasses?: SubclassUncheckedCreateNestedManyWithoutClassInput
    classFeatures?: ClassFeatureUncheckedCreateNestedManyWithoutClassInput
    perses?: PersUncheckedCreateNestedManyWithoutClassInput
    persMulticlasses?: PersMulticlassUncheckedCreateNestedManyWithoutClassInput
    startingEquipmentOption?: ClassStartingEquipmentOptionUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    hitDie?: IntFieldUpdateOperationsInput | number
    primaryCastingStat?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFieldUpdateOperationsInput | $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassUpdateabilityScoreUpLevelsInput | number[]
    subclassLevel?: IntFieldUpdateOperationsInput | number
    multiclassStrReq?: IntFieldUpdateOperationsInput | number
    multiclassDexReq?: IntFieldUpdateOperationsInput | number
    multiclassConReq?: IntFieldUpdateOperationsInput | number
    multiclassIntReq?: IntFieldUpdateOperationsInput | number
    multiclassWisReq?: IntFieldUpdateOperationsInput | number
    multiclassChaReq?: IntFieldUpdateOperationsInput | number
    armorProficiencies?: ClassUpdatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassUpdateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassUpdatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassUpdateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: ClassUpdatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subclasses?: SubclassUpdateManyWithoutClassNestedInput
    classFeatures?: ClassFeatureUpdateManyWithoutClassNestedInput
    perses?: PersUpdateManyWithoutClassNestedInput
    persMulticlasses?: PersMulticlassUpdateManyWithoutClassNestedInput
    startingEquipmentOption?: ClassStartingEquipmentOptionUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    hitDie?: IntFieldUpdateOperationsInput | number
    primaryCastingStat?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFieldUpdateOperationsInput | $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassUpdateabilityScoreUpLevelsInput | number[]
    subclassLevel?: IntFieldUpdateOperationsInput | number
    multiclassStrReq?: IntFieldUpdateOperationsInput | number
    multiclassDexReq?: IntFieldUpdateOperationsInput | number
    multiclassConReq?: IntFieldUpdateOperationsInput | number
    multiclassIntReq?: IntFieldUpdateOperationsInput | number
    multiclassWisReq?: IntFieldUpdateOperationsInput | number
    multiclassChaReq?: IntFieldUpdateOperationsInput | number
    armorProficiencies?: ClassUpdatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassUpdateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassUpdatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassUpdateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: ClassUpdatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subclasses?: SubclassUncheckedUpdateManyWithoutClassNestedInput
    classFeatures?: ClassFeatureUncheckedUpdateManyWithoutClassNestedInput
    perses?: PersUncheckedUpdateManyWithoutClassNestedInput
    persMulticlasses?: PersMulticlassUncheckedUpdateManyWithoutClassNestedInput
    startingEquipmentOption?: ClassStartingEquipmentOptionUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    classId?: number
    name: string
    hitDie: number
    primaryCastingStat?: $Enums.Ability | null
    spellcastingType?: $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassCreateabilityScoreUpLevelsInput | number[]
    subclassLevel?: number
    multiclassStrReq?: number
    multiclassDexReq?: number
    multiclassConReq?: number
    multiclassIntReq?: number
    multiclassWisReq?: number
    multiclassChaReq?: number
    armorProficiencies?: ClassCreatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassCreateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassCreatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassCreateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: number
    languages?: ClassCreatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    hitDie?: IntFieldUpdateOperationsInput | number
    primaryCastingStat?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFieldUpdateOperationsInput | $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassUpdateabilityScoreUpLevelsInput | number[]
    subclassLevel?: IntFieldUpdateOperationsInput | number
    multiclassStrReq?: IntFieldUpdateOperationsInput | number
    multiclassDexReq?: IntFieldUpdateOperationsInput | number
    multiclassConReq?: IntFieldUpdateOperationsInput | number
    multiclassIntReq?: IntFieldUpdateOperationsInput | number
    multiclassWisReq?: IntFieldUpdateOperationsInput | number
    multiclassChaReq?: IntFieldUpdateOperationsInput | number
    armorProficiencies?: ClassUpdatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassUpdateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassUpdatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassUpdateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: ClassUpdatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateManyInput = {
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    hitDie?: IntFieldUpdateOperationsInput | number
    primaryCastingStat?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFieldUpdateOperationsInput | $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassUpdateabilityScoreUpLevelsInput | number[]
    subclassLevel?: IntFieldUpdateOperationsInput | number
    multiclassStrReq?: IntFieldUpdateOperationsInput | number
    multiclassDexReq?: IntFieldUpdateOperationsInput | number
    multiclassConReq?: IntFieldUpdateOperationsInput | number
    multiclassIntReq?: IntFieldUpdateOperationsInput | number
    multiclassWisReq?: IntFieldUpdateOperationsInput | number
    multiclassChaReq?: IntFieldUpdateOperationsInput | number
    armorProficiencies?: ClassUpdatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassUpdateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassUpdatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassUpdateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: ClassUpdatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubclassCreateInput = {
    name: string
    description?: string | null
    grantsSpells?: boolean
    languagesToChooseCount?: number
    languages?: SubclassCreatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellCreateNestedManyWithoutSubclassesInput
    class: ClassCreateNestedOneWithoutSubclassesInput
    features?: SubclassFeatureCreateNestedManyWithoutSubclassInput
    perses?: PersCreateNestedManyWithoutSubclassInput
    persMulticlasses?: PersMulticlassCreateNestedManyWithoutSubclassInput
  }

  export type SubclassUncheckedCreateInput = {
    subclassId?: number
    classId: number
    name: string
    description?: string | null
    grantsSpells?: boolean
    languagesToChooseCount?: number
    languages?: SubclassCreatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellUncheckedCreateNestedManyWithoutSubclassesInput
    features?: SubclassFeatureUncheckedCreateNestedManyWithoutSubclassInput
    perses?: PersUncheckedCreateNestedManyWithoutSubclassInput
    persMulticlasses?: PersMulticlassUncheckedCreateNestedManyWithoutSubclassInput
  }

  export type SubclassUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellUpdateManyWithoutSubclassesNestedInput
    class?: ClassUpdateOneRequiredWithoutSubclassesNestedInput
    features?: SubclassFeatureUpdateManyWithoutSubclassNestedInput
    perses?: PersUpdateManyWithoutSubclassNestedInput
    persMulticlasses?: PersMulticlassUpdateManyWithoutSubclassNestedInput
  }

  export type SubclassUncheckedUpdateInput = {
    subclassId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellUncheckedUpdateManyWithoutSubclassesNestedInput
    features?: SubclassFeatureUncheckedUpdateManyWithoutSubclassNestedInput
    perses?: PersUncheckedUpdateManyWithoutSubclassNestedInput
    persMulticlasses?: PersMulticlassUncheckedUpdateManyWithoutSubclassNestedInput
  }

  export type SubclassCreateManyInput = {
    subclassId?: number
    classId: number
    name: string
    description?: string | null
    grantsSpells?: boolean
    languagesToChooseCount?: number
    languages?: SubclassCreatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassCreatetoolProficienciesInput | $Enums.ToolCategory[]
  }

  export type SubclassUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
  }

  export type SubclassUncheckedUpdateManyInput = {
    subclassId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
  }

  export type PersCreateInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    class: ClassCreateNestedOneWithoutPersesInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type PersCreateManyInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersUncheckedUpdateManyInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersMulticlassCreateInput = {
    classLevel: number
    pers: PersCreateNestedOneWithoutMulticlassesInput
    class: ClassCreateNestedOneWithoutPersMulticlassesInput
    subclass?: SubclassCreateNestedOneWithoutPersMulticlassesInput
  }

  export type PersMulticlassUncheckedCreateInput = {
    persMulticlassId?: number
    persId: number
    classId: number
    subclassId?: number | null
    classLevel: number
  }

  export type PersMulticlassUpdateInput = {
    classLevel?: IntFieldUpdateOperationsInput | number
    pers?: PersUpdateOneRequiredWithoutMulticlassesNestedInput
    class?: ClassUpdateOneRequiredWithoutPersMulticlassesNestedInput
    subclass?: SubclassUpdateOneWithoutPersMulticlassesNestedInput
  }

  export type PersMulticlassUncheckedUpdateInput = {
    persMulticlassId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    classLevel?: IntFieldUpdateOperationsInput | number
  }

  export type PersMulticlassCreateManyInput = {
    persMulticlassId?: number
    persId: number
    classId: number
    subclassId?: number | null
    classLevel: number
  }

  export type PersMulticlassUpdateManyMutationInput = {
    classLevel?: IntFieldUpdateOperationsInput | number
  }

  export type PersMulticlassUncheckedUpdateManyInput = {
    persMulticlassId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    classLevel?: IntFieldUpdateOperationsInput | number
  }

  export type PersFeatureCreateInput = {
    usesRemaining?: number | null
    feature: FeatureCreateNestedOneWithoutPersFeaturesInput
    pers: PersCreateNestedOneWithoutFeaturesInput
  }

  export type PersFeatureUncheckedCreateInput = {
    persFeatureId?: number
    persId: number
    featureId: number
    usesRemaining?: number | null
  }

  export type PersFeatureUpdateInput = {
    usesRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    feature?: FeatureUpdateOneRequiredWithoutPersFeaturesNestedInput
    pers?: PersUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type PersFeatureUncheckedUpdateInput = {
    persFeatureId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    usesRemaining?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersFeatureCreateManyInput = {
    persFeatureId?: number
    persId: number
    featureId: number
    usesRemaining?: number | null
  }

  export type PersFeatureUpdateManyMutationInput = {
    usesRemaining?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersFeatureUncheckedUpdateManyInput = {
    persFeatureId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    usesRemaining?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FeatureCreateInput = {
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateInput = {
    featureId?: number
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellUncheckedCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitUncheckedCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureUncheckedCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureUncheckedCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUncheckedUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureCreateManyInput = {
    featureId?: number
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureUncheckedUpdateManyInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassFeatureCreateInput = {
    levelGranted: number
    grantsSpellSlots?: boolean
    feature: FeatureCreateNestedOneWithoutClassFeaturesInput
    class: ClassCreateNestedOneWithoutClassFeaturesInput
  }

  export type ClassFeatureUncheckedCreateInput = {
    classFeatureId?: number
    classId: number
    featureId: number
    levelGranted: number
    grantsSpellSlots?: boolean
  }

  export type ClassFeatureUpdateInput = {
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
    feature?: FeatureUpdateOneRequiredWithoutClassFeaturesNestedInput
    class?: ClassUpdateOneRequiredWithoutClassFeaturesNestedInput
  }

  export type ClassFeatureUncheckedUpdateInput = {
    classFeatureId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassFeatureCreateManyInput = {
    classFeatureId?: number
    classId: number
    featureId: number
    levelGranted: number
    grantsSpellSlots?: boolean
  }

  export type ClassFeatureUpdateManyMutationInput = {
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassFeatureUncheckedUpdateManyInput = {
    classFeatureId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubclassFeatureCreateInput = {
    levelGranted: number
    grantsSpellSlots?: boolean
    feature: FeatureCreateNestedOneWithoutSubclassFeaturesInput
    subclass: SubclassCreateNestedOneWithoutFeaturesInput
  }

  export type SubclassFeatureUncheckedCreateInput = {
    subclassFeatureId?: number
    subclassId: number
    featureId: number
    levelGranted: number
    grantsSpellSlots?: boolean
  }

  export type SubclassFeatureUpdateInput = {
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
    feature?: FeatureUpdateOneRequiredWithoutSubclassFeaturesNestedInput
    subclass?: SubclassUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type SubclassFeatureUncheckedUpdateInput = {
    subclassFeatureId?: IntFieldUpdateOperationsInput | number
    subclassId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubclassFeatureCreateManyInput = {
    subclassFeatureId?: number
    subclassId: number
    featureId: number
    levelGranted: number
    grantsSpellSlots?: boolean
  }

  export type SubclassFeatureUpdateManyMutationInput = {
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubclassFeatureUncheckedUpdateManyInput = {
    subclassFeatureId?: IntFieldUpdateOperationsInput | number
    subclassId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RaceTraitCreateInput = {
    feature: FeatureCreateNestedOneWithoutRaceTraitsInput
    race: RaceCreateNestedOneWithoutTraitsInput
    subraces?: SubraceCreateNestedManyWithoutReplacesTraitsInput
    raceVariants?: RaceVariantCreateNestedManyWithoutReplacesTraitsInput
  }

  export type RaceTraitUncheckedCreateInput = {
    raceTraitId?: number
    raceId: number
    featureId: number
    subraces?: SubraceUncheckedCreateNestedManyWithoutReplacesTraitsInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutReplacesTraitsInput
  }

  export type RaceTraitUpdateInput = {
    feature?: FeatureUpdateOneRequiredWithoutRaceTraitsNestedInput
    race?: RaceUpdateOneRequiredWithoutTraitsNestedInput
    subraces?: SubraceUpdateManyWithoutReplacesTraitsNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutReplacesTraitsNestedInput
  }

  export type RaceTraitUncheckedUpdateInput = {
    raceTraitId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    subraces?: SubraceUncheckedUpdateManyWithoutReplacesTraitsNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutReplacesTraitsNestedInput
  }

  export type RaceTraitCreateManyInput = {
    raceTraitId?: number
    raceId: number
    featureId: number
  }

  export type RaceTraitUpdateManyMutationInput = {

  }

  export type RaceTraitUncheckedUpdateManyInput = {
    raceTraitId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type SubraceTraitCreateInput = {
    feature: FeatureCreateNestedOneWithoutSubraceTraitsInput
    subrace: SubraceCreateNestedOneWithoutTraitsInput
  }

  export type SubraceTraitUncheckedCreateInput = {
    subraceTraitId?: number
    subraceId: number
    featureId: number
  }

  export type SubraceTraitUpdateInput = {
    feature?: FeatureUpdateOneRequiredWithoutSubraceTraitsNestedInput
    subrace?: SubraceUpdateOneRequiredWithoutTraitsNestedInput
  }

  export type SubraceTraitUncheckedUpdateInput = {
    subraceTraitId?: IntFieldUpdateOperationsInput | number
    subraceId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type SubraceTraitCreateManyInput = {
    subraceTraitId?: number
    subraceId: number
    featureId: number
  }

  export type SubraceTraitUpdateManyMutationInput = {

  }

  export type SubraceTraitUncheckedUpdateManyInput = {
    subraceTraitId?: IntFieldUpdateOperationsInput | number
    subraceId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceVariantTraitCreateInput = {
    feature: FeatureCreateNestedOneWithoutRaceVariantTraitsInput
    raceVariant: RaceVariantCreateNestedOneWithoutTraitsInput
  }

  export type RaceVariantTraitUncheckedCreateInput = {
    raceVariantTraitId?: number
    raceVariantId: number
    featureId: number
  }

  export type RaceVariantTraitUpdateInput = {
    feature?: FeatureUpdateOneRequiredWithoutRaceVariantTraitsNestedInput
    raceVariant?: RaceVariantUpdateOneRequiredWithoutTraitsNestedInput
  }

  export type RaceVariantTraitUncheckedUpdateInput = {
    raceVariantTraitId?: IntFieldUpdateOperationsInput | number
    raceVariantId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceVariantTraitCreateManyInput = {
    raceVariantTraitId?: number
    raceVariantId: number
    featureId: number
  }

  export type RaceVariantTraitUpdateManyMutationInput = {

  }

  export type RaceVariantTraitUncheckedUpdateManyInput = {
    raceVariantTraitId?: IntFieldUpdateOperationsInput | number
    raceVariantId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceChoiceOptionTraitCreateInput = {
    feature: FeatureCreateNestedOneWithoutRaceChoiceOptionsTraitsInput
    raceChoiceOption: RaceChoiceOptionCreateNestedOneWithoutGrantsTraitsInput
  }

  export type RaceChoiceOptionTraitUncheckedCreateInput = {
    raceChoiceOptionTraitId?: number
    optionId: number
    featureId: number
  }

  export type RaceChoiceOptionTraitUpdateInput = {
    feature?: FeatureUpdateOneRequiredWithoutRaceChoiceOptionsTraitsNestedInput
    raceChoiceOption?: RaceChoiceOptionUpdateOneRequiredWithoutGrantsTraitsNestedInput
  }

  export type RaceChoiceOptionTraitUncheckedUpdateInput = {
    raceChoiceOptionTraitId?: IntFieldUpdateOperationsInput | number
    optionId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceChoiceOptionTraitCreateManyInput = {
    raceChoiceOptionTraitId?: number
    optionId: number
    featureId: number
  }

  export type RaceChoiceOptionTraitUpdateManyMutationInput = {

  }

  export type RaceChoiceOptionTraitUncheckedUpdateManyInput = {
    raceChoiceOptionTraitId?: IntFieldUpdateOperationsInput | number
    optionId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type FeatFeatureCreateInput = {
    feature: FeatureCreateNestedOneWithoutFeatFeaturesInput
    feat: FeatCreateNestedOneWithoutFeatFeaturesInput
  }

  export type FeatFeatureUncheckedCreateInput = {
    featFeatureId?: number
    featId: number
    featureId: number
  }

  export type FeatFeatureUpdateInput = {
    feature?: FeatureUpdateOneRequiredWithoutFeatFeaturesNestedInput
    feat?: FeatUpdateOneRequiredWithoutFeatFeaturesNestedInput
  }

  export type FeatFeatureUncheckedUpdateInput = {
    featFeatureId?: IntFieldUpdateOperationsInput | number
    featId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type FeatFeatureCreateManyInput = {
    featFeatureId?: number
    featId: number
    featureId: number
  }

  export type FeatFeatureUpdateManyMutationInput = {

  }

  export type FeatFeatureUncheckedUpdateManyInput = {
    featFeatureId?: IntFieldUpdateOperationsInput | number
    featId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type MagicItemFeatureCreateInput = {
    feature: FeatureCreateNestedOneWithoutMagicItemFeaturesInput
    magicItem: MagicItemCreateNestedOneWithoutFeaturesInput
  }

  export type MagicItemFeatureUncheckedCreateInput = {
    magicItemFeatureId?: number
    magicItemId: number
    featureId: number
  }

  export type MagicItemFeatureUpdateInput = {
    feature?: FeatureUpdateOneRequiredWithoutMagicItemFeaturesNestedInput
    magicItem?: MagicItemUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type MagicItemFeatureUncheckedUpdateInput = {
    magicItemFeatureId?: IntFieldUpdateOperationsInput | number
    magicItemId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type MagicItemFeatureCreateManyInput = {
    magicItemFeatureId?: number
    magicItemId: number
    featureId: number
  }

  export type MagicItemFeatureUpdateManyMutationInput = {

  }

  export type MagicItemFeatureUncheckedUpdateManyInput = {
    magicItemFeatureId?: IntFieldUpdateOperationsInput | number
    magicItemId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceCreateInput = {
    name: $Enums.Races
    size?: RaceCreatesizeInput | $Enums.Size[]
    speed?: number
    burrowSpeed?: number
    flightSpeed?: number
    swimSpeed?: number
    climbSpeed?: number
    ac?: number
    source?: $Enums.Source
    languages?: RaceCreatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    ASI: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceCreateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceCreatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceCreateNestedManyWithoutRaceInput
    perses?: PersCreateNestedManyWithoutRaceInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutRaceInput
    raceVariants?: RaceVariantCreateNestedManyWithoutRaceInput
    traits?: RaceTraitCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateInput = {
    raceId?: number
    name: $Enums.Races
    size?: RaceCreatesizeInput | $Enums.Size[]
    speed?: number
    burrowSpeed?: number
    flightSpeed?: number
    swimSpeed?: number
    climbSpeed?: number
    ac?: number
    source?: $Enums.Source
    languages?: RaceCreatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    ASI: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceCreateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceCreatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceUncheckedCreateNestedManyWithoutRaceInput
    perses?: PersUncheckedCreateNestedManyWithoutRaceInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutRaceInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutRaceInput
    traits?: RaceTraitUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceUpdateInput = {
    name?: EnumRacesFieldUpdateOperationsInput | $Enums.Races
    size?: RaceUpdatesizeInput | $Enums.Size[]
    speed?: IntFieldUpdateOperationsInput | number
    burrowSpeed?: IntFieldUpdateOperationsInput | number
    flightSpeed?: IntFieldUpdateOperationsInput | number
    swimSpeed?: IntFieldUpdateOperationsInput | number
    climbSpeed?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    languages?: RaceUpdatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    ASI?: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceUpdateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceUpdateManyWithoutRaceNestedInput
    perses?: PersUpdateManyWithoutRaceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutRaceNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumRacesFieldUpdateOperationsInput | $Enums.Races
    size?: RaceUpdatesizeInput | $Enums.Size[]
    speed?: IntFieldUpdateOperationsInput | number
    burrowSpeed?: IntFieldUpdateOperationsInput | number
    flightSpeed?: IntFieldUpdateOperationsInput | number
    swimSpeed?: IntFieldUpdateOperationsInput | number
    climbSpeed?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    languages?: RaceUpdatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    ASI?: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceUpdateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceUncheckedUpdateManyWithoutRaceNestedInput
    perses?: PersUncheckedUpdateManyWithoutRaceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutRaceNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type RaceCreateManyInput = {
    raceId?: number
    name: $Enums.Races
    size?: RaceCreatesizeInput | $Enums.Size[]
    speed?: number
    burrowSpeed?: number
    flightSpeed?: number
    swimSpeed?: number
    climbSpeed?: number
    ac?: number
    source?: $Enums.Source
    languages?: RaceCreatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    ASI: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceCreateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceCreatearmorProficienciesInput | $Enums.ArmorType[]
  }

  export type RaceUpdateManyMutationInput = {
    name?: EnumRacesFieldUpdateOperationsInput | $Enums.Races
    size?: RaceUpdatesizeInput | $Enums.Size[]
    speed?: IntFieldUpdateOperationsInput | number
    burrowSpeed?: IntFieldUpdateOperationsInput | number
    flightSpeed?: IntFieldUpdateOperationsInput | number
    swimSpeed?: IntFieldUpdateOperationsInput | number
    climbSpeed?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    languages?: RaceUpdatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    ASI?: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceUpdateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceUpdatearmorProficienciesInput | $Enums.ArmorType[]
  }

  export type RaceUncheckedUpdateManyInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumRacesFieldUpdateOperationsInput | $Enums.Races
    size?: RaceUpdatesizeInput | $Enums.Size[]
    speed?: IntFieldUpdateOperationsInput | number
    burrowSpeed?: IntFieldUpdateOperationsInput | number
    flightSpeed?: IntFieldUpdateOperationsInput | number
    swimSpeed?: IntFieldUpdateOperationsInput | number
    climbSpeed?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    languages?: RaceUpdatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    ASI?: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceUpdateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceUpdatearmorProficienciesInput | $Enums.ArmorType[]
  }

  export type SubraceCreateInput = {
    name: $Enums.Subraces
    speedModifier?: number | null
    source?: $Enums.Source
    replacesASI?: boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceCreateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    toolProficiencies?: SubraceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceCreatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitCreateNestedManyWithoutSubracesInput
    race: RaceCreateNestedOneWithoutSubracesInput
    perses?: PersCreateNestedManyWithoutSubraceInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutSubraceInput
    traits?: SubraceTraitCreateNestedManyWithoutSubraceInput
  }

  export type SubraceUncheckedCreateInput = {
    subraceId?: number
    raceId: number
    name: $Enums.Subraces
    speedModifier?: number | null
    source?: $Enums.Source
    replacesASI?: boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceCreateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    toolProficiencies?: SubraceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceCreatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitUncheckedCreateNestedManyWithoutSubracesInput
    perses?: PersUncheckedCreateNestedManyWithoutSubraceInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutSubraceInput
    traits?: SubraceTraitUncheckedCreateNestedManyWithoutSubraceInput
  }

  export type SubraceUpdateInput = {
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitUpdateManyWithoutSubracesNestedInput
    race?: RaceUpdateOneRequiredWithoutSubracesNestedInput
    perses?: PersUpdateManyWithoutSubraceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutSubraceNestedInput
    traits?: SubraceTraitUpdateManyWithoutSubraceNestedInput
  }

  export type SubraceUncheckedUpdateInput = {
    subraceId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitUncheckedUpdateManyWithoutSubracesNestedInput
    perses?: PersUncheckedUpdateManyWithoutSubraceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutSubraceNestedInput
    traits?: SubraceTraitUncheckedUpdateManyWithoutSubraceNestedInput
  }

  export type SubraceCreateManyInput = {
    subraceId?: number
    raceId: number
    name: $Enums.Subraces
    speedModifier?: number | null
    source?: $Enums.Source
    replacesASI?: boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceCreateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    toolProficiencies?: SubraceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceCreatearmorProficienciesInput | $Enums.ArmorType[]
  }

  export type SubraceUpdateManyMutationInput = {
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
  }

  export type SubraceUncheckedUpdateManyInput = {
    subraceId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
  }

  export type RaceVariantCreateInput = {
    name: $Enums.Variants
    source: $Enums.Source
    exclusivityGroup?: string | null
    overridesRaceASI: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: number | null
    overridesFlightSpeed?: number | null
    replacesTraits?: RaceTraitCreateNestedManyWithoutRaceVariantsInput
    traits?: RaceVariantTraitCreateNestedManyWithoutRaceVariantInput
    race: RaceCreateNestedOneWithoutRaceVariantsInput
    perses?: PersCreateNestedManyWithoutRaceVariantsInput
  }

  export type RaceVariantUncheckedCreateInput = {
    raceVariantId?: number
    raceId: number
    name: $Enums.Variants
    source: $Enums.Source
    exclusivityGroup?: string | null
    overridesRaceASI: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: number | null
    overridesFlightSpeed?: number | null
    replacesTraits?: RaceTraitUncheckedCreateNestedManyWithoutRaceVariantsInput
    traits?: RaceVariantTraitUncheckedCreateNestedManyWithoutRaceVariantInput
    perses?: PersUncheckedCreateNestedManyWithoutRaceVariantsInput
  }

  export type RaceVariantUpdateInput = {
    name?: EnumVariantsFieldUpdateOperationsInput | $Enums.Variants
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    exclusivityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    overridesRaceASI?: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    overridesFlightSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    replacesTraits?: RaceTraitUpdateManyWithoutRaceVariantsNestedInput
    traits?: RaceVariantTraitUpdateManyWithoutRaceVariantNestedInput
    race?: RaceUpdateOneRequiredWithoutRaceVariantsNestedInput
    perses?: PersUpdateManyWithoutRaceVariantsNestedInput
  }

  export type RaceVariantUncheckedUpdateInput = {
    raceVariantId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumVariantsFieldUpdateOperationsInput | $Enums.Variants
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    exclusivityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    overridesRaceASI?: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    overridesFlightSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    replacesTraits?: RaceTraitUncheckedUpdateManyWithoutRaceVariantsNestedInput
    traits?: RaceVariantTraitUncheckedUpdateManyWithoutRaceVariantNestedInput
    perses?: PersUncheckedUpdateManyWithoutRaceVariantsNestedInput
  }

  export type RaceVariantCreateManyInput = {
    raceVariantId?: number
    raceId: number
    name: $Enums.Variants
    source: $Enums.Source
    exclusivityGroup?: string | null
    overridesRaceASI: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: number | null
    overridesFlightSpeed?: number | null
  }

  export type RaceVariantUpdateManyMutationInput = {
    name?: EnumVariantsFieldUpdateOperationsInput | $Enums.Variants
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    exclusivityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    overridesRaceASI?: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    overridesFlightSpeed?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RaceVariantUncheckedUpdateManyInput = {
    raceVariantId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumVariantsFieldUpdateOperationsInput | $Enums.Variants
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    exclusivityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    overridesRaceASI?: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    overridesFlightSpeed?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RaceChoiceOptionCreateInput = {
    choiceGroupName: string
    optionName: string
    description?: string | null
    selectMultiple?: boolean
    maxSelection?: number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionCreategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionCreategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    modifiesSpeed?: number | null
    draconicDamageType?: $Enums.DamageType | null
    breathWeaponShape?: $Enums.AOEShapes | null
    breathWeaponAOE?: string | null
    grantsTraits?: RaceChoiceOptionTraitCreateNestedManyWithoutRaceChoiceOptionInput
    race: RaceCreateNestedOneWithoutRaceChoiceOptionsInput
    subrace?: SubraceCreateNestedOneWithoutRaceChoiceOptionsInput
    perses?: PersCreateNestedManyWithoutRaceChoiceOptionsInput
  }

  export type RaceChoiceOptionUncheckedCreateInput = {
    optionId?: number
    raceId: number
    subraceId?: number | null
    choiceGroupName: string
    optionName: string
    description?: string | null
    selectMultiple?: boolean
    maxSelection?: number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionCreategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionCreategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    modifiesSpeed?: number | null
    draconicDamageType?: $Enums.DamageType | null
    breathWeaponShape?: $Enums.AOEShapes | null
    breathWeaponAOE?: string | null
    grantsTraits?: RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutRaceChoiceOptionInput
    perses?: PersUncheckedCreateNestedManyWithoutRaceChoiceOptionsInput
  }

  export type RaceChoiceOptionUpdateInput = {
    choiceGroupName?: StringFieldUpdateOperationsInput | string
    optionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    selectMultiple?: BoolFieldUpdateOperationsInput | boolean
    maxSelection?: IntFieldUpdateOperationsInput | number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionUpdategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionUpdategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    modifiesSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    draconicDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    breathWeaponShape?: NullableEnumAOEShapesFieldUpdateOperationsInput | $Enums.AOEShapes | null
    breathWeaponAOE?: NullableStringFieldUpdateOperationsInput | string | null
    grantsTraits?: RaceChoiceOptionTraitUpdateManyWithoutRaceChoiceOptionNestedInput
    race?: RaceUpdateOneRequiredWithoutRaceChoiceOptionsNestedInput
    subrace?: SubraceUpdateOneWithoutRaceChoiceOptionsNestedInput
    perses?: PersUpdateManyWithoutRaceChoiceOptionsNestedInput
  }

  export type RaceChoiceOptionUncheckedUpdateInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    choiceGroupName?: StringFieldUpdateOperationsInput | string
    optionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    selectMultiple?: BoolFieldUpdateOperationsInput | boolean
    maxSelection?: IntFieldUpdateOperationsInput | number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionUpdategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionUpdategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    modifiesSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    draconicDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    breathWeaponShape?: NullableEnumAOEShapesFieldUpdateOperationsInput | $Enums.AOEShapes | null
    breathWeaponAOE?: NullableStringFieldUpdateOperationsInput | string | null
    grantsTraits?: RaceChoiceOptionTraitUncheckedUpdateManyWithoutRaceChoiceOptionNestedInput
    perses?: PersUncheckedUpdateManyWithoutRaceChoiceOptionsNestedInput
  }

  export type RaceChoiceOptionCreateManyInput = {
    optionId?: number
    raceId: number
    subraceId?: number | null
    choiceGroupName: string
    optionName: string
    description?: string | null
    selectMultiple?: boolean
    maxSelection?: number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionCreategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionCreategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    modifiesSpeed?: number | null
    draconicDamageType?: $Enums.DamageType | null
    breathWeaponShape?: $Enums.AOEShapes | null
    breathWeaponAOE?: string | null
  }

  export type RaceChoiceOptionUpdateManyMutationInput = {
    choiceGroupName?: StringFieldUpdateOperationsInput | string
    optionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    selectMultiple?: BoolFieldUpdateOperationsInput | boolean
    maxSelection?: IntFieldUpdateOperationsInput | number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionUpdategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionUpdategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    modifiesSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    draconicDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    breathWeaponShape?: NullableEnumAOEShapesFieldUpdateOperationsInput | $Enums.AOEShapes | null
    breathWeaponAOE?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RaceChoiceOptionUncheckedUpdateManyInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    choiceGroupName?: StringFieldUpdateOperationsInput | string
    optionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    selectMultiple?: BoolFieldUpdateOperationsInput | boolean
    maxSelection?: IntFieldUpdateOperationsInput | number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionUpdategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionUpdategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    modifiesSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    draconicDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    breathWeaponShape?: NullableEnumAOEShapesFieldUpdateOperationsInput | $Enums.AOEShapes | null
    breathWeaponAOE?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BackgroundCreateInput = {
    name: $Enums.BackgroundCategory
    source?: $Enums.Source
    toolProficiencies?: BackgroundCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: BackgroundCreateskillProficienciesInput | $Enums.Skills[]
    languagesToChooseCount?: number
    items?: NullableJsonNullValueInput | InputJsonValue
    perses?: PersCreateNestedManyWithoutBackgroundInput
  }

  export type BackgroundUncheckedCreateInput = {
    backgroundId?: number
    name: $Enums.BackgroundCategory
    source?: $Enums.Source
    toolProficiencies?: BackgroundCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: BackgroundCreateskillProficienciesInput | $Enums.Skills[]
    languagesToChooseCount?: number
    items?: NullableJsonNullValueInput | InputJsonValue
    perses?: PersUncheckedCreateNestedManyWithoutBackgroundInput
  }

  export type BackgroundUpdateInput = {
    name?: EnumBackgroundCategoryFieldUpdateOperationsInput | $Enums.BackgroundCategory
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    toolProficiencies?: BackgroundUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: BackgroundUpdateskillProficienciesInput | $Enums.Skills[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    items?: NullableJsonNullValueInput | InputJsonValue
    perses?: PersUpdateManyWithoutBackgroundNestedInput
  }

  export type BackgroundUncheckedUpdateInput = {
    backgroundId?: IntFieldUpdateOperationsInput | number
    name?: EnumBackgroundCategoryFieldUpdateOperationsInput | $Enums.BackgroundCategory
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    toolProficiencies?: BackgroundUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: BackgroundUpdateskillProficienciesInput | $Enums.Skills[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    items?: NullableJsonNullValueInput | InputJsonValue
    perses?: PersUncheckedUpdateManyWithoutBackgroundNestedInput
  }

  export type BackgroundCreateManyInput = {
    backgroundId?: number
    name: $Enums.BackgroundCategory
    source?: $Enums.Source
    toolProficiencies?: BackgroundCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: BackgroundCreateskillProficienciesInput | $Enums.Skills[]
    languagesToChooseCount?: number
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BackgroundUpdateManyMutationInput = {
    name?: EnumBackgroundCategoryFieldUpdateOperationsInput | $Enums.BackgroundCategory
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    toolProficiencies?: BackgroundUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: BackgroundUpdateskillProficienciesInput | $Enums.Skills[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BackgroundUncheckedUpdateManyInput = {
    backgroundId?: IntFieldUpdateOperationsInput | number
    name?: EnumBackgroundCategoryFieldUpdateOperationsInput | $Enums.BackgroundCategory
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    toolProficiencies?: BackgroundUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: BackgroundUpdateskillProficienciesInput | $Enums.Skills[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FeatCreateInput = {
    name: string
    category: $Enums.FeatCategory
    shortDescription: string
    longDescription: string
    languagesToChooseCount?: number
    languages?: FeatCreatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featFeatures?: FeatFeatureCreateNestedManyWithoutFeatInput
    featAbilityBoost?: FeatAbilityBoostCreateNestedOneWithoutFeatInput
    persFeats?: PersFeatCreateNestedManyWithoutFeatInput
  }

  export type FeatUncheckedCreateInput = {
    featId?: number
    name: string
    category: $Enums.FeatCategory
    shortDescription: string
    longDescription: string
    languagesToChooseCount?: number
    languages?: FeatCreatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featFeatures?: FeatFeatureUncheckedCreateNestedManyWithoutFeatInput
    featAbilityBoost?: FeatAbilityBoostUncheckedCreateNestedOneWithoutFeatInput
    persFeats?: PersFeatUncheckedCreateNestedManyWithoutFeatInput
  }

  export type FeatUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatCategoryFieldUpdateOperationsInput | $Enums.FeatCategory
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: FeatUpdatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featFeatures?: FeatFeatureUpdateManyWithoutFeatNestedInput
    featAbilityBoost?: FeatAbilityBoostUpdateOneWithoutFeatNestedInput
    persFeats?: PersFeatUpdateManyWithoutFeatNestedInput
  }

  export type FeatUncheckedUpdateInput = {
    featId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatCategoryFieldUpdateOperationsInput | $Enums.FeatCategory
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: FeatUpdatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featFeatures?: FeatFeatureUncheckedUpdateManyWithoutFeatNestedInput
    featAbilityBoost?: FeatAbilityBoostUncheckedUpdateOneWithoutFeatNestedInput
    persFeats?: PersFeatUncheckedUpdateManyWithoutFeatNestedInput
  }

  export type FeatCreateManyInput = {
    featId?: number
    name: string
    category: $Enums.FeatCategory
    shortDescription: string
    longDescription: string
    languagesToChooseCount?: number
    languages?: FeatCreatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FeatUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatCategoryFieldUpdateOperationsInput | $Enums.FeatCategory
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: FeatUpdatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FeatUncheckedUpdateManyInput = {
    featId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatCategoryFieldUpdateOperationsInput | $Enums.FeatCategory
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: FeatUpdatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FeatAbilityBoostCreateInput = {
    ability?: $Enums.Ability | null
    increaseValue: number
    abilitiesToChoose?: FeatAbilityBoostCreateabilitiesToChooseInput | $Enums.Ability[]
    maxValue?: number
    feat: FeatCreateNestedOneWithoutFeatAbilityBoostInput
  }

  export type FeatAbilityBoostUncheckedCreateInput = {
    boostId?: number
    featId: number
    ability?: $Enums.Ability | null
    increaseValue: number
    abilitiesToChoose?: FeatAbilityBoostCreateabilitiesToChooseInput | $Enums.Ability[]
    maxValue?: number
  }

  export type FeatAbilityBoostUpdateInput = {
    ability?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    increaseValue?: IntFieldUpdateOperationsInput | number
    abilitiesToChoose?: FeatAbilityBoostUpdateabilitiesToChooseInput | $Enums.Ability[]
    maxValue?: IntFieldUpdateOperationsInput | number
    feat?: FeatUpdateOneRequiredWithoutFeatAbilityBoostNestedInput
  }

  export type FeatAbilityBoostUncheckedUpdateInput = {
    boostId?: IntFieldUpdateOperationsInput | number
    featId?: IntFieldUpdateOperationsInput | number
    ability?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    increaseValue?: IntFieldUpdateOperationsInput | number
    abilitiesToChoose?: FeatAbilityBoostUpdateabilitiesToChooseInput | $Enums.Ability[]
    maxValue?: IntFieldUpdateOperationsInput | number
  }

  export type FeatAbilityBoostCreateManyInput = {
    boostId?: number
    featId: number
    ability?: $Enums.Ability | null
    increaseValue: number
    abilitiesToChoose?: FeatAbilityBoostCreateabilitiesToChooseInput | $Enums.Ability[]
    maxValue?: number
  }

  export type FeatAbilityBoostUpdateManyMutationInput = {
    ability?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    increaseValue?: IntFieldUpdateOperationsInput | number
    abilitiesToChoose?: FeatAbilityBoostUpdateabilitiesToChooseInput | $Enums.Ability[]
    maxValue?: IntFieldUpdateOperationsInput | number
  }

  export type FeatAbilityBoostUncheckedUpdateManyInput = {
    boostId?: IntFieldUpdateOperationsInput | number
    featId?: IntFieldUpdateOperationsInput | number
    ability?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    increaseValue?: IntFieldUpdateOperationsInput | number
    abilitiesToChoose?: FeatAbilityBoostUpdateabilitiesToChooseInput | $Enums.Ability[]
    maxValue?: IntFieldUpdateOperationsInput | number
  }

  export type PersFeatCreateInput = {
    feat: FeatCreateNestedOneWithoutPersFeatsInput
    pers: PersCreateNestedOneWithoutFeatsInput
  }

  export type PersFeatUncheckedCreateInput = {
    persFeatId?: number
    featId: number
    persId: number
  }

  export type PersFeatUpdateInput = {
    feat?: FeatUpdateOneRequiredWithoutPersFeatsNestedInput
    pers?: PersUpdateOneRequiredWithoutFeatsNestedInput
  }

  export type PersFeatUncheckedUpdateInput = {
    persFeatId?: IntFieldUpdateOperationsInput | number
    featId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
  }

  export type PersFeatCreateManyInput = {
    persFeatId?: number
    featId: number
    persId: number
  }

  export type PersFeatUpdateManyMutationInput = {

  }

  export type PersFeatUncheckedUpdateManyInput = {
    persFeatId?: IntFieldUpdateOperationsInput | number
    featId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
  }

  export type MagicItemCreateInput = {
    name: string
    itemType: $Enums.MagicItemType
    rarity: $Enums.ItemRarity
    description: string
    bonusToAC?: number | null
    bonusToAttackRoll?: number | null
    bonusToDamage?: number | null
    features?: MagicItemFeatureCreateNestedManyWithoutMagicItemInput
    persMagicItems?: PersMagicItemCreateNestedManyWithoutMagicItemInput
  }

  export type MagicItemUncheckedCreateInput = {
    magicItemId?: number
    name: string
    itemType: $Enums.MagicItemType
    rarity: $Enums.ItemRarity
    description: string
    bonusToAC?: number | null
    bonusToAttackRoll?: number | null
    bonusToDamage?: number | null
    features?: MagicItemFeatureUncheckedCreateNestedManyWithoutMagicItemInput
    persMagicItems?: PersMagicItemUncheckedCreateNestedManyWithoutMagicItemInput
  }

  export type MagicItemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    itemType?: EnumMagicItemTypeFieldUpdateOperationsInput | $Enums.MagicItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: StringFieldUpdateOperationsInput | string
    bonusToAC?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToAttackRoll?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToDamage?: NullableIntFieldUpdateOperationsInput | number | null
    features?: MagicItemFeatureUpdateManyWithoutMagicItemNestedInput
    persMagicItems?: PersMagicItemUpdateManyWithoutMagicItemNestedInput
  }

  export type MagicItemUncheckedUpdateInput = {
    magicItemId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    itemType?: EnumMagicItemTypeFieldUpdateOperationsInput | $Enums.MagicItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: StringFieldUpdateOperationsInput | string
    bonusToAC?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToAttackRoll?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToDamage?: NullableIntFieldUpdateOperationsInput | number | null
    features?: MagicItemFeatureUncheckedUpdateManyWithoutMagicItemNestedInput
    persMagicItems?: PersMagicItemUncheckedUpdateManyWithoutMagicItemNestedInput
  }

  export type MagicItemCreateManyInput = {
    magicItemId?: number
    name: string
    itemType: $Enums.MagicItemType
    rarity: $Enums.ItemRarity
    description: string
    bonusToAC?: number | null
    bonusToAttackRoll?: number | null
    bonusToDamage?: number | null
  }

  export type MagicItemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    itemType?: EnumMagicItemTypeFieldUpdateOperationsInput | $Enums.MagicItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: StringFieldUpdateOperationsInput | string
    bonusToAC?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToAttackRoll?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToDamage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MagicItemUncheckedUpdateManyInput = {
    magicItemId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    itemType?: EnumMagicItemTypeFieldUpdateOperationsInput | $Enums.MagicItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: StringFieldUpdateOperationsInput | string
    bonusToAC?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToAttackRoll?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToDamage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WeaponCreateInput = {
    name: $Enums.WeaponCategory
    damage: string
    damageType: $Enums.DamageType
    weaponType: $Enums.WeaponType
    properties?: WeaponCreatepropertiesInput | $Enums.WeaponProperty[]
    versatileDamage?: string | null
    normalRange?: number | null
    longRange?: number | null
    persWeapons?: PersWeaponCreateNestedManyWithoutWeaponInput
    classStartingEquipmentOption?: ClassStartingEquipmentOptionCreateNestedManyWithoutWeaponInput
  }

  export type WeaponUncheckedCreateInput = {
    weaponId?: number
    name: $Enums.WeaponCategory
    damage: string
    damageType: $Enums.DamageType
    weaponType: $Enums.WeaponType
    properties?: WeaponCreatepropertiesInput | $Enums.WeaponProperty[]
    versatileDamage?: string | null
    normalRange?: number | null
    longRange?: number | null
    persWeapons?: PersWeaponUncheckedCreateNestedManyWithoutWeaponInput
    classStartingEquipmentOption?: ClassStartingEquipmentOptionUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type WeaponUpdateInput = {
    name?: EnumWeaponCategoryFieldUpdateOperationsInput | $Enums.WeaponCategory
    damage?: StringFieldUpdateOperationsInput | string
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    weaponType?: EnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType
    properties?: WeaponUpdatepropertiesInput | $Enums.WeaponProperty[]
    versatileDamage?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableIntFieldUpdateOperationsInput | number | null
    longRange?: NullableIntFieldUpdateOperationsInput | number | null
    persWeapons?: PersWeaponUpdateManyWithoutWeaponNestedInput
    classStartingEquipmentOption?: ClassStartingEquipmentOptionUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateInput = {
    weaponId?: IntFieldUpdateOperationsInput | number
    name?: EnumWeaponCategoryFieldUpdateOperationsInput | $Enums.WeaponCategory
    damage?: StringFieldUpdateOperationsInput | string
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    weaponType?: EnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType
    properties?: WeaponUpdatepropertiesInput | $Enums.WeaponProperty[]
    versatileDamage?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableIntFieldUpdateOperationsInput | number | null
    longRange?: NullableIntFieldUpdateOperationsInput | number | null
    persWeapons?: PersWeaponUncheckedUpdateManyWithoutWeaponNestedInput
    classStartingEquipmentOption?: ClassStartingEquipmentOptionUncheckedUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponCreateManyInput = {
    weaponId?: number
    name: $Enums.WeaponCategory
    damage: string
    damageType: $Enums.DamageType
    weaponType: $Enums.WeaponType
    properties?: WeaponCreatepropertiesInput | $Enums.WeaponProperty[]
    versatileDamage?: string | null
    normalRange?: number | null
    longRange?: number | null
  }

  export type WeaponUpdateManyMutationInput = {
    name?: EnumWeaponCategoryFieldUpdateOperationsInput | $Enums.WeaponCategory
    damage?: StringFieldUpdateOperationsInput | string
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    weaponType?: EnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType
    properties?: WeaponUpdatepropertiesInput | $Enums.WeaponProperty[]
    versatileDamage?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableIntFieldUpdateOperationsInput | number | null
    longRange?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WeaponUncheckedUpdateManyInput = {
    weaponId?: IntFieldUpdateOperationsInput | number
    name?: EnumWeaponCategoryFieldUpdateOperationsInput | $Enums.WeaponCategory
    damage?: StringFieldUpdateOperationsInput | string
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    weaponType?: EnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType
    properties?: WeaponUpdatepropertiesInput | $Enums.WeaponProperty[]
    versatileDamage?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableIntFieldUpdateOperationsInput | number | null
    longRange?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArmorCreateInput = {
    name: $Enums.ArmorCategory
    armorType: $Enums.ArmorType
    baseAC: number
    strengthReq?: number | null
    stealthDisadvantage?: boolean
    persArmor?: PersArmorCreateNestedManyWithoutArmorInput
    classStartingEquipmentOption?: ClassStartingEquipmentOptionCreateNestedManyWithoutArmorInput
  }

  export type ArmorUncheckedCreateInput = {
    armorId?: number
    name: $Enums.ArmorCategory
    armorType: $Enums.ArmorType
    baseAC: number
    strengthReq?: number | null
    stealthDisadvantage?: boolean
    persArmor?: PersArmorUncheckedCreateNestedManyWithoutArmorInput
    classStartingEquipmentOption?: ClassStartingEquipmentOptionUncheckedCreateNestedManyWithoutArmorInput
  }

  export type ArmorUpdateInput = {
    name?: EnumArmorCategoryFieldUpdateOperationsInput | $Enums.ArmorCategory
    armorType?: EnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType
    baseAC?: IntFieldUpdateOperationsInput | number
    strengthReq?: NullableIntFieldUpdateOperationsInput | number | null
    stealthDisadvantage?: BoolFieldUpdateOperationsInput | boolean
    persArmor?: PersArmorUpdateManyWithoutArmorNestedInput
    classStartingEquipmentOption?: ClassStartingEquipmentOptionUpdateManyWithoutArmorNestedInput
  }

  export type ArmorUncheckedUpdateInput = {
    armorId?: IntFieldUpdateOperationsInput | number
    name?: EnumArmorCategoryFieldUpdateOperationsInput | $Enums.ArmorCategory
    armorType?: EnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType
    baseAC?: IntFieldUpdateOperationsInput | number
    strengthReq?: NullableIntFieldUpdateOperationsInput | number | null
    stealthDisadvantage?: BoolFieldUpdateOperationsInput | boolean
    persArmor?: PersArmorUncheckedUpdateManyWithoutArmorNestedInput
    classStartingEquipmentOption?: ClassStartingEquipmentOptionUncheckedUpdateManyWithoutArmorNestedInput
  }

  export type ArmorCreateManyInput = {
    armorId?: number
    name: $Enums.ArmorCategory
    armorType: $Enums.ArmorType
    baseAC: number
    strengthReq?: number | null
    stealthDisadvantage?: boolean
  }

  export type ArmorUpdateManyMutationInput = {
    name?: EnumArmorCategoryFieldUpdateOperationsInput | $Enums.ArmorCategory
    armorType?: EnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType
    baseAC?: IntFieldUpdateOperationsInput | number
    strengthReq?: NullableIntFieldUpdateOperationsInput | number | null
    stealthDisadvantage?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ArmorUncheckedUpdateManyInput = {
    armorId?: IntFieldUpdateOperationsInput | number
    name?: EnumArmorCategoryFieldUpdateOperationsInput | $Enums.ArmorCategory
    armorType?: EnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType
    baseAC?: IntFieldUpdateOperationsInput | number
    strengthReq?: NullableIntFieldUpdateOperationsInput | number | null
    stealthDisadvantage?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersSkillCreateInput = {
    skillId: number
    proficiencyType?: $Enums.SkillProficiencyType
    customModifier?: number | null
    name: $Enums.Skills
    pers: PersCreateNestedOneWithoutSkillsInput
  }

  export type PersSkillUncheckedCreateInput = {
    persSkillId?: number
    skillId: number
    persId: number
    proficiencyType?: $Enums.SkillProficiencyType
    customModifier?: number | null
    name: $Enums.Skills
  }

  export type PersSkillUpdateInput = {
    skillId?: IntFieldUpdateOperationsInput | number
    proficiencyType?: EnumSkillProficiencyTypeFieldUpdateOperationsInput | $Enums.SkillProficiencyType
    customModifier?: NullableIntFieldUpdateOperationsInput | number | null
    name?: EnumSkillsFieldUpdateOperationsInput | $Enums.Skills
    pers?: PersUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type PersSkillUncheckedUpdateInput = {
    persSkillId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    proficiencyType?: EnumSkillProficiencyTypeFieldUpdateOperationsInput | $Enums.SkillProficiencyType
    customModifier?: NullableIntFieldUpdateOperationsInput | number | null
    name?: EnumSkillsFieldUpdateOperationsInput | $Enums.Skills
  }

  export type PersSkillCreateManyInput = {
    persSkillId?: number
    skillId: number
    persId: number
    proficiencyType?: $Enums.SkillProficiencyType
    customModifier?: number | null
    name: $Enums.Skills
  }

  export type PersSkillUpdateManyMutationInput = {
    skillId?: IntFieldUpdateOperationsInput | number
    proficiencyType?: EnumSkillProficiencyTypeFieldUpdateOperationsInput | $Enums.SkillProficiencyType
    customModifier?: NullableIntFieldUpdateOperationsInput | number | null
    name?: EnumSkillsFieldUpdateOperationsInput | $Enums.Skills
  }

  export type PersSkillUncheckedUpdateManyInput = {
    persSkillId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    proficiencyType?: EnumSkillProficiencyTypeFieldUpdateOperationsInput | $Enums.SkillProficiencyType
    customModifier?: NullableIntFieldUpdateOperationsInput | number | null
    name?: EnumSkillsFieldUpdateOperationsInput | $Enums.Skills
  }

  export type PersWeaponCreateInput = {
    overrideDamage?: string | null
    attackBonus?: number | null
    overrideName?: string | null
    overrideNormalRange?: number | null
    overrideLongRange?: number | null
    overrideDamageType?: $Enums.DamageType | null
    overrideAttackAbility?: $Enums.Ability | null
    isProficient?: boolean
    pers: PersCreateNestedOneWithoutWeaponsInput
    weapon: WeaponCreateNestedOneWithoutPersWeaponsInput
  }

  export type PersWeaponUncheckedCreateInput = {
    persWeaponId?: number
    persId: number
    weaponId: number
    overrideDamage?: string | null
    attackBonus?: number | null
    overrideName?: string | null
    overrideNormalRange?: number | null
    overrideLongRange?: number | null
    overrideDamageType?: $Enums.DamageType | null
    overrideAttackAbility?: $Enums.Ability | null
    isProficient?: boolean
  }

  export type PersWeaponUpdateInput = {
    overrideDamage?: NullableStringFieldUpdateOperationsInput | string | null
    attackBonus?: NullableIntFieldUpdateOperationsInput | number | null
    overrideName?: NullableStringFieldUpdateOperationsInput | string | null
    overrideNormalRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideLongRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    overrideAttackAbility?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
    pers?: PersUpdateOneRequiredWithoutWeaponsNestedInput
    weapon?: WeaponUpdateOneRequiredWithoutPersWeaponsNestedInput
  }

  export type PersWeaponUncheckedUpdateInput = {
    persWeaponId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    weaponId?: IntFieldUpdateOperationsInput | number
    overrideDamage?: NullableStringFieldUpdateOperationsInput | string | null
    attackBonus?: NullableIntFieldUpdateOperationsInput | number | null
    overrideName?: NullableStringFieldUpdateOperationsInput | string | null
    overrideNormalRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideLongRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    overrideAttackAbility?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersWeaponCreateManyInput = {
    persWeaponId?: number
    persId: number
    weaponId: number
    overrideDamage?: string | null
    attackBonus?: number | null
    overrideName?: string | null
    overrideNormalRange?: number | null
    overrideLongRange?: number | null
    overrideDamageType?: $Enums.DamageType | null
    overrideAttackAbility?: $Enums.Ability | null
    isProficient?: boolean
  }

  export type PersWeaponUpdateManyMutationInput = {
    overrideDamage?: NullableStringFieldUpdateOperationsInput | string | null
    attackBonus?: NullableIntFieldUpdateOperationsInput | number | null
    overrideName?: NullableStringFieldUpdateOperationsInput | string | null
    overrideNormalRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideLongRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    overrideAttackAbility?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersWeaponUncheckedUpdateManyInput = {
    persWeaponId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    weaponId?: IntFieldUpdateOperationsInput | number
    overrideDamage?: NullableStringFieldUpdateOperationsInput | string | null
    attackBonus?: NullableIntFieldUpdateOperationsInput | number | null
    overrideName?: NullableStringFieldUpdateOperationsInput | string | null
    overrideNormalRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideLongRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    overrideAttackAbility?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersArmorCreateInput = {
    overrideBaseAC?: number | null
    miscACBonus?: number | null
    isProficient?: boolean
    equipped?: boolean
    pers: PersCreateNestedOneWithoutArmorsInput
    armor: ArmorCreateNestedOneWithoutPersArmorInput
  }

  export type PersArmorUncheckedCreateInput = {
    persArmorId?: number
    armorId: number
    persId: number
    overrideBaseAC?: number | null
    miscACBonus?: number | null
    isProficient?: boolean
    equipped?: boolean
  }

  export type PersArmorUpdateInput = {
    overrideBaseAC?: NullableIntFieldUpdateOperationsInput | number | null
    miscACBonus?: NullableIntFieldUpdateOperationsInput | number | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
    equipped?: BoolFieldUpdateOperationsInput | boolean
    pers?: PersUpdateOneRequiredWithoutArmorsNestedInput
    armor?: ArmorUpdateOneRequiredWithoutPersArmorNestedInput
  }

  export type PersArmorUncheckedUpdateInput = {
    persArmorId?: IntFieldUpdateOperationsInput | number
    armorId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    overrideBaseAC?: NullableIntFieldUpdateOperationsInput | number | null
    miscACBonus?: NullableIntFieldUpdateOperationsInput | number | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
    equipped?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersArmorCreateManyInput = {
    persArmorId?: number
    armorId: number
    persId: number
    overrideBaseAC?: number | null
    miscACBonus?: number | null
    isProficient?: boolean
    equipped?: boolean
  }

  export type PersArmorUpdateManyMutationInput = {
    overrideBaseAC?: NullableIntFieldUpdateOperationsInput | number | null
    miscACBonus?: NullableIntFieldUpdateOperationsInput | number | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
    equipped?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersArmorUncheckedUpdateManyInput = {
    persArmorId?: IntFieldUpdateOperationsInput | number
    armorId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    overrideBaseAC?: NullableIntFieldUpdateOperationsInput | number | null
    miscACBonus?: NullableIntFieldUpdateOperationsInput | number | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
    equipped?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersMagicItemCreateInput = {
    pers: PersCreateNestedOneWithoutMagicItemsInput
    magicItem: MagicItemCreateNestedOneWithoutPersMagicItemsInput
  }

  export type PersMagicItemUncheckedCreateInput = {
    persMagicItemId?: number
    persId: number
    magicItemId: number
  }

  export type PersMagicItemUpdateInput = {
    pers?: PersUpdateOneRequiredWithoutMagicItemsNestedInput
    magicItem?: MagicItemUpdateOneRequiredWithoutPersMagicItemsNestedInput
  }

  export type PersMagicItemUncheckedUpdateInput = {
    persMagicItemId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    magicItemId?: IntFieldUpdateOperationsInput | number
  }

  export type PersMagicItemCreateManyInput = {
    persMagicItemId?: number
    persId: number
    magicItemId: number
  }

  export type PersMagicItemUpdateManyMutationInput = {

  }

  export type PersMagicItemUncheckedUpdateManyInput = {
    persMagicItemId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    magicItemId?: IntFieldUpdateOperationsInput | number
  }

  export type EquipmentPackCreateInput = {
    name: $Enums.EquipmentPackCategory
    description: string
    items: JsonNullValueInput | InputJsonValue
    classStartingEquipmentOptions?: ClassStartingEquipmentOptionCreateNestedManyWithoutEquipmentPackInput
  }

  export type EquipmentPackUncheckedCreateInput = {
    equipmentPackId?: number
    name: $Enums.EquipmentPackCategory
    description: string
    items: JsonNullValueInput | InputJsonValue
    classStartingEquipmentOptions?: ClassStartingEquipmentOptionUncheckedCreateNestedManyWithoutEquipmentPackInput
  }

  export type EquipmentPackUpdateInput = {
    name?: EnumEquipmentPackCategoryFieldUpdateOperationsInput | $Enums.EquipmentPackCategory
    description?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    classStartingEquipmentOptions?: ClassStartingEquipmentOptionUpdateManyWithoutEquipmentPackNestedInput
  }

  export type EquipmentPackUncheckedUpdateInput = {
    equipmentPackId?: IntFieldUpdateOperationsInput | number
    name?: EnumEquipmentPackCategoryFieldUpdateOperationsInput | $Enums.EquipmentPackCategory
    description?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    classStartingEquipmentOptions?: ClassStartingEquipmentOptionUncheckedUpdateManyWithoutEquipmentPackNestedInput
  }

  export type EquipmentPackCreateManyInput = {
    equipmentPackId?: number
    name: $Enums.EquipmentPackCategory
    description: string
    items: JsonNullValueInput | InputJsonValue
  }

  export type EquipmentPackUpdateManyMutationInput = {
    name?: EnumEquipmentPackCategoryFieldUpdateOperationsInput | $Enums.EquipmentPackCategory
    description?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
  }

  export type EquipmentPackUncheckedUpdateManyInput = {
    equipmentPackId?: IntFieldUpdateOperationsInput | number
    name?: EnumEquipmentPackCategoryFieldUpdateOperationsInput | $Enums.EquipmentPackCategory
    description?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
  }

  export type ClassStartingEquipmentOptionCreateInput = {
    choiceGroup: number
    option: string
    quantity?: number
    chooseAnyArmor?: boolean
    armorType?: $Enums.ArmorType | null
    chooseAnyWeapon?: boolean
    weaponType?: $Enums.WeaponType | null
    weaponCount?: number
    description?: string | null
    class: ClassCreateNestedOneWithoutStartingEquipmentOptionInput
    weapon?: WeaponCreateNestedOneWithoutClassStartingEquipmentOptionInput
    armor?: ArmorCreateNestedOneWithoutClassStartingEquipmentOptionInput
    equipmentPack?: EquipmentPackCreateNestedOneWithoutClassStartingEquipmentOptionsInput
  }

  export type ClassStartingEquipmentOptionUncheckedCreateInput = {
    optionId?: number
    classId: number
    choiceGroup: number
    option: string
    weaponId?: number | null
    armorId?: number | null
    equipmentPackId?: number | null
    quantity?: number
    chooseAnyArmor?: boolean
    armorType?: $Enums.ArmorType | null
    chooseAnyWeapon?: boolean
    weaponType?: $Enums.WeaponType | null
    weaponCount?: number
    description?: string | null
  }

  export type ClassStartingEquipmentOptionUpdateInput = {
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class?: ClassUpdateOneRequiredWithoutStartingEquipmentOptionNestedInput
    weapon?: WeaponUpdateOneWithoutClassStartingEquipmentOptionNestedInput
    armor?: ArmorUpdateOneWithoutClassStartingEquipmentOptionNestedInput
    equipmentPack?: EquipmentPackUpdateOneWithoutClassStartingEquipmentOptionsNestedInput
  }

  export type ClassStartingEquipmentOptionUncheckedUpdateInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableIntFieldUpdateOperationsInput | number | null
    armorId?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentPackId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassStartingEquipmentOptionCreateManyInput = {
    optionId?: number
    classId: number
    choiceGroup: number
    option: string
    weaponId?: number | null
    armorId?: number | null
    equipmentPackId?: number | null
    quantity?: number
    chooseAnyArmor?: boolean
    armorType?: $Enums.ArmorType | null
    chooseAnyWeapon?: boolean
    weaponType?: $Enums.WeaponType | null
    weaponCount?: number
    description?: string | null
  }

  export type ClassStartingEquipmentOptionUpdateManyMutationInput = {
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassStartingEquipmentOptionUncheckedUpdateManyInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableIntFieldUpdateOperationsInput | number | null
    armorId?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentPackId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CharacterSpellsListRelationFilter = {
    every?: CharacterSpellsWhereInput
    some?: CharacterSpellsWhereInput
    none?: CharacterSpellsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CharacterSpellsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterCountOrderByAggregateInput = {
    characterId?: SortOrder
    name?: SortOrder
    userId?: SortOrder
  }

  export type CharacterAvgOrderByAggregateInput = {
    characterId?: SortOrder
    userId?: SortOrder
  }

  export type CharacterMaxOrderByAggregateInput = {
    characterId?: SortOrder
    name?: SortOrder
    userId?: SortOrder
  }

  export type CharacterMinOrderByAggregateInput = {
    characterId?: SortOrder
    name?: SortOrder
    userId?: SortOrder
  }

  export type CharacterSumOrderByAggregateInput = {
    characterId?: SortOrder
    userId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CharacterNullableScalarRelationFilter = {
    is?: CharacterWhereInput | null
    isNot?: CharacterWhereInput | null
  }

  export type SpellNullableScalarRelationFilter = {
    is?: SpellWhereInput | null
    isNot?: SpellWhereInput | null
  }

  export type CharacterSpellsCountOrderByAggregateInput = {
    characterSpellId?: SortOrder
    characterId?: SortOrder
    spellId?: SortOrder
  }

  export type CharacterSpellsAvgOrderByAggregateInput = {
    characterSpellId?: SortOrder
    characterId?: SortOrder
    spellId?: SortOrder
  }

  export type CharacterSpellsMaxOrderByAggregateInput = {
    characterSpellId?: SortOrder
    characterId?: SortOrder
    spellId?: SortOrder
  }

  export type CharacterSpellsMinOrderByAggregateInput = {
    characterSpellId?: SortOrder
    characterId?: SortOrder
    spellId?: SortOrder
  }

  export type CharacterSpellsSumOrderByAggregateInput = {
    characterSpellId?: SortOrder
    characterId?: SortOrder
    spellId?: SortOrder
  }

  export type EnumSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.Source | EnumSourceFieldRefInput<$PrismaModel>
    in?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceFilter<$PrismaModel> | $Enums.Source
  }

  export type CreatureCountOrderByAggregateInput = {
    creatureId?: SortOrder
    name?: SortOrder
    nameEng?: SortOrder
    size?: SortOrder
    type?: SortOrder
    alignment?: SortOrder
    source?: SortOrder
    ac?: SortOrder
    hp?: SortOrder
    speed?: SortOrder
    strength?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    charisma?: SortOrder
    skills?: SortOrder
    senses?: SortOrder
    languages?: SortOrder
    challenge?: SortOrder
    damageImmunity?: SortOrder
    damageResistance?: SortOrder
    conditionImmunity?: SortOrder
    savingThrows?: SortOrder
    specialAbilities?: SortOrder
    actions?: SortOrder
    reactions?: SortOrder
    legendaryActions?: SortOrder
    proficiencyBonus?: SortOrder
    description?: SortOrder
    lairActions?: SortOrder
    lairInfo?: SortOrder
    regionEffects?: SortOrder
    xp?: SortOrder
  }

  export type CreatureAvgOrderByAggregateInput = {
    creatureId?: SortOrder
  }

  export type CreatureMaxOrderByAggregateInput = {
    creatureId?: SortOrder
    name?: SortOrder
    nameEng?: SortOrder
    size?: SortOrder
    type?: SortOrder
    alignment?: SortOrder
    source?: SortOrder
    ac?: SortOrder
    hp?: SortOrder
    speed?: SortOrder
    strength?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    charisma?: SortOrder
    skills?: SortOrder
    senses?: SortOrder
    languages?: SortOrder
    challenge?: SortOrder
    damageImmunity?: SortOrder
    damageResistance?: SortOrder
    conditionImmunity?: SortOrder
    savingThrows?: SortOrder
    specialAbilities?: SortOrder
    actions?: SortOrder
    reactions?: SortOrder
    legendaryActions?: SortOrder
    proficiencyBonus?: SortOrder
    description?: SortOrder
    lairActions?: SortOrder
    lairInfo?: SortOrder
    regionEffects?: SortOrder
    xp?: SortOrder
  }

  export type CreatureMinOrderByAggregateInput = {
    creatureId?: SortOrder
    name?: SortOrder
    nameEng?: SortOrder
    size?: SortOrder
    type?: SortOrder
    alignment?: SortOrder
    source?: SortOrder
    ac?: SortOrder
    hp?: SortOrder
    speed?: SortOrder
    strength?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    charisma?: SortOrder
    skills?: SortOrder
    senses?: SortOrder
    languages?: SortOrder
    challenge?: SortOrder
    damageImmunity?: SortOrder
    damageResistance?: SortOrder
    conditionImmunity?: SortOrder
    savingThrows?: SortOrder
    specialAbilities?: SortOrder
    actions?: SortOrder
    reactions?: SortOrder
    legendaryActions?: SortOrder
    proficiencyBonus?: SortOrder
    description?: SortOrder
    lairActions?: SortOrder
    lairInfo?: SortOrder
    regionEffects?: SortOrder
    xp?: SortOrder
  }

  export type CreatureSumOrderByAggregateInput = {
    creatureId?: SortOrder
  }

  export type EnumSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Source | EnumSourceFieldRefInput<$PrismaModel>
    in?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceWithAggregatesFilter<$PrismaModel> | $Enums.Source
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSourceFilter<$PrismaModel>
    _max?: NestedEnumSourceFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type SpellClassesListRelationFilter = {
    every?: SpellClassesWhereInput
    some?: SpellClassesWhereInput
    none?: SpellClassesWhereInput
  }

  export type SpellRacesListRelationFilter = {
    every?: SpellRacesWhereInput
    some?: SpellRacesWhereInput
    none?: SpellRacesWhereInput
  }

  export type SpellbookSpellsListRelationFilter = {
    every?: SpellbookSpellsWhereInput
    some?: SpellbookSpellsWhereInput
    none?: SpellbookSpellsWhereInput
  }

  export type SubclassListRelationFilter = {
    every?: SubclassWhereInput
    some?: SubclassWhereInput
    none?: SubclassWhereInput
  }

  export type PersListRelationFilter = {
    every?: PersWhereInput
    some?: PersWhereInput
    none?: PersWhereInput
  }

  export type FeatureListRelationFilter = {
    every?: FeatureWhereInput
    some?: FeatureWhereInput
    none?: FeatureWhereInput
  }

  export type SpellClassesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpellRacesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpellbookSpellsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubclassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpellCountOrderByAggregateInput = {
    spellId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    school?: SortOrder
    castingTime?: SortOrder
    range?: SortOrder
    components?: SortOrder
    duration?: SortOrder
    description?: SortOrder
    hasRitual?: SortOrder
    hasConcentration?: SortOrder
    source?: SortOrder
  }

  export type SpellAvgOrderByAggregateInput = {
    spellId?: SortOrder
    level?: SortOrder
  }

  export type SpellMaxOrderByAggregateInput = {
    spellId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    school?: SortOrder
    castingTime?: SortOrder
    range?: SortOrder
    components?: SortOrder
    duration?: SortOrder
    description?: SortOrder
    hasRitual?: SortOrder
    hasConcentration?: SortOrder
    source?: SortOrder
  }

  export type SpellMinOrderByAggregateInput = {
    spellId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    school?: SortOrder
    castingTime?: SortOrder
    range?: SortOrder
    components?: SortOrder
    duration?: SortOrder
    description?: SortOrder
    hasRitual?: SortOrder
    hasConcentration?: SortOrder
    source?: SortOrder
  }

  export type SpellSumOrderByAggregateInput = {
    spellId?: SortOrder
    level?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type SpellScalarRelationFilter = {
    is?: SpellWhereInput
    isNot?: SpellWhereInput
  }

  export type SpellClassesCountOrderByAggregateInput = {
    classId?: SortOrder
    spellId?: SortOrder
    className?: SortOrder
  }

  export type SpellClassesAvgOrderByAggregateInput = {
    classId?: SortOrder
    spellId?: SortOrder
  }

  export type SpellClassesMaxOrderByAggregateInput = {
    classId?: SortOrder
    spellId?: SortOrder
    className?: SortOrder
  }

  export type SpellClassesMinOrderByAggregateInput = {
    classId?: SortOrder
    spellId?: SortOrder
    className?: SortOrder
  }

  export type SpellClassesSumOrderByAggregateInput = {
    classId?: SortOrder
    spellId?: SortOrder
  }

  export type SpellRacesCountOrderByAggregateInput = {
    spellId?: SortOrder
    raceId?: SortOrder
    raceName?: SortOrder
  }

  export type SpellRacesAvgOrderByAggregateInput = {
    spellId?: SortOrder
    raceId?: SortOrder
  }

  export type SpellRacesMaxOrderByAggregateInput = {
    spellId?: SortOrder
    raceId?: SortOrder
    raceName?: SortOrder
  }

  export type SpellRacesMinOrderByAggregateInput = {
    spellId?: SortOrder
    raceId?: SortOrder
    raceName?: SortOrder
  }

  export type SpellRacesSumOrderByAggregateInput = {
    spellId?: SortOrder
    raceId?: SortOrder
  }

  export type SpellbookCountOrderByAggregateInput = {
    spellbookId?: SortOrder
    userId?: SortOrder
  }

  export type SpellbookAvgOrderByAggregateInput = {
    spellbookId?: SortOrder
    userId?: SortOrder
  }

  export type SpellbookMaxOrderByAggregateInput = {
    spellbookId?: SortOrder
    userId?: SortOrder
  }

  export type SpellbookMinOrderByAggregateInput = {
    spellbookId?: SortOrder
    userId?: SortOrder
  }

  export type SpellbookSumOrderByAggregateInput = {
    spellbookId?: SortOrder
    userId?: SortOrder
  }

  export type SpellbookNullableScalarRelationFilter = {
    is?: SpellbookWhereInput | null
    isNot?: SpellbookWhereInput | null
  }

  export type SpellbookSpellsCountOrderByAggregateInput = {
    spellbookSpellId?: SortOrder
    spellId?: SortOrder
    spellbookId?: SortOrder
  }

  export type SpellbookSpellsAvgOrderByAggregateInput = {
    spellbookSpellId?: SortOrder
    spellId?: SortOrder
    spellbookId?: SortOrder
  }

  export type SpellbookSpellsMaxOrderByAggregateInput = {
    spellbookSpellId?: SortOrder
    spellId?: SortOrder
    spellbookId?: SortOrder
  }

  export type SpellbookSpellsMinOrderByAggregateInput = {
    spellbookSpellId?: SortOrder
    spellId?: SortOrder
    spellbookId?: SortOrder
  }

  export type SpellbookSpellsSumOrderByAggregateInput = {
    spellbookSpellId?: SortOrder
    spellId?: SortOrder
    spellbookId?: SortOrder
  }

  export type CharacterListRelationFilter = {
    every?: CharacterWhereInput
    some?: CharacterWhereInput
    none?: CharacterWhereInput
  }

  export type SpellbookListRelationFilter = {
    every?: SpellbookWhereInput
    some?: SpellbookWhereInput
    none?: SpellbookWhereInput
  }

  export type CharacterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpellbookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    userId?: SortOrder
    login?: SortOrder
    password?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    userId?: SortOrder
    login?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    userId?: SortOrder
    login?: SortOrder
    password?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type EnumAbilityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Ability | EnumAbilityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAbilityNullableFilter<$PrismaModel> | $Enums.Ability | null
  }

  export type EnumSpellcastingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SpellcastingType | EnumSpellcastingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SpellcastingType[] | ListEnumSpellcastingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpellcastingType[] | ListEnumSpellcastingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpellcastingTypeFilter<$PrismaModel> | $Enums.SpellcastingType
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumArmorTypeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel> | null
    has?: $Enums.ArmorType | EnumArmorTypeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumWeaponTypeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel> | null
    has?: $Enums.WeaponType | EnumWeaponTypeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumAbilityNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel> | null
    has?: $Enums.Ability | EnumAbilityFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumToolCategoryNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.ToolCategory[] | ListEnumToolCategoryFieldRefInput<$PrismaModel> | null
    has?: $Enums.ToolCategory | EnumToolCategoryFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.ToolCategory[] | ListEnumToolCategoryFieldRefInput<$PrismaModel>
    hasSome?: $Enums.ToolCategory[] | ListEnumToolCategoryFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumLanguageNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel> | null
    has?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ClassFeatureListRelationFilter = {
    every?: ClassFeatureWhereInput
    some?: ClassFeatureWhereInput
    none?: ClassFeatureWhereInput
  }

  export type PersMulticlassListRelationFilter = {
    every?: PersMulticlassWhereInput
    some?: PersMulticlassWhereInput
    none?: PersMulticlassWhereInput
  }

  export type ClassStartingEquipmentOptionListRelationFilter = {
    every?: ClassStartingEquipmentOptionWhereInput
    some?: ClassStartingEquipmentOptionWhereInput
    none?: ClassStartingEquipmentOptionWhereInput
  }

  export type ClassFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersMulticlassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassStartingEquipmentOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassCountOrderByAggregateInput = {
    classId?: SortOrder
    name?: SortOrder
    hitDie?: SortOrder
    primaryCastingStat?: SortOrder
    spellcastingType?: SortOrder
    abilityScoreUpLevels?: SortOrder
    subclassLevel?: SortOrder
    multiclassStrReq?: SortOrder
    multiclassDexReq?: SortOrder
    multiclassConReq?: SortOrder
    multiclassIntReq?: SortOrder
    multiclassWisReq?: SortOrder
    multiclassChaReq?: SortOrder
    armorProficiencies?: SortOrder
    weaponProficiencies?: SortOrder
    savingThrows?: SortOrder
    skillProficiencies?: SortOrder
    toolProficiencies?: SortOrder
    languagesToChooseCount?: SortOrder
    languages?: SortOrder
    specialSpellSlotProgression?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassAvgOrderByAggregateInput = {
    classId?: SortOrder
    hitDie?: SortOrder
    abilityScoreUpLevels?: SortOrder
    subclassLevel?: SortOrder
    multiclassStrReq?: SortOrder
    multiclassDexReq?: SortOrder
    multiclassConReq?: SortOrder
    multiclassIntReq?: SortOrder
    multiclassWisReq?: SortOrder
    multiclassChaReq?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    classId?: SortOrder
    name?: SortOrder
    hitDie?: SortOrder
    primaryCastingStat?: SortOrder
    spellcastingType?: SortOrder
    subclassLevel?: SortOrder
    multiclassStrReq?: SortOrder
    multiclassDexReq?: SortOrder
    multiclassConReq?: SortOrder
    multiclassIntReq?: SortOrder
    multiclassWisReq?: SortOrder
    multiclassChaReq?: SortOrder
    languagesToChooseCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    classId?: SortOrder
    name?: SortOrder
    hitDie?: SortOrder
    primaryCastingStat?: SortOrder
    spellcastingType?: SortOrder
    subclassLevel?: SortOrder
    multiclassStrReq?: SortOrder
    multiclassDexReq?: SortOrder
    multiclassConReq?: SortOrder
    multiclassIntReq?: SortOrder
    multiclassWisReq?: SortOrder
    multiclassChaReq?: SortOrder
    languagesToChooseCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassSumOrderByAggregateInput = {
    classId?: SortOrder
    hitDie?: SortOrder
    abilityScoreUpLevels?: SortOrder
    subclassLevel?: SortOrder
    multiclassStrReq?: SortOrder
    multiclassDexReq?: SortOrder
    multiclassConReq?: SortOrder
    multiclassIntReq?: SortOrder
    multiclassWisReq?: SortOrder
    multiclassChaReq?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type EnumAbilityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Ability | EnumAbilityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAbilityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Ability | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAbilityNullableFilter<$PrismaModel>
    _max?: NestedEnumAbilityNullableFilter<$PrismaModel>
  }

  export type EnumSpellcastingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpellcastingType | EnumSpellcastingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SpellcastingType[] | ListEnumSpellcastingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpellcastingType[] | ListEnumSpellcastingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpellcastingTypeWithAggregatesFilter<$PrismaModel> | $Enums.SpellcastingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpellcastingTypeFilter<$PrismaModel>
    _max?: NestedEnumSpellcastingTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SpellListRelationFilter = {
    every?: SpellWhereInput
    some?: SpellWhereInput
    none?: SpellWhereInput
  }

  export type ClassScalarRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type SubclassFeatureListRelationFilter = {
    every?: SubclassFeatureWhereInput
    some?: SubclassFeatureWhereInput
    none?: SubclassFeatureWhereInput
  }

  export type SpellOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubclassFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubclassClassIdNameCompoundUniqueInput = {
    classId: number
    name: string
  }

  export type SubclassCountOrderByAggregateInput = {
    subclassId?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    grantsSpells?: SortOrder
    languagesToChooseCount?: SortOrder
    languages?: SortOrder
    toolProficiencies?: SortOrder
  }

  export type SubclassAvgOrderByAggregateInput = {
    subclassId?: SortOrder
    classId?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type SubclassMaxOrderByAggregateInput = {
    subclassId?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    grantsSpells?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type SubclassMinOrderByAggregateInput = {
    subclassId?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    grantsSpells?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type SubclassSumOrderByAggregateInput = {
    subclassId?: SortOrder
    classId?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SubclassNullableScalarRelationFilter = {
    is?: SubclassWhereInput | null
    isNot?: SubclassWhereInput | null
  }

  export type RaceScalarRelationFilter = {
    is?: RaceWhereInput
    isNot?: RaceWhereInput
  }

  export type SubraceNullableScalarRelationFilter = {
    is?: SubraceWhereInput | null
    isNot?: SubraceWhereInput | null
  }

  export type BackgroundScalarRelationFilter = {
    is?: BackgroundWhereInput
    isNot?: BackgroundWhereInput
  }

  export type PersSkillListRelationFilter = {
    every?: PersSkillWhereInput
    some?: PersSkillWhereInput
    none?: PersSkillWhereInput
  }

  export type PersFeatureListRelationFilter = {
    every?: PersFeatureWhereInput
    some?: PersFeatureWhereInput
    none?: PersFeatureWhereInput
  }

  export type PersFeatListRelationFilter = {
    every?: PersFeatWhereInput
    some?: PersFeatWhereInput
    none?: PersFeatWhereInput
  }

  export type PersArmorListRelationFilter = {
    every?: PersArmorWhereInput
    some?: PersArmorWhereInput
    none?: PersArmorWhereInput
  }

  export type PersWeaponListRelationFilter = {
    every?: PersWeaponWhereInput
    some?: PersWeaponWhereInput
    none?: PersWeaponWhereInput
  }

  export type PersMagicItemListRelationFilter = {
    every?: PersMagicItemWhereInput
    some?: PersMagicItemWhereInput
    none?: PersMagicItemWhereInput
  }

  export type RaceVariantListRelationFilter = {
    every?: RaceVariantWhereInput
    some?: RaceVariantWhereInput
    none?: RaceVariantWhereInput
  }

  export type RaceChoiceOptionListRelationFilter = {
    every?: RaceChoiceOptionWhereInput
    some?: RaceChoiceOptionWhereInput
    none?: RaceChoiceOptionWhereInput
  }

  export type PersSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersFeatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersArmorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersWeaponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersMagicItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaceVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaceChoiceOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersCountOrderByAggregateInput = {
    persId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    currentSpellSlots?: SortOrder
    classId?: SortOrder
    subclassId?: SortOrder
    backgroundId?: SortOrder
    raceId?: SortOrder
    subraceId?: SortOrder
    currentHp?: SortOrder
    maxHp?: SortOrder
    tempHp?: SortOrder
    raceCustom?: SortOrder
    classCustom?: SortOrder
    alignment?: SortOrder
    xp?: SortOrder
    customBackground?: SortOrder
    customFeatures?: SortOrder
    customLanguagesKnown?: SortOrder
    customEquipment?: SortOrder
    personalityTraits?: SortOrder
    ideals?: SortOrder
    bonds?: SortOrder
    flaws?: SortOrder
    backstory?: SortOrder
    notes?: SortOrder
    str?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    int?: SortOrder
    wis?: SortOrder
    cha?: SortOrder
    cp?: SortOrder
    sp?: SortOrder
    ep?: SortOrder
    gp?: SortOrder
    pp?: SortOrder
    additionalSaveProficiencies?: SortOrder
    miscSaveBonuses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersAvgOrderByAggregateInput = {
    persId?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    currentSpellSlots?: SortOrder
    classId?: SortOrder
    subclassId?: SortOrder
    backgroundId?: SortOrder
    raceId?: SortOrder
    subraceId?: SortOrder
    currentHp?: SortOrder
    maxHp?: SortOrder
    tempHp?: SortOrder
    xp?: SortOrder
    str?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    int?: SortOrder
    wis?: SortOrder
    cha?: SortOrder
    cp?: SortOrder
    sp?: SortOrder
    ep?: SortOrder
    gp?: SortOrder
    pp?: SortOrder
  }

  export type PersMaxOrderByAggregateInput = {
    persId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    classId?: SortOrder
    subclassId?: SortOrder
    backgroundId?: SortOrder
    raceId?: SortOrder
    subraceId?: SortOrder
    currentHp?: SortOrder
    maxHp?: SortOrder
    tempHp?: SortOrder
    raceCustom?: SortOrder
    classCustom?: SortOrder
    alignment?: SortOrder
    xp?: SortOrder
    customBackground?: SortOrder
    customFeatures?: SortOrder
    customLanguagesKnown?: SortOrder
    customEquipment?: SortOrder
    personalityTraits?: SortOrder
    ideals?: SortOrder
    bonds?: SortOrder
    flaws?: SortOrder
    backstory?: SortOrder
    notes?: SortOrder
    str?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    int?: SortOrder
    wis?: SortOrder
    cha?: SortOrder
    cp?: SortOrder
    sp?: SortOrder
    ep?: SortOrder
    gp?: SortOrder
    pp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersMinOrderByAggregateInput = {
    persId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    classId?: SortOrder
    subclassId?: SortOrder
    backgroundId?: SortOrder
    raceId?: SortOrder
    subraceId?: SortOrder
    currentHp?: SortOrder
    maxHp?: SortOrder
    tempHp?: SortOrder
    raceCustom?: SortOrder
    classCustom?: SortOrder
    alignment?: SortOrder
    xp?: SortOrder
    customBackground?: SortOrder
    customFeatures?: SortOrder
    customLanguagesKnown?: SortOrder
    customEquipment?: SortOrder
    personalityTraits?: SortOrder
    ideals?: SortOrder
    bonds?: SortOrder
    flaws?: SortOrder
    backstory?: SortOrder
    notes?: SortOrder
    str?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    int?: SortOrder
    wis?: SortOrder
    cha?: SortOrder
    cp?: SortOrder
    sp?: SortOrder
    ep?: SortOrder
    gp?: SortOrder
    pp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersSumOrderByAggregateInput = {
    persId?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    currentSpellSlots?: SortOrder
    classId?: SortOrder
    subclassId?: SortOrder
    backgroundId?: SortOrder
    raceId?: SortOrder
    subraceId?: SortOrder
    currentHp?: SortOrder
    maxHp?: SortOrder
    tempHp?: SortOrder
    xp?: SortOrder
    str?: SortOrder
    dex?: SortOrder
    con?: SortOrder
    int?: SortOrder
    wis?: SortOrder
    cha?: SortOrder
    cp?: SortOrder
    sp?: SortOrder
    ep?: SortOrder
    gp?: SortOrder
    pp?: SortOrder
  }

  export type PersScalarRelationFilter = {
    is?: PersWhereInput
    isNot?: PersWhereInput
  }

  export type PersMulticlassPersIdClassIdCompoundUniqueInput = {
    persId: number
    classId: number
  }

  export type PersMulticlassCountOrderByAggregateInput = {
    persMulticlassId?: SortOrder
    persId?: SortOrder
    classId?: SortOrder
    subclassId?: SortOrder
    classLevel?: SortOrder
  }

  export type PersMulticlassAvgOrderByAggregateInput = {
    persMulticlassId?: SortOrder
    persId?: SortOrder
    classId?: SortOrder
    subclassId?: SortOrder
    classLevel?: SortOrder
  }

  export type PersMulticlassMaxOrderByAggregateInput = {
    persMulticlassId?: SortOrder
    persId?: SortOrder
    classId?: SortOrder
    subclassId?: SortOrder
    classLevel?: SortOrder
  }

  export type PersMulticlassMinOrderByAggregateInput = {
    persMulticlassId?: SortOrder
    persId?: SortOrder
    classId?: SortOrder
    subclassId?: SortOrder
    classLevel?: SortOrder
  }

  export type PersMulticlassSumOrderByAggregateInput = {
    persMulticlassId?: SortOrder
    persId?: SortOrder
    classId?: SortOrder
    subclassId?: SortOrder
    classLevel?: SortOrder
  }

  export type FeatureScalarRelationFilter = {
    is?: FeatureWhereInput
    isNot?: FeatureWhereInput
  }

  export type PersFeaturePersIdFeatureIdCompoundUniqueInput = {
    persId: number
    featureId: number
  }

  export type PersFeatureCountOrderByAggregateInput = {
    persFeatureId?: SortOrder
    persId?: SortOrder
    featureId?: SortOrder
    usesRemaining?: SortOrder
  }

  export type PersFeatureAvgOrderByAggregateInput = {
    persFeatureId?: SortOrder
    persId?: SortOrder
    featureId?: SortOrder
    usesRemaining?: SortOrder
  }

  export type PersFeatureMaxOrderByAggregateInput = {
    persFeatureId?: SortOrder
    persId?: SortOrder
    featureId?: SortOrder
    usesRemaining?: SortOrder
  }

  export type PersFeatureMinOrderByAggregateInput = {
    persFeatureId?: SortOrder
    persId?: SortOrder
    featureId?: SortOrder
    usesRemaining?: SortOrder
  }

  export type PersFeatureSumOrderByAggregateInput = {
    persFeatureId?: SortOrder
    persId?: SortOrder
    featureId?: SortOrder
    usesRemaining?: SortOrder
  }

  export type EnumRestTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RestType | EnumRestTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RestType[] | ListEnumRestTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RestType[] | ListEnumRestTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRestTypeNullableFilter<$PrismaModel> | $Enums.RestType | null
  }

  export type EnumFeatureDisplayTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureDisplayType | EnumFeatureDisplayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureDisplayType[] | ListEnumFeatureDisplayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureDisplayType[] | ListEnumFeatureDisplayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureDisplayTypeFilter<$PrismaModel> | $Enums.FeatureDisplayType
  }

  export type RaceTraitListRelationFilter = {
    every?: RaceTraitWhereInput
    some?: RaceTraitWhereInput
    none?: RaceTraitWhereInput
  }

  export type SubraceTraitListRelationFilter = {
    every?: SubraceTraitWhereInput
    some?: SubraceTraitWhereInput
    none?: SubraceTraitWhereInput
  }

  export type RaceVariantTraitListRelationFilter = {
    every?: RaceVariantTraitWhereInput
    some?: RaceVariantTraitWhereInput
    none?: RaceVariantTraitWhereInput
  }

  export type RaceChoiceOptionTraitListRelationFilter = {
    every?: RaceChoiceOptionTraitWhereInput
    some?: RaceChoiceOptionTraitWhereInput
    none?: RaceChoiceOptionTraitWhereInput
  }

  export type FeatFeatureListRelationFilter = {
    every?: FeatFeatureWhereInput
    some?: FeatFeatureWhereInput
    none?: FeatFeatureWhereInput
  }

  export type MagicItemFeatureListRelationFilter = {
    every?: MagicItemFeatureWhereInput
    some?: MagicItemFeatureWhereInput
    none?: MagicItemFeatureWhereInput
  }

  export type RaceTraitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubraceTraitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaceVariantTraitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaceChoiceOptionTraitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeatFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MagicItemFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeatureCountOrderByAggregateInput = {
    featureId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    modifiesStats?: SortOrder
    limitedUsesPer?: SortOrder
    usesCount?: SortOrder
    displayType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureAvgOrderByAggregateInput = {
    featureId?: SortOrder
    usesCount?: SortOrder
  }

  export type FeatureMaxOrderByAggregateInput = {
    featureId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    limitedUsesPer?: SortOrder
    usesCount?: SortOrder
    displayType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureMinOrderByAggregateInput = {
    featureId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    limitedUsesPer?: SortOrder
    usesCount?: SortOrder
    displayType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureSumOrderByAggregateInput = {
    featureId?: SortOrder
    usesCount?: SortOrder
  }

  export type EnumRestTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RestType | EnumRestTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RestType[] | ListEnumRestTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RestType[] | ListEnumRestTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRestTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RestType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRestTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumRestTypeNullableFilter<$PrismaModel>
  }

  export type EnumFeatureDisplayTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureDisplayType | EnumFeatureDisplayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureDisplayType[] | ListEnumFeatureDisplayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureDisplayType[] | ListEnumFeatureDisplayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureDisplayTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeatureDisplayType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeatureDisplayTypeFilter<$PrismaModel>
    _max?: NestedEnumFeatureDisplayTypeFilter<$PrismaModel>
  }

  export type ClassFeatureCountOrderByAggregateInput = {
    classFeatureId?: SortOrder
    classId?: SortOrder
    featureId?: SortOrder
    levelGranted?: SortOrder
    grantsSpellSlots?: SortOrder
  }

  export type ClassFeatureAvgOrderByAggregateInput = {
    classFeatureId?: SortOrder
    classId?: SortOrder
    featureId?: SortOrder
    levelGranted?: SortOrder
  }

  export type ClassFeatureMaxOrderByAggregateInput = {
    classFeatureId?: SortOrder
    classId?: SortOrder
    featureId?: SortOrder
    levelGranted?: SortOrder
    grantsSpellSlots?: SortOrder
  }

  export type ClassFeatureMinOrderByAggregateInput = {
    classFeatureId?: SortOrder
    classId?: SortOrder
    featureId?: SortOrder
    levelGranted?: SortOrder
    grantsSpellSlots?: SortOrder
  }

  export type ClassFeatureSumOrderByAggregateInput = {
    classFeatureId?: SortOrder
    classId?: SortOrder
    featureId?: SortOrder
    levelGranted?: SortOrder
  }

  export type SubclassScalarRelationFilter = {
    is?: SubclassWhereInput
    isNot?: SubclassWhereInput
  }

  export type SubclassFeatureCountOrderByAggregateInput = {
    subclassFeatureId?: SortOrder
    subclassId?: SortOrder
    featureId?: SortOrder
    levelGranted?: SortOrder
    grantsSpellSlots?: SortOrder
  }

  export type SubclassFeatureAvgOrderByAggregateInput = {
    subclassFeatureId?: SortOrder
    subclassId?: SortOrder
    featureId?: SortOrder
    levelGranted?: SortOrder
  }

  export type SubclassFeatureMaxOrderByAggregateInput = {
    subclassFeatureId?: SortOrder
    subclassId?: SortOrder
    featureId?: SortOrder
    levelGranted?: SortOrder
    grantsSpellSlots?: SortOrder
  }

  export type SubclassFeatureMinOrderByAggregateInput = {
    subclassFeatureId?: SortOrder
    subclassId?: SortOrder
    featureId?: SortOrder
    levelGranted?: SortOrder
    grantsSpellSlots?: SortOrder
  }

  export type SubclassFeatureSumOrderByAggregateInput = {
    subclassFeatureId?: SortOrder
    subclassId?: SortOrder
    featureId?: SortOrder
    levelGranted?: SortOrder
  }

  export type SubraceListRelationFilter = {
    every?: SubraceWhereInput
    some?: SubraceWhereInput
    none?: SubraceWhereInput
  }

  export type SubraceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaceTraitCountOrderByAggregateInput = {
    raceTraitId?: SortOrder
    raceId?: SortOrder
    featureId?: SortOrder
  }

  export type RaceTraitAvgOrderByAggregateInput = {
    raceTraitId?: SortOrder
    raceId?: SortOrder
    featureId?: SortOrder
  }

  export type RaceTraitMaxOrderByAggregateInput = {
    raceTraitId?: SortOrder
    raceId?: SortOrder
    featureId?: SortOrder
  }

  export type RaceTraitMinOrderByAggregateInput = {
    raceTraitId?: SortOrder
    raceId?: SortOrder
    featureId?: SortOrder
  }

  export type RaceTraitSumOrderByAggregateInput = {
    raceTraitId?: SortOrder
    raceId?: SortOrder
    featureId?: SortOrder
  }

  export type SubraceScalarRelationFilter = {
    is?: SubraceWhereInput
    isNot?: SubraceWhereInput
  }

  export type SubraceTraitCountOrderByAggregateInput = {
    subraceTraitId?: SortOrder
    subraceId?: SortOrder
    featureId?: SortOrder
  }

  export type SubraceTraitAvgOrderByAggregateInput = {
    subraceTraitId?: SortOrder
    subraceId?: SortOrder
    featureId?: SortOrder
  }

  export type SubraceTraitMaxOrderByAggregateInput = {
    subraceTraitId?: SortOrder
    subraceId?: SortOrder
    featureId?: SortOrder
  }

  export type SubraceTraitMinOrderByAggregateInput = {
    subraceTraitId?: SortOrder
    subraceId?: SortOrder
    featureId?: SortOrder
  }

  export type SubraceTraitSumOrderByAggregateInput = {
    subraceTraitId?: SortOrder
    subraceId?: SortOrder
    featureId?: SortOrder
  }

  export type RaceVariantScalarRelationFilter = {
    is?: RaceVariantWhereInput
    isNot?: RaceVariantWhereInput
  }

  export type RaceVariantTraitCountOrderByAggregateInput = {
    raceVariantTraitId?: SortOrder
    raceVariantId?: SortOrder
    featureId?: SortOrder
  }

  export type RaceVariantTraitAvgOrderByAggregateInput = {
    raceVariantTraitId?: SortOrder
    raceVariantId?: SortOrder
    featureId?: SortOrder
  }

  export type RaceVariantTraitMaxOrderByAggregateInput = {
    raceVariantTraitId?: SortOrder
    raceVariantId?: SortOrder
    featureId?: SortOrder
  }

  export type RaceVariantTraitMinOrderByAggregateInput = {
    raceVariantTraitId?: SortOrder
    raceVariantId?: SortOrder
    featureId?: SortOrder
  }

  export type RaceVariantTraitSumOrderByAggregateInput = {
    raceVariantTraitId?: SortOrder
    raceVariantId?: SortOrder
    featureId?: SortOrder
  }

  export type RaceChoiceOptionScalarRelationFilter = {
    is?: RaceChoiceOptionWhereInput
    isNot?: RaceChoiceOptionWhereInput
  }

  export type RaceChoiceOptionTraitCountOrderByAggregateInput = {
    raceChoiceOptionTraitId?: SortOrder
    optionId?: SortOrder
    featureId?: SortOrder
  }

  export type RaceChoiceOptionTraitAvgOrderByAggregateInput = {
    raceChoiceOptionTraitId?: SortOrder
    optionId?: SortOrder
    featureId?: SortOrder
  }

  export type RaceChoiceOptionTraitMaxOrderByAggregateInput = {
    raceChoiceOptionTraitId?: SortOrder
    optionId?: SortOrder
    featureId?: SortOrder
  }

  export type RaceChoiceOptionTraitMinOrderByAggregateInput = {
    raceChoiceOptionTraitId?: SortOrder
    optionId?: SortOrder
    featureId?: SortOrder
  }

  export type RaceChoiceOptionTraitSumOrderByAggregateInput = {
    raceChoiceOptionTraitId?: SortOrder
    optionId?: SortOrder
    featureId?: SortOrder
  }

  export type FeatScalarRelationFilter = {
    is?: FeatWhereInput
    isNot?: FeatWhereInput
  }

  export type FeatFeatureFeatIdFeatureIdCompoundUniqueInput = {
    featId: number
    featureId: number
  }

  export type FeatFeatureCountOrderByAggregateInput = {
    featFeatureId?: SortOrder
    featId?: SortOrder
    featureId?: SortOrder
  }

  export type FeatFeatureAvgOrderByAggregateInput = {
    featFeatureId?: SortOrder
    featId?: SortOrder
    featureId?: SortOrder
  }

  export type FeatFeatureMaxOrderByAggregateInput = {
    featFeatureId?: SortOrder
    featId?: SortOrder
    featureId?: SortOrder
  }

  export type FeatFeatureMinOrderByAggregateInput = {
    featFeatureId?: SortOrder
    featId?: SortOrder
    featureId?: SortOrder
  }

  export type FeatFeatureSumOrderByAggregateInput = {
    featFeatureId?: SortOrder
    featId?: SortOrder
    featureId?: SortOrder
  }

  export type MagicItemScalarRelationFilter = {
    is?: MagicItemWhereInput
    isNot?: MagicItemWhereInput
  }

  export type MagicItemFeatureCountOrderByAggregateInput = {
    magicItemFeatureId?: SortOrder
    magicItemId?: SortOrder
    featureId?: SortOrder
  }

  export type MagicItemFeatureAvgOrderByAggregateInput = {
    magicItemFeatureId?: SortOrder
    magicItemId?: SortOrder
    featureId?: SortOrder
  }

  export type MagicItemFeatureMaxOrderByAggregateInput = {
    magicItemFeatureId?: SortOrder
    magicItemId?: SortOrder
    featureId?: SortOrder
  }

  export type MagicItemFeatureMinOrderByAggregateInput = {
    magicItemFeatureId?: SortOrder
    magicItemId?: SortOrder
    featureId?: SortOrder
  }

  export type MagicItemFeatureSumOrderByAggregateInput = {
    magicItemFeatureId?: SortOrder
    magicItemId?: SortOrder
    featureId?: SortOrder
  }

  export type EnumRacesFilter<$PrismaModel = never> = {
    equals?: $Enums.Races | EnumRacesFieldRefInput<$PrismaModel>
    in?: $Enums.Races[] | ListEnumRacesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Races[] | ListEnumRacesFieldRefInput<$PrismaModel>
    not?: NestedEnumRacesFilter<$PrismaModel> | $Enums.Races
  }

  export type EnumSizeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel> | null
    has?: $Enums.Size | EnumSizeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumSkillsNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Skills[] | ListEnumSkillsFieldRefInput<$PrismaModel> | null
    has?: $Enums.Skills | EnumSkillsFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Skills[] | ListEnumSkillsFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Skills[] | ListEnumSkillsFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumWeaponCategoryNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponCategory[] | ListEnumWeaponCategoryFieldRefInput<$PrismaModel> | null
    has?: $Enums.WeaponCategory | EnumWeaponCategoryFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.WeaponCategory[] | ListEnumWeaponCategoryFieldRefInput<$PrismaModel>
    hasSome?: $Enums.WeaponCategory[] | ListEnumWeaponCategoryFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type RaceCountOrderByAggregateInput = {
    raceId?: SortOrder
    name?: SortOrder
    size?: SortOrder
    speed?: SortOrder
    burrowSpeed?: SortOrder
    flightSpeed?: SortOrder
    swimSpeed?: SortOrder
    climbSpeed?: SortOrder
    ac?: SortOrder
    source?: SortOrder
    languages?: SortOrder
    languagesToChooseCount?: SortOrder
    ASI?: SortOrder
    toolProficiencies?: SortOrder
    skillProficiencies?: SortOrder
    weaponProficiencies?: SortOrder
    armorProficiencies?: SortOrder
  }

  export type RaceAvgOrderByAggregateInput = {
    raceId?: SortOrder
    speed?: SortOrder
    burrowSpeed?: SortOrder
    flightSpeed?: SortOrder
    swimSpeed?: SortOrder
    climbSpeed?: SortOrder
    ac?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type RaceMaxOrderByAggregateInput = {
    raceId?: SortOrder
    name?: SortOrder
    speed?: SortOrder
    burrowSpeed?: SortOrder
    flightSpeed?: SortOrder
    swimSpeed?: SortOrder
    climbSpeed?: SortOrder
    ac?: SortOrder
    source?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type RaceMinOrderByAggregateInput = {
    raceId?: SortOrder
    name?: SortOrder
    speed?: SortOrder
    burrowSpeed?: SortOrder
    flightSpeed?: SortOrder
    swimSpeed?: SortOrder
    climbSpeed?: SortOrder
    ac?: SortOrder
    source?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type RaceSumOrderByAggregateInput = {
    raceId?: SortOrder
    speed?: SortOrder
    burrowSpeed?: SortOrder
    flightSpeed?: SortOrder
    swimSpeed?: SortOrder
    climbSpeed?: SortOrder
    ac?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type EnumRacesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Races | EnumRacesFieldRefInput<$PrismaModel>
    in?: $Enums.Races[] | ListEnumRacesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Races[] | ListEnumRacesFieldRefInput<$PrismaModel>
    not?: NestedEnumRacesWithAggregatesFilter<$PrismaModel> | $Enums.Races
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRacesFilter<$PrismaModel>
    _max?: NestedEnumRacesFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumSubracesFilter<$PrismaModel = never> = {
    equals?: $Enums.Subraces | EnumSubracesFieldRefInput<$PrismaModel>
    in?: $Enums.Subraces[] | ListEnumSubracesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Subraces[] | ListEnumSubracesFieldRefInput<$PrismaModel>
    not?: NestedEnumSubracesFilter<$PrismaModel> | $Enums.Subraces
  }

  export type SubraceCountOrderByAggregateInput = {
    subraceId?: SortOrder
    raceId?: SortOrder
    name?: SortOrder
    speedModifier?: SortOrder
    source?: SortOrder
    replacesASI?: SortOrder
    additionalASI?: SortOrder
    additionalLanguages?: SortOrder
    languagesToChooseCount?: SortOrder
    toolProficiencies?: SortOrder
    skillProficiencies?: SortOrder
    weaponProficiencies?: SortOrder
    armorProficiencies?: SortOrder
  }

  export type SubraceAvgOrderByAggregateInput = {
    subraceId?: SortOrder
    raceId?: SortOrder
    speedModifier?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type SubraceMaxOrderByAggregateInput = {
    subraceId?: SortOrder
    raceId?: SortOrder
    name?: SortOrder
    speedModifier?: SortOrder
    source?: SortOrder
    replacesASI?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type SubraceMinOrderByAggregateInput = {
    subraceId?: SortOrder
    raceId?: SortOrder
    name?: SortOrder
    speedModifier?: SortOrder
    source?: SortOrder
    replacesASI?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type SubraceSumOrderByAggregateInput = {
    subraceId?: SortOrder
    raceId?: SortOrder
    speedModifier?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type EnumSubracesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Subraces | EnumSubracesFieldRefInput<$PrismaModel>
    in?: $Enums.Subraces[] | ListEnumSubracesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Subraces[] | ListEnumSubracesFieldRefInput<$PrismaModel>
    not?: NestedEnumSubracesWithAggregatesFilter<$PrismaModel> | $Enums.Subraces
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubracesFilter<$PrismaModel>
    _max?: NestedEnumSubracesFilter<$PrismaModel>
  }

  export type EnumVariantsFilter<$PrismaModel = never> = {
    equals?: $Enums.Variants | EnumVariantsFieldRefInput<$PrismaModel>
    in?: $Enums.Variants[] | ListEnumVariantsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Variants[] | ListEnumVariantsFieldRefInput<$PrismaModel>
    not?: NestedEnumVariantsFilter<$PrismaModel> | $Enums.Variants
  }

  export type RaceVariantCountOrderByAggregateInput = {
    raceVariantId?: SortOrder
    raceId?: SortOrder
    name?: SortOrder
    source?: SortOrder
    exclusivityGroup?: SortOrder
    overridesRaceASI?: SortOrder
    overridesRaceSpeed?: SortOrder
    overridesFlightSpeed?: SortOrder
  }

  export type RaceVariantAvgOrderByAggregateInput = {
    raceVariantId?: SortOrder
    raceId?: SortOrder
    overridesRaceSpeed?: SortOrder
    overridesFlightSpeed?: SortOrder
  }

  export type RaceVariantMaxOrderByAggregateInput = {
    raceVariantId?: SortOrder
    raceId?: SortOrder
    name?: SortOrder
    source?: SortOrder
    exclusivityGroup?: SortOrder
    overridesRaceSpeed?: SortOrder
    overridesFlightSpeed?: SortOrder
  }

  export type RaceVariantMinOrderByAggregateInput = {
    raceVariantId?: SortOrder
    raceId?: SortOrder
    name?: SortOrder
    source?: SortOrder
    exclusivityGroup?: SortOrder
    overridesRaceSpeed?: SortOrder
    overridesFlightSpeed?: SortOrder
  }

  export type RaceVariantSumOrderByAggregateInput = {
    raceVariantId?: SortOrder
    raceId?: SortOrder
    overridesRaceSpeed?: SortOrder
    overridesFlightSpeed?: SortOrder
  }

  export type EnumVariantsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Variants | EnumVariantsFieldRefInput<$PrismaModel>
    in?: $Enums.Variants[] | ListEnumVariantsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Variants[] | ListEnumVariantsFieldRefInput<$PrismaModel>
    not?: NestedEnumVariantsWithAggregatesFilter<$PrismaModel> | $Enums.Variants
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVariantsFilter<$PrismaModel>
    _max?: NestedEnumVariantsFilter<$PrismaModel>
  }

  export type EnumDamageTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DamageType | EnumDamageTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDamageTypeNullableFilter<$PrismaModel> | $Enums.DamageType | null
  }

  export type EnumAOEShapesNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AOEShapes | EnumAOEShapesFieldRefInput<$PrismaModel> | null
    in?: $Enums.AOEShapes[] | ListEnumAOEShapesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AOEShapes[] | ListEnumAOEShapesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAOEShapesNullableFilter<$PrismaModel> | $Enums.AOEShapes | null
  }

  export type RaceChoiceOptionRaceIdSubraceIdChoiceGroupNameOptionNameCompoundUniqueInput = {
    raceId: number
    subraceId: number
    choiceGroupName: string
    optionName: string
  }

  export type RaceChoiceOptionCountOrderByAggregateInput = {
    optionId?: SortOrder
    raceId?: SortOrder
    subraceId?: SortOrder
    choiceGroupName?: SortOrder
    optionName?: SortOrder
    description?: SortOrder
    selectMultiple?: SortOrder
    maxSelection?: SortOrder
    grantsASI?: SortOrder
    grantsSkillProficiencies?: SortOrder
    grantsLanguages?: SortOrder
    languagesToChooseCount?: SortOrder
    modifiesSpeed?: SortOrder
    draconicDamageType?: SortOrder
    breathWeaponShape?: SortOrder
    breathWeaponAOE?: SortOrder
  }

  export type RaceChoiceOptionAvgOrderByAggregateInput = {
    optionId?: SortOrder
    raceId?: SortOrder
    subraceId?: SortOrder
    maxSelection?: SortOrder
    languagesToChooseCount?: SortOrder
    modifiesSpeed?: SortOrder
  }

  export type RaceChoiceOptionMaxOrderByAggregateInput = {
    optionId?: SortOrder
    raceId?: SortOrder
    subraceId?: SortOrder
    choiceGroupName?: SortOrder
    optionName?: SortOrder
    description?: SortOrder
    selectMultiple?: SortOrder
    maxSelection?: SortOrder
    languagesToChooseCount?: SortOrder
    modifiesSpeed?: SortOrder
    draconicDamageType?: SortOrder
    breathWeaponShape?: SortOrder
    breathWeaponAOE?: SortOrder
  }

  export type RaceChoiceOptionMinOrderByAggregateInput = {
    optionId?: SortOrder
    raceId?: SortOrder
    subraceId?: SortOrder
    choiceGroupName?: SortOrder
    optionName?: SortOrder
    description?: SortOrder
    selectMultiple?: SortOrder
    maxSelection?: SortOrder
    languagesToChooseCount?: SortOrder
    modifiesSpeed?: SortOrder
    draconicDamageType?: SortOrder
    breathWeaponShape?: SortOrder
    breathWeaponAOE?: SortOrder
  }

  export type RaceChoiceOptionSumOrderByAggregateInput = {
    optionId?: SortOrder
    raceId?: SortOrder
    subraceId?: SortOrder
    maxSelection?: SortOrder
    languagesToChooseCount?: SortOrder
    modifiesSpeed?: SortOrder
  }

  export type EnumDamageTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DamageType | EnumDamageTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDamageTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DamageType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDamageTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDamageTypeNullableFilter<$PrismaModel>
  }

  export type EnumAOEShapesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AOEShapes | EnumAOEShapesFieldRefInput<$PrismaModel> | null
    in?: $Enums.AOEShapes[] | ListEnumAOEShapesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AOEShapes[] | ListEnumAOEShapesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAOEShapesNullableWithAggregatesFilter<$PrismaModel> | $Enums.AOEShapes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAOEShapesNullableFilter<$PrismaModel>
    _max?: NestedEnumAOEShapesNullableFilter<$PrismaModel>
  }

  export type EnumBackgroundCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.BackgroundCategory | EnumBackgroundCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BackgroundCategory[] | ListEnumBackgroundCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BackgroundCategory[] | ListEnumBackgroundCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBackgroundCategoryFilter<$PrismaModel> | $Enums.BackgroundCategory
  }

  export type BackgroundCountOrderByAggregateInput = {
    backgroundId?: SortOrder
    name?: SortOrder
    source?: SortOrder
    toolProficiencies?: SortOrder
    skillProficiencies?: SortOrder
    languagesToChooseCount?: SortOrder
    items?: SortOrder
  }

  export type BackgroundAvgOrderByAggregateInput = {
    backgroundId?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type BackgroundMaxOrderByAggregateInput = {
    backgroundId?: SortOrder
    name?: SortOrder
    source?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type BackgroundMinOrderByAggregateInput = {
    backgroundId?: SortOrder
    name?: SortOrder
    source?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type BackgroundSumOrderByAggregateInput = {
    backgroundId?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type EnumBackgroundCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BackgroundCategory | EnumBackgroundCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BackgroundCategory[] | ListEnumBackgroundCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BackgroundCategory[] | ListEnumBackgroundCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBackgroundCategoryWithAggregatesFilter<$PrismaModel> | $Enums.BackgroundCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBackgroundCategoryFilter<$PrismaModel>
    _max?: NestedEnumBackgroundCategoryFilter<$PrismaModel>
  }

  export type EnumFeatCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatCategory | EnumFeatCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeatCategory[] | ListEnumFeatCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatCategory[] | ListEnumFeatCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatCategoryFilter<$PrismaModel> | $Enums.FeatCategory
  }

  export type FeatAbilityBoostNullableScalarRelationFilter = {
    is?: FeatAbilityBoostWhereInput | null
    isNot?: FeatAbilityBoostWhereInput | null
  }

  export type FeatCountOrderByAggregateInput = {
    featId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    languagesToChooseCount?: SortOrder
    languages?: SortOrder
    prerequisites?: SortOrder
  }

  export type FeatAvgOrderByAggregateInput = {
    featId?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type FeatMaxOrderByAggregateInput = {
    featId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type FeatMinOrderByAggregateInput = {
    featId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type FeatSumOrderByAggregateInput = {
    featId?: SortOrder
    languagesToChooseCount?: SortOrder
  }

  export type EnumFeatCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatCategory | EnumFeatCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeatCategory[] | ListEnumFeatCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatCategory[] | ListEnumFeatCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FeatCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeatCategoryFilter<$PrismaModel>
    _max?: NestedEnumFeatCategoryFilter<$PrismaModel>
  }

  export type FeatAbilityBoostCountOrderByAggregateInput = {
    boostId?: SortOrder
    featId?: SortOrder
    ability?: SortOrder
    increaseValue?: SortOrder
    abilitiesToChoose?: SortOrder
    maxValue?: SortOrder
  }

  export type FeatAbilityBoostAvgOrderByAggregateInput = {
    boostId?: SortOrder
    featId?: SortOrder
    increaseValue?: SortOrder
    maxValue?: SortOrder
  }

  export type FeatAbilityBoostMaxOrderByAggregateInput = {
    boostId?: SortOrder
    featId?: SortOrder
    ability?: SortOrder
    increaseValue?: SortOrder
    maxValue?: SortOrder
  }

  export type FeatAbilityBoostMinOrderByAggregateInput = {
    boostId?: SortOrder
    featId?: SortOrder
    ability?: SortOrder
    increaseValue?: SortOrder
    maxValue?: SortOrder
  }

  export type FeatAbilityBoostSumOrderByAggregateInput = {
    boostId?: SortOrder
    featId?: SortOrder
    increaseValue?: SortOrder
    maxValue?: SortOrder
  }

  export type PersFeatFeatIdPersIdCompoundUniqueInput = {
    featId: number
    persId: number
  }

  export type PersFeatCountOrderByAggregateInput = {
    persFeatId?: SortOrder
    featId?: SortOrder
    persId?: SortOrder
  }

  export type PersFeatAvgOrderByAggregateInput = {
    persFeatId?: SortOrder
    featId?: SortOrder
    persId?: SortOrder
  }

  export type PersFeatMaxOrderByAggregateInput = {
    persFeatId?: SortOrder
    featId?: SortOrder
    persId?: SortOrder
  }

  export type PersFeatMinOrderByAggregateInput = {
    persFeatId?: SortOrder
    featId?: SortOrder
    persId?: SortOrder
  }

  export type PersFeatSumOrderByAggregateInput = {
    persFeatId?: SortOrder
    featId?: SortOrder
    persId?: SortOrder
  }

  export type EnumMagicItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MagicItemType | EnumMagicItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MagicItemType[] | ListEnumMagicItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MagicItemType[] | ListEnumMagicItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMagicItemTypeFilter<$PrismaModel> | $Enums.MagicItemType
  }

  export type EnumItemRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityFilter<$PrismaModel> | $Enums.ItemRarity
  }

  export type MagicItemCountOrderByAggregateInput = {
    magicItemId?: SortOrder
    name?: SortOrder
    itemType?: SortOrder
    rarity?: SortOrder
    description?: SortOrder
    bonusToAC?: SortOrder
    bonusToAttackRoll?: SortOrder
    bonusToDamage?: SortOrder
  }

  export type MagicItemAvgOrderByAggregateInput = {
    magicItemId?: SortOrder
    bonusToAC?: SortOrder
    bonusToAttackRoll?: SortOrder
    bonusToDamage?: SortOrder
  }

  export type MagicItemMaxOrderByAggregateInput = {
    magicItemId?: SortOrder
    name?: SortOrder
    itemType?: SortOrder
    rarity?: SortOrder
    description?: SortOrder
    bonusToAC?: SortOrder
    bonusToAttackRoll?: SortOrder
    bonusToDamage?: SortOrder
  }

  export type MagicItemMinOrderByAggregateInput = {
    magicItemId?: SortOrder
    name?: SortOrder
    itemType?: SortOrder
    rarity?: SortOrder
    description?: SortOrder
    bonusToAC?: SortOrder
    bonusToAttackRoll?: SortOrder
    bonusToDamage?: SortOrder
  }

  export type MagicItemSumOrderByAggregateInput = {
    magicItemId?: SortOrder
    bonusToAC?: SortOrder
    bonusToAttackRoll?: SortOrder
    bonusToDamage?: SortOrder
  }

  export type EnumMagicItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MagicItemType | EnumMagicItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MagicItemType[] | ListEnumMagicItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MagicItemType[] | ListEnumMagicItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMagicItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.MagicItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMagicItemTypeFilter<$PrismaModel>
    _max?: NestedEnumMagicItemTypeFilter<$PrismaModel>
  }

  export type EnumItemRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityWithAggregatesFilter<$PrismaModel> | $Enums.ItemRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemRarityFilter<$PrismaModel>
    _max?: NestedEnumItemRarityFilter<$PrismaModel>
  }

  export type EnumWeaponCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponCategory | EnumWeaponCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.WeaponCategory[] | ListEnumWeaponCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeaponCategory[] | ListEnumWeaponCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumWeaponCategoryFilter<$PrismaModel> | $Enums.WeaponCategory
  }

  export type EnumDamageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DamageType | EnumDamageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDamageTypeFilter<$PrismaModel> | $Enums.DamageType
  }

  export type EnumWeaponTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponType | EnumWeaponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWeaponTypeFilter<$PrismaModel> | $Enums.WeaponType
  }

  export type EnumWeaponPropertyNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponProperty[] | ListEnumWeaponPropertyFieldRefInput<$PrismaModel> | null
    has?: $Enums.WeaponProperty | EnumWeaponPropertyFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.WeaponProperty[] | ListEnumWeaponPropertyFieldRefInput<$PrismaModel>
    hasSome?: $Enums.WeaponProperty[] | ListEnumWeaponPropertyFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type WeaponCountOrderByAggregateInput = {
    weaponId?: SortOrder
    name?: SortOrder
    damage?: SortOrder
    damageType?: SortOrder
    weaponType?: SortOrder
    properties?: SortOrder
    versatileDamage?: SortOrder
    normalRange?: SortOrder
    longRange?: SortOrder
  }

  export type WeaponAvgOrderByAggregateInput = {
    weaponId?: SortOrder
    normalRange?: SortOrder
    longRange?: SortOrder
  }

  export type WeaponMaxOrderByAggregateInput = {
    weaponId?: SortOrder
    name?: SortOrder
    damage?: SortOrder
    damageType?: SortOrder
    weaponType?: SortOrder
    versatileDamage?: SortOrder
    normalRange?: SortOrder
    longRange?: SortOrder
  }

  export type WeaponMinOrderByAggregateInput = {
    weaponId?: SortOrder
    name?: SortOrder
    damage?: SortOrder
    damageType?: SortOrder
    weaponType?: SortOrder
    versatileDamage?: SortOrder
    normalRange?: SortOrder
    longRange?: SortOrder
  }

  export type WeaponSumOrderByAggregateInput = {
    weaponId?: SortOrder
    normalRange?: SortOrder
    longRange?: SortOrder
  }

  export type EnumWeaponCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponCategory | EnumWeaponCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.WeaponCategory[] | ListEnumWeaponCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeaponCategory[] | ListEnumWeaponCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumWeaponCategoryWithAggregatesFilter<$PrismaModel> | $Enums.WeaponCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeaponCategoryFilter<$PrismaModel>
    _max?: NestedEnumWeaponCategoryFilter<$PrismaModel>
  }

  export type EnumDamageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DamageType | EnumDamageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDamageTypeWithAggregatesFilter<$PrismaModel> | $Enums.DamageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDamageTypeFilter<$PrismaModel>
    _max?: NestedEnumDamageTypeFilter<$PrismaModel>
  }

  export type EnumWeaponTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponType | EnumWeaponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWeaponTypeWithAggregatesFilter<$PrismaModel> | $Enums.WeaponType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeaponTypeFilter<$PrismaModel>
    _max?: NestedEnumWeaponTypeFilter<$PrismaModel>
  }

  export type EnumArmorCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ArmorCategory | EnumArmorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ArmorCategory[] | ListEnumArmorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArmorCategory[] | ListEnumArmorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumArmorCategoryFilter<$PrismaModel> | $Enums.ArmorCategory
  }

  export type EnumArmorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ArmorType | EnumArmorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArmorTypeFilter<$PrismaModel> | $Enums.ArmorType
  }

  export type ArmorCountOrderByAggregateInput = {
    armorId?: SortOrder
    name?: SortOrder
    armorType?: SortOrder
    baseAC?: SortOrder
    strengthReq?: SortOrder
    stealthDisadvantage?: SortOrder
  }

  export type ArmorAvgOrderByAggregateInput = {
    armorId?: SortOrder
    baseAC?: SortOrder
    strengthReq?: SortOrder
  }

  export type ArmorMaxOrderByAggregateInput = {
    armorId?: SortOrder
    name?: SortOrder
    armorType?: SortOrder
    baseAC?: SortOrder
    strengthReq?: SortOrder
    stealthDisadvantage?: SortOrder
  }

  export type ArmorMinOrderByAggregateInput = {
    armorId?: SortOrder
    name?: SortOrder
    armorType?: SortOrder
    baseAC?: SortOrder
    strengthReq?: SortOrder
    stealthDisadvantage?: SortOrder
  }

  export type ArmorSumOrderByAggregateInput = {
    armorId?: SortOrder
    baseAC?: SortOrder
    strengthReq?: SortOrder
  }

  export type EnumArmorCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArmorCategory | EnumArmorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ArmorCategory[] | ListEnumArmorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArmorCategory[] | ListEnumArmorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumArmorCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ArmorCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArmorCategoryFilter<$PrismaModel>
    _max?: NestedEnumArmorCategoryFilter<$PrismaModel>
  }

  export type EnumArmorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArmorType | EnumArmorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArmorTypeWithAggregatesFilter<$PrismaModel> | $Enums.ArmorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArmorTypeFilter<$PrismaModel>
    _max?: NestedEnumArmorTypeFilter<$PrismaModel>
  }

  export type EnumSkillProficiencyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillProficiencyType | EnumSkillProficiencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SkillProficiencyType[] | ListEnumSkillProficiencyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillProficiencyType[] | ListEnumSkillProficiencyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillProficiencyTypeFilter<$PrismaModel> | $Enums.SkillProficiencyType
  }

  export type EnumSkillsFilter<$PrismaModel = never> = {
    equals?: $Enums.Skills | EnumSkillsFieldRefInput<$PrismaModel>
    in?: $Enums.Skills[] | ListEnumSkillsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Skills[] | ListEnumSkillsFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillsFilter<$PrismaModel> | $Enums.Skills
  }

  export type PersSkillPersIdNameCompoundUniqueInput = {
    persId: number
    name: $Enums.Skills
  }

  export type PersSkillCountOrderByAggregateInput = {
    persSkillId?: SortOrder
    skillId?: SortOrder
    persId?: SortOrder
    proficiencyType?: SortOrder
    customModifier?: SortOrder
    name?: SortOrder
  }

  export type PersSkillAvgOrderByAggregateInput = {
    persSkillId?: SortOrder
    skillId?: SortOrder
    persId?: SortOrder
    customModifier?: SortOrder
  }

  export type PersSkillMaxOrderByAggregateInput = {
    persSkillId?: SortOrder
    skillId?: SortOrder
    persId?: SortOrder
    proficiencyType?: SortOrder
    customModifier?: SortOrder
    name?: SortOrder
  }

  export type PersSkillMinOrderByAggregateInput = {
    persSkillId?: SortOrder
    skillId?: SortOrder
    persId?: SortOrder
    proficiencyType?: SortOrder
    customModifier?: SortOrder
    name?: SortOrder
  }

  export type PersSkillSumOrderByAggregateInput = {
    persSkillId?: SortOrder
    skillId?: SortOrder
    persId?: SortOrder
    customModifier?: SortOrder
  }

  export type EnumSkillProficiencyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillProficiencyType | EnumSkillProficiencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SkillProficiencyType[] | ListEnumSkillProficiencyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillProficiencyType[] | ListEnumSkillProficiencyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillProficiencyTypeWithAggregatesFilter<$PrismaModel> | $Enums.SkillProficiencyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillProficiencyTypeFilter<$PrismaModel>
    _max?: NestedEnumSkillProficiencyTypeFilter<$PrismaModel>
  }

  export type EnumSkillsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Skills | EnumSkillsFieldRefInput<$PrismaModel>
    in?: $Enums.Skills[] | ListEnumSkillsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Skills[] | ListEnumSkillsFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillsWithAggregatesFilter<$PrismaModel> | $Enums.Skills
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillsFilter<$PrismaModel>
    _max?: NestedEnumSkillsFilter<$PrismaModel>
  }

  export type WeaponScalarRelationFilter = {
    is?: WeaponWhereInput
    isNot?: WeaponWhereInput
  }

  export type PersWeaponCountOrderByAggregateInput = {
    persWeaponId?: SortOrder
    persId?: SortOrder
    weaponId?: SortOrder
    overrideDamage?: SortOrder
    attackBonus?: SortOrder
    overrideName?: SortOrder
    overrideNormalRange?: SortOrder
    overrideLongRange?: SortOrder
    overrideDamageType?: SortOrder
    overrideAttackAbility?: SortOrder
    isProficient?: SortOrder
  }

  export type PersWeaponAvgOrderByAggregateInput = {
    persWeaponId?: SortOrder
    persId?: SortOrder
    weaponId?: SortOrder
    attackBonus?: SortOrder
    overrideNormalRange?: SortOrder
    overrideLongRange?: SortOrder
  }

  export type PersWeaponMaxOrderByAggregateInput = {
    persWeaponId?: SortOrder
    persId?: SortOrder
    weaponId?: SortOrder
    overrideDamage?: SortOrder
    attackBonus?: SortOrder
    overrideName?: SortOrder
    overrideNormalRange?: SortOrder
    overrideLongRange?: SortOrder
    overrideDamageType?: SortOrder
    overrideAttackAbility?: SortOrder
    isProficient?: SortOrder
  }

  export type PersWeaponMinOrderByAggregateInput = {
    persWeaponId?: SortOrder
    persId?: SortOrder
    weaponId?: SortOrder
    overrideDamage?: SortOrder
    attackBonus?: SortOrder
    overrideName?: SortOrder
    overrideNormalRange?: SortOrder
    overrideLongRange?: SortOrder
    overrideDamageType?: SortOrder
    overrideAttackAbility?: SortOrder
    isProficient?: SortOrder
  }

  export type PersWeaponSumOrderByAggregateInput = {
    persWeaponId?: SortOrder
    persId?: SortOrder
    weaponId?: SortOrder
    attackBonus?: SortOrder
    overrideNormalRange?: SortOrder
    overrideLongRange?: SortOrder
  }

  export type ArmorScalarRelationFilter = {
    is?: ArmorWhereInput
    isNot?: ArmorWhereInput
  }

  export type PersArmorCountOrderByAggregateInput = {
    persArmorId?: SortOrder
    armorId?: SortOrder
    persId?: SortOrder
    overrideBaseAC?: SortOrder
    miscACBonus?: SortOrder
    isProficient?: SortOrder
    equipped?: SortOrder
  }

  export type PersArmorAvgOrderByAggregateInput = {
    persArmorId?: SortOrder
    armorId?: SortOrder
    persId?: SortOrder
    overrideBaseAC?: SortOrder
    miscACBonus?: SortOrder
  }

  export type PersArmorMaxOrderByAggregateInput = {
    persArmorId?: SortOrder
    armorId?: SortOrder
    persId?: SortOrder
    overrideBaseAC?: SortOrder
    miscACBonus?: SortOrder
    isProficient?: SortOrder
    equipped?: SortOrder
  }

  export type PersArmorMinOrderByAggregateInput = {
    persArmorId?: SortOrder
    armorId?: SortOrder
    persId?: SortOrder
    overrideBaseAC?: SortOrder
    miscACBonus?: SortOrder
    isProficient?: SortOrder
    equipped?: SortOrder
  }

  export type PersArmorSumOrderByAggregateInput = {
    persArmorId?: SortOrder
    armorId?: SortOrder
    persId?: SortOrder
    overrideBaseAC?: SortOrder
    miscACBonus?: SortOrder
  }

  export type PersMagicItemCountOrderByAggregateInput = {
    persMagicItemId?: SortOrder
    persId?: SortOrder
    magicItemId?: SortOrder
  }

  export type PersMagicItemAvgOrderByAggregateInput = {
    persMagicItemId?: SortOrder
    persId?: SortOrder
    magicItemId?: SortOrder
  }

  export type PersMagicItemMaxOrderByAggregateInput = {
    persMagicItemId?: SortOrder
    persId?: SortOrder
    magicItemId?: SortOrder
  }

  export type PersMagicItemMinOrderByAggregateInput = {
    persMagicItemId?: SortOrder
    persId?: SortOrder
    magicItemId?: SortOrder
  }

  export type PersMagicItemSumOrderByAggregateInput = {
    persMagicItemId?: SortOrder
    persId?: SortOrder
    magicItemId?: SortOrder
  }

  export type EnumEquipmentPackCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentPackCategory | EnumEquipmentPackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentPackCategory[] | ListEnumEquipmentPackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentPackCategory[] | ListEnumEquipmentPackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentPackCategoryFilter<$PrismaModel> | $Enums.EquipmentPackCategory
  }

  export type EquipmentPackCountOrderByAggregateInput = {
    equipmentPackId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    items?: SortOrder
  }

  export type EquipmentPackAvgOrderByAggregateInput = {
    equipmentPackId?: SortOrder
  }

  export type EquipmentPackMaxOrderByAggregateInput = {
    equipmentPackId?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type EquipmentPackMinOrderByAggregateInput = {
    equipmentPackId?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type EquipmentPackSumOrderByAggregateInput = {
    equipmentPackId?: SortOrder
  }

  export type EnumEquipmentPackCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentPackCategory | EnumEquipmentPackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentPackCategory[] | ListEnumEquipmentPackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentPackCategory[] | ListEnumEquipmentPackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentPackCategoryWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentPackCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentPackCategoryFilter<$PrismaModel>
    _max?: NestedEnumEquipmentPackCategoryFilter<$PrismaModel>
  }

  export type EnumArmorTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ArmorType | EnumArmorTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumArmorTypeNullableFilter<$PrismaModel> | $Enums.ArmorType | null
  }

  export type EnumWeaponTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponType | EnumWeaponTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWeaponTypeNullableFilter<$PrismaModel> | $Enums.WeaponType | null
  }

  export type WeaponNullableScalarRelationFilter = {
    is?: WeaponWhereInput | null
    isNot?: WeaponWhereInput | null
  }

  export type ArmorNullableScalarRelationFilter = {
    is?: ArmorWhereInput | null
    isNot?: ArmorWhereInput | null
  }

  export type EquipmentPackNullableScalarRelationFilter = {
    is?: EquipmentPackWhereInput | null
    isNot?: EquipmentPackWhereInput | null
  }

  export type ClassStartingEquipmentOptionCountOrderByAggregateInput = {
    optionId?: SortOrder
    classId?: SortOrder
    choiceGroup?: SortOrder
    option?: SortOrder
    weaponId?: SortOrder
    armorId?: SortOrder
    equipmentPackId?: SortOrder
    quantity?: SortOrder
    chooseAnyArmor?: SortOrder
    armorType?: SortOrder
    chooseAnyWeapon?: SortOrder
    weaponType?: SortOrder
    weaponCount?: SortOrder
    description?: SortOrder
  }

  export type ClassStartingEquipmentOptionAvgOrderByAggregateInput = {
    optionId?: SortOrder
    classId?: SortOrder
    choiceGroup?: SortOrder
    weaponId?: SortOrder
    armorId?: SortOrder
    equipmentPackId?: SortOrder
    quantity?: SortOrder
    weaponCount?: SortOrder
  }

  export type ClassStartingEquipmentOptionMaxOrderByAggregateInput = {
    optionId?: SortOrder
    classId?: SortOrder
    choiceGroup?: SortOrder
    option?: SortOrder
    weaponId?: SortOrder
    armorId?: SortOrder
    equipmentPackId?: SortOrder
    quantity?: SortOrder
    chooseAnyArmor?: SortOrder
    armorType?: SortOrder
    chooseAnyWeapon?: SortOrder
    weaponType?: SortOrder
    weaponCount?: SortOrder
    description?: SortOrder
  }

  export type ClassStartingEquipmentOptionMinOrderByAggregateInput = {
    optionId?: SortOrder
    classId?: SortOrder
    choiceGroup?: SortOrder
    option?: SortOrder
    weaponId?: SortOrder
    armorId?: SortOrder
    equipmentPackId?: SortOrder
    quantity?: SortOrder
    chooseAnyArmor?: SortOrder
    armorType?: SortOrder
    chooseAnyWeapon?: SortOrder
    weaponType?: SortOrder
    weaponCount?: SortOrder
    description?: SortOrder
  }

  export type ClassStartingEquipmentOptionSumOrderByAggregateInput = {
    optionId?: SortOrder
    classId?: SortOrder
    choiceGroup?: SortOrder
    weaponId?: SortOrder
    armorId?: SortOrder
    equipmentPackId?: SortOrder
    quantity?: SortOrder
    weaponCount?: SortOrder
  }

  export type EnumArmorTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArmorType | EnumArmorTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumArmorTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ArmorType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumArmorTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumArmorTypeNullableFilter<$PrismaModel>
  }

  export type EnumWeaponTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponType | EnumWeaponTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWeaponTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.WeaponType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWeaponTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumWeaponTypeNullableFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutCharacterInput = {
    create?: XOR<UserCreateWithoutCharacterInput, UserUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharacterInput
    connect?: UserWhereUniqueInput
  }

  export type CharacterSpellsCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterSpellsCreateWithoutCharacterInput, CharacterSpellsUncheckedCreateWithoutCharacterInput> | CharacterSpellsCreateWithoutCharacterInput[] | CharacterSpellsUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSpellsCreateOrConnectWithoutCharacterInput | CharacterSpellsCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterSpellsCreateManyCharacterInputEnvelope
    connect?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
  }

  export type CharacterSpellsUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterSpellsCreateWithoutCharacterInput, CharacterSpellsUncheckedCreateWithoutCharacterInput> | CharacterSpellsCreateWithoutCharacterInput[] | CharacterSpellsUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSpellsCreateOrConnectWithoutCharacterInput | CharacterSpellsCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterSpellsCreateManyCharacterInputEnvelope
    connect?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneWithoutCharacterNestedInput = {
    create?: XOR<UserCreateWithoutCharacterInput, UserUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharacterInput
    upsert?: UserUpsertWithoutCharacterInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCharacterInput, UserUpdateWithoutCharacterInput>, UserUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterSpellsUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterSpellsCreateWithoutCharacterInput, CharacterSpellsUncheckedCreateWithoutCharacterInput> | CharacterSpellsCreateWithoutCharacterInput[] | CharacterSpellsUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSpellsCreateOrConnectWithoutCharacterInput | CharacterSpellsCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterSpellsUpsertWithWhereUniqueWithoutCharacterInput | CharacterSpellsUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterSpellsCreateManyCharacterInputEnvelope
    set?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    disconnect?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    delete?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    connect?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    update?: CharacterSpellsUpdateWithWhereUniqueWithoutCharacterInput | CharacterSpellsUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterSpellsUpdateManyWithWhereWithoutCharacterInput | CharacterSpellsUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterSpellsScalarWhereInput | CharacterSpellsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CharacterSpellsUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterSpellsCreateWithoutCharacterInput, CharacterSpellsUncheckedCreateWithoutCharacterInput> | CharacterSpellsCreateWithoutCharacterInput[] | CharacterSpellsUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSpellsCreateOrConnectWithoutCharacterInput | CharacterSpellsCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterSpellsUpsertWithWhereUniqueWithoutCharacterInput | CharacterSpellsUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterSpellsCreateManyCharacterInputEnvelope
    set?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    disconnect?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    delete?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    connect?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    update?: CharacterSpellsUpdateWithWhereUniqueWithoutCharacterInput | CharacterSpellsUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterSpellsUpdateManyWithWhereWithoutCharacterInput | CharacterSpellsUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterSpellsScalarWhereInput | CharacterSpellsScalarWhereInput[]
  }

  export type CharacterCreateNestedOneWithoutCharacterSpellsInput = {
    create?: XOR<CharacterCreateWithoutCharacterSpellsInput, CharacterUncheckedCreateWithoutCharacterSpellsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutCharacterSpellsInput
    connect?: CharacterWhereUniqueInput
  }

  export type SpellCreateNestedOneWithoutCharacterSpellsInput = {
    create?: XOR<SpellCreateWithoutCharacterSpellsInput, SpellUncheckedCreateWithoutCharacterSpellsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutCharacterSpellsInput
    connect?: SpellWhereUniqueInput
  }

  export type CharacterUpdateOneWithoutCharacterSpellsNestedInput = {
    create?: XOR<CharacterCreateWithoutCharacterSpellsInput, CharacterUncheckedCreateWithoutCharacterSpellsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutCharacterSpellsInput
    upsert?: CharacterUpsertWithoutCharacterSpellsInput
    disconnect?: CharacterWhereInput | boolean
    delete?: CharacterWhereInput | boolean
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutCharacterSpellsInput, CharacterUpdateWithoutCharacterSpellsInput>, CharacterUncheckedUpdateWithoutCharacterSpellsInput>
  }

  export type SpellUpdateOneWithoutCharacterSpellsNestedInput = {
    create?: XOR<SpellCreateWithoutCharacterSpellsInput, SpellUncheckedCreateWithoutCharacterSpellsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutCharacterSpellsInput
    upsert?: SpellUpsertWithoutCharacterSpellsInput
    disconnect?: SpellWhereInput | boolean
    delete?: SpellWhereInput | boolean
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutCharacterSpellsInput, SpellUpdateWithoutCharacterSpellsInput>, SpellUncheckedUpdateWithoutCharacterSpellsInput>
  }

  export type EnumSourceFieldUpdateOperationsInput = {
    set?: $Enums.Source
  }

  export type CharacterSpellsCreateNestedManyWithoutSpellInput = {
    create?: XOR<CharacterSpellsCreateWithoutSpellInput, CharacterSpellsUncheckedCreateWithoutSpellInput> | CharacterSpellsCreateWithoutSpellInput[] | CharacterSpellsUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: CharacterSpellsCreateOrConnectWithoutSpellInput | CharacterSpellsCreateOrConnectWithoutSpellInput[]
    createMany?: CharacterSpellsCreateManySpellInputEnvelope
    connect?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
  }

  export type SpellClassesCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellClassesCreateWithoutSpellInput, SpellClassesUncheckedCreateWithoutSpellInput> | SpellClassesCreateWithoutSpellInput[] | SpellClassesUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellClassesCreateOrConnectWithoutSpellInput | SpellClassesCreateOrConnectWithoutSpellInput[]
    createMany?: SpellClassesCreateManySpellInputEnvelope
    connect?: SpellClassesWhereUniqueInput | SpellClassesWhereUniqueInput[]
  }

  export type SpellRacesCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellRacesCreateWithoutSpellInput, SpellRacesUncheckedCreateWithoutSpellInput> | SpellRacesCreateWithoutSpellInput[] | SpellRacesUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellRacesCreateOrConnectWithoutSpellInput | SpellRacesCreateOrConnectWithoutSpellInput[]
    createMany?: SpellRacesCreateManySpellInputEnvelope
    connect?: SpellRacesWhereUniqueInput | SpellRacesWhereUniqueInput[]
  }

  export type SpellbookSpellsCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellbookSpellsCreateWithoutSpellInput, SpellbookSpellsUncheckedCreateWithoutSpellInput> | SpellbookSpellsCreateWithoutSpellInput[] | SpellbookSpellsUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellbookSpellsCreateOrConnectWithoutSpellInput | SpellbookSpellsCreateOrConnectWithoutSpellInput[]
    createMany?: SpellbookSpellsCreateManySpellInputEnvelope
    connect?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
  }

  export type SubclassCreateNestedManyWithoutExpandedSpellsInput = {
    create?: XOR<SubclassCreateWithoutExpandedSpellsInput, SubclassUncheckedCreateWithoutExpandedSpellsInput> | SubclassCreateWithoutExpandedSpellsInput[] | SubclassUncheckedCreateWithoutExpandedSpellsInput[]
    connectOrCreate?: SubclassCreateOrConnectWithoutExpandedSpellsInput | SubclassCreateOrConnectWithoutExpandedSpellsInput[]
    connect?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
  }

  export type PersCreateNestedManyWithoutSpellsInput = {
    create?: XOR<PersCreateWithoutSpellsInput, PersUncheckedCreateWithoutSpellsInput> | PersCreateWithoutSpellsInput[] | PersUncheckedCreateWithoutSpellsInput[]
    connectOrCreate?: PersCreateOrConnectWithoutSpellsInput | PersCreateOrConnectWithoutSpellsInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type FeatureCreateNestedManyWithoutGivesSpellsInput = {
    create?: XOR<FeatureCreateWithoutGivesSpellsInput, FeatureUncheckedCreateWithoutGivesSpellsInput> | FeatureCreateWithoutGivesSpellsInput[] | FeatureUncheckedCreateWithoutGivesSpellsInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutGivesSpellsInput | FeatureCreateOrConnectWithoutGivesSpellsInput[]
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
  }

  export type CharacterSpellsUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<CharacterSpellsCreateWithoutSpellInput, CharacterSpellsUncheckedCreateWithoutSpellInput> | CharacterSpellsCreateWithoutSpellInput[] | CharacterSpellsUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: CharacterSpellsCreateOrConnectWithoutSpellInput | CharacterSpellsCreateOrConnectWithoutSpellInput[]
    createMany?: CharacterSpellsCreateManySpellInputEnvelope
    connect?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
  }

  export type SpellClassesUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellClassesCreateWithoutSpellInput, SpellClassesUncheckedCreateWithoutSpellInput> | SpellClassesCreateWithoutSpellInput[] | SpellClassesUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellClassesCreateOrConnectWithoutSpellInput | SpellClassesCreateOrConnectWithoutSpellInput[]
    createMany?: SpellClassesCreateManySpellInputEnvelope
    connect?: SpellClassesWhereUniqueInput | SpellClassesWhereUniqueInput[]
  }

  export type SpellRacesUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellRacesCreateWithoutSpellInput, SpellRacesUncheckedCreateWithoutSpellInput> | SpellRacesCreateWithoutSpellInput[] | SpellRacesUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellRacesCreateOrConnectWithoutSpellInput | SpellRacesCreateOrConnectWithoutSpellInput[]
    createMany?: SpellRacesCreateManySpellInputEnvelope
    connect?: SpellRacesWhereUniqueInput | SpellRacesWhereUniqueInput[]
  }

  export type SpellbookSpellsUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellbookSpellsCreateWithoutSpellInput, SpellbookSpellsUncheckedCreateWithoutSpellInput> | SpellbookSpellsCreateWithoutSpellInput[] | SpellbookSpellsUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellbookSpellsCreateOrConnectWithoutSpellInput | SpellbookSpellsCreateOrConnectWithoutSpellInput[]
    createMany?: SpellbookSpellsCreateManySpellInputEnvelope
    connect?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
  }

  export type SubclassUncheckedCreateNestedManyWithoutExpandedSpellsInput = {
    create?: XOR<SubclassCreateWithoutExpandedSpellsInput, SubclassUncheckedCreateWithoutExpandedSpellsInput> | SubclassCreateWithoutExpandedSpellsInput[] | SubclassUncheckedCreateWithoutExpandedSpellsInput[]
    connectOrCreate?: SubclassCreateOrConnectWithoutExpandedSpellsInput | SubclassCreateOrConnectWithoutExpandedSpellsInput[]
    connect?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
  }

  export type PersUncheckedCreateNestedManyWithoutSpellsInput = {
    create?: XOR<PersCreateWithoutSpellsInput, PersUncheckedCreateWithoutSpellsInput> | PersCreateWithoutSpellsInput[] | PersUncheckedCreateWithoutSpellsInput[]
    connectOrCreate?: PersCreateOrConnectWithoutSpellsInput | PersCreateOrConnectWithoutSpellsInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type FeatureUncheckedCreateNestedManyWithoutGivesSpellsInput = {
    create?: XOR<FeatureCreateWithoutGivesSpellsInput, FeatureUncheckedCreateWithoutGivesSpellsInput> | FeatureCreateWithoutGivesSpellsInput[] | FeatureUncheckedCreateWithoutGivesSpellsInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutGivesSpellsInput | FeatureCreateOrConnectWithoutGivesSpellsInput[]
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type CharacterSpellsUpdateManyWithoutSpellNestedInput = {
    create?: XOR<CharacterSpellsCreateWithoutSpellInput, CharacterSpellsUncheckedCreateWithoutSpellInput> | CharacterSpellsCreateWithoutSpellInput[] | CharacterSpellsUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: CharacterSpellsCreateOrConnectWithoutSpellInput | CharacterSpellsCreateOrConnectWithoutSpellInput[]
    upsert?: CharacterSpellsUpsertWithWhereUniqueWithoutSpellInput | CharacterSpellsUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: CharacterSpellsCreateManySpellInputEnvelope
    set?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    disconnect?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    delete?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    connect?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    update?: CharacterSpellsUpdateWithWhereUniqueWithoutSpellInput | CharacterSpellsUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: CharacterSpellsUpdateManyWithWhereWithoutSpellInput | CharacterSpellsUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: CharacterSpellsScalarWhereInput | CharacterSpellsScalarWhereInput[]
  }

  export type SpellClassesUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellClassesCreateWithoutSpellInput, SpellClassesUncheckedCreateWithoutSpellInput> | SpellClassesCreateWithoutSpellInput[] | SpellClassesUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellClassesCreateOrConnectWithoutSpellInput | SpellClassesCreateOrConnectWithoutSpellInput[]
    upsert?: SpellClassesUpsertWithWhereUniqueWithoutSpellInput | SpellClassesUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellClassesCreateManySpellInputEnvelope
    set?: SpellClassesWhereUniqueInput | SpellClassesWhereUniqueInput[]
    disconnect?: SpellClassesWhereUniqueInput | SpellClassesWhereUniqueInput[]
    delete?: SpellClassesWhereUniqueInput | SpellClassesWhereUniqueInput[]
    connect?: SpellClassesWhereUniqueInput | SpellClassesWhereUniqueInput[]
    update?: SpellClassesUpdateWithWhereUniqueWithoutSpellInput | SpellClassesUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellClassesUpdateManyWithWhereWithoutSpellInput | SpellClassesUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellClassesScalarWhereInput | SpellClassesScalarWhereInput[]
  }

  export type SpellRacesUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellRacesCreateWithoutSpellInput, SpellRacesUncheckedCreateWithoutSpellInput> | SpellRacesCreateWithoutSpellInput[] | SpellRacesUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellRacesCreateOrConnectWithoutSpellInput | SpellRacesCreateOrConnectWithoutSpellInput[]
    upsert?: SpellRacesUpsertWithWhereUniqueWithoutSpellInput | SpellRacesUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellRacesCreateManySpellInputEnvelope
    set?: SpellRacesWhereUniqueInput | SpellRacesWhereUniqueInput[]
    disconnect?: SpellRacesWhereUniqueInput | SpellRacesWhereUniqueInput[]
    delete?: SpellRacesWhereUniqueInput | SpellRacesWhereUniqueInput[]
    connect?: SpellRacesWhereUniqueInput | SpellRacesWhereUniqueInput[]
    update?: SpellRacesUpdateWithWhereUniqueWithoutSpellInput | SpellRacesUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellRacesUpdateManyWithWhereWithoutSpellInput | SpellRacesUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellRacesScalarWhereInput | SpellRacesScalarWhereInput[]
  }

  export type SpellbookSpellsUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellbookSpellsCreateWithoutSpellInput, SpellbookSpellsUncheckedCreateWithoutSpellInput> | SpellbookSpellsCreateWithoutSpellInput[] | SpellbookSpellsUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellbookSpellsCreateOrConnectWithoutSpellInput | SpellbookSpellsCreateOrConnectWithoutSpellInput[]
    upsert?: SpellbookSpellsUpsertWithWhereUniqueWithoutSpellInput | SpellbookSpellsUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellbookSpellsCreateManySpellInputEnvelope
    set?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    disconnect?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    delete?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    connect?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    update?: SpellbookSpellsUpdateWithWhereUniqueWithoutSpellInput | SpellbookSpellsUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellbookSpellsUpdateManyWithWhereWithoutSpellInput | SpellbookSpellsUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellbookSpellsScalarWhereInput | SpellbookSpellsScalarWhereInput[]
  }

  export type SubclassUpdateManyWithoutExpandedSpellsNestedInput = {
    create?: XOR<SubclassCreateWithoutExpandedSpellsInput, SubclassUncheckedCreateWithoutExpandedSpellsInput> | SubclassCreateWithoutExpandedSpellsInput[] | SubclassUncheckedCreateWithoutExpandedSpellsInput[]
    connectOrCreate?: SubclassCreateOrConnectWithoutExpandedSpellsInput | SubclassCreateOrConnectWithoutExpandedSpellsInput[]
    upsert?: SubclassUpsertWithWhereUniqueWithoutExpandedSpellsInput | SubclassUpsertWithWhereUniqueWithoutExpandedSpellsInput[]
    set?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    disconnect?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    delete?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    connect?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    update?: SubclassUpdateWithWhereUniqueWithoutExpandedSpellsInput | SubclassUpdateWithWhereUniqueWithoutExpandedSpellsInput[]
    updateMany?: SubclassUpdateManyWithWhereWithoutExpandedSpellsInput | SubclassUpdateManyWithWhereWithoutExpandedSpellsInput[]
    deleteMany?: SubclassScalarWhereInput | SubclassScalarWhereInput[]
  }

  export type PersUpdateManyWithoutSpellsNestedInput = {
    create?: XOR<PersCreateWithoutSpellsInput, PersUncheckedCreateWithoutSpellsInput> | PersCreateWithoutSpellsInput[] | PersUncheckedCreateWithoutSpellsInput[]
    connectOrCreate?: PersCreateOrConnectWithoutSpellsInput | PersCreateOrConnectWithoutSpellsInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutSpellsInput | PersUpsertWithWhereUniqueWithoutSpellsInput[]
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutSpellsInput | PersUpdateWithWhereUniqueWithoutSpellsInput[]
    updateMany?: PersUpdateManyWithWhereWithoutSpellsInput | PersUpdateManyWithWhereWithoutSpellsInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type FeatureUpdateManyWithoutGivesSpellsNestedInput = {
    create?: XOR<FeatureCreateWithoutGivesSpellsInput, FeatureUncheckedCreateWithoutGivesSpellsInput> | FeatureCreateWithoutGivesSpellsInput[] | FeatureUncheckedCreateWithoutGivesSpellsInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutGivesSpellsInput | FeatureCreateOrConnectWithoutGivesSpellsInput[]
    upsert?: FeatureUpsertWithWhereUniqueWithoutGivesSpellsInput | FeatureUpsertWithWhereUniqueWithoutGivesSpellsInput[]
    set?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    disconnect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    delete?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    update?: FeatureUpdateWithWhereUniqueWithoutGivesSpellsInput | FeatureUpdateWithWhereUniqueWithoutGivesSpellsInput[]
    updateMany?: FeatureUpdateManyWithWhereWithoutGivesSpellsInput | FeatureUpdateManyWithWhereWithoutGivesSpellsInput[]
    deleteMany?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
  }

  export type CharacterSpellsUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<CharacterSpellsCreateWithoutSpellInput, CharacterSpellsUncheckedCreateWithoutSpellInput> | CharacterSpellsCreateWithoutSpellInput[] | CharacterSpellsUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: CharacterSpellsCreateOrConnectWithoutSpellInput | CharacterSpellsCreateOrConnectWithoutSpellInput[]
    upsert?: CharacterSpellsUpsertWithWhereUniqueWithoutSpellInput | CharacterSpellsUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: CharacterSpellsCreateManySpellInputEnvelope
    set?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    disconnect?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    delete?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    connect?: CharacterSpellsWhereUniqueInput | CharacterSpellsWhereUniqueInput[]
    update?: CharacterSpellsUpdateWithWhereUniqueWithoutSpellInput | CharacterSpellsUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: CharacterSpellsUpdateManyWithWhereWithoutSpellInput | CharacterSpellsUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: CharacterSpellsScalarWhereInput | CharacterSpellsScalarWhereInput[]
  }

  export type SpellClassesUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellClassesCreateWithoutSpellInput, SpellClassesUncheckedCreateWithoutSpellInput> | SpellClassesCreateWithoutSpellInput[] | SpellClassesUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellClassesCreateOrConnectWithoutSpellInput | SpellClassesCreateOrConnectWithoutSpellInput[]
    upsert?: SpellClassesUpsertWithWhereUniqueWithoutSpellInput | SpellClassesUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellClassesCreateManySpellInputEnvelope
    set?: SpellClassesWhereUniqueInput | SpellClassesWhereUniqueInput[]
    disconnect?: SpellClassesWhereUniqueInput | SpellClassesWhereUniqueInput[]
    delete?: SpellClassesWhereUniqueInput | SpellClassesWhereUniqueInput[]
    connect?: SpellClassesWhereUniqueInput | SpellClassesWhereUniqueInput[]
    update?: SpellClassesUpdateWithWhereUniqueWithoutSpellInput | SpellClassesUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellClassesUpdateManyWithWhereWithoutSpellInput | SpellClassesUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellClassesScalarWhereInput | SpellClassesScalarWhereInput[]
  }

  export type SpellRacesUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellRacesCreateWithoutSpellInput, SpellRacesUncheckedCreateWithoutSpellInput> | SpellRacesCreateWithoutSpellInput[] | SpellRacesUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellRacesCreateOrConnectWithoutSpellInput | SpellRacesCreateOrConnectWithoutSpellInput[]
    upsert?: SpellRacesUpsertWithWhereUniqueWithoutSpellInput | SpellRacesUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellRacesCreateManySpellInputEnvelope
    set?: SpellRacesWhereUniqueInput | SpellRacesWhereUniqueInput[]
    disconnect?: SpellRacesWhereUniqueInput | SpellRacesWhereUniqueInput[]
    delete?: SpellRacesWhereUniqueInput | SpellRacesWhereUniqueInput[]
    connect?: SpellRacesWhereUniqueInput | SpellRacesWhereUniqueInput[]
    update?: SpellRacesUpdateWithWhereUniqueWithoutSpellInput | SpellRacesUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellRacesUpdateManyWithWhereWithoutSpellInput | SpellRacesUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellRacesScalarWhereInput | SpellRacesScalarWhereInput[]
  }

  export type SpellbookSpellsUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellbookSpellsCreateWithoutSpellInput, SpellbookSpellsUncheckedCreateWithoutSpellInput> | SpellbookSpellsCreateWithoutSpellInput[] | SpellbookSpellsUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellbookSpellsCreateOrConnectWithoutSpellInput | SpellbookSpellsCreateOrConnectWithoutSpellInput[]
    upsert?: SpellbookSpellsUpsertWithWhereUniqueWithoutSpellInput | SpellbookSpellsUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellbookSpellsCreateManySpellInputEnvelope
    set?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    disconnect?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    delete?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    connect?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    update?: SpellbookSpellsUpdateWithWhereUniqueWithoutSpellInput | SpellbookSpellsUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellbookSpellsUpdateManyWithWhereWithoutSpellInput | SpellbookSpellsUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellbookSpellsScalarWhereInput | SpellbookSpellsScalarWhereInput[]
  }

  export type SubclassUncheckedUpdateManyWithoutExpandedSpellsNestedInput = {
    create?: XOR<SubclassCreateWithoutExpandedSpellsInput, SubclassUncheckedCreateWithoutExpandedSpellsInput> | SubclassCreateWithoutExpandedSpellsInput[] | SubclassUncheckedCreateWithoutExpandedSpellsInput[]
    connectOrCreate?: SubclassCreateOrConnectWithoutExpandedSpellsInput | SubclassCreateOrConnectWithoutExpandedSpellsInput[]
    upsert?: SubclassUpsertWithWhereUniqueWithoutExpandedSpellsInput | SubclassUpsertWithWhereUniqueWithoutExpandedSpellsInput[]
    set?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    disconnect?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    delete?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    connect?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    update?: SubclassUpdateWithWhereUniqueWithoutExpandedSpellsInput | SubclassUpdateWithWhereUniqueWithoutExpandedSpellsInput[]
    updateMany?: SubclassUpdateManyWithWhereWithoutExpandedSpellsInput | SubclassUpdateManyWithWhereWithoutExpandedSpellsInput[]
    deleteMany?: SubclassScalarWhereInput | SubclassScalarWhereInput[]
  }

  export type PersUncheckedUpdateManyWithoutSpellsNestedInput = {
    create?: XOR<PersCreateWithoutSpellsInput, PersUncheckedCreateWithoutSpellsInput> | PersCreateWithoutSpellsInput[] | PersUncheckedCreateWithoutSpellsInput[]
    connectOrCreate?: PersCreateOrConnectWithoutSpellsInput | PersCreateOrConnectWithoutSpellsInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutSpellsInput | PersUpsertWithWhereUniqueWithoutSpellsInput[]
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutSpellsInput | PersUpdateWithWhereUniqueWithoutSpellsInput[]
    updateMany?: PersUpdateManyWithWhereWithoutSpellsInput | PersUpdateManyWithWhereWithoutSpellsInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type FeatureUncheckedUpdateManyWithoutGivesSpellsNestedInput = {
    create?: XOR<FeatureCreateWithoutGivesSpellsInput, FeatureUncheckedCreateWithoutGivesSpellsInput> | FeatureCreateWithoutGivesSpellsInput[] | FeatureUncheckedCreateWithoutGivesSpellsInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutGivesSpellsInput | FeatureCreateOrConnectWithoutGivesSpellsInput[]
    upsert?: FeatureUpsertWithWhereUniqueWithoutGivesSpellsInput | FeatureUpsertWithWhereUniqueWithoutGivesSpellsInput[]
    set?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    disconnect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    delete?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    update?: FeatureUpdateWithWhereUniqueWithoutGivesSpellsInput | FeatureUpdateWithWhereUniqueWithoutGivesSpellsInput[]
    updateMany?: FeatureUpdateManyWithWhereWithoutGivesSpellsInput | FeatureUpdateManyWithWhereWithoutGivesSpellsInput[]
    deleteMany?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
  }

  export type SpellCreateNestedOneWithoutSpellClassesInput = {
    create?: XOR<SpellCreateWithoutSpellClassesInput, SpellUncheckedCreateWithoutSpellClassesInput>
    connectOrCreate?: SpellCreateOrConnectWithoutSpellClassesInput
    connect?: SpellWhereUniqueInput
  }

  export type SpellUpdateOneRequiredWithoutSpellClassesNestedInput = {
    create?: XOR<SpellCreateWithoutSpellClassesInput, SpellUncheckedCreateWithoutSpellClassesInput>
    connectOrCreate?: SpellCreateOrConnectWithoutSpellClassesInput
    upsert?: SpellUpsertWithoutSpellClassesInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutSpellClassesInput, SpellUpdateWithoutSpellClassesInput>, SpellUncheckedUpdateWithoutSpellClassesInput>
  }

  export type SpellCreateNestedOneWithoutSpellRacesInput = {
    create?: XOR<SpellCreateWithoutSpellRacesInput, SpellUncheckedCreateWithoutSpellRacesInput>
    connectOrCreate?: SpellCreateOrConnectWithoutSpellRacesInput
    connect?: SpellWhereUniqueInput
  }

  export type SpellUpdateOneWithoutSpellRacesNestedInput = {
    create?: XOR<SpellCreateWithoutSpellRacesInput, SpellUncheckedCreateWithoutSpellRacesInput>
    connectOrCreate?: SpellCreateOrConnectWithoutSpellRacesInput
    upsert?: SpellUpsertWithoutSpellRacesInput
    disconnect?: SpellWhereInput | boolean
    delete?: SpellWhereInput | boolean
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutSpellRacesInput, SpellUpdateWithoutSpellRacesInput>, SpellUncheckedUpdateWithoutSpellRacesInput>
  }

  export type UserCreateNestedOneWithoutSpellbookInput = {
    create?: XOR<UserCreateWithoutSpellbookInput, UserUncheckedCreateWithoutSpellbookInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpellbookInput
    connect?: UserWhereUniqueInput
  }

  export type SpellbookSpellsCreateNestedManyWithoutSpellbookInput = {
    create?: XOR<SpellbookSpellsCreateWithoutSpellbookInput, SpellbookSpellsUncheckedCreateWithoutSpellbookInput> | SpellbookSpellsCreateWithoutSpellbookInput[] | SpellbookSpellsUncheckedCreateWithoutSpellbookInput[]
    connectOrCreate?: SpellbookSpellsCreateOrConnectWithoutSpellbookInput | SpellbookSpellsCreateOrConnectWithoutSpellbookInput[]
    createMany?: SpellbookSpellsCreateManySpellbookInputEnvelope
    connect?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
  }

  export type SpellbookSpellsUncheckedCreateNestedManyWithoutSpellbookInput = {
    create?: XOR<SpellbookSpellsCreateWithoutSpellbookInput, SpellbookSpellsUncheckedCreateWithoutSpellbookInput> | SpellbookSpellsCreateWithoutSpellbookInput[] | SpellbookSpellsUncheckedCreateWithoutSpellbookInput[]
    connectOrCreate?: SpellbookSpellsCreateOrConnectWithoutSpellbookInput | SpellbookSpellsCreateOrConnectWithoutSpellbookInput[]
    createMany?: SpellbookSpellsCreateManySpellbookInputEnvelope
    connect?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutSpellbookNestedInput = {
    create?: XOR<UserCreateWithoutSpellbookInput, UserUncheckedCreateWithoutSpellbookInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpellbookInput
    upsert?: UserUpsertWithoutSpellbookInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSpellbookInput, UserUpdateWithoutSpellbookInput>, UserUncheckedUpdateWithoutSpellbookInput>
  }

  export type SpellbookSpellsUpdateManyWithoutSpellbookNestedInput = {
    create?: XOR<SpellbookSpellsCreateWithoutSpellbookInput, SpellbookSpellsUncheckedCreateWithoutSpellbookInput> | SpellbookSpellsCreateWithoutSpellbookInput[] | SpellbookSpellsUncheckedCreateWithoutSpellbookInput[]
    connectOrCreate?: SpellbookSpellsCreateOrConnectWithoutSpellbookInput | SpellbookSpellsCreateOrConnectWithoutSpellbookInput[]
    upsert?: SpellbookSpellsUpsertWithWhereUniqueWithoutSpellbookInput | SpellbookSpellsUpsertWithWhereUniqueWithoutSpellbookInput[]
    createMany?: SpellbookSpellsCreateManySpellbookInputEnvelope
    set?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    disconnect?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    delete?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    connect?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    update?: SpellbookSpellsUpdateWithWhereUniqueWithoutSpellbookInput | SpellbookSpellsUpdateWithWhereUniqueWithoutSpellbookInput[]
    updateMany?: SpellbookSpellsUpdateManyWithWhereWithoutSpellbookInput | SpellbookSpellsUpdateManyWithWhereWithoutSpellbookInput[]
    deleteMany?: SpellbookSpellsScalarWhereInput | SpellbookSpellsScalarWhereInput[]
  }

  export type SpellbookSpellsUncheckedUpdateManyWithoutSpellbookNestedInput = {
    create?: XOR<SpellbookSpellsCreateWithoutSpellbookInput, SpellbookSpellsUncheckedCreateWithoutSpellbookInput> | SpellbookSpellsCreateWithoutSpellbookInput[] | SpellbookSpellsUncheckedCreateWithoutSpellbookInput[]
    connectOrCreate?: SpellbookSpellsCreateOrConnectWithoutSpellbookInput | SpellbookSpellsCreateOrConnectWithoutSpellbookInput[]
    upsert?: SpellbookSpellsUpsertWithWhereUniqueWithoutSpellbookInput | SpellbookSpellsUpsertWithWhereUniqueWithoutSpellbookInput[]
    createMany?: SpellbookSpellsCreateManySpellbookInputEnvelope
    set?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    disconnect?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    delete?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    connect?: SpellbookSpellsWhereUniqueInput | SpellbookSpellsWhereUniqueInput[]
    update?: SpellbookSpellsUpdateWithWhereUniqueWithoutSpellbookInput | SpellbookSpellsUpdateWithWhereUniqueWithoutSpellbookInput[]
    updateMany?: SpellbookSpellsUpdateManyWithWhereWithoutSpellbookInput | SpellbookSpellsUpdateManyWithWhereWithoutSpellbookInput[]
    deleteMany?: SpellbookSpellsScalarWhereInput | SpellbookSpellsScalarWhereInput[]
  }

  export type SpellCreateNestedOneWithoutSpellbookSpellsInput = {
    create?: XOR<SpellCreateWithoutSpellbookSpellsInput, SpellUncheckedCreateWithoutSpellbookSpellsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutSpellbookSpellsInput
    connect?: SpellWhereUniqueInput
  }

  export type SpellbookCreateNestedOneWithoutSpellbookSpellsInput = {
    create?: XOR<SpellbookCreateWithoutSpellbookSpellsInput, SpellbookUncheckedCreateWithoutSpellbookSpellsInput>
    connectOrCreate?: SpellbookCreateOrConnectWithoutSpellbookSpellsInput
    connect?: SpellbookWhereUniqueInput
  }

  export type SpellUpdateOneWithoutSpellbookSpellsNestedInput = {
    create?: XOR<SpellCreateWithoutSpellbookSpellsInput, SpellUncheckedCreateWithoutSpellbookSpellsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutSpellbookSpellsInput
    upsert?: SpellUpsertWithoutSpellbookSpellsInput
    disconnect?: SpellWhereInput | boolean
    delete?: SpellWhereInput | boolean
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutSpellbookSpellsInput, SpellUpdateWithoutSpellbookSpellsInput>, SpellUncheckedUpdateWithoutSpellbookSpellsInput>
  }

  export type SpellbookUpdateOneWithoutSpellbookSpellsNestedInput = {
    create?: XOR<SpellbookCreateWithoutSpellbookSpellsInput, SpellbookUncheckedCreateWithoutSpellbookSpellsInput>
    connectOrCreate?: SpellbookCreateOrConnectWithoutSpellbookSpellsInput
    upsert?: SpellbookUpsertWithoutSpellbookSpellsInput
    disconnect?: SpellbookWhereInput | boolean
    delete?: SpellbookWhereInput | boolean
    connect?: SpellbookWhereUniqueInput
    update?: XOR<XOR<SpellbookUpdateToOneWithWhereWithoutSpellbookSpellsInput, SpellbookUpdateWithoutSpellbookSpellsInput>, SpellbookUncheckedUpdateWithoutSpellbookSpellsInput>
  }

  export type CharacterCreateNestedManyWithoutUserInput = {
    create?: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput> | CharacterCreateWithoutUserInput[] | CharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutUserInput | CharacterCreateOrConnectWithoutUserInput[]
    createMany?: CharacterCreateManyUserInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type SpellbookCreateNestedManyWithoutUserInput = {
    create?: XOR<SpellbookCreateWithoutUserInput, SpellbookUncheckedCreateWithoutUserInput> | SpellbookCreateWithoutUserInput[] | SpellbookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SpellbookCreateOrConnectWithoutUserInput | SpellbookCreateOrConnectWithoutUserInput[]
    createMany?: SpellbookCreateManyUserInputEnvelope
    connect?: SpellbookWhereUniqueInput | SpellbookWhereUniqueInput[]
  }

  export type PersCreateNestedManyWithoutUserInput = {
    create?: XOR<PersCreateWithoutUserInput, PersUncheckedCreateWithoutUserInput> | PersCreateWithoutUserInput[] | PersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersCreateOrConnectWithoutUserInput | PersCreateOrConnectWithoutUserInput[]
    createMany?: PersCreateManyUserInputEnvelope
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput> | CharacterCreateWithoutUserInput[] | CharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutUserInput | CharacterCreateOrConnectWithoutUserInput[]
    createMany?: CharacterCreateManyUserInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type SpellbookUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SpellbookCreateWithoutUserInput, SpellbookUncheckedCreateWithoutUserInput> | SpellbookCreateWithoutUserInput[] | SpellbookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SpellbookCreateOrConnectWithoutUserInput | SpellbookCreateOrConnectWithoutUserInput[]
    createMany?: SpellbookCreateManyUserInputEnvelope
    connect?: SpellbookWhereUniqueInput | SpellbookWhereUniqueInput[]
  }

  export type PersUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PersCreateWithoutUserInput, PersUncheckedCreateWithoutUserInput> | PersCreateWithoutUserInput[] | PersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersCreateOrConnectWithoutUserInput | PersCreateOrConnectWithoutUserInput[]
    createMany?: PersCreateManyUserInputEnvelope
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type CharacterUpdateManyWithoutUserNestedInput = {
    create?: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput> | CharacterCreateWithoutUserInput[] | CharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutUserInput | CharacterCreateOrConnectWithoutUserInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutUserInput | CharacterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CharacterCreateManyUserInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutUserInput | CharacterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutUserInput | CharacterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type SpellbookUpdateManyWithoutUserNestedInput = {
    create?: XOR<SpellbookCreateWithoutUserInput, SpellbookUncheckedCreateWithoutUserInput> | SpellbookCreateWithoutUserInput[] | SpellbookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SpellbookCreateOrConnectWithoutUserInput | SpellbookCreateOrConnectWithoutUserInput[]
    upsert?: SpellbookUpsertWithWhereUniqueWithoutUserInput | SpellbookUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SpellbookCreateManyUserInputEnvelope
    set?: SpellbookWhereUniqueInput | SpellbookWhereUniqueInput[]
    disconnect?: SpellbookWhereUniqueInput | SpellbookWhereUniqueInput[]
    delete?: SpellbookWhereUniqueInput | SpellbookWhereUniqueInput[]
    connect?: SpellbookWhereUniqueInput | SpellbookWhereUniqueInput[]
    update?: SpellbookUpdateWithWhereUniqueWithoutUserInput | SpellbookUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SpellbookUpdateManyWithWhereWithoutUserInput | SpellbookUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SpellbookScalarWhereInput | SpellbookScalarWhereInput[]
  }

  export type PersUpdateManyWithoutUserNestedInput = {
    create?: XOR<PersCreateWithoutUserInput, PersUncheckedCreateWithoutUserInput> | PersCreateWithoutUserInput[] | PersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersCreateOrConnectWithoutUserInput | PersCreateOrConnectWithoutUserInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutUserInput | PersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PersCreateManyUserInputEnvelope
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutUserInput | PersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PersUpdateManyWithWhereWithoutUserInput | PersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput> | CharacterCreateWithoutUserInput[] | CharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutUserInput | CharacterCreateOrConnectWithoutUserInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutUserInput | CharacterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CharacterCreateManyUserInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutUserInput | CharacterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutUserInput | CharacterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type SpellbookUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SpellbookCreateWithoutUserInput, SpellbookUncheckedCreateWithoutUserInput> | SpellbookCreateWithoutUserInput[] | SpellbookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SpellbookCreateOrConnectWithoutUserInput | SpellbookCreateOrConnectWithoutUserInput[]
    upsert?: SpellbookUpsertWithWhereUniqueWithoutUserInput | SpellbookUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SpellbookCreateManyUserInputEnvelope
    set?: SpellbookWhereUniqueInput | SpellbookWhereUniqueInput[]
    disconnect?: SpellbookWhereUniqueInput | SpellbookWhereUniqueInput[]
    delete?: SpellbookWhereUniqueInput | SpellbookWhereUniqueInput[]
    connect?: SpellbookWhereUniqueInput | SpellbookWhereUniqueInput[]
    update?: SpellbookUpdateWithWhereUniqueWithoutUserInput | SpellbookUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SpellbookUpdateManyWithWhereWithoutUserInput | SpellbookUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SpellbookScalarWhereInput | SpellbookScalarWhereInput[]
  }

  export type PersUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PersCreateWithoutUserInput, PersUncheckedCreateWithoutUserInput> | PersCreateWithoutUserInput[] | PersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersCreateOrConnectWithoutUserInput | PersCreateOrConnectWithoutUserInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutUserInput | PersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PersCreateManyUserInputEnvelope
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutUserInput | PersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PersUpdateManyWithWhereWithoutUserInput | PersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type ClassCreateabilityScoreUpLevelsInput = {
    set: number[]
  }

  export type ClassCreatearmorProficienciesInput = {
    set: $Enums.ArmorType[]
  }

  export type ClassCreateweaponProficienciesInput = {
    set: $Enums.WeaponType[]
  }

  export type ClassCreatesavingThrowsInput = {
    set: $Enums.Ability[]
  }

  export type ClassCreateskillProficienciesInput = {
    set: $Enums.Ability[]
  }

  export type ClassCreatetoolProficienciesInput = {
    set: $Enums.ToolCategory[]
  }

  export type ClassCreatelanguagesInput = {
    set: $Enums.Language[]
  }

  export type SubclassCreateNestedManyWithoutClassInput = {
    create?: XOR<SubclassCreateWithoutClassInput, SubclassUncheckedCreateWithoutClassInput> | SubclassCreateWithoutClassInput[] | SubclassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubclassCreateOrConnectWithoutClassInput | SubclassCreateOrConnectWithoutClassInput[]
    createMany?: SubclassCreateManyClassInputEnvelope
    connect?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
  }

  export type ClassFeatureCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassFeatureCreateWithoutClassInput, ClassFeatureUncheckedCreateWithoutClassInput> | ClassFeatureCreateWithoutClassInput[] | ClassFeatureUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassFeatureCreateOrConnectWithoutClassInput | ClassFeatureCreateOrConnectWithoutClassInput[]
    createMany?: ClassFeatureCreateManyClassInputEnvelope
    connect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
  }

  export type PersCreateNestedManyWithoutClassInput = {
    create?: XOR<PersCreateWithoutClassInput, PersUncheckedCreateWithoutClassInput> | PersCreateWithoutClassInput[] | PersUncheckedCreateWithoutClassInput[]
    connectOrCreate?: PersCreateOrConnectWithoutClassInput | PersCreateOrConnectWithoutClassInput[]
    createMany?: PersCreateManyClassInputEnvelope
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type PersMulticlassCreateNestedManyWithoutClassInput = {
    create?: XOR<PersMulticlassCreateWithoutClassInput, PersMulticlassUncheckedCreateWithoutClassInput> | PersMulticlassCreateWithoutClassInput[] | PersMulticlassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: PersMulticlassCreateOrConnectWithoutClassInput | PersMulticlassCreateOrConnectWithoutClassInput[]
    createMany?: PersMulticlassCreateManyClassInputEnvelope
    connect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
  }

  export type ClassStartingEquipmentOptionCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutClassInput, ClassStartingEquipmentOptionUncheckedCreateWithoutClassInput> | ClassStartingEquipmentOptionCreateWithoutClassInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutClassInput | ClassStartingEquipmentOptionCreateOrConnectWithoutClassInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyClassInputEnvelope
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
  }

  export type SubclassUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<SubclassCreateWithoutClassInput, SubclassUncheckedCreateWithoutClassInput> | SubclassCreateWithoutClassInput[] | SubclassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubclassCreateOrConnectWithoutClassInput | SubclassCreateOrConnectWithoutClassInput[]
    createMany?: SubclassCreateManyClassInputEnvelope
    connect?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
  }

  export type ClassFeatureUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassFeatureCreateWithoutClassInput, ClassFeatureUncheckedCreateWithoutClassInput> | ClassFeatureCreateWithoutClassInput[] | ClassFeatureUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassFeatureCreateOrConnectWithoutClassInput | ClassFeatureCreateOrConnectWithoutClassInput[]
    createMany?: ClassFeatureCreateManyClassInputEnvelope
    connect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
  }

  export type PersUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<PersCreateWithoutClassInput, PersUncheckedCreateWithoutClassInput> | PersCreateWithoutClassInput[] | PersUncheckedCreateWithoutClassInput[]
    connectOrCreate?: PersCreateOrConnectWithoutClassInput | PersCreateOrConnectWithoutClassInput[]
    createMany?: PersCreateManyClassInputEnvelope
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type PersMulticlassUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<PersMulticlassCreateWithoutClassInput, PersMulticlassUncheckedCreateWithoutClassInput> | PersMulticlassCreateWithoutClassInput[] | PersMulticlassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: PersMulticlassCreateOrConnectWithoutClassInput | PersMulticlassCreateOrConnectWithoutClassInput[]
    createMany?: PersMulticlassCreateManyClassInputEnvelope
    connect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
  }

  export type ClassStartingEquipmentOptionUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutClassInput, ClassStartingEquipmentOptionUncheckedCreateWithoutClassInput> | ClassStartingEquipmentOptionCreateWithoutClassInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutClassInput | ClassStartingEquipmentOptionCreateOrConnectWithoutClassInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyClassInputEnvelope
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
  }

  export type NullableEnumAbilityFieldUpdateOperationsInput = {
    set?: $Enums.Ability | null
  }

  export type EnumSpellcastingTypeFieldUpdateOperationsInput = {
    set?: $Enums.SpellcastingType
  }

  export type ClassUpdateabilityScoreUpLevelsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type ClassUpdatearmorProficienciesInput = {
    set?: $Enums.ArmorType[]
    push?: $Enums.ArmorType | $Enums.ArmorType[]
  }

  export type ClassUpdateweaponProficienciesInput = {
    set?: $Enums.WeaponType[]
    push?: $Enums.WeaponType | $Enums.WeaponType[]
  }

  export type ClassUpdatesavingThrowsInput = {
    set?: $Enums.Ability[]
    push?: $Enums.Ability | $Enums.Ability[]
  }

  export type ClassUpdateskillProficienciesInput = {
    set?: $Enums.Ability[]
    push?: $Enums.Ability | $Enums.Ability[]
  }

  export type ClassUpdatetoolProficienciesInput = {
    set?: $Enums.ToolCategory[]
    push?: $Enums.ToolCategory | $Enums.ToolCategory[]
  }

  export type ClassUpdatelanguagesInput = {
    set?: $Enums.Language[]
    push?: $Enums.Language | $Enums.Language[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SubclassUpdateManyWithoutClassNestedInput = {
    create?: XOR<SubclassCreateWithoutClassInput, SubclassUncheckedCreateWithoutClassInput> | SubclassCreateWithoutClassInput[] | SubclassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubclassCreateOrConnectWithoutClassInput | SubclassCreateOrConnectWithoutClassInput[]
    upsert?: SubclassUpsertWithWhereUniqueWithoutClassInput | SubclassUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SubclassCreateManyClassInputEnvelope
    set?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    disconnect?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    delete?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    connect?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    update?: SubclassUpdateWithWhereUniqueWithoutClassInput | SubclassUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SubclassUpdateManyWithWhereWithoutClassInput | SubclassUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SubclassScalarWhereInput | SubclassScalarWhereInput[]
  }

  export type ClassFeatureUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassFeatureCreateWithoutClassInput, ClassFeatureUncheckedCreateWithoutClassInput> | ClassFeatureCreateWithoutClassInput[] | ClassFeatureUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassFeatureCreateOrConnectWithoutClassInput | ClassFeatureCreateOrConnectWithoutClassInput[]
    upsert?: ClassFeatureUpsertWithWhereUniqueWithoutClassInput | ClassFeatureUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassFeatureCreateManyClassInputEnvelope
    set?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    disconnect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    delete?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    connect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    update?: ClassFeatureUpdateWithWhereUniqueWithoutClassInput | ClassFeatureUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassFeatureUpdateManyWithWhereWithoutClassInput | ClassFeatureUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassFeatureScalarWhereInput | ClassFeatureScalarWhereInput[]
  }

  export type PersUpdateManyWithoutClassNestedInput = {
    create?: XOR<PersCreateWithoutClassInput, PersUncheckedCreateWithoutClassInput> | PersCreateWithoutClassInput[] | PersUncheckedCreateWithoutClassInput[]
    connectOrCreate?: PersCreateOrConnectWithoutClassInput | PersCreateOrConnectWithoutClassInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutClassInput | PersUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: PersCreateManyClassInputEnvelope
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutClassInput | PersUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: PersUpdateManyWithWhereWithoutClassInput | PersUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type PersMulticlassUpdateManyWithoutClassNestedInput = {
    create?: XOR<PersMulticlassCreateWithoutClassInput, PersMulticlassUncheckedCreateWithoutClassInput> | PersMulticlassCreateWithoutClassInput[] | PersMulticlassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: PersMulticlassCreateOrConnectWithoutClassInput | PersMulticlassCreateOrConnectWithoutClassInput[]
    upsert?: PersMulticlassUpsertWithWhereUniqueWithoutClassInput | PersMulticlassUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: PersMulticlassCreateManyClassInputEnvelope
    set?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    disconnect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    delete?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    connect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    update?: PersMulticlassUpdateWithWhereUniqueWithoutClassInput | PersMulticlassUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: PersMulticlassUpdateManyWithWhereWithoutClassInput | PersMulticlassUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: PersMulticlassScalarWhereInput | PersMulticlassScalarWhereInput[]
  }

  export type ClassStartingEquipmentOptionUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutClassInput, ClassStartingEquipmentOptionUncheckedCreateWithoutClassInput> | ClassStartingEquipmentOptionCreateWithoutClassInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutClassInput | ClassStartingEquipmentOptionCreateOrConnectWithoutClassInput[]
    upsert?: ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutClassInput | ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyClassInputEnvelope
    set?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    disconnect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    delete?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    update?: ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutClassInput | ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassStartingEquipmentOptionUpdateManyWithWhereWithoutClassInput | ClassStartingEquipmentOptionUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassStartingEquipmentOptionScalarWhereInput | ClassStartingEquipmentOptionScalarWhereInput[]
  }

  export type SubclassUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<SubclassCreateWithoutClassInput, SubclassUncheckedCreateWithoutClassInput> | SubclassCreateWithoutClassInput[] | SubclassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SubclassCreateOrConnectWithoutClassInput | SubclassCreateOrConnectWithoutClassInput[]
    upsert?: SubclassUpsertWithWhereUniqueWithoutClassInput | SubclassUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SubclassCreateManyClassInputEnvelope
    set?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    disconnect?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    delete?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    connect?: SubclassWhereUniqueInput | SubclassWhereUniqueInput[]
    update?: SubclassUpdateWithWhereUniqueWithoutClassInput | SubclassUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SubclassUpdateManyWithWhereWithoutClassInput | SubclassUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SubclassScalarWhereInput | SubclassScalarWhereInput[]
  }

  export type ClassFeatureUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassFeatureCreateWithoutClassInput, ClassFeatureUncheckedCreateWithoutClassInput> | ClassFeatureCreateWithoutClassInput[] | ClassFeatureUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassFeatureCreateOrConnectWithoutClassInput | ClassFeatureCreateOrConnectWithoutClassInput[]
    upsert?: ClassFeatureUpsertWithWhereUniqueWithoutClassInput | ClassFeatureUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassFeatureCreateManyClassInputEnvelope
    set?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    disconnect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    delete?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    connect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    update?: ClassFeatureUpdateWithWhereUniqueWithoutClassInput | ClassFeatureUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassFeatureUpdateManyWithWhereWithoutClassInput | ClassFeatureUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassFeatureScalarWhereInput | ClassFeatureScalarWhereInput[]
  }

  export type PersUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<PersCreateWithoutClassInput, PersUncheckedCreateWithoutClassInput> | PersCreateWithoutClassInput[] | PersUncheckedCreateWithoutClassInput[]
    connectOrCreate?: PersCreateOrConnectWithoutClassInput | PersCreateOrConnectWithoutClassInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutClassInput | PersUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: PersCreateManyClassInputEnvelope
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutClassInput | PersUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: PersUpdateManyWithWhereWithoutClassInput | PersUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type PersMulticlassUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<PersMulticlassCreateWithoutClassInput, PersMulticlassUncheckedCreateWithoutClassInput> | PersMulticlassCreateWithoutClassInput[] | PersMulticlassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: PersMulticlassCreateOrConnectWithoutClassInput | PersMulticlassCreateOrConnectWithoutClassInput[]
    upsert?: PersMulticlassUpsertWithWhereUniqueWithoutClassInput | PersMulticlassUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: PersMulticlassCreateManyClassInputEnvelope
    set?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    disconnect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    delete?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    connect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    update?: PersMulticlassUpdateWithWhereUniqueWithoutClassInput | PersMulticlassUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: PersMulticlassUpdateManyWithWhereWithoutClassInput | PersMulticlassUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: PersMulticlassScalarWhereInput | PersMulticlassScalarWhereInput[]
  }

  export type ClassStartingEquipmentOptionUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutClassInput, ClassStartingEquipmentOptionUncheckedCreateWithoutClassInput> | ClassStartingEquipmentOptionCreateWithoutClassInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutClassInput | ClassStartingEquipmentOptionCreateOrConnectWithoutClassInput[]
    upsert?: ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutClassInput | ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyClassInputEnvelope
    set?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    disconnect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    delete?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    update?: ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutClassInput | ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassStartingEquipmentOptionUpdateManyWithWhereWithoutClassInput | ClassStartingEquipmentOptionUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassStartingEquipmentOptionScalarWhereInput | ClassStartingEquipmentOptionScalarWhereInput[]
  }

  export type SubclassCreatelanguagesInput = {
    set: $Enums.Language[]
  }

  export type SubclassCreatetoolProficienciesInput = {
    set: $Enums.ToolCategory[]
  }

  export type SpellCreateNestedManyWithoutSubclassesInput = {
    create?: XOR<SpellCreateWithoutSubclassesInput, SpellUncheckedCreateWithoutSubclassesInput> | SpellCreateWithoutSubclassesInput[] | SpellUncheckedCreateWithoutSubclassesInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutSubclassesInput | SpellCreateOrConnectWithoutSubclassesInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
  }

  export type ClassCreateNestedOneWithoutSubclassesInput = {
    create?: XOR<ClassCreateWithoutSubclassesInput, ClassUncheckedCreateWithoutSubclassesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSubclassesInput
    connect?: ClassWhereUniqueInput
  }

  export type SubclassFeatureCreateNestedManyWithoutSubclassInput = {
    create?: XOR<SubclassFeatureCreateWithoutSubclassInput, SubclassFeatureUncheckedCreateWithoutSubclassInput> | SubclassFeatureCreateWithoutSubclassInput[] | SubclassFeatureUncheckedCreateWithoutSubclassInput[]
    connectOrCreate?: SubclassFeatureCreateOrConnectWithoutSubclassInput | SubclassFeatureCreateOrConnectWithoutSubclassInput[]
    createMany?: SubclassFeatureCreateManySubclassInputEnvelope
    connect?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
  }

  export type PersCreateNestedManyWithoutSubclassInput = {
    create?: XOR<PersCreateWithoutSubclassInput, PersUncheckedCreateWithoutSubclassInput> | PersCreateWithoutSubclassInput[] | PersUncheckedCreateWithoutSubclassInput[]
    connectOrCreate?: PersCreateOrConnectWithoutSubclassInput | PersCreateOrConnectWithoutSubclassInput[]
    createMany?: PersCreateManySubclassInputEnvelope
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type PersMulticlassCreateNestedManyWithoutSubclassInput = {
    create?: XOR<PersMulticlassCreateWithoutSubclassInput, PersMulticlassUncheckedCreateWithoutSubclassInput> | PersMulticlassCreateWithoutSubclassInput[] | PersMulticlassUncheckedCreateWithoutSubclassInput[]
    connectOrCreate?: PersMulticlassCreateOrConnectWithoutSubclassInput | PersMulticlassCreateOrConnectWithoutSubclassInput[]
    createMany?: PersMulticlassCreateManySubclassInputEnvelope
    connect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
  }

  export type SpellUncheckedCreateNestedManyWithoutSubclassesInput = {
    create?: XOR<SpellCreateWithoutSubclassesInput, SpellUncheckedCreateWithoutSubclassesInput> | SpellCreateWithoutSubclassesInput[] | SpellUncheckedCreateWithoutSubclassesInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutSubclassesInput | SpellCreateOrConnectWithoutSubclassesInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
  }

  export type SubclassFeatureUncheckedCreateNestedManyWithoutSubclassInput = {
    create?: XOR<SubclassFeatureCreateWithoutSubclassInput, SubclassFeatureUncheckedCreateWithoutSubclassInput> | SubclassFeatureCreateWithoutSubclassInput[] | SubclassFeatureUncheckedCreateWithoutSubclassInput[]
    connectOrCreate?: SubclassFeatureCreateOrConnectWithoutSubclassInput | SubclassFeatureCreateOrConnectWithoutSubclassInput[]
    createMany?: SubclassFeatureCreateManySubclassInputEnvelope
    connect?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
  }

  export type PersUncheckedCreateNestedManyWithoutSubclassInput = {
    create?: XOR<PersCreateWithoutSubclassInput, PersUncheckedCreateWithoutSubclassInput> | PersCreateWithoutSubclassInput[] | PersUncheckedCreateWithoutSubclassInput[]
    connectOrCreate?: PersCreateOrConnectWithoutSubclassInput | PersCreateOrConnectWithoutSubclassInput[]
    createMany?: PersCreateManySubclassInputEnvelope
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type PersMulticlassUncheckedCreateNestedManyWithoutSubclassInput = {
    create?: XOR<PersMulticlassCreateWithoutSubclassInput, PersMulticlassUncheckedCreateWithoutSubclassInput> | PersMulticlassCreateWithoutSubclassInput[] | PersMulticlassUncheckedCreateWithoutSubclassInput[]
    connectOrCreate?: PersMulticlassCreateOrConnectWithoutSubclassInput | PersMulticlassCreateOrConnectWithoutSubclassInput[]
    createMany?: PersMulticlassCreateManySubclassInputEnvelope
    connect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SubclassUpdatelanguagesInput = {
    set?: $Enums.Language[]
    push?: $Enums.Language | $Enums.Language[]
  }

  export type SubclassUpdatetoolProficienciesInput = {
    set?: $Enums.ToolCategory[]
    push?: $Enums.ToolCategory | $Enums.ToolCategory[]
  }

  export type SpellUpdateManyWithoutSubclassesNestedInput = {
    create?: XOR<SpellCreateWithoutSubclassesInput, SpellUncheckedCreateWithoutSubclassesInput> | SpellCreateWithoutSubclassesInput[] | SpellUncheckedCreateWithoutSubclassesInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutSubclassesInput | SpellCreateOrConnectWithoutSubclassesInput[]
    upsert?: SpellUpsertWithWhereUniqueWithoutSubclassesInput | SpellUpsertWithWhereUniqueWithoutSubclassesInput[]
    set?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    disconnect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    delete?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    update?: SpellUpdateWithWhereUniqueWithoutSubclassesInput | SpellUpdateWithWhereUniqueWithoutSubclassesInput[]
    updateMany?: SpellUpdateManyWithWhereWithoutSubclassesInput | SpellUpdateManyWithWhereWithoutSubclassesInput[]
    deleteMany?: SpellScalarWhereInput | SpellScalarWhereInput[]
  }

  export type ClassUpdateOneRequiredWithoutSubclassesNestedInput = {
    create?: XOR<ClassCreateWithoutSubclassesInput, ClassUncheckedCreateWithoutSubclassesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSubclassesInput
    upsert?: ClassUpsertWithoutSubclassesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutSubclassesInput, ClassUpdateWithoutSubclassesInput>, ClassUncheckedUpdateWithoutSubclassesInput>
  }

  export type SubclassFeatureUpdateManyWithoutSubclassNestedInput = {
    create?: XOR<SubclassFeatureCreateWithoutSubclassInput, SubclassFeatureUncheckedCreateWithoutSubclassInput> | SubclassFeatureCreateWithoutSubclassInput[] | SubclassFeatureUncheckedCreateWithoutSubclassInput[]
    connectOrCreate?: SubclassFeatureCreateOrConnectWithoutSubclassInput | SubclassFeatureCreateOrConnectWithoutSubclassInput[]
    upsert?: SubclassFeatureUpsertWithWhereUniqueWithoutSubclassInput | SubclassFeatureUpsertWithWhereUniqueWithoutSubclassInput[]
    createMany?: SubclassFeatureCreateManySubclassInputEnvelope
    set?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    disconnect?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    delete?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    connect?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    update?: SubclassFeatureUpdateWithWhereUniqueWithoutSubclassInput | SubclassFeatureUpdateWithWhereUniqueWithoutSubclassInput[]
    updateMany?: SubclassFeatureUpdateManyWithWhereWithoutSubclassInput | SubclassFeatureUpdateManyWithWhereWithoutSubclassInput[]
    deleteMany?: SubclassFeatureScalarWhereInput | SubclassFeatureScalarWhereInput[]
  }

  export type PersUpdateManyWithoutSubclassNestedInput = {
    create?: XOR<PersCreateWithoutSubclassInput, PersUncheckedCreateWithoutSubclassInput> | PersCreateWithoutSubclassInput[] | PersUncheckedCreateWithoutSubclassInput[]
    connectOrCreate?: PersCreateOrConnectWithoutSubclassInput | PersCreateOrConnectWithoutSubclassInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutSubclassInput | PersUpsertWithWhereUniqueWithoutSubclassInput[]
    createMany?: PersCreateManySubclassInputEnvelope
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutSubclassInput | PersUpdateWithWhereUniqueWithoutSubclassInput[]
    updateMany?: PersUpdateManyWithWhereWithoutSubclassInput | PersUpdateManyWithWhereWithoutSubclassInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type PersMulticlassUpdateManyWithoutSubclassNestedInput = {
    create?: XOR<PersMulticlassCreateWithoutSubclassInput, PersMulticlassUncheckedCreateWithoutSubclassInput> | PersMulticlassCreateWithoutSubclassInput[] | PersMulticlassUncheckedCreateWithoutSubclassInput[]
    connectOrCreate?: PersMulticlassCreateOrConnectWithoutSubclassInput | PersMulticlassCreateOrConnectWithoutSubclassInput[]
    upsert?: PersMulticlassUpsertWithWhereUniqueWithoutSubclassInput | PersMulticlassUpsertWithWhereUniqueWithoutSubclassInput[]
    createMany?: PersMulticlassCreateManySubclassInputEnvelope
    set?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    disconnect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    delete?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    connect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    update?: PersMulticlassUpdateWithWhereUniqueWithoutSubclassInput | PersMulticlassUpdateWithWhereUniqueWithoutSubclassInput[]
    updateMany?: PersMulticlassUpdateManyWithWhereWithoutSubclassInput | PersMulticlassUpdateManyWithWhereWithoutSubclassInput[]
    deleteMany?: PersMulticlassScalarWhereInput | PersMulticlassScalarWhereInput[]
  }

  export type SpellUncheckedUpdateManyWithoutSubclassesNestedInput = {
    create?: XOR<SpellCreateWithoutSubclassesInput, SpellUncheckedCreateWithoutSubclassesInput> | SpellCreateWithoutSubclassesInput[] | SpellUncheckedCreateWithoutSubclassesInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutSubclassesInput | SpellCreateOrConnectWithoutSubclassesInput[]
    upsert?: SpellUpsertWithWhereUniqueWithoutSubclassesInput | SpellUpsertWithWhereUniqueWithoutSubclassesInput[]
    set?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    disconnect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    delete?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    update?: SpellUpdateWithWhereUniqueWithoutSubclassesInput | SpellUpdateWithWhereUniqueWithoutSubclassesInput[]
    updateMany?: SpellUpdateManyWithWhereWithoutSubclassesInput | SpellUpdateManyWithWhereWithoutSubclassesInput[]
    deleteMany?: SpellScalarWhereInput | SpellScalarWhereInput[]
  }

  export type SubclassFeatureUncheckedUpdateManyWithoutSubclassNestedInput = {
    create?: XOR<SubclassFeatureCreateWithoutSubclassInput, SubclassFeatureUncheckedCreateWithoutSubclassInput> | SubclassFeatureCreateWithoutSubclassInput[] | SubclassFeatureUncheckedCreateWithoutSubclassInput[]
    connectOrCreate?: SubclassFeatureCreateOrConnectWithoutSubclassInput | SubclassFeatureCreateOrConnectWithoutSubclassInput[]
    upsert?: SubclassFeatureUpsertWithWhereUniqueWithoutSubclassInput | SubclassFeatureUpsertWithWhereUniqueWithoutSubclassInput[]
    createMany?: SubclassFeatureCreateManySubclassInputEnvelope
    set?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    disconnect?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    delete?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    connect?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    update?: SubclassFeatureUpdateWithWhereUniqueWithoutSubclassInput | SubclassFeatureUpdateWithWhereUniqueWithoutSubclassInput[]
    updateMany?: SubclassFeatureUpdateManyWithWhereWithoutSubclassInput | SubclassFeatureUpdateManyWithWhereWithoutSubclassInput[]
    deleteMany?: SubclassFeatureScalarWhereInput | SubclassFeatureScalarWhereInput[]
  }

  export type PersUncheckedUpdateManyWithoutSubclassNestedInput = {
    create?: XOR<PersCreateWithoutSubclassInput, PersUncheckedCreateWithoutSubclassInput> | PersCreateWithoutSubclassInput[] | PersUncheckedCreateWithoutSubclassInput[]
    connectOrCreate?: PersCreateOrConnectWithoutSubclassInput | PersCreateOrConnectWithoutSubclassInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutSubclassInput | PersUpsertWithWhereUniqueWithoutSubclassInput[]
    createMany?: PersCreateManySubclassInputEnvelope
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutSubclassInput | PersUpdateWithWhereUniqueWithoutSubclassInput[]
    updateMany?: PersUpdateManyWithWhereWithoutSubclassInput | PersUpdateManyWithWhereWithoutSubclassInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type PersMulticlassUncheckedUpdateManyWithoutSubclassNestedInput = {
    create?: XOR<PersMulticlassCreateWithoutSubclassInput, PersMulticlassUncheckedCreateWithoutSubclassInput> | PersMulticlassCreateWithoutSubclassInput[] | PersMulticlassUncheckedCreateWithoutSubclassInput[]
    connectOrCreate?: PersMulticlassCreateOrConnectWithoutSubclassInput | PersMulticlassCreateOrConnectWithoutSubclassInput[]
    upsert?: PersMulticlassUpsertWithWhereUniqueWithoutSubclassInput | PersMulticlassUpsertWithWhereUniqueWithoutSubclassInput[]
    createMany?: PersMulticlassCreateManySubclassInputEnvelope
    set?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    disconnect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    delete?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    connect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    update?: PersMulticlassUpdateWithWhereUniqueWithoutSubclassInput | PersMulticlassUpdateWithWhereUniqueWithoutSubclassInput[]
    updateMany?: PersMulticlassUpdateManyWithWhereWithoutSubclassInput | PersMulticlassUpdateManyWithWhereWithoutSubclassInput[]
    deleteMany?: PersMulticlassScalarWhereInput | PersMulticlassScalarWhereInput[]
  }

  export type PersCreatecurrentSpellSlotsInput = {
    set: number[]
  }

  export type PersCreateadditionalSaveProficienciesInput = {
    set: $Enums.Ability[]
  }

  export type UserCreateNestedOneWithoutPersInput = {
    create?: XOR<UserCreateWithoutPersInput, UserUncheckedCreateWithoutPersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutPersesInput = {
    create?: XOR<ClassCreateWithoutPersesInput, ClassUncheckedCreateWithoutPersesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutPersesInput
    connect?: ClassWhereUniqueInput
  }

  export type SubclassCreateNestedOneWithoutPersesInput = {
    create?: XOR<SubclassCreateWithoutPersesInput, SubclassUncheckedCreateWithoutPersesInput>
    connectOrCreate?: SubclassCreateOrConnectWithoutPersesInput
    connect?: SubclassWhereUniqueInput
  }

  export type RaceCreateNestedOneWithoutPersesInput = {
    create?: XOR<RaceCreateWithoutPersesInput, RaceUncheckedCreateWithoutPersesInput>
    connectOrCreate?: RaceCreateOrConnectWithoutPersesInput
    connect?: RaceWhereUniqueInput
  }

  export type SubraceCreateNestedOneWithoutPersesInput = {
    create?: XOR<SubraceCreateWithoutPersesInput, SubraceUncheckedCreateWithoutPersesInput>
    connectOrCreate?: SubraceCreateOrConnectWithoutPersesInput
    connect?: SubraceWhereUniqueInput
  }

  export type BackgroundCreateNestedOneWithoutPersesInput = {
    create?: XOR<BackgroundCreateWithoutPersesInput, BackgroundUncheckedCreateWithoutPersesInput>
    connectOrCreate?: BackgroundCreateOrConnectWithoutPersesInput
    connect?: BackgroundWhereUniqueInput
  }

  export type PersSkillCreateNestedManyWithoutPersInput = {
    create?: XOR<PersSkillCreateWithoutPersInput, PersSkillUncheckedCreateWithoutPersInput> | PersSkillCreateWithoutPersInput[] | PersSkillUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersSkillCreateOrConnectWithoutPersInput | PersSkillCreateOrConnectWithoutPersInput[]
    createMany?: PersSkillCreateManyPersInputEnvelope
    connect?: PersSkillWhereUniqueInput | PersSkillWhereUniqueInput[]
  }

  export type PersMulticlassCreateNestedManyWithoutPersInput = {
    create?: XOR<PersMulticlassCreateWithoutPersInput, PersMulticlassUncheckedCreateWithoutPersInput> | PersMulticlassCreateWithoutPersInput[] | PersMulticlassUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersMulticlassCreateOrConnectWithoutPersInput | PersMulticlassCreateOrConnectWithoutPersInput[]
    createMany?: PersMulticlassCreateManyPersInputEnvelope
    connect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
  }

  export type PersFeatureCreateNestedManyWithoutPersInput = {
    create?: XOR<PersFeatureCreateWithoutPersInput, PersFeatureUncheckedCreateWithoutPersInput> | PersFeatureCreateWithoutPersInput[] | PersFeatureUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersFeatureCreateOrConnectWithoutPersInput | PersFeatureCreateOrConnectWithoutPersInput[]
    createMany?: PersFeatureCreateManyPersInputEnvelope
    connect?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
  }

  export type SpellCreateNestedManyWithoutPersesInput = {
    create?: XOR<SpellCreateWithoutPersesInput, SpellUncheckedCreateWithoutPersesInput> | SpellCreateWithoutPersesInput[] | SpellUncheckedCreateWithoutPersesInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutPersesInput | SpellCreateOrConnectWithoutPersesInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
  }

  export type PersFeatCreateNestedManyWithoutPersInput = {
    create?: XOR<PersFeatCreateWithoutPersInput, PersFeatUncheckedCreateWithoutPersInput> | PersFeatCreateWithoutPersInput[] | PersFeatUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersFeatCreateOrConnectWithoutPersInput | PersFeatCreateOrConnectWithoutPersInput[]
    createMany?: PersFeatCreateManyPersInputEnvelope
    connect?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
  }

  export type PersArmorCreateNestedManyWithoutPersInput = {
    create?: XOR<PersArmorCreateWithoutPersInput, PersArmorUncheckedCreateWithoutPersInput> | PersArmorCreateWithoutPersInput[] | PersArmorUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersArmorCreateOrConnectWithoutPersInput | PersArmorCreateOrConnectWithoutPersInput[]
    createMany?: PersArmorCreateManyPersInputEnvelope
    connect?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
  }

  export type PersWeaponCreateNestedManyWithoutPersInput = {
    create?: XOR<PersWeaponCreateWithoutPersInput, PersWeaponUncheckedCreateWithoutPersInput> | PersWeaponCreateWithoutPersInput[] | PersWeaponUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersWeaponCreateOrConnectWithoutPersInput | PersWeaponCreateOrConnectWithoutPersInput[]
    createMany?: PersWeaponCreateManyPersInputEnvelope
    connect?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
  }

  export type PersMagicItemCreateNestedManyWithoutPersInput = {
    create?: XOR<PersMagicItemCreateWithoutPersInput, PersMagicItemUncheckedCreateWithoutPersInput> | PersMagicItemCreateWithoutPersInput[] | PersMagicItemUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersMagicItemCreateOrConnectWithoutPersInput | PersMagicItemCreateOrConnectWithoutPersInput[]
    createMany?: PersMagicItemCreateManyPersInputEnvelope
    connect?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
  }

  export type RaceVariantCreateNestedManyWithoutPersesInput = {
    create?: XOR<RaceVariantCreateWithoutPersesInput, RaceVariantUncheckedCreateWithoutPersesInput> | RaceVariantCreateWithoutPersesInput[] | RaceVariantUncheckedCreateWithoutPersesInput[]
    connectOrCreate?: RaceVariantCreateOrConnectWithoutPersesInput | RaceVariantCreateOrConnectWithoutPersesInput[]
    connect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
  }

  export type RaceChoiceOptionCreateNestedManyWithoutPersesInput = {
    create?: XOR<RaceChoiceOptionCreateWithoutPersesInput, RaceChoiceOptionUncheckedCreateWithoutPersesInput> | RaceChoiceOptionCreateWithoutPersesInput[] | RaceChoiceOptionUncheckedCreateWithoutPersesInput[]
    connectOrCreate?: RaceChoiceOptionCreateOrConnectWithoutPersesInput | RaceChoiceOptionCreateOrConnectWithoutPersesInput[]
    connect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
  }

  export type PersSkillUncheckedCreateNestedManyWithoutPersInput = {
    create?: XOR<PersSkillCreateWithoutPersInput, PersSkillUncheckedCreateWithoutPersInput> | PersSkillCreateWithoutPersInput[] | PersSkillUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersSkillCreateOrConnectWithoutPersInput | PersSkillCreateOrConnectWithoutPersInput[]
    createMany?: PersSkillCreateManyPersInputEnvelope
    connect?: PersSkillWhereUniqueInput | PersSkillWhereUniqueInput[]
  }

  export type PersMulticlassUncheckedCreateNestedManyWithoutPersInput = {
    create?: XOR<PersMulticlassCreateWithoutPersInput, PersMulticlassUncheckedCreateWithoutPersInput> | PersMulticlassCreateWithoutPersInput[] | PersMulticlassUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersMulticlassCreateOrConnectWithoutPersInput | PersMulticlassCreateOrConnectWithoutPersInput[]
    createMany?: PersMulticlassCreateManyPersInputEnvelope
    connect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
  }

  export type PersFeatureUncheckedCreateNestedManyWithoutPersInput = {
    create?: XOR<PersFeatureCreateWithoutPersInput, PersFeatureUncheckedCreateWithoutPersInput> | PersFeatureCreateWithoutPersInput[] | PersFeatureUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersFeatureCreateOrConnectWithoutPersInput | PersFeatureCreateOrConnectWithoutPersInput[]
    createMany?: PersFeatureCreateManyPersInputEnvelope
    connect?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
  }

  export type SpellUncheckedCreateNestedManyWithoutPersesInput = {
    create?: XOR<SpellCreateWithoutPersesInput, SpellUncheckedCreateWithoutPersesInput> | SpellCreateWithoutPersesInput[] | SpellUncheckedCreateWithoutPersesInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutPersesInput | SpellCreateOrConnectWithoutPersesInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
  }

  export type PersFeatUncheckedCreateNestedManyWithoutPersInput = {
    create?: XOR<PersFeatCreateWithoutPersInput, PersFeatUncheckedCreateWithoutPersInput> | PersFeatCreateWithoutPersInput[] | PersFeatUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersFeatCreateOrConnectWithoutPersInput | PersFeatCreateOrConnectWithoutPersInput[]
    createMany?: PersFeatCreateManyPersInputEnvelope
    connect?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
  }

  export type PersArmorUncheckedCreateNestedManyWithoutPersInput = {
    create?: XOR<PersArmorCreateWithoutPersInput, PersArmorUncheckedCreateWithoutPersInput> | PersArmorCreateWithoutPersInput[] | PersArmorUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersArmorCreateOrConnectWithoutPersInput | PersArmorCreateOrConnectWithoutPersInput[]
    createMany?: PersArmorCreateManyPersInputEnvelope
    connect?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
  }

  export type PersWeaponUncheckedCreateNestedManyWithoutPersInput = {
    create?: XOR<PersWeaponCreateWithoutPersInput, PersWeaponUncheckedCreateWithoutPersInput> | PersWeaponCreateWithoutPersInput[] | PersWeaponUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersWeaponCreateOrConnectWithoutPersInput | PersWeaponCreateOrConnectWithoutPersInput[]
    createMany?: PersWeaponCreateManyPersInputEnvelope
    connect?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
  }

  export type PersMagicItemUncheckedCreateNestedManyWithoutPersInput = {
    create?: XOR<PersMagicItemCreateWithoutPersInput, PersMagicItemUncheckedCreateWithoutPersInput> | PersMagicItemCreateWithoutPersInput[] | PersMagicItemUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersMagicItemCreateOrConnectWithoutPersInput | PersMagicItemCreateOrConnectWithoutPersInput[]
    createMany?: PersMagicItemCreateManyPersInputEnvelope
    connect?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
  }

  export type RaceVariantUncheckedCreateNestedManyWithoutPersesInput = {
    create?: XOR<RaceVariantCreateWithoutPersesInput, RaceVariantUncheckedCreateWithoutPersesInput> | RaceVariantCreateWithoutPersesInput[] | RaceVariantUncheckedCreateWithoutPersesInput[]
    connectOrCreate?: RaceVariantCreateOrConnectWithoutPersesInput | RaceVariantCreateOrConnectWithoutPersesInput[]
    connect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
  }

  export type RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput = {
    create?: XOR<RaceChoiceOptionCreateWithoutPersesInput, RaceChoiceOptionUncheckedCreateWithoutPersesInput> | RaceChoiceOptionCreateWithoutPersesInput[] | RaceChoiceOptionUncheckedCreateWithoutPersesInput[]
    connectOrCreate?: RaceChoiceOptionCreateOrConnectWithoutPersesInput | RaceChoiceOptionCreateOrConnectWithoutPersesInput[]
    connect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
  }

  export type PersUpdatecurrentSpellSlotsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type PersUpdateadditionalSaveProficienciesInput = {
    set?: $Enums.Ability[]
    push?: $Enums.Ability | $Enums.Ability[]
  }

  export type UserUpdateOneRequiredWithoutPersNestedInput = {
    create?: XOR<UserCreateWithoutPersInput, UserUncheckedCreateWithoutPersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersInput
    upsert?: UserUpsertWithoutPersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPersInput, UserUpdateWithoutPersInput>, UserUncheckedUpdateWithoutPersInput>
  }

  export type ClassUpdateOneRequiredWithoutPersesNestedInput = {
    create?: XOR<ClassCreateWithoutPersesInput, ClassUncheckedCreateWithoutPersesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutPersesInput
    upsert?: ClassUpsertWithoutPersesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutPersesInput, ClassUpdateWithoutPersesInput>, ClassUncheckedUpdateWithoutPersesInput>
  }

  export type SubclassUpdateOneWithoutPersesNestedInput = {
    create?: XOR<SubclassCreateWithoutPersesInput, SubclassUncheckedCreateWithoutPersesInput>
    connectOrCreate?: SubclassCreateOrConnectWithoutPersesInput
    upsert?: SubclassUpsertWithoutPersesInput
    disconnect?: SubclassWhereInput | boolean
    delete?: SubclassWhereInput | boolean
    connect?: SubclassWhereUniqueInput
    update?: XOR<XOR<SubclassUpdateToOneWithWhereWithoutPersesInput, SubclassUpdateWithoutPersesInput>, SubclassUncheckedUpdateWithoutPersesInput>
  }

  export type RaceUpdateOneRequiredWithoutPersesNestedInput = {
    create?: XOR<RaceCreateWithoutPersesInput, RaceUncheckedCreateWithoutPersesInput>
    connectOrCreate?: RaceCreateOrConnectWithoutPersesInput
    upsert?: RaceUpsertWithoutPersesInput
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutPersesInput, RaceUpdateWithoutPersesInput>, RaceUncheckedUpdateWithoutPersesInput>
  }

  export type SubraceUpdateOneWithoutPersesNestedInput = {
    create?: XOR<SubraceCreateWithoutPersesInput, SubraceUncheckedCreateWithoutPersesInput>
    connectOrCreate?: SubraceCreateOrConnectWithoutPersesInput
    upsert?: SubraceUpsertWithoutPersesInput
    disconnect?: SubraceWhereInput | boolean
    delete?: SubraceWhereInput | boolean
    connect?: SubraceWhereUniqueInput
    update?: XOR<XOR<SubraceUpdateToOneWithWhereWithoutPersesInput, SubraceUpdateWithoutPersesInput>, SubraceUncheckedUpdateWithoutPersesInput>
  }

  export type BackgroundUpdateOneRequiredWithoutPersesNestedInput = {
    create?: XOR<BackgroundCreateWithoutPersesInput, BackgroundUncheckedCreateWithoutPersesInput>
    connectOrCreate?: BackgroundCreateOrConnectWithoutPersesInput
    upsert?: BackgroundUpsertWithoutPersesInput
    connect?: BackgroundWhereUniqueInput
    update?: XOR<XOR<BackgroundUpdateToOneWithWhereWithoutPersesInput, BackgroundUpdateWithoutPersesInput>, BackgroundUncheckedUpdateWithoutPersesInput>
  }

  export type PersSkillUpdateManyWithoutPersNestedInput = {
    create?: XOR<PersSkillCreateWithoutPersInput, PersSkillUncheckedCreateWithoutPersInput> | PersSkillCreateWithoutPersInput[] | PersSkillUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersSkillCreateOrConnectWithoutPersInput | PersSkillCreateOrConnectWithoutPersInput[]
    upsert?: PersSkillUpsertWithWhereUniqueWithoutPersInput | PersSkillUpsertWithWhereUniqueWithoutPersInput[]
    createMany?: PersSkillCreateManyPersInputEnvelope
    set?: PersSkillWhereUniqueInput | PersSkillWhereUniqueInput[]
    disconnect?: PersSkillWhereUniqueInput | PersSkillWhereUniqueInput[]
    delete?: PersSkillWhereUniqueInput | PersSkillWhereUniqueInput[]
    connect?: PersSkillWhereUniqueInput | PersSkillWhereUniqueInput[]
    update?: PersSkillUpdateWithWhereUniqueWithoutPersInput | PersSkillUpdateWithWhereUniqueWithoutPersInput[]
    updateMany?: PersSkillUpdateManyWithWhereWithoutPersInput | PersSkillUpdateManyWithWhereWithoutPersInput[]
    deleteMany?: PersSkillScalarWhereInput | PersSkillScalarWhereInput[]
  }

  export type PersMulticlassUpdateManyWithoutPersNestedInput = {
    create?: XOR<PersMulticlassCreateWithoutPersInput, PersMulticlassUncheckedCreateWithoutPersInput> | PersMulticlassCreateWithoutPersInput[] | PersMulticlassUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersMulticlassCreateOrConnectWithoutPersInput | PersMulticlassCreateOrConnectWithoutPersInput[]
    upsert?: PersMulticlassUpsertWithWhereUniqueWithoutPersInput | PersMulticlassUpsertWithWhereUniqueWithoutPersInput[]
    createMany?: PersMulticlassCreateManyPersInputEnvelope
    set?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    disconnect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    delete?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    connect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    update?: PersMulticlassUpdateWithWhereUniqueWithoutPersInput | PersMulticlassUpdateWithWhereUniqueWithoutPersInput[]
    updateMany?: PersMulticlassUpdateManyWithWhereWithoutPersInput | PersMulticlassUpdateManyWithWhereWithoutPersInput[]
    deleteMany?: PersMulticlassScalarWhereInput | PersMulticlassScalarWhereInput[]
  }

  export type PersFeatureUpdateManyWithoutPersNestedInput = {
    create?: XOR<PersFeatureCreateWithoutPersInput, PersFeatureUncheckedCreateWithoutPersInput> | PersFeatureCreateWithoutPersInput[] | PersFeatureUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersFeatureCreateOrConnectWithoutPersInput | PersFeatureCreateOrConnectWithoutPersInput[]
    upsert?: PersFeatureUpsertWithWhereUniqueWithoutPersInput | PersFeatureUpsertWithWhereUniqueWithoutPersInput[]
    createMany?: PersFeatureCreateManyPersInputEnvelope
    set?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    disconnect?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    delete?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    connect?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    update?: PersFeatureUpdateWithWhereUniqueWithoutPersInput | PersFeatureUpdateWithWhereUniqueWithoutPersInput[]
    updateMany?: PersFeatureUpdateManyWithWhereWithoutPersInput | PersFeatureUpdateManyWithWhereWithoutPersInput[]
    deleteMany?: PersFeatureScalarWhereInput | PersFeatureScalarWhereInput[]
  }

  export type SpellUpdateManyWithoutPersesNestedInput = {
    create?: XOR<SpellCreateWithoutPersesInput, SpellUncheckedCreateWithoutPersesInput> | SpellCreateWithoutPersesInput[] | SpellUncheckedCreateWithoutPersesInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutPersesInput | SpellCreateOrConnectWithoutPersesInput[]
    upsert?: SpellUpsertWithWhereUniqueWithoutPersesInput | SpellUpsertWithWhereUniqueWithoutPersesInput[]
    set?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    disconnect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    delete?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    update?: SpellUpdateWithWhereUniqueWithoutPersesInput | SpellUpdateWithWhereUniqueWithoutPersesInput[]
    updateMany?: SpellUpdateManyWithWhereWithoutPersesInput | SpellUpdateManyWithWhereWithoutPersesInput[]
    deleteMany?: SpellScalarWhereInput | SpellScalarWhereInput[]
  }

  export type PersFeatUpdateManyWithoutPersNestedInput = {
    create?: XOR<PersFeatCreateWithoutPersInput, PersFeatUncheckedCreateWithoutPersInput> | PersFeatCreateWithoutPersInput[] | PersFeatUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersFeatCreateOrConnectWithoutPersInput | PersFeatCreateOrConnectWithoutPersInput[]
    upsert?: PersFeatUpsertWithWhereUniqueWithoutPersInput | PersFeatUpsertWithWhereUniqueWithoutPersInput[]
    createMany?: PersFeatCreateManyPersInputEnvelope
    set?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    disconnect?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    delete?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    connect?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    update?: PersFeatUpdateWithWhereUniqueWithoutPersInput | PersFeatUpdateWithWhereUniqueWithoutPersInput[]
    updateMany?: PersFeatUpdateManyWithWhereWithoutPersInput | PersFeatUpdateManyWithWhereWithoutPersInput[]
    deleteMany?: PersFeatScalarWhereInput | PersFeatScalarWhereInput[]
  }

  export type PersArmorUpdateManyWithoutPersNestedInput = {
    create?: XOR<PersArmorCreateWithoutPersInput, PersArmorUncheckedCreateWithoutPersInput> | PersArmorCreateWithoutPersInput[] | PersArmorUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersArmorCreateOrConnectWithoutPersInput | PersArmorCreateOrConnectWithoutPersInput[]
    upsert?: PersArmorUpsertWithWhereUniqueWithoutPersInput | PersArmorUpsertWithWhereUniqueWithoutPersInput[]
    createMany?: PersArmorCreateManyPersInputEnvelope
    set?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    disconnect?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    delete?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    connect?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    update?: PersArmorUpdateWithWhereUniqueWithoutPersInput | PersArmorUpdateWithWhereUniqueWithoutPersInput[]
    updateMany?: PersArmorUpdateManyWithWhereWithoutPersInput | PersArmorUpdateManyWithWhereWithoutPersInput[]
    deleteMany?: PersArmorScalarWhereInput | PersArmorScalarWhereInput[]
  }

  export type PersWeaponUpdateManyWithoutPersNestedInput = {
    create?: XOR<PersWeaponCreateWithoutPersInput, PersWeaponUncheckedCreateWithoutPersInput> | PersWeaponCreateWithoutPersInput[] | PersWeaponUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersWeaponCreateOrConnectWithoutPersInput | PersWeaponCreateOrConnectWithoutPersInput[]
    upsert?: PersWeaponUpsertWithWhereUniqueWithoutPersInput | PersWeaponUpsertWithWhereUniqueWithoutPersInput[]
    createMany?: PersWeaponCreateManyPersInputEnvelope
    set?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    disconnect?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    delete?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    connect?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    update?: PersWeaponUpdateWithWhereUniqueWithoutPersInput | PersWeaponUpdateWithWhereUniqueWithoutPersInput[]
    updateMany?: PersWeaponUpdateManyWithWhereWithoutPersInput | PersWeaponUpdateManyWithWhereWithoutPersInput[]
    deleteMany?: PersWeaponScalarWhereInput | PersWeaponScalarWhereInput[]
  }

  export type PersMagicItemUpdateManyWithoutPersNestedInput = {
    create?: XOR<PersMagicItemCreateWithoutPersInput, PersMagicItemUncheckedCreateWithoutPersInput> | PersMagicItemCreateWithoutPersInput[] | PersMagicItemUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersMagicItemCreateOrConnectWithoutPersInput | PersMagicItemCreateOrConnectWithoutPersInput[]
    upsert?: PersMagicItemUpsertWithWhereUniqueWithoutPersInput | PersMagicItemUpsertWithWhereUniqueWithoutPersInput[]
    createMany?: PersMagicItemCreateManyPersInputEnvelope
    set?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    disconnect?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    delete?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    connect?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    update?: PersMagicItemUpdateWithWhereUniqueWithoutPersInput | PersMagicItemUpdateWithWhereUniqueWithoutPersInput[]
    updateMany?: PersMagicItemUpdateManyWithWhereWithoutPersInput | PersMagicItemUpdateManyWithWhereWithoutPersInput[]
    deleteMany?: PersMagicItemScalarWhereInput | PersMagicItemScalarWhereInput[]
  }

  export type RaceVariantUpdateManyWithoutPersesNestedInput = {
    create?: XOR<RaceVariantCreateWithoutPersesInput, RaceVariantUncheckedCreateWithoutPersesInput> | RaceVariantCreateWithoutPersesInput[] | RaceVariantUncheckedCreateWithoutPersesInput[]
    connectOrCreate?: RaceVariantCreateOrConnectWithoutPersesInput | RaceVariantCreateOrConnectWithoutPersesInput[]
    upsert?: RaceVariantUpsertWithWhereUniqueWithoutPersesInput | RaceVariantUpsertWithWhereUniqueWithoutPersesInput[]
    set?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    disconnect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    delete?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    connect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    update?: RaceVariantUpdateWithWhereUniqueWithoutPersesInput | RaceVariantUpdateWithWhereUniqueWithoutPersesInput[]
    updateMany?: RaceVariantUpdateManyWithWhereWithoutPersesInput | RaceVariantUpdateManyWithWhereWithoutPersesInput[]
    deleteMany?: RaceVariantScalarWhereInput | RaceVariantScalarWhereInput[]
  }

  export type RaceChoiceOptionUpdateManyWithoutPersesNestedInput = {
    create?: XOR<RaceChoiceOptionCreateWithoutPersesInput, RaceChoiceOptionUncheckedCreateWithoutPersesInput> | RaceChoiceOptionCreateWithoutPersesInput[] | RaceChoiceOptionUncheckedCreateWithoutPersesInput[]
    connectOrCreate?: RaceChoiceOptionCreateOrConnectWithoutPersesInput | RaceChoiceOptionCreateOrConnectWithoutPersesInput[]
    upsert?: RaceChoiceOptionUpsertWithWhereUniqueWithoutPersesInput | RaceChoiceOptionUpsertWithWhereUniqueWithoutPersesInput[]
    set?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    disconnect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    delete?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    connect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    update?: RaceChoiceOptionUpdateWithWhereUniqueWithoutPersesInput | RaceChoiceOptionUpdateWithWhereUniqueWithoutPersesInput[]
    updateMany?: RaceChoiceOptionUpdateManyWithWhereWithoutPersesInput | RaceChoiceOptionUpdateManyWithWhereWithoutPersesInput[]
    deleteMany?: RaceChoiceOptionScalarWhereInput | RaceChoiceOptionScalarWhereInput[]
  }

  export type PersSkillUncheckedUpdateManyWithoutPersNestedInput = {
    create?: XOR<PersSkillCreateWithoutPersInput, PersSkillUncheckedCreateWithoutPersInput> | PersSkillCreateWithoutPersInput[] | PersSkillUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersSkillCreateOrConnectWithoutPersInput | PersSkillCreateOrConnectWithoutPersInput[]
    upsert?: PersSkillUpsertWithWhereUniqueWithoutPersInput | PersSkillUpsertWithWhereUniqueWithoutPersInput[]
    createMany?: PersSkillCreateManyPersInputEnvelope
    set?: PersSkillWhereUniqueInput | PersSkillWhereUniqueInput[]
    disconnect?: PersSkillWhereUniqueInput | PersSkillWhereUniqueInput[]
    delete?: PersSkillWhereUniqueInput | PersSkillWhereUniqueInput[]
    connect?: PersSkillWhereUniqueInput | PersSkillWhereUniqueInput[]
    update?: PersSkillUpdateWithWhereUniqueWithoutPersInput | PersSkillUpdateWithWhereUniqueWithoutPersInput[]
    updateMany?: PersSkillUpdateManyWithWhereWithoutPersInput | PersSkillUpdateManyWithWhereWithoutPersInput[]
    deleteMany?: PersSkillScalarWhereInput | PersSkillScalarWhereInput[]
  }

  export type PersMulticlassUncheckedUpdateManyWithoutPersNestedInput = {
    create?: XOR<PersMulticlassCreateWithoutPersInput, PersMulticlassUncheckedCreateWithoutPersInput> | PersMulticlassCreateWithoutPersInput[] | PersMulticlassUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersMulticlassCreateOrConnectWithoutPersInput | PersMulticlassCreateOrConnectWithoutPersInput[]
    upsert?: PersMulticlassUpsertWithWhereUniqueWithoutPersInput | PersMulticlassUpsertWithWhereUniqueWithoutPersInput[]
    createMany?: PersMulticlassCreateManyPersInputEnvelope
    set?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    disconnect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    delete?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    connect?: PersMulticlassWhereUniqueInput | PersMulticlassWhereUniqueInput[]
    update?: PersMulticlassUpdateWithWhereUniqueWithoutPersInput | PersMulticlassUpdateWithWhereUniqueWithoutPersInput[]
    updateMany?: PersMulticlassUpdateManyWithWhereWithoutPersInput | PersMulticlassUpdateManyWithWhereWithoutPersInput[]
    deleteMany?: PersMulticlassScalarWhereInput | PersMulticlassScalarWhereInput[]
  }

  export type PersFeatureUncheckedUpdateManyWithoutPersNestedInput = {
    create?: XOR<PersFeatureCreateWithoutPersInput, PersFeatureUncheckedCreateWithoutPersInput> | PersFeatureCreateWithoutPersInput[] | PersFeatureUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersFeatureCreateOrConnectWithoutPersInput | PersFeatureCreateOrConnectWithoutPersInput[]
    upsert?: PersFeatureUpsertWithWhereUniqueWithoutPersInput | PersFeatureUpsertWithWhereUniqueWithoutPersInput[]
    createMany?: PersFeatureCreateManyPersInputEnvelope
    set?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    disconnect?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    delete?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    connect?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    update?: PersFeatureUpdateWithWhereUniqueWithoutPersInput | PersFeatureUpdateWithWhereUniqueWithoutPersInput[]
    updateMany?: PersFeatureUpdateManyWithWhereWithoutPersInput | PersFeatureUpdateManyWithWhereWithoutPersInput[]
    deleteMany?: PersFeatureScalarWhereInput | PersFeatureScalarWhereInput[]
  }

  export type SpellUncheckedUpdateManyWithoutPersesNestedInput = {
    create?: XOR<SpellCreateWithoutPersesInput, SpellUncheckedCreateWithoutPersesInput> | SpellCreateWithoutPersesInput[] | SpellUncheckedCreateWithoutPersesInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutPersesInput | SpellCreateOrConnectWithoutPersesInput[]
    upsert?: SpellUpsertWithWhereUniqueWithoutPersesInput | SpellUpsertWithWhereUniqueWithoutPersesInput[]
    set?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    disconnect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    delete?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    update?: SpellUpdateWithWhereUniqueWithoutPersesInput | SpellUpdateWithWhereUniqueWithoutPersesInput[]
    updateMany?: SpellUpdateManyWithWhereWithoutPersesInput | SpellUpdateManyWithWhereWithoutPersesInput[]
    deleteMany?: SpellScalarWhereInput | SpellScalarWhereInput[]
  }

  export type PersFeatUncheckedUpdateManyWithoutPersNestedInput = {
    create?: XOR<PersFeatCreateWithoutPersInput, PersFeatUncheckedCreateWithoutPersInput> | PersFeatCreateWithoutPersInput[] | PersFeatUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersFeatCreateOrConnectWithoutPersInput | PersFeatCreateOrConnectWithoutPersInput[]
    upsert?: PersFeatUpsertWithWhereUniqueWithoutPersInput | PersFeatUpsertWithWhereUniqueWithoutPersInput[]
    createMany?: PersFeatCreateManyPersInputEnvelope
    set?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    disconnect?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    delete?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    connect?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    update?: PersFeatUpdateWithWhereUniqueWithoutPersInput | PersFeatUpdateWithWhereUniqueWithoutPersInput[]
    updateMany?: PersFeatUpdateManyWithWhereWithoutPersInput | PersFeatUpdateManyWithWhereWithoutPersInput[]
    deleteMany?: PersFeatScalarWhereInput | PersFeatScalarWhereInput[]
  }

  export type PersArmorUncheckedUpdateManyWithoutPersNestedInput = {
    create?: XOR<PersArmorCreateWithoutPersInput, PersArmorUncheckedCreateWithoutPersInput> | PersArmorCreateWithoutPersInput[] | PersArmorUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersArmorCreateOrConnectWithoutPersInput | PersArmorCreateOrConnectWithoutPersInput[]
    upsert?: PersArmorUpsertWithWhereUniqueWithoutPersInput | PersArmorUpsertWithWhereUniqueWithoutPersInput[]
    createMany?: PersArmorCreateManyPersInputEnvelope
    set?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    disconnect?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    delete?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    connect?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    update?: PersArmorUpdateWithWhereUniqueWithoutPersInput | PersArmorUpdateWithWhereUniqueWithoutPersInput[]
    updateMany?: PersArmorUpdateManyWithWhereWithoutPersInput | PersArmorUpdateManyWithWhereWithoutPersInput[]
    deleteMany?: PersArmorScalarWhereInput | PersArmorScalarWhereInput[]
  }

  export type PersWeaponUncheckedUpdateManyWithoutPersNestedInput = {
    create?: XOR<PersWeaponCreateWithoutPersInput, PersWeaponUncheckedCreateWithoutPersInput> | PersWeaponCreateWithoutPersInput[] | PersWeaponUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersWeaponCreateOrConnectWithoutPersInput | PersWeaponCreateOrConnectWithoutPersInput[]
    upsert?: PersWeaponUpsertWithWhereUniqueWithoutPersInput | PersWeaponUpsertWithWhereUniqueWithoutPersInput[]
    createMany?: PersWeaponCreateManyPersInputEnvelope
    set?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    disconnect?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    delete?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    connect?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    update?: PersWeaponUpdateWithWhereUniqueWithoutPersInput | PersWeaponUpdateWithWhereUniqueWithoutPersInput[]
    updateMany?: PersWeaponUpdateManyWithWhereWithoutPersInput | PersWeaponUpdateManyWithWhereWithoutPersInput[]
    deleteMany?: PersWeaponScalarWhereInput | PersWeaponScalarWhereInput[]
  }

  export type PersMagicItemUncheckedUpdateManyWithoutPersNestedInput = {
    create?: XOR<PersMagicItemCreateWithoutPersInput, PersMagicItemUncheckedCreateWithoutPersInput> | PersMagicItemCreateWithoutPersInput[] | PersMagicItemUncheckedCreateWithoutPersInput[]
    connectOrCreate?: PersMagicItemCreateOrConnectWithoutPersInput | PersMagicItemCreateOrConnectWithoutPersInput[]
    upsert?: PersMagicItemUpsertWithWhereUniqueWithoutPersInput | PersMagicItemUpsertWithWhereUniqueWithoutPersInput[]
    createMany?: PersMagicItemCreateManyPersInputEnvelope
    set?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    disconnect?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    delete?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    connect?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    update?: PersMagicItemUpdateWithWhereUniqueWithoutPersInput | PersMagicItemUpdateWithWhereUniqueWithoutPersInput[]
    updateMany?: PersMagicItemUpdateManyWithWhereWithoutPersInput | PersMagicItemUpdateManyWithWhereWithoutPersInput[]
    deleteMany?: PersMagicItemScalarWhereInput | PersMagicItemScalarWhereInput[]
  }

  export type RaceVariantUncheckedUpdateManyWithoutPersesNestedInput = {
    create?: XOR<RaceVariantCreateWithoutPersesInput, RaceVariantUncheckedCreateWithoutPersesInput> | RaceVariantCreateWithoutPersesInput[] | RaceVariantUncheckedCreateWithoutPersesInput[]
    connectOrCreate?: RaceVariantCreateOrConnectWithoutPersesInput | RaceVariantCreateOrConnectWithoutPersesInput[]
    upsert?: RaceVariantUpsertWithWhereUniqueWithoutPersesInput | RaceVariantUpsertWithWhereUniqueWithoutPersesInput[]
    set?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    disconnect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    delete?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    connect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    update?: RaceVariantUpdateWithWhereUniqueWithoutPersesInput | RaceVariantUpdateWithWhereUniqueWithoutPersesInput[]
    updateMany?: RaceVariantUpdateManyWithWhereWithoutPersesInput | RaceVariantUpdateManyWithWhereWithoutPersesInput[]
    deleteMany?: RaceVariantScalarWhereInput | RaceVariantScalarWhereInput[]
  }

  export type RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput = {
    create?: XOR<RaceChoiceOptionCreateWithoutPersesInput, RaceChoiceOptionUncheckedCreateWithoutPersesInput> | RaceChoiceOptionCreateWithoutPersesInput[] | RaceChoiceOptionUncheckedCreateWithoutPersesInput[]
    connectOrCreate?: RaceChoiceOptionCreateOrConnectWithoutPersesInput | RaceChoiceOptionCreateOrConnectWithoutPersesInput[]
    upsert?: RaceChoiceOptionUpsertWithWhereUniqueWithoutPersesInput | RaceChoiceOptionUpsertWithWhereUniqueWithoutPersesInput[]
    set?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    disconnect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    delete?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    connect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    update?: RaceChoiceOptionUpdateWithWhereUniqueWithoutPersesInput | RaceChoiceOptionUpdateWithWhereUniqueWithoutPersesInput[]
    updateMany?: RaceChoiceOptionUpdateManyWithWhereWithoutPersesInput | RaceChoiceOptionUpdateManyWithWhereWithoutPersesInput[]
    deleteMany?: RaceChoiceOptionScalarWhereInput | RaceChoiceOptionScalarWhereInput[]
  }

  export type PersCreateNestedOneWithoutMulticlassesInput = {
    create?: XOR<PersCreateWithoutMulticlassesInput, PersUncheckedCreateWithoutMulticlassesInput>
    connectOrCreate?: PersCreateOrConnectWithoutMulticlassesInput
    connect?: PersWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutPersMulticlassesInput = {
    create?: XOR<ClassCreateWithoutPersMulticlassesInput, ClassUncheckedCreateWithoutPersMulticlassesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutPersMulticlassesInput
    connect?: ClassWhereUniqueInput
  }

  export type SubclassCreateNestedOneWithoutPersMulticlassesInput = {
    create?: XOR<SubclassCreateWithoutPersMulticlassesInput, SubclassUncheckedCreateWithoutPersMulticlassesInput>
    connectOrCreate?: SubclassCreateOrConnectWithoutPersMulticlassesInput
    connect?: SubclassWhereUniqueInput
  }

  export type PersUpdateOneRequiredWithoutMulticlassesNestedInput = {
    create?: XOR<PersCreateWithoutMulticlassesInput, PersUncheckedCreateWithoutMulticlassesInput>
    connectOrCreate?: PersCreateOrConnectWithoutMulticlassesInput
    upsert?: PersUpsertWithoutMulticlassesInput
    connect?: PersWhereUniqueInput
    update?: XOR<XOR<PersUpdateToOneWithWhereWithoutMulticlassesInput, PersUpdateWithoutMulticlassesInput>, PersUncheckedUpdateWithoutMulticlassesInput>
  }

  export type ClassUpdateOneRequiredWithoutPersMulticlassesNestedInput = {
    create?: XOR<ClassCreateWithoutPersMulticlassesInput, ClassUncheckedCreateWithoutPersMulticlassesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutPersMulticlassesInput
    upsert?: ClassUpsertWithoutPersMulticlassesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutPersMulticlassesInput, ClassUpdateWithoutPersMulticlassesInput>, ClassUncheckedUpdateWithoutPersMulticlassesInput>
  }

  export type SubclassUpdateOneWithoutPersMulticlassesNestedInput = {
    create?: XOR<SubclassCreateWithoutPersMulticlassesInput, SubclassUncheckedCreateWithoutPersMulticlassesInput>
    connectOrCreate?: SubclassCreateOrConnectWithoutPersMulticlassesInput
    upsert?: SubclassUpsertWithoutPersMulticlassesInput
    disconnect?: SubclassWhereInput | boolean
    delete?: SubclassWhereInput | boolean
    connect?: SubclassWhereUniqueInput
    update?: XOR<XOR<SubclassUpdateToOneWithWhereWithoutPersMulticlassesInput, SubclassUpdateWithoutPersMulticlassesInput>, SubclassUncheckedUpdateWithoutPersMulticlassesInput>
  }

  export type FeatureCreateNestedOneWithoutPersFeaturesInput = {
    create?: XOR<FeatureCreateWithoutPersFeaturesInput, FeatureUncheckedCreateWithoutPersFeaturesInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutPersFeaturesInput
    connect?: FeatureWhereUniqueInput
  }

  export type PersCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<PersCreateWithoutFeaturesInput, PersUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: PersCreateOrConnectWithoutFeaturesInput
    connect?: PersWhereUniqueInput
  }

  export type FeatureUpdateOneRequiredWithoutPersFeaturesNestedInput = {
    create?: XOR<FeatureCreateWithoutPersFeaturesInput, FeatureUncheckedCreateWithoutPersFeaturesInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutPersFeaturesInput
    upsert?: FeatureUpsertWithoutPersFeaturesInput
    connect?: FeatureWhereUniqueInput
    update?: XOR<XOR<FeatureUpdateToOneWithWhereWithoutPersFeaturesInput, FeatureUpdateWithoutPersFeaturesInput>, FeatureUncheckedUpdateWithoutPersFeaturesInput>
  }

  export type PersUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<PersCreateWithoutFeaturesInput, PersUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: PersCreateOrConnectWithoutFeaturesInput
    upsert?: PersUpsertWithoutFeaturesInput
    connect?: PersWhereUniqueInput
    update?: XOR<XOR<PersUpdateToOneWithWhereWithoutFeaturesInput, PersUpdateWithoutFeaturesInput>, PersUncheckedUpdateWithoutFeaturesInput>
  }

  export type SpellCreateNestedManyWithoutFeaturesInput = {
    create?: XOR<SpellCreateWithoutFeaturesInput, SpellUncheckedCreateWithoutFeaturesInput> | SpellCreateWithoutFeaturesInput[] | SpellUncheckedCreateWithoutFeaturesInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutFeaturesInput | SpellCreateOrConnectWithoutFeaturesInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
  }

  export type ClassFeatureCreateNestedManyWithoutFeatureInput = {
    create?: XOR<ClassFeatureCreateWithoutFeatureInput, ClassFeatureUncheckedCreateWithoutFeatureInput> | ClassFeatureCreateWithoutFeatureInput[] | ClassFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: ClassFeatureCreateOrConnectWithoutFeatureInput | ClassFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: ClassFeatureCreateManyFeatureInputEnvelope
    connect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
  }

  export type SubclassFeatureCreateNestedManyWithoutFeatureInput = {
    create?: XOR<SubclassFeatureCreateWithoutFeatureInput, SubclassFeatureUncheckedCreateWithoutFeatureInput> | SubclassFeatureCreateWithoutFeatureInput[] | SubclassFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: SubclassFeatureCreateOrConnectWithoutFeatureInput | SubclassFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: SubclassFeatureCreateManyFeatureInputEnvelope
    connect?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
  }

  export type RaceTraitCreateNestedManyWithoutFeatureInput = {
    create?: XOR<RaceTraitCreateWithoutFeatureInput, RaceTraitUncheckedCreateWithoutFeatureInput> | RaceTraitCreateWithoutFeatureInput[] | RaceTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutFeatureInput | RaceTraitCreateOrConnectWithoutFeatureInput[]
    createMany?: RaceTraitCreateManyFeatureInputEnvelope
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
  }

  export type SubraceTraitCreateNestedManyWithoutFeatureInput = {
    create?: XOR<SubraceTraitCreateWithoutFeatureInput, SubraceTraitUncheckedCreateWithoutFeatureInput> | SubraceTraitCreateWithoutFeatureInput[] | SubraceTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: SubraceTraitCreateOrConnectWithoutFeatureInput | SubraceTraitCreateOrConnectWithoutFeatureInput[]
    createMany?: SubraceTraitCreateManyFeatureInputEnvelope
    connect?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
  }

  export type RaceVariantTraitCreateNestedManyWithoutFeatureInput = {
    create?: XOR<RaceVariantTraitCreateWithoutFeatureInput, RaceVariantTraitUncheckedCreateWithoutFeatureInput> | RaceVariantTraitCreateWithoutFeatureInput[] | RaceVariantTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: RaceVariantTraitCreateOrConnectWithoutFeatureInput | RaceVariantTraitCreateOrConnectWithoutFeatureInput[]
    createMany?: RaceVariantTraitCreateManyFeatureInputEnvelope
    connect?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
  }

  export type RaceChoiceOptionTraitCreateNestedManyWithoutFeatureInput = {
    create?: XOR<RaceChoiceOptionTraitCreateWithoutFeatureInput, RaceChoiceOptionTraitUncheckedCreateWithoutFeatureInput> | RaceChoiceOptionTraitCreateWithoutFeatureInput[] | RaceChoiceOptionTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: RaceChoiceOptionTraitCreateOrConnectWithoutFeatureInput | RaceChoiceOptionTraitCreateOrConnectWithoutFeatureInput[]
    createMany?: RaceChoiceOptionTraitCreateManyFeatureInputEnvelope
    connect?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
  }

  export type FeatFeatureCreateNestedManyWithoutFeatureInput = {
    create?: XOR<FeatFeatureCreateWithoutFeatureInput, FeatFeatureUncheckedCreateWithoutFeatureInput> | FeatFeatureCreateWithoutFeatureInput[] | FeatFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: FeatFeatureCreateOrConnectWithoutFeatureInput | FeatFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: FeatFeatureCreateManyFeatureInputEnvelope
    connect?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
  }

  export type MagicItemFeatureCreateNestedManyWithoutFeatureInput = {
    create?: XOR<MagicItemFeatureCreateWithoutFeatureInput, MagicItemFeatureUncheckedCreateWithoutFeatureInput> | MagicItemFeatureCreateWithoutFeatureInput[] | MagicItemFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: MagicItemFeatureCreateOrConnectWithoutFeatureInput | MagicItemFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: MagicItemFeatureCreateManyFeatureInputEnvelope
    connect?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
  }

  export type PersFeatureCreateNestedManyWithoutFeatureInput = {
    create?: XOR<PersFeatureCreateWithoutFeatureInput, PersFeatureUncheckedCreateWithoutFeatureInput> | PersFeatureCreateWithoutFeatureInput[] | PersFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: PersFeatureCreateOrConnectWithoutFeatureInput | PersFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: PersFeatureCreateManyFeatureInputEnvelope
    connect?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
  }

  export type SpellUncheckedCreateNestedManyWithoutFeaturesInput = {
    create?: XOR<SpellCreateWithoutFeaturesInput, SpellUncheckedCreateWithoutFeaturesInput> | SpellCreateWithoutFeaturesInput[] | SpellUncheckedCreateWithoutFeaturesInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutFeaturesInput | SpellCreateOrConnectWithoutFeaturesInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
  }

  export type ClassFeatureUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<ClassFeatureCreateWithoutFeatureInput, ClassFeatureUncheckedCreateWithoutFeatureInput> | ClassFeatureCreateWithoutFeatureInput[] | ClassFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: ClassFeatureCreateOrConnectWithoutFeatureInput | ClassFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: ClassFeatureCreateManyFeatureInputEnvelope
    connect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
  }

  export type SubclassFeatureUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<SubclassFeatureCreateWithoutFeatureInput, SubclassFeatureUncheckedCreateWithoutFeatureInput> | SubclassFeatureCreateWithoutFeatureInput[] | SubclassFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: SubclassFeatureCreateOrConnectWithoutFeatureInput | SubclassFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: SubclassFeatureCreateManyFeatureInputEnvelope
    connect?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
  }

  export type RaceTraitUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<RaceTraitCreateWithoutFeatureInput, RaceTraitUncheckedCreateWithoutFeatureInput> | RaceTraitCreateWithoutFeatureInput[] | RaceTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutFeatureInput | RaceTraitCreateOrConnectWithoutFeatureInput[]
    createMany?: RaceTraitCreateManyFeatureInputEnvelope
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
  }

  export type SubraceTraitUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<SubraceTraitCreateWithoutFeatureInput, SubraceTraitUncheckedCreateWithoutFeatureInput> | SubraceTraitCreateWithoutFeatureInput[] | SubraceTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: SubraceTraitCreateOrConnectWithoutFeatureInput | SubraceTraitCreateOrConnectWithoutFeatureInput[]
    createMany?: SubraceTraitCreateManyFeatureInputEnvelope
    connect?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
  }

  export type RaceVariantTraitUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<RaceVariantTraitCreateWithoutFeatureInput, RaceVariantTraitUncheckedCreateWithoutFeatureInput> | RaceVariantTraitCreateWithoutFeatureInput[] | RaceVariantTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: RaceVariantTraitCreateOrConnectWithoutFeatureInput | RaceVariantTraitCreateOrConnectWithoutFeatureInput[]
    createMany?: RaceVariantTraitCreateManyFeatureInputEnvelope
    connect?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
  }

  export type RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<RaceChoiceOptionTraitCreateWithoutFeatureInput, RaceChoiceOptionTraitUncheckedCreateWithoutFeatureInput> | RaceChoiceOptionTraitCreateWithoutFeatureInput[] | RaceChoiceOptionTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: RaceChoiceOptionTraitCreateOrConnectWithoutFeatureInput | RaceChoiceOptionTraitCreateOrConnectWithoutFeatureInput[]
    createMany?: RaceChoiceOptionTraitCreateManyFeatureInputEnvelope
    connect?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
  }

  export type FeatFeatureUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<FeatFeatureCreateWithoutFeatureInput, FeatFeatureUncheckedCreateWithoutFeatureInput> | FeatFeatureCreateWithoutFeatureInput[] | FeatFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: FeatFeatureCreateOrConnectWithoutFeatureInput | FeatFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: FeatFeatureCreateManyFeatureInputEnvelope
    connect?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
  }

  export type MagicItemFeatureUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<MagicItemFeatureCreateWithoutFeatureInput, MagicItemFeatureUncheckedCreateWithoutFeatureInput> | MagicItemFeatureCreateWithoutFeatureInput[] | MagicItemFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: MagicItemFeatureCreateOrConnectWithoutFeatureInput | MagicItemFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: MagicItemFeatureCreateManyFeatureInputEnvelope
    connect?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
  }

  export type PersFeatureUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<PersFeatureCreateWithoutFeatureInput, PersFeatureUncheckedCreateWithoutFeatureInput> | PersFeatureCreateWithoutFeatureInput[] | PersFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: PersFeatureCreateOrConnectWithoutFeatureInput | PersFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: PersFeatureCreateManyFeatureInputEnvelope
    connect?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
  }

  export type NullableEnumRestTypeFieldUpdateOperationsInput = {
    set?: $Enums.RestType | null
  }

  export type EnumFeatureDisplayTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeatureDisplayType
  }

  export type SpellUpdateManyWithoutFeaturesNestedInput = {
    create?: XOR<SpellCreateWithoutFeaturesInput, SpellUncheckedCreateWithoutFeaturesInput> | SpellCreateWithoutFeaturesInput[] | SpellUncheckedCreateWithoutFeaturesInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutFeaturesInput | SpellCreateOrConnectWithoutFeaturesInput[]
    upsert?: SpellUpsertWithWhereUniqueWithoutFeaturesInput | SpellUpsertWithWhereUniqueWithoutFeaturesInput[]
    set?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    disconnect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    delete?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    update?: SpellUpdateWithWhereUniqueWithoutFeaturesInput | SpellUpdateWithWhereUniqueWithoutFeaturesInput[]
    updateMany?: SpellUpdateManyWithWhereWithoutFeaturesInput | SpellUpdateManyWithWhereWithoutFeaturesInput[]
    deleteMany?: SpellScalarWhereInput | SpellScalarWhereInput[]
  }

  export type ClassFeatureUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<ClassFeatureCreateWithoutFeatureInput, ClassFeatureUncheckedCreateWithoutFeatureInput> | ClassFeatureCreateWithoutFeatureInput[] | ClassFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: ClassFeatureCreateOrConnectWithoutFeatureInput | ClassFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: ClassFeatureUpsertWithWhereUniqueWithoutFeatureInput | ClassFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: ClassFeatureCreateManyFeatureInputEnvelope
    set?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    disconnect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    delete?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    connect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    update?: ClassFeatureUpdateWithWhereUniqueWithoutFeatureInput | ClassFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: ClassFeatureUpdateManyWithWhereWithoutFeatureInput | ClassFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: ClassFeatureScalarWhereInput | ClassFeatureScalarWhereInput[]
  }

  export type SubclassFeatureUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<SubclassFeatureCreateWithoutFeatureInput, SubclassFeatureUncheckedCreateWithoutFeatureInput> | SubclassFeatureCreateWithoutFeatureInput[] | SubclassFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: SubclassFeatureCreateOrConnectWithoutFeatureInput | SubclassFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: SubclassFeatureUpsertWithWhereUniqueWithoutFeatureInput | SubclassFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: SubclassFeatureCreateManyFeatureInputEnvelope
    set?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    disconnect?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    delete?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    connect?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    update?: SubclassFeatureUpdateWithWhereUniqueWithoutFeatureInput | SubclassFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: SubclassFeatureUpdateManyWithWhereWithoutFeatureInput | SubclassFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: SubclassFeatureScalarWhereInput | SubclassFeatureScalarWhereInput[]
  }

  export type RaceTraitUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<RaceTraitCreateWithoutFeatureInput, RaceTraitUncheckedCreateWithoutFeatureInput> | RaceTraitCreateWithoutFeatureInput[] | RaceTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutFeatureInput | RaceTraitCreateOrConnectWithoutFeatureInput[]
    upsert?: RaceTraitUpsertWithWhereUniqueWithoutFeatureInput | RaceTraitUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: RaceTraitCreateManyFeatureInputEnvelope
    set?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    disconnect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    delete?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    update?: RaceTraitUpdateWithWhereUniqueWithoutFeatureInput | RaceTraitUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: RaceTraitUpdateManyWithWhereWithoutFeatureInput | RaceTraitUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: RaceTraitScalarWhereInput | RaceTraitScalarWhereInput[]
  }

  export type SubraceTraitUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<SubraceTraitCreateWithoutFeatureInput, SubraceTraitUncheckedCreateWithoutFeatureInput> | SubraceTraitCreateWithoutFeatureInput[] | SubraceTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: SubraceTraitCreateOrConnectWithoutFeatureInput | SubraceTraitCreateOrConnectWithoutFeatureInput[]
    upsert?: SubraceTraitUpsertWithWhereUniqueWithoutFeatureInput | SubraceTraitUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: SubraceTraitCreateManyFeatureInputEnvelope
    set?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    disconnect?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    delete?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    connect?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    update?: SubraceTraitUpdateWithWhereUniqueWithoutFeatureInput | SubraceTraitUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: SubraceTraitUpdateManyWithWhereWithoutFeatureInput | SubraceTraitUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: SubraceTraitScalarWhereInput | SubraceTraitScalarWhereInput[]
  }

  export type RaceVariantTraitUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<RaceVariantTraitCreateWithoutFeatureInput, RaceVariantTraitUncheckedCreateWithoutFeatureInput> | RaceVariantTraitCreateWithoutFeatureInput[] | RaceVariantTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: RaceVariantTraitCreateOrConnectWithoutFeatureInput | RaceVariantTraitCreateOrConnectWithoutFeatureInput[]
    upsert?: RaceVariantTraitUpsertWithWhereUniqueWithoutFeatureInput | RaceVariantTraitUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: RaceVariantTraitCreateManyFeatureInputEnvelope
    set?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    disconnect?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    delete?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    connect?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    update?: RaceVariantTraitUpdateWithWhereUniqueWithoutFeatureInput | RaceVariantTraitUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: RaceVariantTraitUpdateManyWithWhereWithoutFeatureInput | RaceVariantTraitUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: RaceVariantTraitScalarWhereInput | RaceVariantTraitScalarWhereInput[]
  }

  export type RaceChoiceOptionTraitUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<RaceChoiceOptionTraitCreateWithoutFeatureInput, RaceChoiceOptionTraitUncheckedCreateWithoutFeatureInput> | RaceChoiceOptionTraitCreateWithoutFeatureInput[] | RaceChoiceOptionTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: RaceChoiceOptionTraitCreateOrConnectWithoutFeatureInput | RaceChoiceOptionTraitCreateOrConnectWithoutFeatureInput[]
    upsert?: RaceChoiceOptionTraitUpsertWithWhereUniqueWithoutFeatureInput | RaceChoiceOptionTraitUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: RaceChoiceOptionTraitCreateManyFeatureInputEnvelope
    set?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    disconnect?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    delete?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    connect?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    update?: RaceChoiceOptionTraitUpdateWithWhereUniqueWithoutFeatureInput | RaceChoiceOptionTraitUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: RaceChoiceOptionTraitUpdateManyWithWhereWithoutFeatureInput | RaceChoiceOptionTraitUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: RaceChoiceOptionTraitScalarWhereInput | RaceChoiceOptionTraitScalarWhereInput[]
  }

  export type FeatFeatureUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<FeatFeatureCreateWithoutFeatureInput, FeatFeatureUncheckedCreateWithoutFeatureInput> | FeatFeatureCreateWithoutFeatureInput[] | FeatFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: FeatFeatureCreateOrConnectWithoutFeatureInput | FeatFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: FeatFeatureUpsertWithWhereUniqueWithoutFeatureInput | FeatFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: FeatFeatureCreateManyFeatureInputEnvelope
    set?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    disconnect?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    delete?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    connect?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    update?: FeatFeatureUpdateWithWhereUniqueWithoutFeatureInput | FeatFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: FeatFeatureUpdateManyWithWhereWithoutFeatureInput | FeatFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: FeatFeatureScalarWhereInput | FeatFeatureScalarWhereInput[]
  }

  export type MagicItemFeatureUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<MagicItemFeatureCreateWithoutFeatureInput, MagicItemFeatureUncheckedCreateWithoutFeatureInput> | MagicItemFeatureCreateWithoutFeatureInput[] | MagicItemFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: MagicItemFeatureCreateOrConnectWithoutFeatureInput | MagicItemFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: MagicItemFeatureUpsertWithWhereUniqueWithoutFeatureInput | MagicItemFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: MagicItemFeatureCreateManyFeatureInputEnvelope
    set?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    disconnect?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    delete?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    connect?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    update?: MagicItemFeatureUpdateWithWhereUniqueWithoutFeatureInput | MagicItemFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: MagicItemFeatureUpdateManyWithWhereWithoutFeatureInput | MagicItemFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: MagicItemFeatureScalarWhereInput | MagicItemFeatureScalarWhereInput[]
  }

  export type PersFeatureUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<PersFeatureCreateWithoutFeatureInput, PersFeatureUncheckedCreateWithoutFeatureInput> | PersFeatureCreateWithoutFeatureInput[] | PersFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: PersFeatureCreateOrConnectWithoutFeatureInput | PersFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: PersFeatureUpsertWithWhereUniqueWithoutFeatureInput | PersFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: PersFeatureCreateManyFeatureInputEnvelope
    set?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    disconnect?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    delete?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    connect?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    update?: PersFeatureUpdateWithWhereUniqueWithoutFeatureInput | PersFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: PersFeatureUpdateManyWithWhereWithoutFeatureInput | PersFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: PersFeatureScalarWhereInput | PersFeatureScalarWhereInput[]
  }

  export type SpellUncheckedUpdateManyWithoutFeaturesNestedInput = {
    create?: XOR<SpellCreateWithoutFeaturesInput, SpellUncheckedCreateWithoutFeaturesInput> | SpellCreateWithoutFeaturesInput[] | SpellUncheckedCreateWithoutFeaturesInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutFeaturesInput | SpellCreateOrConnectWithoutFeaturesInput[]
    upsert?: SpellUpsertWithWhereUniqueWithoutFeaturesInput | SpellUpsertWithWhereUniqueWithoutFeaturesInput[]
    set?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    disconnect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    delete?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    update?: SpellUpdateWithWhereUniqueWithoutFeaturesInput | SpellUpdateWithWhereUniqueWithoutFeaturesInput[]
    updateMany?: SpellUpdateManyWithWhereWithoutFeaturesInput | SpellUpdateManyWithWhereWithoutFeaturesInput[]
    deleteMany?: SpellScalarWhereInput | SpellScalarWhereInput[]
  }

  export type ClassFeatureUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<ClassFeatureCreateWithoutFeatureInput, ClassFeatureUncheckedCreateWithoutFeatureInput> | ClassFeatureCreateWithoutFeatureInput[] | ClassFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: ClassFeatureCreateOrConnectWithoutFeatureInput | ClassFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: ClassFeatureUpsertWithWhereUniqueWithoutFeatureInput | ClassFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: ClassFeatureCreateManyFeatureInputEnvelope
    set?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    disconnect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    delete?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    connect?: ClassFeatureWhereUniqueInput | ClassFeatureWhereUniqueInput[]
    update?: ClassFeatureUpdateWithWhereUniqueWithoutFeatureInput | ClassFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: ClassFeatureUpdateManyWithWhereWithoutFeatureInput | ClassFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: ClassFeatureScalarWhereInput | ClassFeatureScalarWhereInput[]
  }

  export type SubclassFeatureUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<SubclassFeatureCreateWithoutFeatureInput, SubclassFeatureUncheckedCreateWithoutFeatureInput> | SubclassFeatureCreateWithoutFeatureInput[] | SubclassFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: SubclassFeatureCreateOrConnectWithoutFeatureInput | SubclassFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: SubclassFeatureUpsertWithWhereUniqueWithoutFeatureInput | SubclassFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: SubclassFeatureCreateManyFeatureInputEnvelope
    set?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    disconnect?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    delete?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    connect?: SubclassFeatureWhereUniqueInput | SubclassFeatureWhereUniqueInput[]
    update?: SubclassFeatureUpdateWithWhereUniqueWithoutFeatureInput | SubclassFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: SubclassFeatureUpdateManyWithWhereWithoutFeatureInput | SubclassFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: SubclassFeatureScalarWhereInput | SubclassFeatureScalarWhereInput[]
  }

  export type RaceTraitUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<RaceTraitCreateWithoutFeatureInput, RaceTraitUncheckedCreateWithoutFeatureInput> | RaceTraitCreateWithoutFeatureInput[] | RaceTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutFeatureInput | RaceTraitCreateOrConnectWithoutFeatureInput[]
    upsert?: RaceTraitUpsertWithWhereUniqueWithoutFeatureInput | RaceTraitUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: RaceTraitCreateManyFeatureInputEnvelope
    set?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    disconnect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    delete?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    update?: RaceTraitUpdateWithWhereUniqueWithoutFeatureInput | RaceTraitUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: RaceTraitUpdateManyWithWhereWithoutFeatureInput | RaceTraitUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: RaceTraitScalarWhereInput | RaceTraitScalarWhereInput[]
  }

  export type SubraceTraitUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<SubraceTraitCreateWithoutFeatureInput, SubraceTraitUncheckedCreateWithoutFeatureInput> | SubraceTraitCreateWithoutFeatureInput[] | SubraceTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: SubraceTraitCreateOrConnectWithoutFeatureInput | SubraceTraitCreateOrConnectWithoutFeatureInput[]
    upsert?: SubraceTraitUpsertWithWhereUniqueWithoutFeatureInput | SubraceTraitUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: SubraceTraitCreateManyFeatureInputEnvelope
    set?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    disconnect?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    delete?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    connect?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    update?: SubraceTraitUpdateWithWhereUniqueWithoutFeatureInput | SubraceTraitUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: SubraceTraitUpdateManyWithWhereWithoutFeatureInput | SubraceTraitUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: SubraceTraitScalarWhereInput | SubraceTraitScalarWhereInput[]
  }

  export type RaceVariantTraitUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<RaceVariantTraitCreateWithoutFeatureInput, RaceVariantTraitUncheckedCreateWithoutFeatureInput> | RaceVariantTraitCreateWithoutFeatureInput[] | RaceVariantTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: RaceVariantTraitCreateOrConnectWithoutFeatureInput | RaceVariantTraitCreateOrConnectWithoutFeatureInput[]
    upsert?: RaceVariantTraitUpsertWithWhereUniqueWithoutFeatureInput | RaceVariantTraitUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: RaceVariantTraitCreateManyFeatureInputEnvelope
    set?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    disconnect?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    delete?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    connect?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    update?: RaceVariantTraitUpdateWithWhereUniqueWithoutFeatureInput | RaceVariantTraitUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: RaceVariantTraitUpdateManyWithWhereWithoutFeatureInput | RaceVariantTraitUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: RaceVariantTraitScalarWhereInput | RaceVariantTraitScalarWhereInput[]
  }

  export type RaceChoiceOptionTraitUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<RaceChoiceOptionTraitCreateWithoutFeatureInput, RaceChoiceOptionTraitUncheckedCreateWithoutFeatureInput> | RaceChoiceOptionTraitCreateWithoutFeatureInput[] | RaceChoiceOptionTraitUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: RaceChoiceOptionTraitCreateOrConnectWithoutFeatureInput | RaceChoiceOptionTraitCreateOrConnectWithoutFeatureInput[]
    upsert?: RaceChoiceOptionTraitUpsertWithWhereUniqueWithoutFeatureInput | RaceChoiceOptionTraitUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: RaceChoiceOptionTraitCreateManyFeatureInputEnvelope
    set?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    disconnect?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    delete?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    connect?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    update?: RaceChoiceOptionTraitUpdateWithWhereUniqueWithoutFeatureInput | RaceChoiceOptionTraitUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: RaceChoiceOptionTraitUpdateManyWithWhereWithoutFeatureInput | RaceChoiceOptionTraitUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: RaceChoiceOptionTraitScalarWhereInput | RaceChoiceOptionTraitScalarWhereInput[]
  }

  export type FeatFeatureUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<FeatFeatureCreateWithoutFeatureInput, FeatFeatureUncheckedCreateWithoutFeatureInput> | FeatFeatureCreateWithoutFeatureInput[] | FeatFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: FeatFeatureCreateOrConnectWithoutFeatureInput | FeatFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: FeatFeatureUpsertWithWhereUniqueWithoutFeatureInput | FeatFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: FeatFeatureCreateManyFeatureInputEnvelope
    set?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    disconnect?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    delete?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    connect?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    update?: FeatFeatureUpdateWithWhereUniqueWithoutFeatureInput | FeatFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: FeatFeatureUpdateManyWithWhereWithoutFeatureInput | FeatFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: FeatFeatureScalarWhereInput | FeatFeatureScalarWhereInput[]
  }

  export type MagicItemFeatureUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<MagicItemFeatureCreateWithoutFeatureInput, MagicItemFeatureUncheckedCreateWithoutFeatureInput> | MagicItemFeatureCreateWithoutFeatureInput[] | MagicItemFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: MagicItemFeatureCreateOrConnectWithoutFeatureInput | MagicItemFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: MagicItemFeatureUpsertWithWhereUniqueWithoutFeatureInput | MagicItemFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: MagicItemFeatureCreateManyFeatureInputEnvelope
    set?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    disconnect?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    delete?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    connect?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    update?: MagicItemFeatureUpdateWithWhereUniqueWithoutFeatureInput | MagicItemFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: MagicItemFeatureUpdateManyWithWhereWithoutFeatureInput | MagicItemFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: MagicItemFeatureScalarWhereInput | MagicItemFeatureScalarWhereInput[]
  }

  export type PersFeatureUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<PersFeatureCreateWithoutFeatureInput, PersFeatureUncheckedCreateWithoutFeatureInput> | PersFeatureCreateWithoutFeatureInput[] | PersFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: PersFeatureCreateOrConnectWithoutFeatureInput | PersFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: PersFeatureUpsertWithWhereUniqueWithoutFeatureInput | PersFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: PersFeatureCreateManyFeatureInputEnvelope
    set?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    disconnect?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    delete?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    connect?: PersFeatureWhereUniqueInput | PersFeatureWhereUniqueInput[]
    update?: PersFeatureUpdateWithWhereUniqueWithoutFeatureInput | PersFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: PersFeatureUpdateManyWithWhereWithoutFeatureInput | PersFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: PersFeatureScalarWhereInput | PersFeatureScalarWhereInput[]
  }

  export type FeatureCreateNestedOneWithoutClassFeaturesInput = {
    create?: XOR<FeatureCreateWithoutClassFeaturesInput, FeatureUncheckedCreateWithoutClassFeaturesInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutClassFeaturesInput
    connect?: FeatureWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutClassFeaturesInput = {
    create?: XOR<ClassCreateWithoutClassFeaturesInput, ClassUncheckedCreateWithoutClassFeaturesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutClassFeaturesInput
    connect?: ClassWhereUniqueInput
  }

  export type FeatureUpdateOneRequiredWithoutClassFeaturesNestedInput = {
    create?: XOR<FeatureCreateWithoutClassFeaturesInput, FeatureUncheckedCreateWithoutClassFeaturesInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutClassFeaturesInput
    upsert?: FeatureUpsertWithoutClassFeaturesInput
    connect?: FeatureWhereUniqueInput
    update?: XOR<XOR<FeatureUpdateToOneWithWhereWithoutClassFeaturesInput, FeatureUpdateWithoutClassFeaturesInput>, FeatureUncheckedUpdateWithoutClassFeaturesInput>
  }

  export type ClassUpdateOneRequiredWithoutClassFeaturesNestedInput = {
    create?: XOR<ClassCreateWithoutClassFeaturesInput, ClassUncheckedCreateWithoutClassFeaturesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutClassFeaturesInput
    upsert?: ClassUpsertWithoutClassFeaturesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutClassFeaturesInput, ClassUpdateWithoutClassFeaturesInput>, ClassUncheckedUpdateWithoutClassFeaturesInput>
  }

  export type FeatureCreateNestedOneWithoutSubclassFeaturesInput = {
    create?: XOR<FeatureCreateWithoutSubclassFeaturesInput, FeatureUncheckedCreateWithoutSubclassFeaturesInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutSubclassFeaturesInput
    connect?: FeatureWhereUniqueInput
  }

  export type SubclassCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<SubclassCreateWithoutFeaturesInput, SubclassUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: SubclassCreateOrConnectWithoutFeaturesInput
    connect?: SubclassWhereUniqueInput
  }

  export type FeatureUpdateOneRequiredWithoutSubclassFeaturesNestedInput = {
    create?: XOR<FeatureCreateWithoutSubclassFeaturesInput, FeatureUncheckedCreateWithoutSubclassFeaturesInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutSubclassFeaturesInput
    upsert?: FeatureUpsertWithoutSubclassFeaturesInput
    connect?: FeatureWhereUniqueInput
    update?: XOR<XOR<FeatureUpdateToOneWithWhereWithoutSubclassFeaturesInput, FeatureUpdateWithoutSubclassFeaturesInput>, FeatureUncheckedUpdateWithoutSubclassFeaturesInput>
  }

  export type SubclassUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<SubclassCreateWithoutFeaturesInput, SubclassUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: SubclassCreateOrConnectWithoutFeaturesInput
    upsert?: SubclassUpsertWithoutFeaturesInput
    connect?: SubclassWhereUniqueInput
    update?: XOR<XOR<SubclassUpdateToOneWithWhereWithoutFeaturesInput, SubclassUpdateWithoutFeaturesInput>, SubclassUncheckedUpdateWithoutFeaturesInput>
  }

  export type FeatureCreateNestedOneWithoutRaceTraitsInput = {
    create?: XOR<FeatureCreateWithoutRaceTraitsInput, FeatureUncheckedCreateWithoutRaceTraitsInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutRaceTraitsInput
    connect?: FeatureWhereUniqueInput
  }

  export type RaceCreateNestedOneWithoutTraitsInput = {
    create?: XOR<RaceCreateWithoutTraitsInput, RaceUncheckedCreateWithoutTraitsInput>
    connectOrCreate?: RaceCreateOrConnectWithoutTraitsInput
    connect?: RaceWhereUniqueInput
  }

  export type SubraceCreateNestedManyWithoutReplacesTraitsInput = {
    create?: XOR<SubraceCreateWithoutReplacesTraitsInput, SubraceUncheckedCreateWithoutReplacesTraitsInput> | SubraceCreateWithoutReplacesTraitsInput[] | SubraceUncheckedCreateWithoutReplacesTraitsInput[]
    connectOrCreate?: SubraceCreateOrConnectWithoutReplacesTraitsInput | SubraceCreateOrConnectWithoutReplacesTraitsInput[]
    connect?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
  }

  export type RaceVariantCreateNestedManyWithoutReplacesTraitsInput = {
    create?: XOR<RaceVariantCreateWithoutReplacesTraitsInput, RaceVariantUncheckedCreateWithoutReplacesTraitsInput> | RaceVariantCreateWithoutReplacesTraitsInput[] | RaceVariantUncheckedCreateWithoutReplacesTraitsInput[]
    connectOrCreate?: RaceVariantCreateOrConnectWithoutReplacesTraitsInput | RaceVariantCreateOrConnectWithoutReplacesTraitsInput[]
    connect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
  }

  export type SubraceUncheckedCreateNestedManyWithoutReplacesTraitsInput = {
    create?: XOR<SubraceCreateWithoutReplacesTraitsInput, SubraceUncheckedCreateWithoutReplacesTraitsInput> | SubraceCreateWithoutReplacesTraitsInput[] | SubraceUncheckedCreateWithoutReplacesTraitsInput[]
    connectOrCreate?: SubraceCreateOrConnectWithoutReplacesTraitsInput | SubraceCreateOrConnectWithoutReplacesTraitsInput[]
    connect?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
  }

  export type RaceVariantUncheckedCreateNestedManyWithoutReplacesTraitsInput = {
    create?: XOR<RaceVariantCreateWithoutReplacesTraitsInput, RaceVariantUncheckedCreateWithoutReplacesTraitsInput> | RaceVariantCreateWithoutReplacesTraitsInput[] | RaceVariantUncheckedCreateWithoutReplacesTraitsInput[]
    connectOrCreate?: RaceVariantCreateOrConnectWithoutReplacesTraitsInput | RaceVariantCreateOrConnectWithoutReplacesTraitsInput[]
    connect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
  }

  export type FeatureUpdateOneRequiredWithoutRaceTraitsNestedInput = {
    create?: XOR<FeatureCreateWithoutRaceTraitsInput, FeatureUncheckedCreateWithoutRaceTraitsInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutRaceTraitsInput
    upsert?: FeatureUpsertWithoutRaceTraitsInput
    connect?: FeatureWhereUniqueInput
    update?: XOR<XOR<FeatureUpdateToOneWithWhereWithoutRaceTraitsInput, FeatureUpdateWithoutRaceTraitsInput>, FeatureUncheckedUpdateWithoutRaceTraitsInput>
  }

  export type RaceUpdateOneRequiredWithoutTraitsNestedInput = {
    create?: XOR<RaceCreateWithoutTraitsInput, RaceUncheckedCreateWithoutTraitsInput>
    connectOrCreate?: RaceCreateOrConnectWithoutTraitsInput
    upsert?: RaceUpsertWithoutTraitsInput
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutTraitsInput, RaceUpdateWithoutTraitsInput>, RaceUncheckedUpdateWithoutTraitsInput>
  }

  export type SubraceUpdateManyWithoutReplacesTraitsNestedInput = {
    create?: XOR<SubraceCreateWithoutReplacesTraitsInput, SubraceUncheckedCreateWithoutReplacesTraitsInput> | SubraceCreateWithoutReplacesTraitsInput[] | SubraceUncheckedCreateWithoutReplacesTraitsInput[]
    connectOrCreate?: SubraceCreateOrConnectWithoutReplacesTraitsInput | SubraceCreateOrConnectWithoutReplacesTraitsInput[]
    upsert?: SubraceUpsertWithWhereUniqueWithoutReplacesTraitsInput | SubraceUpsertWithWhereUniqueWithoutReplacesTraitsInput[]
    set?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    disconnect?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    delete?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    connect?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    update?: SubraceUpdateWithWhereUniqueWithoutReplacesTraitsInput | SubraceUpdateWithWhereUniqueWithoutReplacesTraitsInput[]
    updateMany?: SubraceUpdateManyWithWhereWithoutReplacesTraitsInput | SubraceUpdateManyWithWhereWithoutReplacesTraitsInput[]
    deleteMany?: SubraceScalarWhereInput | SubraceScalarWhereInput[]
  }

  export type RaceVariantUpdateManyWithoutReplacesTraitsNestedInput = {
    create?: XOR<RaceVariantCreateWithoutReplacesTraitsInput, RaceVariantUncheckedCreateWithoutReplacesTraitsInput> | RaceVariantCreateWithoutReplacesTraitsInput[] | RaceVariantUncheckedCreateWithoutReplacesTraitsInput[]
    connectOrCreate?: RaceVariantCreateOrConnectWithoutReplacesTraitsInput | RaceVariantCreateOrConnectWithoutReplacesTraitsInput[]
    upsert?: RaceVariantUpsertWithWhereUniqueWithoutReplacesTraitsInput | RaceVariantUpsertWithWhereUniqueWithoutReplacesTraitsInput[]
    set?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    disconnect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    delete?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    connect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    update?: RaceVariantUpdateWithWhereUniqueWithoutReplacesTraitsInput | RaceVariantUpdateWithWhereUniqueWithoutReplacesTraitsInput[]
    updateMany?: RaceVariantUpdateManyWithWhereWithoutReplacesTraitsInput | RaceVariantUpdateManyWithWhereWithoutReplacesTraitsInput[]
    deleteMany?: RaceVariantScalarWhereInput | RaceVariantScalarWhereInput[]
  }

  export type SubraceUncheckedUpdateManyWithoutReplacesTraitsNestedInput = {
    create?: XOR<SubraceCreateWithoutReplacesTraitsInput, SubraceUncheckedCreateWithoutReplacesTraitsInput> | SubraceCreateWithoutReplacesTraitsInput[] | SubraceUncheckedCreateWithoutReplacesTraitsInput[]
    connectOrCreate?: SubraceCreateOrConnectWithoutReplacesTraitsInput | SubraceCreateOrConnectWithoutReplacesTraitsInput[]
    upsert?: SubraceUpsertWithWhereUniqueWithoutReplacesTraitsInput | SubraceUpsertWithWhereUniqueWithoutReplacesTraitsInput[]
    set?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    disconnect?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    delete?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    connect?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    update?: SubraceUpdateWithWhereUniqueWithoutReplacesTraitsInput | SubraceUpdateWithWhereUniqueWithoutReplacesTraitsInput[]
    updateMany?: SubraceUpdateManyWithWhereWithoutReplacesTraitsInput | SubraceUpdateManyWithWhereWithoutReplacesTraitsInput[]
    deleteMany?: SubraceScalarWhereInput | SubraceScalarWhereInput[]
  }

  export type RaceVariantUncheckedUpdateManyWithoutReplacesTraitsNestedInput = {
    create?: XOR<RaceVariantCreateWithoutReplacesTraitsInput, RaceVariantUncheckedCreateWithoutReplacesTraitsInput> | RaceVariantCreateWithoutReplacesTraitsInput[] | RaceVariantUncheckedCreateWithoutReplacesTraitsInput[]
    connectOrCreate?: RaceVariantCreateOrConnectWithoutReplacesTraitsInput | RaceVariantCreateOrConnectWithoutReplacesTraitsInput[]
    upsert?: RaceVariantUpsertWithWhereUniqueWithoutReplacesTraitsInput | RaceVariantUpsertWithWhereUniqueWithoutReplacesTraitsInput[]
    set?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    disconnect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    delete?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    connect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    update?: RaceVariantUpdateWithWhereUniqueWithoutReplacesTraitsInput | RaceVariantUpdateWithWhereUniqueWithoutReplacesTraitsInput[]
    updateMany?: RaceVariantUpdateManyWithWhereWithoutReplacesTraitsInput | RaceVariantUpdateManyWithWhereWithoutReplacesTraitsInput[]
    deleteMany?: RaceVariantScalarWhereInput | RaceVariantScalarWhereInput[]
  }

  export type FeatureCreateNestedOneWithoutSubraceTraitsInput = {
    create?: XOR<FeatureCreateWithoutSubraceTraitsInput, FeatureUncheckedCreateWithoutSubraceTraitsInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutSubraceTraitsInput
    connect?: FeatureWhereUniqueInput
  }

  export type SubraceCreateNestedOneWithoutTraitsInput = {
    create?: XOR<SubraceCreateWithoutTraitsInput, SubraceUncheckedCreateWithoutTraitsInput>
    connectOrCreate?: SubraceCreateOrConnectWithoutTraitsInput
    connect?: SubraceWhereUniqueInput
  }

  export type FeatureUpdateOneRequiredWithoutSubraceTraitsNestedInput = {
    create?: XOR<FeatureCreateWithoutSubraceTraitsInput, FeatureUncheckedCreateWithoutSubraceTraitsInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutSubraceTraitsInput
    upsert?: FeatureUpsertWithoutSubraceTraitsInput
    connect?: FeatureWhereUniqueInput
    update?: XOR<XOR<FeatureUpdateToOneWithWhereWithoutSubraceTraitsInput, FeatureUpdateWithoutSubraceTraitsInput>, FeatureUncheckedUpdateWithoutSubraceTraitsInput>
  }

  export type SubraceUpdateOneRequiredWithoutTraitsNestedInput = {
    create?: XOR<SubraceCreateWithoutTraitsInput, SubraceUncheckedCreateWithoutTraitsInput>
    connectOrCreate?: SubraceCreateOrConnectWithoutTraitsInput
    upsert?: SubraceUpsertWithoutTraitsInput
    connect?: SubraceWhereUniqueInput
    update?: XOR<XOR<SubraceUpdateToOneWithWhereWithoutTraitsInput, SubraceUpdateWithoutTraitsInput>, SubraceUncheckedUpdateWithoutTraitsInput>
  }

  export type FeatureCreateNestedOneWithoutRaceVariantTraitsInput = {
    create?: XOR<FeatureCreateWithoutRaceVariantTraitsInput, FeatureUncheckedCreateWithoutRaceVariantTraitsInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutRaceVariantTraitsInput
    connect?: FeatureWhereUniqueInput
  }

  export type RaceVariantCreateNestedOneWithoutTraitsInput = {
    create?: XOR<RaceVariantCreateWithoutTraitsInput, RaceVariantUncheckedCreateWithoutTraitsInput>
    connectOrCreate?: RaceVariantCreateOrConnectWithoutTraitsInput
    connect?: RaceVariantWhereUniqueInput
  }

  export type FeatureUpdateOneRequiredWithoutRaceVariantTraitsNestedInput = {
    create?: XOR<FeatureCreateWithoutRaceVariantTraitsInput, FeatureUncheckedCreateWithoutRaceVariantTraitsInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutRaceVariantTraitsInput
    upsert?: FeatureUpsertWithoutRaceVariantTraitsInput
    connect?: FeatureWhereUniqueInput
    update?: XOR<XOR<FeatureUpdateToOneWithWhereWithoutRaceVariantTraitsInput, FeatureUpdateWithoutRaceVariantTraitsInput>, FeatureUncheckedUpdateWithoutRaceVariantTraitsInput>
  }

  export type RaceVariantUpdateOneRequiredWithoutTraitsNestedInput = {
    create?: XOR<RaceVariantCreateWithoutTraitsInput, RaceVariantUncheckedCreateWithoutTraitsInput>
    connectOrCreate?: RaceVariantCreateOrConnectWithoutTraitsInput
    upsert?: RaceVariantUpsertWithoutTraitsInput
    connect?: RaceVariantWhereUniqueInput
    update?: XOR<XOR<RaceVariantUpdateToOneWithWhereWithoutTraitsInput, RaceVariantUpdateWithoutTraitsInput>, RaceVariantUncheckedUpdateWithoutTraitsInput>
  }

  export type FeatureCreateNestedOneWithoutRaceChoiceOptionsTraitsInput = {
    create?: XOR<FeatureCreateWithoutRaceChoiceOptionsTraitsInput, FeatureUncheckedCreateWithoutRaceChoiceOptionsTraitsInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutRaceChoiceOptionsTraitsInput
    connect?: FeatureWhereUniqueInput
  }

  export type RaceChoiceOptionCreateNestedOneWithoutGrantsTraitsInput = {
    create?: XOR<RaceChoiceOptionCreateWithoutGrantsTraitsInput, RaceChoiceOptionUncheckedCreateWithoutGrantsTraitsInput>
    connectOrCreate?: RaceChoiceOptionCreateOrConnectWithoutGrantsTraitsInput
    connect?: RaceChoiceOptionWhereUniqueInput
  }

  export type FeatureUpdateOneRequiredWithoutRaceChoiceOptionsTraitsNestedInput = {
    create?: XOR<FeatureCreateWithoutRaceChoiceOptionsTraitsInput, FeatureUncheckedCreateWithoutRaceChoiceOptionsTraitsInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutRaceChoiceOptionsTraitsInput
    upsert?: FeatureUpsertWithoutRaceChoiceOptionsTraitsInput
    connect?: FeatureWhereUniqueInput
    update?: XOR<XOR<FeatureUpdateToOneWithWhereWithoutRaceChoiceOptionsTraitsInput, FeatureUpdateWithoutRaceChoiceOptionsTraitsInput>, FeatureUncheckedUpdateWithoutRaceChoiceOptionsTraitsInput>
  }

  export type RaceChoiceOptionUpdateOneRequiredWithoutGrantsTraitsNestedInput = {
    create?: XOR<RaceChoiceOptionCreateWithoutGrantsTraitsInput, RaceChoiceOptionUncheckedCreateWithoutGrantsTraitsInput>
    connectOrCreate?: RaceChoiceOptionCreateOrConnectWithoutGrantsTraitsInput
    upsert?: RaceChoiceOptionUpsertWithoutGrantsTraitsInput
    connect?: RaceChoiceOptionWhereUniqueInput
    update?: XOR<XOR<RaceChoiceOptionUpdateToOneWithWhereWithoutGrantsTraitsInput, RaceChoiceOptionUpdateWithoutGrantsTraitsInput>, RaceChoiceOptionUncheckedUpdateWithoutGrantsTraitsInput>
  }

  export type FeatureCreateNestedOneWithoutFeatFeaturesInput = {
    create?: XOR<FeatureCreateWithoutFeatFeaturesInput, FeatureUncheckedCreateWithoutFeatFeaturesInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutFeatFeaturesInput
    connect?: FeatureWhereUniqueInput
  }

  export type FeatCreateNestedOneWithoutFeatFeaturesInput = {
    create?: XOR<FeatCreateWithoutFeatFeaturesInput, FeatUncheckedCreateWithoutFeatFeaturesInput>
    connectOrCreate?: FeatCreateOrConnectWithoutFeatFeaturesInput
    connect?: FeatWhereUniqueInput
  }

  export type FeatureUpdateOneRequiredWithoutFeatFeaturesNestedInput = {
    create?: XOR<FeatureCreateWithoutFeatFeaturesInput, FeatureUncheckedCreateWithoutFeatFeaturesInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutFeatFeaturesInput
    upsert?: FeatureUpsertWithoutFeatFeaturesInput
    connect?: FeatureWhereUniqueInput
    update?: XOR<XOR<FeatureUpdateToOneWithWhereWithoutFeatFeaturesInput, FeatureUpdateWithoutFeatFeaturesInput>, FeatureUncheckedUpdateWithoutFeatFeaturesInput>
  }

  export type FeatUpdateOneRequiredWithoutFeatFeaturesNestedInput = {
    create?: XOR<FeatCreateWithoutFeatFeaturesInput, FeatUncheckedCreateWithoutFeatFeaturesInput>
    connectOrCreate?: FeatCreateOrConnectWithoutFeatFeaturesInput
    upsert?: FeatUpsertWithoutFeatFeaturesInput
    connect?: FeatWhereUniqueInput
    update?: XOR<XOR<FeatUpdateToOneWithWhereWithoutFeatFeaturesInput, FeatUpdateWithoutFeatFeaturesInput>, FeatUncheckedUpdateWithoutFeatFeaturesInput>
  }

  export type FeatureCreateNestedOneWithoutMagicItemFeaturesInput = {
    create?: XOR<FeatureCreateWithoutMagicItemFeaturesInput, FeatureUncheckedCreateWithoutMagicItemFeaturesInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutMagicItemFeaturesInput
    connect?: FeatureWhereUniqueInput
  }

  export type MagicItemCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<MagicItemCreateWithoutFeaturesInput, MagicItemUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: MagicItemCreateOrConnectWithoutFeaturesInput
    connect?: MagicItemWhereUniqueInput
  }

  export type FeatureUpdateOneRequiredWithoutMagicItemFeaturesNestedInput = {
    create?: XOR<FeatureCreateWithoutMagicItemFeaturesInput, FeatureUncheckedCreateWithoutMagicItemFeaturesInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutMagicItemFeaturesInput
    upsert?: FeatureUpsertWithoutMagicItemFeaturesInput
    connect?: FeatureWhereUniqueInput
    update?: XOR<XOR<FeatureUpdateToOneWithWhereWithoutMagicItemFeaturesInput, FeatureUpdateWithoutMagicItemFeaturesInput>, FeatureUncheckedUpdateWithoutMagicItemFeaturesInput>
  }

  export type MagicItemUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<MagicItemCreateWithoutFeaturesInput, MagicItemUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: MagicItemCreateOrConnectWithoutFeaturesInput
    upsert?: MagicItemUpsertWithoutFeaturesInput
    connect?: MagicItemWhereUniqueInput
    update?: XOR<XOR<MagicItemUpdateToOneWithWhereWithoutFeaturesInput, MagicItemUpdateWithoutFeaturesInput>, MagicItemUncheckedUpdateWithoutFeaturesInput>
  }

  export type RaceCreatesizeInput = {
    set: $Enums.Size[]
  }

  export type RaceCreatelanguagesInput = {
    set: $Enums.Language[]
  }

  export type RaceCreatetoolProficienciesInput = {
    set: $Enums.ToolCategory[]
  }

  export type RaceCreateskillProficienciesInput = {
    set: $Enums.Skills[]
  }

  export type RaceCreateweaponProficienciesInput = {
    set: $Enums.WeaponCategory[]
  }

  export type RaceCreatearmorProficienciesInput = {
    set: $Enums.ArmorType[]
  }

  export type SubraceCreateNestedManyWithoutRaceInput = {
    create?: XOR<SubraceCreateWithoutRaceInput, SubraceUncheckedCreateWithoutRaceInput> | SubraceCreateWithoutRaceInput[] | SubraceUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: SubraceCreateOrConnectWithoutRaceInput | SubraceCreateOrConnectWithoutRaceInput[]
    createMany?: SubraceCreateManyRaceInputEnvelope
    connect?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
  }

  export type PersCreateNestedManyWithoutRaceInput = {
    create?: XOR<PersCreateWithoutRaceInput, PersUncheckedCreateWithoutRaceInput> | PersCreateWithoutRaceInput[] | PersUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: PersCreateOrConnectWithoutRaceInput | PersCreateOrConnectWithoutRaceInput[]
    createMany?: PersCreateManyRaceInputEnvelope
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type RaceChoiceOptionCreateNestedManyWithoutRaceInput = {
    create?: XOR<RaceChoiceOptionCreateWithoutRaceInput, RaceChoiceOptionUncheckedCreateWithoutRaceInput> | RaceChoiceOptionCreateWithoutRaceInput[] | RaceChoiceOptionUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceChoiceOptionCreateOrConnectWithoutRaceInput | RaceChoiceOptionCreateOrConnectWithoutRaceInput[]
    createMany?: RaceChoiceOptionCreateManyRaceInputEnvelope
    connect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
  }

  export type RaceVariantCreateNestedManyWithoutRaceInput = {
    create?: XOR<RaceVariantCreateWithoutRaceInput, RaceVariantUncheckedCreateWithoutRaceInput> | RaceVariantCreateWithoutRaceInput[] | RaceVariantUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceVariantCreateOrConnectWithoutRaceInput | RaceVariantCreateOrConnectWithoutRaceInput[]
    createMany?: RaceVariantCreateManyRaceInputEnvelope
    connect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
  }

  export type RaceTraitCreateNestedManyWithoutRaceInput = {
    create?: XOR<RaceTraitCreateWithoutRaceInput, RaceTraitUncheckedCreateWithoutRaceInput> | RaceTraitCreateWithoutRaceInput[] | RaceTraitUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutRaceInput | RaceTraitCreateOrConnectWithoutRaceInput[]
    createMany?: RaceTraitCreateManyRaceInputEnvelope
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
  }

  export type SubraceUncheckedCreateNestedManyWithoutRaceInput = {
    create?: XOR<SubraceCreateWithoutRaceInput, SubraceUncheckedCreateWithoutRaceInput> | SubraceCreateWithoutRaceInput[] | SubraceUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: SubraceCreateOrConnectWithoutRaceInput | SubraceCreateOrConnectWithoutRaceInput[]
    createMany?: SubraceCreateManyRaceInputEnvelope
    connect?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
  }

  export type PersUncheckedCreateNestedManyWithoutRaceInput = {
    create?: XOR<PersCreateWithoutRaceInput, PersUncheckedCreateWithoutRaceInput> | PersCreateWithoutRaceInput[] | PersUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: PersCreateOrConnectWithoutRaceInput | PersCreateOrConnectWithoutRaceInput[]
    createMany?: PersCreateManyRaceInputEnvelope
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type RaceChoiceOptionUncheckedCreateNestedManyWithoutRaceInput = {
    create?: XOR<RaceChoiceOptionCreateWithoutRaceInput, RaceChoiceOptionUncheckedCreateWithoutRaceInput> | RaceChoiceOptionCreateWithoutRaceInput[] | RaceChoiceOptionUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceChoiceOptionCreateOrConnectWithoutRaceInput | RaceChoiceOptionCreateOrConnectWithoutRaceInput[]
    createMany?: RaceChoiceOptionCreateManyRaceInputEnvelope
    connect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
  }

  export type RaceVariantUncheckedCreateNestedManyWithoutRaceInput = {
    create?: XOR<RaceVariantCreateWithoutRaceInput, RaceVariantUncheckedCreateWithoutRaceInput> | RaceVariantCreateWithoutRaceInput[] | RaceVariantUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceVariantCreateOrConnectWithoutRaceInput | RaceVariantCreateOrConnectWithoutRaceInput[]
    createMany?: RaceVariantCreateManyRaceInputEnvelope
    connect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
  }

  export type RaceTraitUncheckedCreateNestedManyWithoutRaceInput = {
    create?: XOR<RaceTraitCreateWithoutRaceInput, RaceTraitUncheckedCreateWithoutRaceInput> | RaceTraitCreateWithoutRaceInput[] | RaceTraitUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutRaceInput | RaceTraitCreateOrConnectWithoutRaceInput[]
    createMany?: RaceTraitCreateManyRaceInputEnvelope
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
  }

  export type EnumRacesFieldUpdateOperationsInput = {
    set?: $Enums.Races
  }

  export type RaceUpdatesizeInput = {
    set?: $Enums.Size[]
    push?: $Enums.Size | $Enums.Size[]
  }

  export type RaceUpdatelanguagesInput = {
    set?: $Enums.Language[]
    push?: $Enums.Language | $Enums.Language[]
  }

  export type RaceUpdatetoolProficienciesInput = {
    set?: $Enums.ToolCategory[]
    push?: $Enums.ToolCategory | $Enums.ToolCategory[]
  }

  export type RaceUpdateskillProficienciesInput = {
    set?: $Enums.Skills[]
    push?: $Enums.Skills | $Enums.Skills[]
  }

  export type RaceUpdateweaponProficienciesInput = {
    set?: $Enums.WeaponCategory[]
    push?: $Enums.WeaponCategory | $Enums.WeaponCategory[]
  }

  export type RaceUpdatearmorProficienciesInput = {
    set?: $Enums.ArmorType[]
    push?: $Enums.ArmorType | $Enums.ArmorType[]
  }

  export type SubraceUpdateManyWithoutRaceNestedInput = {
    create?: XOR<SubraceCreateWithoutRaceInput, SubraceUncheckedCreateWithoutRaceInput> | SubraceCreateWithoutRaceInput[] | SubraceUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: SubraceCreateOrConnectWithoutRaceInput | SubraceCreateOrConnectWithoutRaceInput[]
    upsert?: SubraceUpsertWithWhereUniqueWithoutRaceInput | SubraceUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: SubraceCreateManyRaceInputEnvelope
    set?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    disconnect?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    delete?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    connect?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    update?: SubraceUpdateWithWhereUniqueWithoutRaceInput | SubraceUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: SubraceUpdateManyWithWhereWithoutRaceInput | SubraceUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: SubraceScalarWhereInput | SubraceScalarWhereInput[]
  }

  export type PersUpdateManyWithoutRaceNestedInput = {
    create?: XOR<PersCreateWithoutRaceInput, PersUncheckedCreateWithoutRaceInput> | PersCreateWithoutRaceInput[] | PersUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: PersCreateOrConnectWithoutRaceInput | PersCreateOrConnectWithoutRaceInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutRaceInput | PersUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: PersCreateManyRaceInputEnvelope
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutRaceInput | PersUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: PersUpdateManyWithWhereWithoutRaceInput | PersUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type RaceChoiceOptionUpdateManyWithoutRaceNestedInput = {
    create?: XOR<RaceChoiceOptionCreateWithoutRaceInput, RaceChoiceOptionUncheckedCreateWithoutRaceInput> | RaceChoiceOptionCreateWithoutRaceInput[] | RaceChoiceOptionUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceChoiceOptionCreateOrConnectWithoutRaceInput | RaceChoiceOptionCreateOrConnectWithoutRaceInput[]
    upsert?: RaceChoiceOptionUpsertWithWhereUniqueWithoutRaceInput | RaceChoiceOptionUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: RaceChoiceOptionCreateManyRaceInputEnvelope
    set?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    disconnect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    delete?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    connect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    update?: RaceChoiceOptionUpdateWithWhereUniqueWithoutRaceInput | RaceChoiceOptionUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: RaceChoiceOptionUpdateManyWithWhereWithoutRaceInput | RaceChoiceOptionUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: RaceChoiceOptionScalarWhereInput | RaceChoiceOptionScalarWhereInput[]
  }

  export type RaceVariantUpdateManyWithoutRaceNestedInput = {
    create?: XOR<RaceVariantCreateWithoutRaceInput, RaceVariantUncheckedCreateWithoutRaceInput> | RaceVariantCreateWithoutRaceInput[] | RaceVariantUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceVariantCreateOrConnectWithoutRaceInput | RaceVariantCreateOrConnectWithoutRaceInput[]
    upsert?: RaceVariantUpsertWithWhereUniqueWithoutRaceInput | RaceVariantUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: RaceVariantCreateManyRaceInputEnvelope
    set?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    disconnect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    delete?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    connect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    update?: RaceVariantUpdateWithWhereUniqueWithoutRaceInput | RaceVariantUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: RaceVariantUpdateManyWithWhereWithoutRaceInput | RaceVariantUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: RaceVariantScalarWhereInput | RaceVariantScalarWhereInput[]
  }

  export type RaceTraitUpdateManyWithoutRaceNestedInput = {
    create?: XOR<RaceTraitCreateWithoutRaceInput, RaceTraitUncheckedCreateWithoutRaceInput> | RaceTraitCreateWithoutRaceInput[] | RaceTraitUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutRaceInput | RaceTraitCreateOrConnectWithoutRaceInput[]
    upsert?: RaceTraitUpsertWithWhereUniqueWithoutRaceInput | RaceTraitUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: RaceTraitCreateManyRaceInputEnvelope
    set?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    disconnect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    delete?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    update?: RaceTraitUpdateWithWhereUniqueWithoutRaceInput | RaceTraitUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: RaceTraitUpdateManyWithWhereWithoutRaceInput | RaceTraitUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: RaceTraitScalarWhereInput | RaceTraitScalarWhereInput[]
  }

  export type SubraceUncheckedUpdateManyWithoutRaceNestedInput = {
    create?: XOR<SubraceCreateWithoutRaceInput, SubraceUncheckedCreateWithoutRaceInput> | SubraceCreateWithoutRaceInput[] | SubraceUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: SubraceCreateOrConnectWithoutRaceInput | SubraceCreateOrConnectWithoutRaceInput[]
    upsert?: SubraceUpsertWithWhereUniqueWithoutRaceInput | SubraceUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: SubraceCreateManyRaceInputEnvelope
    set?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    disconnect?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    delete?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    connect?: SubraceWhereUniqueInput | SubraceWhereUniqueInput[]
    update?: SubraceUpdateWithWhereUniqueWithoutRaceInput | SubraceUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: SubraceUpdateManyWithWhereWithoutRaceInput | SubraceUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: SubraceScalarWhereInput | SubraceScalarWhereInput[]
  }

  export type PersUncheckedUpdateManyWithoutRaceNestedInput = {
    create?: XOR<PersCreateWithoutRaceInput, PersUncheckedCreateWithoutRaceInput> | PersCreateWithoutRaceInput[] | PersUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: PersCreateOrConnectWithoutRaceInput | PersCreateOrConnectWithoutRaceInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutRaceInput | PersUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: PersCreateManyRaceInputEnvelope
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutRaceInput | PersUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: PersUpdateManyWithWhereWithoutRaceInput | PersUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type RaceChoiceOptionUncheckedUpdateManyWithoutRaceNestedInput = {
    create?: XOR<RaceChoiceOptionCreateWithoutRaceInput, RaceChoiceOptionUncheckedCreateWithoutRaceInput> | RaceChoiceOptionCreateWithoutRaceInput[] | RaceChoiceOptionUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceChoiceOptionCreateOrConnectWithoutRaceInput | RaceChoiceOptionCreateOrConnectWithoutRaceInput[]
    upsert?: RaceChoiceOptionUpsertWithWhereUniqueWithoutRaceInput | RaceChoiceOptionUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: RaceChoiceOptionCreateManyRaceInputEnvelope
    set?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    disconnect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    delete?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    connect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    update?: RaceChoiceOptionUpdateWithWhereUniqueWithoutRaceInput | RaceChoiceOptionUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: RaceChoiceOptionUpdateManyWithWhereWithoutRaceInput | RaceChoiceOptionUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: RaceChoiceOptionScalarWhereInput | RaceChoiceOptionScalarWhereInput[]
  }

  export type RaceVariantUncheckedUpdateManyWithoutRaceNestedInput = {
    create?: XOR<RaceVariantCreateWithoutRaceInput, RaceVariantUncheckedCreateWithoutRaceInput> | RaceVariantCreateWithoutRaceInput[] | RaceVariantUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceVariantCreateOrConnectWithoutRaceInput | RaceVariantCreateOrConnectWithoutRaceInput[]
    upsert?: RaceVariantUpsertWithWhereUniqueWithoutRaceInput | RaceVariantUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: RaceVariantCreateManyRaceInputEnvelope
    set?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    disconnect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    delete?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    connect?: RaceVariantWhereUniqueInput | RaceVariantWhereUniqueInput[]
    update?: RaceVariantUpdateWithWhereUniqueWithoutRaceInput | RaceVariantUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: RaceVariantUpdateManyWithWhereWithoutRaceInput | RaceVariantUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: RaceVariantScalarWhereInput | RaceVariantScalarWhereInput[]
  }

  export type RaceTraitUncheckedUpdateManyWithoutRaceNestedInput = {
    create?: XOR<RaceTraitCreateWithoutRaceInput, RaceTraitUncheckedCreateWithoutRaceInput> | RaceTraitCreateWithoutRaceInput[] | RaceTraitUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutRaceInput | RaceTraitCreateOrConnectWithoutRaceInput[]
    upsert?: RaceTraitUpsertWithWhereUniqueWithoutRaceInput | RaceTraitUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: RaceTraitCreateManyRaceInputEnvelope
    set?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    disconnect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    delete?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    update?: RaceTraitUpdateWithWhereUniqueWithoutRaceInput | RaceTraitUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: RaceTraitUpdateManyWithWhereWithoutRaceInput | RaceTraitUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: RaceTraitScalarWhereInput | RaceTraitScalarWhereInput[]
  }

  export type SubraceCreateadditionalLanguagesInput = {
    set: $Enums.Language[]
  }

  export type SubraceCreatetoolProficienciesInput = {
    set: $Enums.ToolCategory[]
  }

  export type SubraceCreateweaponProficienciesInput = {
    set: $Enums.WeaponCategory[]
  }

  export type SubraceCreatearmorProficienciesInput = {
    set: $Enums.ArmorType[]
  }

  export type RaceTraitCreateNestedManyWithoutSubracesInput = {
    create?: XOR<RaceTraitCreateWithoutSubracesInput, RaceTraitUncheckedCreateWithoutSubracesInput> | RaceTraitCreateWithoutSubracesInput[] | RaceTraitUncheckedCreateWithoutSubracesInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutSubracesInput | RaceTraitCreateOrConnectWithoutSubracesInput[]
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
  }

  export type RaceCreateNestedOneWithoutSubracesInput = {
    create?: XOR<RaceCreateWithoutSubracesInput, RaceUncheckedCreateWithoutSubracesInput>
    connectOrCreate?: RaceCreateOrConnectWithoutSubracesInput
    connect?: RaceWhereUniqueInput
  }

  export type PersCreateNestedManyWithoutSubraceInput = {
    create?: XOR<PersCreateWithoutSubraceInput, PersUncheckedCreateWithoutSubraceInput> | PersCreateWithoutSubraceInput[] | PersUncheckedCreateWithoutSubraceInput[]
    connectOrCreate?: PersCreateOrConnectWithoutSubraceInput | PersCreateOrConnectWithoutSubraceInput[]
    createMany?: PersCreateManySubraceInputEnvelope
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type RaceChoiceOptionCreateNestedManyWithoutSubraceInput = {
    create?: XOR<RaceChoiceOptionCreateWithoutSubraceInput, RaceChoiceOptionUncheckedCreateWithoutSubraceInput> | RaceChoiceOptionCreateWithoutSubraceInput[] | RaceChoiceOptionUncheckedCreateWithoutSubraceInput[]
    connectOrCreate?: RaceChoiceOptionCreateOrConnectWithoutSubraceInput | RaceChoiceOptionCreateOrConnectWithoutSubraceInput[]
    createMany?: RaceChoiceOptionCreateManySubraceInputEnvelope
    connect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
  }

  export type SubraceTraitCreateNestedManyWithoutSubraceInput = {
    create?: XOR<SubraceTraitCreateWithoutSubraceInput, SubraceTraitUncheckedCreateWithoutSubraceInput> | SubraceTraitCreateWithoutSubraceInput[] | SubraceTraitUncheckedCreateWithoutSubraceInput[]
    connectOrCreate?: SubraceTraitCreateOrConnectWithoutSubraceInput | SubraceTraitCreateOrConnectWithoutSubraceInput[]
    createMany?: SubraceTraitCreateManySubraceInputEnvelope
    connect?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
  }

  export type RaceTraitUncheckedCreateNestedManyWithoutSubracesInput = {
    create?: XOR<RaceTraitCreateWithoutSubracesInput, RaceTraitUncheckedCreateWithoutSubracesInput> | RaceTraitCreateWithoutSubracesInput[] | RaceTraitUncheckedCreateWithoutSubracesInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutSubracesInput | RaceTraitCreateOrConnectWithoutSubracesInput[]
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
  }

  export type PersUncheckedCreateNestedManyWithoutSubraceInput = {
    create?: XOR<PersCreateWithoutSubraceInput, PersUncheckedCreateWithoutSubraceInput> | PersCreateWithoutSubraceInput[] | PersUncheckedCreateWithoutSubraceInput[]
    connectOrCreate?: PersCreateOrConnectWithoutSubraceInput | PersCreateOrConnectWithoutSubraceInput[]
    createMany?: PersCreateManySubraceInputEnvelope
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type RaceChoiceOptionUncheckedCreateNestedManyWithoutSubraceInput = {
    create?: XOR<RaceChoiceOptionCreateWithoutSubraceInput, RaceChoiceOptionUncheckedCreateWithoutSubraceInput> | RaceChoiceOptionCreateWithoutSubraceInput[] | RaceChoiceOptionUncheckedCreateWithoutSubraceInput[]
    connectOrCreate?: RaceChoiceOptionCreateOrConnectWithoutSubraceInput | RaceChoiceOptionCreateOrConnectWithoutSubraceInput[]
    createMany?: RaceChoiceOptionCreateManySubraceInputEnvelope
    connect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
  }

  export type SubraceTraitUncheckedCreateNestedManyWithoutSubraceInput = {
    create?: XOR<SubraceTraitCreateWithoutSubraceInput, SubraceTraitUncheckedCreateWithoutSubraceInput> | SubraceTraitCreateWithoutSubraceInput[] | SubraceTraitUncheckedCreateWithoutSubraceInput[]
    connectOrCreate?: SubraceTraitCreateOrConnectWithoutSubraceInput | SubraceTraitCreateOrConnectWithoutSubraceInput[]
    createMany?: SubraceTraitCreateManySubraceInputEnvelope
    connect?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
  }

  export type EnumSubracesFieldUpdateOperationsInput = {
    set?: $Enums.Subraces
  }

  export type SubraceUpdateadditionalLanguagesInput = {
    set?: $Enums.Language[]
    push?: $Enums.Language | $Enums.Language[]
  }

  export type SubraceUpdatetoolProficienciesInput = {
    set?: $Enums.ToolCategory[]
    push?: $Enums.ToolCategory | $Enums.ToolCategory[]
  }

  export type SubraceUpdateweaponProficienciesInput = {
    set?: $Enums.WeaponCategory[]
    push?: $Enums.WeaponCategory | $Enums.WeaponCategory[]
  }

  export type SubraceUpdatearmorProficienciesInput = {
    set?: $Enums.ArmorType[]
    push?: $Enums.ArmorType | $Enums.ArmorType[]
  }

  export type RaceTraitUpdateManyWithoutSubracesNestedInput = {
    create?: XOR<RaceTraitCreateWithoutSubracesInput, RaceTraitUncheckedCreateWithoutSubracesInput> | RaceTraitCreateWithoutSubracesInput[] | RaceTraitUncheckedCreateWithoutSubracesInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutSubracesInput | RaceTraitCreateOrConnectWithoutSubracesInput[]
    upsert?: RaceTraitUpsertWithWhereUniqueWithoutSubracesInput | RaceTraitUpsertWithWhereUniqueWithoutSubracesInput[]
    set?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    disconnect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    delete?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    update?: RaceTraitUpdateWithWhereUniqueWithoutSubracesInput | RaceTraitUpdateWithWhereUniqueWithoutSubracesInput[]
    updateMany?: RaceTraitUpdateManyWithWhereWithoutSubracesInput | RaceTraitUpdateManyWithWhereWithoutSubracesInput[]
    deleteMany?: RaceTraitScalarWhereInput | RaceTraitScalarWhereInput[]
  }

  export type RaceUpdateOneRequiredWithoutSubracesNestedInput = {
    create?: XOR<RaceCreateWithoutSubracesInput, RaceUncheckedCreateWithoutSubracesInput>
    connectOrCreate?: RaceCreateOrConnectWithoutSubracesInput
    upsert?: RaceUpsertWithoutSubracesInput
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutSubracesInput, RaceUpdateWithoutSubracesInput>, RaceUncheckedUpdateWithoutSubracesInput>
  }

  export type PersUpdateManyWithoutSubraceNestedInput = {
    create?: XOR<PersCreateWithoutSubraceInput, PersUncheckedCreateWithoutSubraceInput> | PersCreateWithoutSubraceInput[] | PersUncheckedCreateWithoutSubraceInput[]
    connectOrCreate?: PersCreateOrConnectWithoutSubraceInput | PersCreateOrConnectWithoutSubraceInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutSubraceInput | PersUpsertWithWhereUniqueWithoutSubraceInput[]
    createMany?: PersCreateManySubraceInputEnvelope
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutSubraceInput | PersUpdateWithWhereUniqueWithoutSubraceInput[]
    updateMany?: PersUpdateManyWithWhereWithoutSubraceInput | PersUpdateManyWithWhereWithoutSubraceInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type RaceChoiceOptionUpdateManyWithoutSubraceNestedInput = {
    create?: XOR<RaceChoiceOptionCreateWithoutSubraceInput, RaceChoiceOptionUncheckedCreateWithoutSubraceInput> | RaceChoiceOptionCreateWithoutSubraceInput[] | RaceChoiceOptionUncheckedCreateWithoutSubraceInput[]
    connectOrCreate?: RaceChoiceOptionCreateOrConnectWithoutSubraceInput | RaceChoiceOptionCreateOrConnectWithoutSubraceInput[]
    upsert?: RaceChoiceOptionUpsertWithWhereUniqueWithoutSubraceInput | RaceChoiceOptionUpsertWithWhereUniqueWithoutSubraceInput[]
    createMany?: RaceChoiceOptionCreateManySubraceInputEnvelope
    set?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    disconnect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    delete?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    connect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    update?: RaceChoiceOptionUpdateWithWhereUniqueWithoutSubraceInput | RaceChoiceOptionUpdateWithWhereUniqueWithoutSubraceInput[]
    updateMany?: RaceChoiceOptionUpdateManyWithWhereWithoutSubraceInput | RaceChoiceOptionUpdateManyWithWhereWithoutSubraceInput[]
    deleteMany?: RaceChoiceOptionScalarWhereInput | RaceChoiceOptionScalarWhereInput[]
  }

  export type SubraceTraitUpdateManyWithoutSubraceNestedInput = {
    create?: XOR<SubraceTraitCreateWithoutSubraceInput, SubraceTraitUncheckedCreateWithoutSubraceInput> | SubraceTraitCreateWithoutSubraceInput[] | SubraceTraitUncheckedCreateWithoutSubraceInput[]
    connectOrCreate?: SubraceTraitCreateOrConnectWithoutSubraceInput | SubraceTraitCreateOrConnectWithoutSubraceInput[]
    upsert?: SubraceTraitUpsertWithWhereUniqueWithoutSubraceInput | SubraceTraitUpsertWithWhereUniqueWithoutSubraceInput[]
    createMany?: SubraceTraitCreateManySubraceInputEnvelope
    set?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    disconnect?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    delete?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    connect?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    update?: SubraceTraitUpdateWithWhereUniqueWithoutSubraceInput | SubraceTraitUpdateWithWhereUniqueWithoutSubraceInput[]
    updateMany?: SubraceTraitUpdateManyWithWhereWithoutSubraceInput | SubraceTraitUpdateManyWithWhereWithoutSubraceInput[]
    deleteMany?: SubraceTraitScalarWhereInput | SubraceTraitScalarWhereInput[]
  }

  export type RaceTraitUncheckedUpdateManyWithoutSubracesNestedInput = {
    create?: XOR<RaceTraitCreateWithoutSubracesInput, RaceTraitUncheckedCreateWithoutSubracesInput> | RaceTraitCreateWithoutSubracesInput[] | RaceTraitUncheckedCreateWithoutSubracesInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutSubracesInput | RaceTraitCreateOrConnectWithoutSubracesInput[]
    upsert?: RaceTraitUpsertWithWhereUniqueWithoutSubracesInput | RaceTraitUpsertWithWhereUniqueWithoutSubracesInput[]
    set?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    disconnect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    delete?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    update?: RaceTraitUpdateWithWhereUniqueWithoutSubracesInput | RaceTraitUpdateWithWhereUniqueWithoutSubracesInput[]
    updateMany?: RaceTraitUpdateManyWithWhereWithoutSubracesInput | RaceTraitUpdateManyWithWhereWithoutSubracesInput[]
    deleteMany?: RaceTraitScalarWhereInput | RaceTraitScalarWhereInput[]
  }

  export type PersUncheckedUpdateManyWithoutSubraceNestedInput = {
    create?: XOR<PersCreateWithoutSubraceInput, PersUncheckedCreateWithoutSubraceInput> | PersCreateWithoutSubraceInput[] | PersUncheckedCreateWithoutSubraceInput[]
    connectOrCreate?: PersCreateOrConnectWithoutSubraceInput | PersCreateOrConnectWithoutSubraceInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutSubraceInput | PersUpsertWithWhereUniqueWithoutSubraceInput[]
    createMany?: PersCreateManySubraceInputEnvelope
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutSubraceInput | PersUpdateWithWhereUniqueWithoutSubraceInput[]
    updateMany?: PersUpdateManyWithWhereWithoutSubraceInput | PersUpdateManyWithWhereWithoutSubraceInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type RaceChoiceOptionUncheckedUpdateManyWithoutSubraceNestedInput = {
    create?: XOR<RaceChoiceOptionCreateWithoutSubraceInput, RaceChoiceOptionUncheckedCreateWithoutSubraceInput> | RaceChoiceOptionCreateWithoutSubraceInput[] | RaceChoiceOptionUncheckedCreateWithoutSubraceInput[]
    connectOrCreate?: RaceChoiceOptionCreateOrConnectWithoutSubraceInput | RaceChoiceOptionCreateOrConnectWithoutSubraceInput[]
    upsert?: RaceChoiceOptionUpsertWithWhereUniqueWithoutSubraceInput | RaceChoiceOptionUpsertWithWhereUniqueWithoutSubraceInput[]
    createMany?: RaceChoiceOptionCreateManySubraceInputEnvelope
    set?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    disconnect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    delete?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    connect?: RaceChoiceOptionWhereUniqueInput | RaceChoiceOptionWhereUniqueInput[]
    update?: RaceChoiceOptionUpdateWithWhereUniqueWithoutSubraceInput | RaceChoiceOptionUpdateWithWhereUniqueWithoutSubraceInput[]
    updateMany?: RaceChoiceOptionUpdateManyWithWhereWithoutSubraceInput | RaceChoiceOptionUpdateManyWithWhereWithoutSubraceInput[]
    deleteMany?: RaceChoiceOptionScalarWhereInput | RaceChoiceOptionScalarWhereInput[]
  }

  export type SubraceTraitUncheckedUpdateManyWithoutSubraceNestedInput = {
    create?: XOR<SubraceTraitCreateWithoutSubraceInput, SubraceTraitUncheckedCreateWithoutSubraceInput> | SubraceTraitCreateWithoutSubraceInput[] | SubraceTraitUncheckedCreateWithoutSubraceInput[]
    connectOrCreate?: SubraceTraitCreateOrConnectWithoutSubraceInput | SubraceTraitCreateOrConnectWithoutSubraceInput[]
    upsert?: SubraceTraitUpsertWithWhereUniqueWithoutSubraceInput | SubraceTraitUpsertWithWhereUniqueWithoutSubraceInput[]
    createMany?: SubraceTraitCreateManySubraceInputEnvelope
    set?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    disconnect?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    delete?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    connect?: SubraceTraitWhereUniqueInput | SubraceTraitWhereUniqueInput[]
    update?: SubraceTraitUpdateWithWhereUniqueWithoutSubraceInput | SubraceTraitUpdateWithWhereUniqueWithoutSubraceInput[]
    updateMany?: SubraceTraitUpdateManyWithWhereWithoutSubraceInput | SubraceTraitUpdateManyWithWhereWithoutSubraceInput[]
    deleteMany?: SubraceTraitScalarWhereInput | SubraceTraitScalarWhereInput[]
  }

  export type RaceTraitCreateNestedManyWithoutRaceVariantsInput = {
    create?: XOR<RaceTraitCreateWithoutRaceVariantsInput, RaceTraitUncheckedCreateWithoutRaceVariantsInput> | RaceTraitCreateWithoutRaceVariantsInput[] | RaceTraitUncheckedCreateWithoutRaceVariantsInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutRaceVariantsInput | RaceTraitCreateOrConnectWithoutRaceVariantsInput[]
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
  }

  export type RaceVariantTraitCreateNestedManyWithoutRaceVariantInput = {
    create?: XOR<RaceVariantTraitCreateWithoutRaceVariantInput, RaceVariantTraitUncheckedCreateWithoutRaceVariantInput> | RaceVariantTraitCreateWithoutRaceVariantInput[] | RaceVariantTraitUncheckedCreateWithoutRaceVariantInput[]
    connectOrCreate?: RaceVariantTraitCreateOrConnectWithoutRaceVariantInput | RaceVariantTraitCreateOrConnectWithoutRaceVariantInput[]
    createMany?: RaceVariantTraitCreateManyRaceVariantInputEnvelope
    connect?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
  }

  export type RaceCreateNestedOneWithoutRaceVariantsInput = {
    create?: XOR<RaceCreateWithoutRaceVariantsInput, RaceUncheckedCreateWithoutRaceVariantsInput>
    connectOrCreate?: RaceCreateOrConnectWithoutRaceVariantsInput
    connect?: RaceWhereUniqueInput
  }

  export type PersCreateNestedManyWithoutRaceVariantsInput = {
    create?: XOR<PersCreateWithoutRaceVariantsInput, PersUncheckedCreateWithoutRaceVariantsInput> | PersCreateWithoutRaceVariantsInput[] | PersUncheckedCreateWithoutRaceVariantsInput[]
    connectOrCreate?: PersCreateOrConnectWithoutRaceVariantsInput | PersCreateOrConnectWithoutRaceVariantsInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type RaceTraitUncheckedCreateNestedManyWithoutRaceVariantsInput = {
    create?: XOR<RaceTraitCreateWithoutRaceVariantsInput, RaceTraitUncheckedCreateWithoutRaceVariantsInput> | RaceTraitCreateWithoutRaceVariantsInput[] | RaceTraitUncheckedCreateWithoutRaceVariantsInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutRaceVariantsInput | RaceTraitCreateOrConnectWithoutRaceVariantsInput[]
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
  }

  export type RaceVariantTraitUncheckedCreateNestedManyWithoutRaceVariantInput = {
    create?: XOR<RaceVariantTraitCreateWithoutRaceVariantInput, RaceVariantTraitUncheckedCreateWithoutRaceVariantInput> | RaceVariantTraitCreateWithoutRaceVariantInput[] | RaceVariantTraitUncheckedCreateWithoutRaceVariantInput[]
    connectOrCreate?: RaceVariantTraitCreateOrConnectWithoutRaceVariantInput | RaceVariantTraitCreateOrConnectWithoutRaceVariantInput[]
    createMany?: RaceVariantTraitCreateManyRaceVariantInputEnvelope
    connect?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
  }

  export type PersUncheckedCreateNestedManyWithoutRaceVariantsInput = {
    create?: XOR<PersCreateWithoutRaceVariantsInput, PersUncheckedCreateWithoutRaceVariantsInput> | PersCreateWithoutRaceVariantsInput[] | PersUncheckedCreateWithoutRaceVariantsInput[]
    connectOrCreate?: PersCreateOrConnectWithoutRaceVariantsInput | PersCreateOrConnectWithoutRaceVariantsInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type EnumVariantsFieldUpdateOperationsInput = {
    set?: $Enums.Variants
  }

  export type RaceTraitUpdateManyWithoutRaceVariantsNestedInput = {
    create?: XOR<RaceTraitCreateWithoutRaceVariantsInput, RaceTraitUncheckedCreateWithoutRaceVariantsInput> | RaceTraitCreateWithoutRaceVariantsInput[] | RaceTraitUncheckedCreateWithoutRaceVariantsInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutRaceVariantsInput | RaceTraitCreateOrConnectWithoutRaceVariantsInput[]
    upsert?: RaceTraitUpsertWithWhereUniqueWithoutRaceVariantsInput | RaceTraitUpsertWithWhereUniqueWithoutRaceVariantsInput[]
    set?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    disconnect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    delete?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    update?: RaceTraitUpdateWithWhereUniqueWithoutRaceVariantsInput | RaceTraitUpdateWithWhereUniqueWithoutRaceVariantsInput[]
    updateMany?: RaceTraitUpdateManyWithWhereWithoutRaceVariantsInput | RaceTraitUpdateManyWithWhereWithoutRaceVariantsInput[]
    deleteMany?: RaceTraitScalarWhereInput | RaceTraitScalarWhereInput[]
  }

  export type RaceVariantTraitUpdateManyWithoutRaceVariantNestedInput = {
    create?: XOR<RaceVariantTraitCreateWithoutRaceVariantInput, RaceVariantTraitUncheckedCreateWithoutRaceVariantInput> | RaceVariantTraitCreateWithoutRaceVariantInput[] | RaceVariantTraitUncheckedCreateWithoutRaceVariantInput[]
    connectOrCreate?: RaceVariantTraitCreateOrConnectWithoutRaceVariantInput | RaceVariantTraitCreateOrConnectWithoutRaceVariantInput[]
    upsert?: RaceVariantTraitUpsertWithWhereUniqueWithoutRaceVariantInput | RaceVariantTraitUpsertWithWhereUniqueWithoutRaceVariantInput[]
    createMany?: RaceVariantTraitCreateManyRaceVariantInputEnvelope
    set?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    disconnect?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    delete?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    connect?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    update?: RaceVariantTraitUpdateWithWhereUniqueWithoutRaceVariantInput | RaceVariantTraitUpdateWithWhereUniqueWithoutRaceVariantInput[]
    updateMany?: RaceVariantTraitUpdateManyWithWhereWithoutRaceVariantInput | RaceVariantTraitUpdateManyWithWhereWithoutRaceVariantInput[]
    deleteMany?: RaceVariantTraitScalarWhereInput | RaceVariantTraitScalarWhereInput[]
  }

  export type RaceUpdateOneRequiredWithoutRaceVariantsNestedInput = {
    create?: XOR<RaceCreateWithoutRaceVariantsInput, RaceUncheckedCreateWithoutRaceVariantsInput>
    connectOrCreate?: RaceCreateOrConnectWithoutRaceVariantsInput
    upsert?: RaceUpsertWithoutRaceVariantsInput
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutRaceVariantsInput, RaceUpdateWithoutRaceVariantsInput>, RaceUncheckedUpdateWithoutRaceVariantsInput>
  }

  export type PersUpdateManyWithoutRaceVariantsNestedInput = {
    create?: XOR<PersCreateWithoutRaceVariantsInput, PersUncheckedCreateWithoutRaceVariantsInput> | PersCreateWithoutRaceVariantsInput[] | PersUncheckedCreateWithoutRaceVariantsInput[]
    connectOrCreate?: PersCreateOrConnectWithoutRaceVariantsInput | PersCreateOrConnectWithoutRaceVariantsInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutRaceVariantsInput | PersUpsertWithWhereUniqueWithoutRaceVariantsInput[]
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutRaceVariantsInput | PersUpdateWithWhereUniqueWithoutRaceVariantsInput[]
    updateMany?: PersUpdateManyWithWhereWithoutRaceVariantsInput | PersUpdateManyWithWhereWithoutRaceVariantsInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type RaceTraitUncheckedUpdateManyWithoutRaceVariantsNestedInput = {
    create?: XOR<RaceTraitCreateWithoutRaceVariantsInput, RaceTraitUncheckedCreateWithoutRaceVariantsInput> | RaceTraitCreateWithoutRaceVariantsInput[] | RaceTraitUncheckedCreateWithoutRaceVariantsInput[]
    connectOrCreate?: RaceTraitCreateOrConnectWithoutRaceVariantsInput | RaceTraitCreateOrConnectWithoutRaceVariantsInput[]
    upsert?: RaceTraitUpsertWithWhereUniqueWithoutRaceVariantsInput | RaceTraitUpsertWithWhereUniqueWithoutRaceVariantsInput[]
    set?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    disconnect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    delete?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    connect?: RaceTraitWhereUniqueInput | RaceTraitWhereUniqueInput[]
    update?: RaceTraitUpdateWithWhereUniqueWithoutRaceVariantsInput | RaceTraitUpdateWithWhereUniqueWithoutRaceVariantsInput[]
    updateMany?: RaceTraitUpdateManyWithWhereWithoutRaceVariantsInput | RaceTraitUpdateManyWithWhereWithoutRaceVariantsInput[]
    deleteMany?: RaceTraitScalarWhereInput | RaceTraitScalarWhereInput[]
  }

  export type RaceVariantTraitUncheckedUpdateManyWithoutRaceVariantNestedInput = {
    create?: XOR<RaceVariantTraitCreateWithoutRaceVariantInput, RaceVariantTraitUncheckedCreateWithoutRaceVariantInput> | RaceVariantTraitCreateWithoutRaceVariantInput[] | RaceVariantTraitUncheckedCreateWithoutRaceVariantInput[]
    connectOrCreate?: RaceVariantTraitCreateOrConnectWithoutRaceVariantInput | RaceVariantTraitCreateOrConnectWithoutRaceVariantInput[]
    upsert?: RaceVariantTraitUpsertWithWhereUniqueWithoutRaceVariantInput | RaceVariantTraitUpsertWithWhereUniqueWithoutRaceVariantInput[]
    createMany?: RaceVariantTraitCreateManyRaceVariantInputEnvelope
    set?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    disconnect?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    delete?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    connect?: RaceVariantTraitWhereUniqueInput | RaceVariantTraitWhereUniqueInput[]
    update?: RaceVariantTraitUpdateWithWhereUniqueWithoutRaceVariantInput | RaceVariantTraitUpdateWithWhereUniqueWithoutRaceVariantInput[]
    updateMany?: RaceVariantTraitUpdateManyWithWhereWithoutRaceVariantInput | RaceVariantTraitUpdateManyWithWhereWithoutRaceVariantInput[]
    deleteMany?: RaceVariantTraitScalarWhereInput | RaceVariantTraitScalarWhereInput[]
  }

  export type PersUncheckedUpdateManyWithoutRaceVariantsNestedInput = {
    create?: XOR<PersCreateWithoutRaceVariantsInput, PersUncheckedCreateWithoutRaceVariantsInput> | PersCreateWithoutRaceVariantsInput[] | PersUncheckedCreateWithoutRaceVariantsInput[]
    connectOrCreate?: PersCreateOrConnectWithoutRaceVariantsInput | PersCreateOrConnectWithoutRaceVariantsInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutRaceVariantsInput | PersUpsertWithWhereUniqueWithoutRaceVariantsInput[]
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutRaceVariantsInput | PersUpdateWithWhereUniqueWithoutRaceVariantsInput[]
    updateMany?: PersUpdateManyWithWhereWithoutRaceVariantsInput | PersUpdateManyWithWhereWithoutRaceVariantsInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type RaceChoiceOptionCreategrantsSkillProficienciesInput = {
    set: $Enums.Skills[]
  }

  export type RaceChoiceOptionCreategrantsLanguagesInput = {
    set: $Enums.Language[]
  }

  export type RaceChoiceOptionTraitCreateNestedManyWithoutRaceChoiceOptionInput = {
    create?: XOR<RaceChoiceOptionTraitCreateWithoutRaceChoiceOptionInput, RaceChoiceOptionTraitUncheckedCreateWithoutRaceChoiceOptionInput> | RaceChoiceOptionTraitCreateWithoutRaceChoiceOptionInput[] | RaceChoiceOptionTraitUncheckedCreateWithoutRaceChoiceOptionInput[]
    connectOrCreate?: RaceChoiceOptionTraitCreateOrConnectWithoutRaceChoiceOptionInput | RaceChoiceOptionTraitCreateOrConnectWithoutRaceChoiceOptionInput[]
    createMany?: RaceChoiceOptionTraitCreateManyRaceChoiceOptionInputEnvelope
    connect?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
  }

  export type RaceCreateNestedOneWithoutRaceChoiceOptionsInput = {
    create?: XOR<RaceCreateWithoutRaceChoiceOptionsInput, RaceUncheckedCreateWithoutRaceChoiceOptionsInput>
    connectOrCreate?: RaceCreateOrConnectWithoutRaceChoiceOptionsInput
    connect?: RaceWhereUniqueInput
  }

  export type SubraceCreateNestedOneWithoutRaceChoiceOptionsInput = {
    create?: XOR<SubraceCreateWithoutRaceChoiceOptionsInput, SubraceUncheckedCreateWithoutRaceChoiceOptionsInput>
    connectOrCreate?: SubraceCreateOrConnectWithoutRaceChoiceOptionsInput
    connect?: SubraceWhereUniqueInput
  }

  export type PersCreateNestedManyWithoutRaceChoiceOptionsInput = {
    create?: XOR<PersCreateWithoutRaceChoiceOptionsInput, PersUncheckedCreateWithoutRaceChoiceOptionsInput> | PersCreateWithoutRaceChoiceOptionsInput[] | PersUncheckedCreateWithoutRaceChoiceOptionsInput[]
    connectOrCreate?: PersCreateOrConnectWithoutRaceChoiceOptionsInput | PersCreateOrConnectWithoutRaceChoiceOptionsInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutRaceChoiceOptionInput = {
    create?: XOR<RaceChoiceOptionTraitCreateWithoutRaceChoiceOptionInput, RaceChoiceOptionTraitUncheckedCreateWithoutRaceChoiceOptionInput> | RaceChoiceOptionTraitCreateWithoutRaceChoiceOptionInput[] | RaceChoiceOptionTraitUncheckedCreateWithoutRaceChoiceOptionInput[]
    connectOrCreate?: RaceChoiceOptionTraitCreateOrConnectWithoutRaceChoiceOptionInput | RaceChoiceOptionTraitCreateOrConnectWithoutRaceChoiceOptionInput[]
    createMany?: RaceChoiceOptionTraitCreateManyRaceChoiceOptionInputEnvelope
    connect?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
  }

  export type PersUncheckedCreateNestedManyWithoutRaceChoiceOptionsInput = {
    create?: XOR<PersCreateWithoutRaceChoiceOptionsInput, PersUncheckedCreateWithoutRaceChoiceOptionsInput> | PersCreateWithoutRaceChoiceOptionsInput[] | PersUncheckedCreateWithoutRaceChoiceOptionsInput[]
    connectOrCreate?: PersCreateOrConnectWithoutRaceChoiceOptionsInput | PersCreateOrConnectWithoutRaceChoiceOptionsInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type RaceChoiceOptionUpdategrantsSkillProficienciesInput = {
    set?: $Enums.Skills[]
    push?: $Enums.Skills | $Enums.Skills[]
  }

  export type RaceChoiceOptionUpdategrantsLanguagesInput = {
    set?: $Enums.Language[]
    push?: $Enums.Language | $Enums.Language[]
  }

  export type NullableEnumDamageTypeFieldUpdateOperationsInput = {
    set?: $Enums.DamageType | null
  }

  export type NullableEnumAOEShapesFieldUpdateOperationsInput = {
    set?: $Enums.AOEShapes | null
  }

  export type RaceChoiceOptionTraitUpdateManyWithoutRaceChoiceOptionNestedInput = {
    create?: XOR<RaceChoiceOptionTraitCreateWithoutRaceChoiceOptionInput, RaceChoiceOptionTraitUncheckedCreateWithoutRaceChoiceOptionInput> | RaceChoiceOptionTraitCreateWithoutRaceChoiceOptionInput[] | RaceChoiceOptionTraitUncheckedCreateWithoutRaceChoiceOptionInput[]
    connectOrCreate?: RaceChoiceOptionTraitCreateOrConnectWithoutRaceChoiceOptionInput | RaceChoiceOptionTraitCreateOrConnectWithoutRaceChoiceOptionInput[]
    upsert?: RaceChoiceOptionTraitUpsertWithWhereUniqueWithoutRaceChoiceOptionInput | RaceChoiceOptionTraitUpsertWithWhereUniqueWithoutRaceChoiceOptionInput[]
    createMany?: RaceChoiceOptionTraitCreateManyRaceChoiceOptionInputEnvelope
    set?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    disconnect?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    delete?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    connect?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    update?: RaceChoiceOptionTraitUpdateWithWhereUniqueWithoutRaceChoiceOptionInput | RaceChoiceOptionTraitUpdateWithWhereUniqueWithoutRaceChoiceOptionInput[]
    updateMany?: RaceChoiceOptionTraitUpdateManyWithWhereWithoutRaceChoiceOptionInput | RaceChoiceOptionTraitUpdateManyWithWhereWithoutRaceChoiceOptionInput[]
    deleteMany?: RaceChoiceOptionTraitScalarWhereInput | RaceChoiceOptionTraitScalarWhereInput[]
  }

  export type RaceUpdateOneRequiredWithoutRaceChoiceOptionsNestedInput = {
    create?: XOR<RaceCreateWithoutRaceChoiceOptionsInput, RaceUncheckedCreateWithoutRaceChoiceOptionsInput>
    connectOrCreate?: RaceCreateOrConnectWithoutRaceChoiceOptionsInput
    upsert?: RaceUpsertWithoutRaceChoiceOptionsInput
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutRaceChoiceOptionsInput, RaceUpdateWithoutRaceChoiceOptionsInput>, RaceUncheckedUpdateWithoutRaceChoiceOptionsInput>
  }

  export type SubraceUpdateOneWithoutRaceChoiceOptionsNestedInput = {
    create?: XOR<SubraceCreateWithoutRaceChoiceOptionsInput, SubraceUncheckedCreateWithoutRaceChoiceOptionsInput>
    connectOrCreate?: SubraceCreateOrConnectWithoutRaceChoiceOptionsInput
    upsert?: SubraceUpsertWithoutRaceChoiceOptionsInput
    disconnect?: SubraceWhereInput | boolean
    delete?: SubraceWhereInput | boolean
    connect?: SubraceWhereUniqueInput
    update?: XOR<XOR<SubraceUpdateToOneWithWhereWithoutRaceChoiceOptionsInput, SubraceUpdateWithoutRaceChoiceOptionsInput>, SubraceUncheckedUpdateWithoutRaceChoiceOptionsInput>
  }

  export type PersUpdateManyWithoutRaceChoiceOptionsNestedInput = {
    create?: XOR<PersCreateWithoutRaceChoiceOptionsInput, PersUncheckedCreateWithoutRaceChoiceOptionsInput> | PersCreateWithoutRaceChoiceOptionsInput[] | PersUncheckedCreateWithoutRaceChoiceOptionsInput[]
    connectOrCreate?: PersCreateOrConnectWithoutRaceChoiceOptionsInput | PersCreateOrConnectWithoutRaceChoiceOptionsInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutRaceChoiceOptionsInput | PersUpsertWithWhereUniqueWithoutRaceChoiceOptionsInput[]
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutRaceChoiceOptionsInput | PersUpdateWithWhereUniqueWithoutRaceChoiceOptionsInput[]
    updateMany?: PersUpdateManyWithWhereWithoutRaceChoiceOptionsInput | PersUpdateManyWithWhereWithoutRaceChoiceOptionsInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type RaceChoiceOptionTraitUncheckedUpdateManyWithoutRaceChoiceOptionNestedInput = {
    create?: XOR<RaceChoiceOptionTraitCreateWithoutRaceChoiceOptionInput, RaceChoiceOptionTraitUncheckedCreateWithoutRaceChoiceOptionInput> | RaceChoiceOptionTraitCreateWithoutRaceChoiceOptionInput[] | RaceChoiceOptionTraitUncheckedCreateWithoutRaceChoiceOptionInput[]
    connectOrCreate?: RaceChoiceOptionTraitCreateOrConnectWithoutRaceChoiceOptionInput | RaceChoiceOptionTraitCreateOrConnectWithoutRaceChoiceOptionInput[]
    upsert?: RaceChoiceOptionTraitUpsertWithWhereUniqueWithoutRaceChoiceOptionInput | RaceChoiceOptionTraitUpsertWithWhereUniqueWithoutRaceChoiceOptionInput[]
    createMany?: RaceChoiceOptionTraitCreateManyRaceChoiceOptionInputEnvelope
    set?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    disconnect?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    delete?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    connect?: RaceChoiceOptionTraitWhereUniqueInput | RaceChoiceOptionTraitWhereUniqueInput[]
    update?: RaceChoiceOptionTraitUpdateWithWhereUniqueWithoutRaceChoiceOptionInput | RaceChoiceOptionTraitUpdateWithWhereUniqueWithoutRaceChoiceOptionInput[]
    updateMany?: RaceChoiceOptionTraitUpdateManyWithWhereWithoutRaceChoiceOptionInput | RaceChoiceOptionTraitUpdateManyWithWhereWithoutRaceChoiceOptionInput[]
    deleteMany?: RaceChoiceOptionTraitScalarWhereInput | RaceChoiceOptionTraitScalarWhereInput[]
  }

  export type PersUncheckedUpdateManyWithoutRaceChoiceOptionsNestedInput = {
    create?: XOR<PersCreateWithoutRaceChoiceOptionsInput, PersUncheckedCreateWithoutRaceChoiceOptionsInput> | PersCreateWithoutRaceChoiceOptionsInput[] | PersUncheckedCreateWithoutRaceChoiceOptionsInput[]
    connectOrCreate?: PersCreateOrConnectWithoutRaceChoiceOptionsInput | PersCreateOrConnectWithoutRaceChoiceOptionsInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutRaceChoiceOptionsInput | PersUpsertWithWhereUniqueWithoutRaceChoiceOptionsInput[]
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutRaceChoiceOptionsInput | PersUpdateWithWhereUniqueWithoutRaceChoiceOptionsInput[]
    updateMany?: PersUpdateManyWithWhereWithoutRaceChoiceOptionsInput | PersUpdateManyWithWhereWithoutRaceChoiceOptionsInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type BackgroundCreatetoolProficienciesInput = {
    set: $Enums.ToolCategory[]
  }

  export type BackgroundCreateskillProficienciesInput = {
    set: $Enums.Skills[]
  }

  export type PersCreateNestedManyWithoutBackgroundInput = {
    create?: XOR<PersCreateWithoutBackgroundInput, PersUncheckedCreateWithoutBackgroundInput> | PersCreateWithoutBackgroundInput[] | PersUncheckedCreateWithoutBackgroundInput[]
    connectOrCreate?: PersCreateOrConnectWithoutBackgroundInput | PersCreateOrConnectWithoutBackgroundInput[]
    createMany?: PersCreateManyBackgroundInputEnvelope
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type PersUncheckedCreateNestedManyWithoutBackgroundInput = {
    create?: XOR<PersCreateWithoutBackgroundInput, PersUncheckedCreateWithoutBackgroundInput> | PersCreateWithoutBackgroundInput[] | PersUncheckedCreateWithoutBackgroundInput[]
    connectOrCreate?: PersCreateOrConnectWithoutBackgroundInput | PersCreateOrConnectWithoutBackgroundInput[]
    createMany?: PersCreateManyBackgroundInputEnvelope
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
  }

  export type EnumBackgroundCategoryFieldUpdateOperationsInput = {
    set?: $Enums.BackgroundCategory
  }

  export type BackgroundUpdatetoolProficienciesInput = {
    set?: $Enums.ToolCategory[]
    push?: $Enums.ToolCategory | $Enums.ToolCategory[]
  }

  export type BackgroundUpdateskillProficienciesInput = {
    set?: $Enums.Skills[]
    push?: $Enums.Skills | $Enums.Skills[]
  }

  export type PersUpdateManyWithoutBackgroundNestedInput = {
    create?: XOR<PersCreateWithoutBackgroundInput, PersUncheckedCreateWithoutBackgroundInput> | PersCreateWithoutBackgroundInput[] | PersUncheckedCreateWithoutBackgroundInput[]
    connectOrCreate?: PersCreateOrConnectWithoutBackgroundInput | PersCreateOrConnectWithoutBackgroundInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutBackgroundInput | PersUpsertWithWhereUniqueWithoutBackgroundInput[]
    createMany?: PersCreateManyBackgroundInputEnvelope
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutBackgroundInput | PersUpdateWithWhereUniqueWithoutBackgroundInput[]
    updateMany?: PersUpdateManyWithWhereWithoutBackgroundInput | PersUpdateManyWithWhereWithoutBackgroundInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type PersUncheckedUpdateManyWithoutBackgroundNestedInput = {
    create?: XOR<PersCreateWithoutBackgroundInput, PersUncheckedCreateWithoutBackgroundInput> | PersCreateWithoutBackgroundInput[] | PersUncheckedCreateWithoutBackgroundInput[]
    connectOrCreate?: PersCreateOrConnectWithoutBackgroundInput | PersCreateOrConnectWithoutBackgroundInput[]
    upsert?: PersUpsertWithWhereUniqueWithoutBackgroundInput | PersUpsertWithWhereUniqueWithoutBackgroundInput[]
    createMany?: PersCreateManyBackgroundInputEnvelope
    set?: PersWhereUniqueInput | PersWhereUniqueInput[]
    disconnect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    delete?: PersWhereUniqueInput | PersWhereUniqueInput[]
    connect?: PersWhereUniqueInput | PersWhereUniqueInput[]
    update?: PersUpdateWithWhereUniqueWithoutBackgroundInput | PersUpdateWithWhereUniqueWithoutBackgroundInput[]
    updateMany?: PersUpdateManyWithWhereWithoutBackgroundInput | PersUpdateManyWithWhereWithoutBackgroundInput[]
    deleteMany?: PersScalarWhereInput | PersScalarWhereInput[]
  }

  export type FeatCreatelanguagesInput = {
    set: $Enums.Language[]
  }

  export type FeatFeatureCreateNestedManyWithoutFeatInput = {
    create?: XOR<FeatFeatureCreateWithoutFeatInput, FeatFeatureUncheckedCreateWithoutFeatInput> | FeatFeatureCreateWithoutFeatInput[] | FeatFeatureUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: FeatFeatureCreateOrConnectWithoutFeatInput | FeatFeatureCreateOrConnectWithoutFeatInput[]
    createMany?: FeatFeatureCreateManyFeatInputEnvelope
    connect?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
  }

  export type FeatAbilityBoostCreateNestedOneWithoutFeatInput = {
    create?: XOR<FeatAbilityBoostCreateWithoutFeatInput, FeatAbilityBoostUncheckedCreateWithoutFeatInput>
    connectOrCreate?: FeatAbilityBoostCreateOrConnectWithoutFeatInput
    connect?: FeatAbilityBoostWhereUniqueInput
  }

  export type PersFeatCreateNestedManyWithoutFeatInput = {
    create?: XOR<PersFeatCreateWithoutFeatInput, PersFeatUncheckedCreateWithoutFeatInput> | PersFeatCreateWithoutFeatInput[] | PersFeatUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: PersFeatCreateOrConnectWithoutFeatInput | PersFeatCreateOrConnectWithoutFeatInput[]
    createMany?: PersFeatCreateManyFeatInputEnvelope
    connect?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
  }

  export type FeatFeatureUncheckedCreateNestedManyWithoutFeatInput = {
    create?: XOR<FeatFeatureCreateWithoutFeatInput, FeatFeatureUncheckedCreateWithoutFeatInput> | FeatFeatureCreateWithoutFeatInput[] | FeatFeatureUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: FeatFeatureCreateOrConnectWithoutFeatInput | FeatFeatureCreateOrConnectWithoutFeatInput[]
    createMany?: FeatFeatureCreateManyFeatInputEnvelope
    connect?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
  }

  export type FeatAbilityBoostUncheckedCreateNestedOneWithoutFeatInput = {
    create?: XOR<FeatAbilityBoostCreateWithoutFeatInput, FeatAbilityBoostUncheckedCreateWithoutFeatInput>
    connectOrCreate?: FeatAbilityBoostCreateOrConnectWithoutFeatInput
    connect?: FeatAbilityBoostWhereUniqueInput
  }

  export type PersFeatUncheckedCreateNestedManyWithoutFeatInput = {
    create?: XOR<PersFeatCreateWithoutFeatInput, PersFeatUncheckedCreateWithoutFeatInput> | PersFeatCreateWithoutFeatInput[] | PersFeatUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: PersFeatCreateOrConnectWithoutFeatInput | PersFeatCreateOrConnectWithoutFeatInput[]
    createMany?: PersFeatCreateManyFeatInputEnvelope
    connect?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
  }

  export type EnumFeatCategoryFieldUpdateOperationsInput = {
    set?: $Enums.FeatCategory
  }

  export type FeatUpdatelanguagesInput = {
    set?: $Enums.Language[]
    push?: $Enums.Language | $Enums.Language[]
  }

  export type FeatFeatureUpdateManyWithoutFeatNestedInput = {
    create?: XOR<FeatFeatureCreateWithoutFeatInput, FeatFeatureUncheckedCreateWithoutFeatInput> | FeatFeatureCreateWithoutFeatInput[] | FeatFeatureUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: FeatFeatureCreateOrConnectWithoutFeatInput | FeatFeatureCreateOrConnectWithoutFeatInput[]
    upsert?: FeatFeatureUpsertWithWhereUniqueWithoutFeatInput | FeatFeatureUpsertWithWhereUniqueWithoutFeatInput[]
    createMany?: FeatFeatureCreateManyFeatInputEnvelope
    set?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    disconnect?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    delete?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    connect?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    update?: FeatFeatureUpdateWithWhereUniqueWithoutFeatInput | FeatFeatureUpdateWithWhereUniqueWithoutFeatInput[]
    updateMany?: FeatFeatureUpdateManyWithWhereWithoutFeatInput | FeatFeatureUpdateManyWithWhereWithoutFeatInput[]
    deleteMany?: FeatFeatureScalarWhereInput | FeatFeatureScalarWhereInput[]
  }

  export type FeatAbilityBoostUpdateOneWithoutFeatNestedInput = {
    create?: XOR<FeatAbilityBoostCreateWithoutFeatInput, FeatAbilityBoostUncheckedCreateWithoutFeatInput>
    connectOrCreate?: FeatAbilityBoostCreateOrConnectWithoutFeatInput
    upsert?: FeatAbilityBoostUpsertWithoutFeatInput
    disconnect?: FeatAbilityBoostWhereInput | boolean
    delete?: FeatAbilityBoostWhereInput | boolean
    connect?: FeatAbilityBoostWhereUniqueInput
    update?: XOR<XOR<FeatAbilityBoostUpdateToOneWithWhereWithoutFeatInput, FeatAbilityBoostUpdateWithoutFeatInput>, FeatAbilityBoostUncheckedUpdateWithoutFeatInput>
  }

  export type PersFeatUpdateManyWithoutFeatNestedInput = {
    create?: XOR<PersFeatCreateWithoutFeatInput, PersFeatUncheckedCreateWithoutFeatInput> | PersFeatCreateWithoutFeatInput[] | PersFeatUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: PersFeatCreateOrConnectWithoutFeatInput | PersFeatCreateOrConnectWithoutFeatInput[]
    upsert?: PersFeatUpsertWithWhereUniqueWithoutFeatInput | PersFeatUpsertWithWhereUniqueWithoutFeatInput[]
    createMany?: PersFeatCreateManyFeatInputEnvelope
    set?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    disconnect?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    delete?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    connect?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    update?: PersFeatUpdateWithWhereUniqueWithoutFeatInput | PersFeatUpdateWithWhereUniqueWithoutFeatInput[]
    updateMany?: PersFeatUpdateManyWithWhereWithoutFeatInput | PersFeatUpdateManyWithWhereWithoutFeatInput[]
    deleteMany?: PersFeatScalarWhereInput | PersFeatScalarWhereInput[]
  }

  export type FeatFeatureUncheckedUpdateManyWithoutFeatNestedInput = {
    create?: XOR<FeatFeatureCreateWithoutFeatInput, FeatFeatureUncheckedCreateWithoutFeatInput> | FeatFeatureCreateWithoutFeatInput[] | FeatFeatureUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: FeatFeatureCreateOrConnectWithoutFeatInput | FeatFeatureCreateOrConnectWithoutFeatInput[]
    upsert?: FeatFeatureUpsertWithWhereUniqueWithoutFeatInput | FeatFeatureUpsertWithWhereUniqueWithoutFeatInput[]
    createMany?: FeatFeatureCreateManyFeatInputEnvelope
    set?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    disconnect?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    delete?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    connect?: FeatFeatureWhereUniqueInput | FeatFeatureWhereUniqueInput[]
    update?: FeatFeatureUpdateWithWhereUniqueWithoutFeatInput | FeatFeatureUpdateWithWhereUniqueWithoutFeatInput[]
    updateMany?: FeatFeatureUpdateManyWithWhereWithoutFeatInput | FeatFeatureUpdateManyWithWhereWithoutFeatInput[]
    deleteMany?: FeatFeatureScalarWhereInput | FeatFeatureScalarWhereInput[]
  }

  export type FeatAbilityBoostUncheckedUpdateOneWithoutFeatNestedInput = {
    create?: XOR<FeatAbilityBoostCreateWithoutFeatInput, FeatAbilityBoostUncheckedCreateWithoutFeatInput>
    connectOrCreate?: FeatAbilityBoostCreateOrConnectWithoutFeatInput
    upsert?: FeatAbilityBoostUpsertWithoutFeatInput
    disconnect?: FeatAbilityBoostWhereInput | boolean
    delete?: FeatAbilityBoostWhereInput | boolean
    connect?: FeatAbilityBoostWhereUniqueInput
    update?: XOR<XOR<FeatAbilityBoostUpdateToOneWithWhereWithoutFeatInput, FeatAbilityBoostUpdateWithoutFeatInput>, FeatAbilityBoostUncheckedUpdateWithoutFeatInput>
  }

  export type PersFeatUncheckedUpdateManyWithoutFeatNestedInput = {
    create?: XOR<PersFeatCreateWithoutFeatInput, PersFeatUncheckedCreateWithoutFeatInput> | PersFeatCreateWithoutFeatInput[] | PersFeatUncheckedCreateWithoutFeatInput[]
    connectOrCreate?: PersFeatCreateOrConnectWithoutFeatInput | PersFeatCreateOrConnectWithoutFeatInput[]
    upsert?: PersFeatUpsertWithWhereUniqueWithoutFeatInput | PersFeatUpsertWithWhereUniqueWithoutFeatInput[]
    createMany?: PersFeatCreateManyFeatInputEnvelope
    set?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    disconnect?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    delete?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    connect?: PersFeatWhereUniqueInput | PersFeatWhereUniqueInput[]
    update?: PersFeatUpdateWithWhereUniqueWithoutFeatInput | PersFeatUpdateWithWhereUniqueWithoutFeatInput[]
    updateMany?: PersFeatUpdateManyWithWhereWithoutFeatInput | PersFeatUpdateManyWithWhereWithoutFeatInput[]
    deleteMany?: PersFeatScalarWhereInput | PersFeatScalarWhereInput[]
  }

  export type FeatAbilityBoostCreateabilitiesToChooseInput = {
    set: $Enums.Ability[]
  }

  export type FeatCreateNestedOneWithoutFeatAbilityBoostInput = {
    create?: XOR<FeatCreateWithoutFeatAbilityBoostInput, FeatUncheckedCreateWithoutFeatAbilityBoostInput>
    connectOrCreate?: FeatCreateOrConnectWithoutFeatAbilityBoostInput
    connect?: FeatWhereUniqueInput
  }

  export type FeatAbilityBoostUpdateabilitiesToChooseInput = {
    set?: $Enums.Ability[]
    push?: $Enums.Ability | $Enums.Ability[]
  }

  export type FeatUpdateOneRequiredWithoutFeatAbilityBoostNestedInput = {
    create?: XOR<FeatCreateWithoutFeatAbilityBoostInput, FeatUncheckedCreateWithoutFeatAbilityBoostInput>
    connectOrCreate?: FeatCreateOrConnectWithoutFeatAbilityBoostInput
    upsert?: FeatUpsertWithoutFeatAbilityBoostInput
    connect?: FeatWhereUniqueInput
    update?: XOR<XOR<FeatUpdateToOneWithWhereWithoutFeatAbilityBoostInput, FeatUpdateWithoutFeatAbilityBoostInput>, FeatUncheckedUpdateWithoutFeatAbilityBoostInput>
  }

  export type FeatCreateNestedOneWithoutPersFeatsInput = {
    create?: XOR<FeatCreateWithoutPersFeatsInput, FeatUncheckedCreateWithoutPersFeatsInput>
    connectOrCreate?: FeatCreateOrConnectWithoutPersFeatsInput
    connect?: FeatWhereUniqueInput
  }

  export type PersCreateNestedOneWithoutFeatsInput = {
    create?: XOR<PersCreateWithoutFeatsInput, PersUncheckedCreateWithoutFeatsInput>
    connectOrCreate?: PersCreateOrConnectWithoutFeatsInput
    connect?: PersWhereUniqueInput
  }

  export type FeatUpdateOneRequiredWithoutPersFeatsNestedInput = {
    create?: XOR<FeatCreateWithoutPersFeatsInput, FeatUncheckedCreateWithoutPersFeatsInput>
    connectOrCreate?: FeatCreateOrConnectWithoutPersFeatsInput
    upsert?: FeatUpsertWithoutPersFeatsInput
    connect?: FeatWhereUniqueInput
    update?: XOR<XOR<FeatUpdateToOneWithWhereWithoutPersFeatsInput, FeatUpdateWithoutPersFeatsInput>, FeatUncheckedUpdateWithoutPersFeatsInput>
  }

  export type PersUpdateOneRequiredWithoutFeatsNestedInput = {
    create?: XOR<PersCreateWithoutFeatsInput, PersUncheckedCreateWithoutFeatsInput>
    connectOrCreate?: PersCreateOrConnectWithoutFeatsInput
    upsert?: PersUpsertWithoutFeatsInput
    connect?: PersWhereUniqueInput
    update?: XOR<XOR<PersUpdateToOneWithWhereWithoutFeatsInput, PersUpdateWithoutFeatsInput>, PersUncheckedUpdateWithoutFeatsInput>
  }

  export type MagicItemFeatureCreateNestedManyWithoutMagicItemInput = {
    create?: XOR<MagicItemFeatureCreateWithoutMagicItemInput, MagicItemFeatureUncheckedCreateWithoutMagicItemInput> | MagicItemFeatureCreateWithoutMagicItemInput[] | MagicItemFeatureUncheckedCreateWithoutMagicItemInput[]
    connectOrCreate?: MagicItemFeatureCreateOrConnectWithoutMagicItemInput | MagicItemFeatureCreateOrConnectWithoutMagicItemInput[]
    createMany?: MagicItemFeatureCreateManyMagicItemInputEnvelope
    connect?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
  }

  export type PersMagicItemCreateNestedManyWithoutMagicItemInput = {
    create?: XOR<PersMagicItemCreateWithoutMagicItemInput, PersMagicItemUncheckedCreateWithoutMagicItemInput> | PersMagicItemCreateWithoutMagicItemInput[] | PersMagicItemUncheckedCreateWithoutMagicItemInput[]
    connectOrCreate?: PersMagicItemCreateOrConnectWithoutMagicItemInput | PersMagicItemCreateOrConnectWithoutMagicItemInput[]
    createMany?: PersMagicItemCreateManyMagicItemInputEnvelope
    connect?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
  }

  export type MagicItemFeatureUncheckedCreateNestedManyWithoutMagicItemInput = {
    create?: XOR<MagicItemFeatureCreateWithoutMagicItemInput, MagicItemFeatureUncheckedCreateWithoutMagicItemInput> | MagicItemFeatureCreateWithoutMagicItemInput[] | MagicItemFeatureUncheckedCreateWithoutMagicItemInput[]
    connectOrCreate?: MagicItemFeatureCreateOrConnectWithoutMagicItemInput | MagicItemFeatureCreateOrConnectWithoutMagicItemInput[]
    createMany?: MagicItemFeatureCreateManyMagicItemInputEnvelope
    connect?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
  }

  export type PersMagicItemUncheckedCreateNestedManyWithoutMagicItemInput = {
    create?: XOR<PersMagicItemCreateWithoutMagicItemInput, PersMagicItemUncheckedCreateWithoutMagicItemInput> | PersMagicItemCreateWithoutMagicItemInput[] | PersMagicItemUncheckedCreateWithoutMagicItemInput[]
    connectOrCreate?: PersMagicItemCreateOrConnectWithoutMagicItemInput | PersMagicItemCreateOrConnectWithoutMagicItemInput[]
    createMany?: PersMagicItemCreateManyMagicItemInputEnvelope
    connect?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
  }

  export type EnumMagicItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.MagicItemType
  }

  export type EnumItemRarityFieldUpdateOperationsInput = {
    set?: $Enums.ItemRarity
  }

  export type MagicItemFeatureUpdateManyWithoutMagicItemNestedInput = {
    create?: XOR<MagicItemFeatureCreateWithoutMagicItemInput, MagicItemFeatureUncheckedCreateWithoutMagicItemInput> | MagicItemFeatureCreateWithoutMagicItemInput[] | MagicItemFeatureUncheckedCreateWithoutMagicItemInput[]
    connectOrCreate?: MagicItemFeatureCreateOrConnectWithoutMagicItemInput | MagicItemFeatureCreateOrConnectWithoutMagicItemInput[]
    upsert?: MagicItemFeatureUpsertWithWhereUniqueWithoutMagicItemInput | MagicItemFeatureUpsertWithWhereUniqueWithoutMagicItemInput[]
    createMany?: MagicItemFeatureCreateManyMagicItemInputEnvelope
    set?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    disconnect?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    delete?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    connect?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    update?: MagicItemFeatureUpdateWithWhereUniqueWithoutMagicItemInput | MagicItemFeatureUpdateWithWhereUniqueWithoutMagicItemInput[]
    updateMany?: MagicItemFeatureUpdateManyWithWhereWithoutMagicItemInput | MagicItemFeatureUpdateManyWithWhereWithoutMagicItemInput[]
    deleteMany?: MagicItemFeatureScalarWhereInput | MagicItemFeatureScalarWhereInput[]
  }

  export type PersMagicItemUpdateManyWithoutMagicItemNestedInput = {
    create?: XOR<PersMagicItemCreateWithoutMagicItemInput, PersMagicItemUncheckedCreateWithoutMagicItemInput> | PersMagicItemCreateWithoutMagicItemInput[] | PersMagicItemUncheckedCreateWithoutMagicItemInput[]
    connectOrCreate?: PersMagicItemCreateOrConnectWithoutMagicItemInput | PersMagicItemCreateOrConnectWithoutMagicItemInput[]
    upsert?: PersMagicItemUpsertWithWhereUniqueWithoutMagicItemInput | PersMagicItemUpsertWithWhereUniqueWithoutMagicItemInput[]
    createMany?: PersMagicItemCreateManyMagicItemInputEnvelope
    set?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    disconnect?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    delete?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    connect?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    update?: PersMagicItemUpdateWithWhereUniqueWithoutMagicItemInput | PersMagicItemUpdateWithWhereUniqueWithoutMagicItemInput[]
    updateMany?: PersMagicItemUpdateManyWithWhereWithoutMagicItemInput | PersMagicItemUpdateManyWithWhereWithoutMagicItemInput[]
    deleteMany?: PersMagicItemScalarWhereInput | PersMagicItemScalarWhereInput[]
  }

  export type MagicItemFeatureUncheckedUpdateManyWithoutMagicItemNestedInput = {
    create?: XOR<MagicItemFeatureCreateWithoutMagicItemInput, MagicItemFeatureUncheckedCreateWithoutMagicItemInput> | MagicItemFeatureCreateWithoutMagicItemInput[] | MagicItemFeatureUncheckedCreateWithoutMagicItemInput[]
    connectOrCreate?: MagicItemFeatureCreateOrConnectWithoutMagicItemInput | MagicItemFeatureCreateOrConnectWithoutMagicItemInput[]
    upsert?: MagicItemFeatureUpsertWithWhereUniqueWithoutMagicItemInput | MagicItemFeatureUpsertWithWhereUniqueWithoutMagicItemInput[]
    createMany?: MagicItemFeatureCreateManyMagicItemInputEnvelope
    set?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    disconnect?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    delete?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    connect?: MagicItemFeatureWhereUniqueInput | MagicItemFeatureWhereUniqueInput[]
    update?: MagicItemFeatureUpdateWithWhereUniqueWithoutMagicItemInput | MagicItemFeatureUpdateWithWhereUniqueWithoutMagicItemInput[]
    updateMany?: MagicItemFeatureUpdateManyWithWhereWithoutMagicItemInput | MagicItemFeatureUpdateManyWithWhereWithoutMagicItemInput[]
    deleteMany?: MagicItemFeatureScalarWhereInput | MagicItemFeatureScalarWhereInput[]
  }

  export type PersMagicItemUncheckedUpdateManyWithoutMagicItemNestedInput = {
    create?: XOR<PersMagicItemCreateWithoutMagicItemInput, PersMagicItemUncheckedCreateWithoutMagicItemInput> | PersMagicItemCreateWithoutMagicItemInput[] | PersMagicItemUncheckedCreateWithoutMagicItemInput[]
    connectOrCreate?: PersMagicItemCreateOrConnectWithoutMagicItemInput | PersMagicItemCreateOrConnectWithoutMagicItemInput[]
    upsert?: PersMagicItemUpsertWithWhereUniqueWithoutMagicItemInput | PersMagicItemUpsertWithWhereUniqueWithoutMagicItemInput[]
    createMany?: PersMagicItemCreateManyMagicItemInputEnvelope
    set?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    disconnect?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    delete?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    connect?: PersMagicItemWhereUniqueInput | PersMagicItemWhereUniqueInput[]
    update?: PersMagicItemUpdateWithWhereUniqueWithoutMagicItemInput | PersMagicItemUpdateWithWhereUniqueWithoutMagicItemInput[]
    updateMany?: PersMagicItemUpdateManyWithWhereWithoutMagicItemInput | PersMagicItemUpdateManyWithWhereWithoutMagicItemInput[]
    deleteMany?: PersMagicItemScalarWhereInput | PersMagicItemScalarWhereInput[]
  }

  export type WeaponCreatepropertiesInput = {
    set: $Enums.WeaponProperty[]
  }

  export type PersWeaponCreateNestedManyWithoutWeaponInput = {
    create?: XOR<PersWeaponCreateWithoutWeaponInput, PersWeaponUncheckedCreateWithoutWeaponInput> | PersWeaponCreateWithoutWeaponInput[] | PersWeaponUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: PersWeaponCreateOrConnectWithoutWeaponInput | PersWeaponCreateOrConnectWithoutWeaponInput[]
    createMany?: PersWeaponCreateManyWeaponInputEnvelope
    connect?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
  }

  export type ClassStartingEquipmentOptionCreateNestedManyWithoutWeaponInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutWeaponInput, ClassStartingEquipmentOptionUncheckedCreateWithoutWeaponInput> | ClassStartingEquipmentOptionCreateWithoutWeaponInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutWeaponInput | ClassStartingEquipmentOptionCreateOrConnectWithoutWeaponInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyWeaponInputEnvelope
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
  }

  export type PersWeaponUncheckedCreateNestedManyWithoutWeaponInput = {
    create?: XOR<PersWeaponCreateWithoutWeaponInput, PersWeaponUncheckedCreateWithoutWeaponInput> | PersWeaponCreateWithoutWeaponInput[] | PersWeaponUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: PersWeaponCreateOrConnectWithoutWeaponInput | PersWeaponCreateOrConnectWithoutWeaponInput[]
    createMany?: PersWeaponCreateManyWeaponInputEnvelope
    connect?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
  }

  export type ClassStartingEquipmentOptionUncheckedCreateNestedManyWithoutWeaponInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutWeaponInput, ClassStartingEquipmentOptionUncheckedCreateWithoutWeaponInput> | ClassStartingEquipmentOptionCreateWithoutWeaponInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutWeaponInput | ClassStartingEquipmentOptionCreateOrConnectWithoutWeaponInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyWeaponInputEnvelope
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
  }

  export type EnumWeaponCategoryFieldUpdateOperationsInput = {
    set?: $Enums.WeaponCategory
  }

  export type EnumDamageTypeFieldUpdateOperationsInput = {
    set?: $Enums.DamageType
  }

  export type EnumWeaponTypeFieldUpdateOperationsInput = {
    set?: $Enums.WeaponType
  }

  export type WeaponUpdatepropertiesInput = {
    set?: $Enums.WeaponProperty[]
    push?: $Enums.WeaponProperty | $Enums.WeaponProperty[]
  }

  export type PersWeaponUpdateManyWithoutWeaponNestedInput = {
    create?: XOR<PersWeaponCreateWithoutWeaponInput, PersWeaponUncheckedCreateWithoutWeaponInput> | PersWeaponCreateWithoutWeaponInput[] | PersWeaponUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: PersWeaponCreateOrConnectWithoutWeaponInput | PersWeaponCreateOrConnectWithoutWeaponInput[]
    upsert?: PersWeaponUpsertWithWhereUniqueWithoutWeaponInput | PersWeaponUpsertWithWhereUniqueWithoutWeaponInput[]
    createMany?: PersWeaponCreateManyWeaponInputEnvelope
    set?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    disconnect?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    delete?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    connect?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    update?: PersWeaponUpdateWithWhereUniqueWithoutWeaponInput | PersWeaponUpdateWithWhereUniqueWithoutWeaponInput[]
    updateMany?: PersWeaponUpdateManyWithWhereWithoutWeaponInput | PersWeaponUpdateManyWithWhereWithoutWeaponInput[]
    deleteMany?: PersWeaponScalarWhereInput | PersWeaponScalarWhereInput[]
  }

  export type ClassStartingEquipmentOptionUpdateManyWithoutWeaponNestedInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutWeaponInput, ClassStartingEquipmentOptionUncheckedCreateWithoutWeaponInput> | ClassStartingEquipmentOptionCreateWithoutWeaponInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutWeaponInput | ClassStartingEquipmentOptionCreateOrConnectWithoutWeaponInput[]
    upsert?: ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutWeaponInput | ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutWeaponInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyWeaponInputEnvelope
    set?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    disconnect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    delete?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    update?: ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutWeaponInput | ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutWeaponInput[]
    updateMany?: ClassStartingEquipmentOptionUpdateManyWithWhereWithoutWeaponInput | ClassStartingEquipmentOptionUpdateManyWithWhereWithoutWeaponInput[]
    deleteMany?: ClassStartingEquipmentOptionScalarWhereInput | ClassStartingEquipmentOptionScalarWhereInput[]
  }

  export type PersWeaponUncheckedUpdateManyWithoutWeaponNestedInput = {
    create?: XOR<PersWeaponCreateWithoutWeaponInput, PersWeaponUncheckedCreateWithoutWeaponInput> | PersWeaponCreateWithoutWeaponInput[] | PersWeaponUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: PersWeaponCreateOrConnectWithoutWeaponInput | PersWeaponCreateOrConnectWithoutWeaponInput[]
    upsert?: PersWeaponUpsertWithWhereUniqueWithoutWeaponInput | PersWeaponUpsertWithWhereUniqueWithoutWeaponInput[]
    createMany?: PersWeaponCreateManyWeaponInputEnvelope
    set?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    disconnect?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    delete?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    connect?: PersWeaponWhereUniqueInput | PersWeaponWhereUniqueInput[]
    update?: PersWeaponUpdateWithWhereUniqueWithoutWeaponInput | PersWeaponUpdateWithWhereUniqueWithoutWeaponInput[]
    updateMany?: PersWeaponUpdateManyWithWhereWithoutWeaponInput | PersWeaponUpdateManyWithWhereWithoutWeaponInput[]
    deleteMany?: PersWeaponScalarWhereInput | PersWeaponScalarWhereInput[]
  }

  export type ClassStartingEquipmentOptionUncheckedUpdateManyWithoutWeaponNestedInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutWeaponInput, ClassStartingEquipmentOptionUncheckedCreateWithoutWeaponInput> | ClassStartingEquipmentOptionCreateWithoutWeaponInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutWeaponInput | ClassStartingEquipmentOptionCreateOrConnectWithoutWeaponInput[]
    upsert?: ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutWeaponInput | ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutWeaponInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyWeaponInputEnvelope
    set?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    disconnect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    delete?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    update?: ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutWeaponInput | ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutWeaponInput[]
    updateMany?: ClassStartingEquipmentOptionUpdateManyWithWhereWithoutWeaponInput | ClassStartingEquipmentOptionUpdateManyWithWhereWithoutWeaponInput[]
    deleteMany?: ClassStartingEquipmentOptionScalarWhereInput | ClassStartingEquipmentOptionScalarWhereInput[]
  }

  export type PersArmorCreateNestedManyWithoutArmorInput = {
    create?: XOR<PersArmorCreateWithoutArmorInput, PersArmorUncheckedCreateWithoutArmorInput> | PersArmorCreateWithoutArmorInput[] | PersArmorUncheckedCreateWithoutArmorInput[]
    connectOrCreate?: PersArmorCreateOrConnectWithoutArmorInput | PersArmorCreateOrConnectWithoutArmorInput[]
    createMany?: PersArmorCreateManyArmorInputEnvelope
    connect?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
  }

  export type ClassStartingEquipmentOptionCreateNestedManyWithoutArmorInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutArmorInput, ClassStartingEquipmentOptionUncheckedCreateWithoutArmorInput> | ClassStartingEquipmentOptionCreateWithoutArmorInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutArmorInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutArmorInput | ClassStartingEquipmentOptionCreateOrConnectWithoutArmorInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyArmorInputEnvelope
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
  }

  export type PersArmorUncheckedCreateNestedManyWithoutArmorInput = {
    create?: XOR<PersArmorCreateWithoutArmorInput, PersArmorUncheckedCreateWithoutArmorInput> | PersArmorCreateWithoutArmorInput[] | PersArmorUncheckedCreateWithoutArmorInput[]
    connectOrCreate?: PersArmorCreateOrConnectWithoutArmorInput | PersArmorCreateOrConnectWithoutArmorInput[]
    createMany?: PersArmorCreateManyArmorInputEnvelope
    connect?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
  }

  export type ClassStartingEquipmentOptionUncheckedCreateNestedManyWithoutArmorInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutArmorInput, ClassStartingEquipmentOptionUncheckedCreateWithoutArmorInput> | ClassStartingEquipmentOptionCreateWithoutArmorInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutArmorInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutArmorInput | ClassStartingEquipmentOptionCreateOrConnectWithoutArmorInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyArmorInputEnvelope
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
  }

  export type EnumArmorCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ArmorCategory
  }

  export type EnumArmorTypeFieldUpdateOperationsInput = {
    set?: $Enums.ArmorType
  }

  export type PersArmorUpdateManyWithoutArmorNestedInput = {
    create?: XOR<PersArmorCreateWithoutArmorInput, PersArmorUncheckedCreateWithoutArmorInput> | PersArmorCreateWithoutArmorInput[] | PersArmorUncheckedCreateWithoutArmorInput[]
    connectOrCreate?: PersArmorCreateOrConnectWithoutArmorInput | PersArmorCreateOrConnectWithoutArmorInput[]
    upsert?: PersArmorUpsertWithWhereUniqueWithoutArmorInput | PersArmorUpsertWithWhereUniqueWithoutArmorInput[]
    createMany?: PersArmorCreateManyArmorInputEnvelope
    set?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    disconnect?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    delete?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    connect?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    update?: PersArmorUpdateWithWhereUniqueWithoutArmorInput | PersArmorUpdateWithWhereUniqueWithoutArmorInput[]
    updateMany?: PersArmorUpdateManyWithWhereWithoutArmorInput | PersArmorUpdateManyWithWhereWithoutArmorInput[]
    deleteMany?: PersArmorScalarWhereInput | PersArmorScalarWhereInput[]
  }

  export type ClassStartingEquipmentOptionUpdateManyWithoutArmorNestedInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutArmorInput, ClassStartingEquipmentOptionUncheckedCreateWithoutArmorInput> | ClassStartingEquipmentOptionCreateWithoutArmorInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutArmorInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutArmorInput | ClassStartingEquipmentOptionCreateOrConnectWithoutArmorInput[]
    upsert?: ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutArmorInput | ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutArmorInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyArmorInputEnvelope
    set?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    disconnect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    delete?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    update?: ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutArmorInput | ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutArmorInput[]
    updateMany?: ClassStartingEquipmentOptionUpdateManyWithWhereWithoutArmorInput | ClassStartingEquipmentOptionUpdateManyWithWhereWithoutArmorInput[]
    deleteMany?: ClassStartingEquipmentOptionScalarWhereInput | ClassStartingEquipmentOptionScalarWhereInput[]
  }

  export type PersArmorUncheckedUpdateManyWithoutArmorNestedInput = {
    create?: XOR<PersArmorCreateWithoutArmorInput, PersArmorUncheckedCreateWithoutArmorInput> | PersArmorCreateWithoutArmorInput[] | PersArmorUncheckedCreateWithoutArmorInput[]
    connectOrCreate?: PersArmorCreateOrConnectWithoutArmorInput | PersArmorCreateOrConnectWithoutArmorInput[]
    upsert?: PersArmorUpsertWithWhereUniqueWithoutArmorInput | PersArmorUpsertWithWhereUniqueWithoutArmorInput[]
    createMany?: PersArmorCreateManyArmorInputEnvelope
    set?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    disconnect?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    delete?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    connect?: PersArmorWhereUniqueInput | PersArmorWhereUniqueInput[]
    update?: PersArmorUpdateWithWhereUniqueWithoutArmorInput | PersArmorUpdateWithWhereUniqueWithoutArmorInput[]
    updateMany?: PersArmorUpdateManyWithWhereWithoutArmorInput | PersArmorUpdateManyWithWhereWithoutArmorInput[]
    deleteMany?: PersArmorScalarWhereInput | PersArmorScalarWhereInput[]
  }

  export type ClassStartingEquipmentOptionUncheckedUpdateManyWithoutArmorNestedInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutArmorInput, ClassStartingEquipmentOptionUncheckedCreateWithoutArmorInput> | ClassStartingEquipmentOptionCreateWithoutArmorInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutArmorInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutArmorInput | ClassStartingEquipmentOptionCreateOrConnectWithoutArmorInput[]
    upsert?: ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutArmorInput | ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutArmorInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyArmorInputEnvelope
    set?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    disconnect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    delete?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    update?: ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutArmorInput | ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutArmorInput[]
    updateMany?: ClassStartingEquipmentOptionUpdateManyWithWhereWithoutArmorInput | ClassStartingEquipmentOptionUpdateManyWithWhereWithoutArmorInput[]
    deleteMany?: ClassStartingEquipmentOptionScalarWhereInput | ClassStartingEquipmentOptionScalarWhereInput[]
  }

  export type PersCreateNestedOneWithoutSkillsInput = {
    create?: XOR<PersCreateWithoutSkillsInput, PersUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: PersCreateOrConnectWithoutSkillsInput
    connect?: PersWhereUniqueInput
  }

  export type EnumSkillProficiencyTypeFieldUpdateOperationsInput = {
    set?: $Enums.SkillProficiencyType
  }

  export type EnumSkillsFieldUpdateOperationsInput = {
    set?: $Enums.Skills
  }

  export type PersUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<PersCreateWithoutSkillsInput, PersUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: PersCreateOrConnectWithoutSkillsInput
    upsert?: PersUpsertWithoutSkillsInput
    connect?: PersWhereUniqueInput
    update?: XOR<XOR<PersUpdateToOneWithWhereWithoutSkillsInput, PersUpdateWithoutSkillsInput>, PersUncheckedUpdateWithoutSkillsInput>
  }

  export type PersCreateNestedOneWithoutWeaponsInput = {
    create?: XOR<PersCreateWithoutWeaponsInput, PersUncheckedCreateWithoutWeaponsInput>
    connectOrCreate?: PersCreateOrConnectWithoutWeaponsInput
    connect?: PersWhereUniqueInput
  }

  export type WeaponCreateNestedOneWithoutPersWeaponsInput = {
    create?: XOR<WeaponCreateWithoutPersWeaponsInput, WeaponUncheckedCreateWithoutPersWeaponsInput>
    connectOrCreate?: WeaponCreateOrConnectWithoutPersWeaponsInput
    connect?: WeaponWhereUniqueInput
  }

  export type PersUpdateOneRequiredWithoutWeaponsNestedInput = {
    create?: XOR<PersCreateWithoutWeaponsInput, PersUncheckedCreateWithoutWeaponsInput>
    connectOrCreate?: PersCreateOrConnectWithoutWeaponsInput
    upsert?: PersUpsertWithoutWeaponsInput
    connect?: PersWhereUniqueInput
    update?: XOR<XOR<PersUpdateToOneWithWhereWithoutWeaponsInput, PersUpdateWithoutWeaponsInput>, PersUncheckedUpdateWithoutWeaponsInput>
  }

  export type WeaponUpdateOneRequiredWithoutPersWeaponsNestedInput = {
    create?: XOR<WeaponCreateWithoutPersWeaponsInput, WeaponUncheckedCreateWithoutPersWeaponsInput>
    connectOrCreate?: WeaponCreateOrConnectWithoutPersWeaponsInput
    upsert?: WeaponUpsertWithoutPersWeaponsInput
    connect?: WeaponWhereUniqueInput
    update?: XOR<XOR<WeaponUpdateToOneWithWhereWithoutPersWeaponsInput, WeaponUpdateWithoutPersWeaponsInput>, WeaponUncheckedUpdateWithoutPersWeaponsInput>
  }

  export type PersCreateNestedOneWithoutArmorsInput = {
    create?: XOR<PersCreateWithoutArmorsInput, PersUncheckedCreateWithoutArmorsInput>
    connectOrCreate?: PersCreateOrConnectWithoutArmorsInput
    connect?: PersWhereUniqueInput
  }

  export type ArmorCreateNestedOneWithoutPersArmorInput = {
    create?: XOR<ArmorCreateWithoutPersArmorInput, ArmorUncheckedCreateWithoutPersArmorInput>
    connectOrCreate?: ArmorCreateOrConnectWithoutPersArmorInput
    connect?: ArmorWhereUniqueInput
  }

  export type PersUpdateOneRequiredWithoutArmorsNestedInput = {
    create?: XOR<PersCreateWithoutArmorsInput, PersUncheckedCreateWithoutArmorsInput>
    connectOrCreate?: PersCreateOrConnectWithoutArmorsInput
    upsert?: PersUpsertWithoutArmorsInput
    connect?: PersWhereUniqueInput
    update?: XOR<XOR<PersUpdateToOneWithWhereWithoutArmorsInput, PersUpdateWithoutArmorsInput>, PersUncheckedUpdateWithoutArmorsInput>
  }

  export type ArmorUpdateOneRequiredWithoutPersArmorNestedInput = {
    create?: XOR<ArmorCreateWithoutPersArmorInput, ArmorUncheckedCreateWithoutPersArmorInput>
    connectOrCreate?: ArmorCreateOrConnectWithoutPersArmorInput
    upsert?: ArmorUpsertWithoutPersArmorInput
    connect?: ArmorWhereUniqueInput
    update?: XOR<XOR<ArmorUpdateToOneWithWhereWithoutPersArmorInput, ArmorUpdateWithoutPersArmorInput>, ArmorUncheckedUpdateWithoutPersArmorInput>
  }

  export type PersCreateNestedOneWithoutMagicItemsInput = {
    create?: XOR<PersCreateWithoutMagicItemsInput, PersUncheckedCreateWithoutMagicItemsInput>
    connectOrCreate?: PersCreateOrConnectWithoutMagicItemsInput
    connect?: PersWhereUniqueInput
  }

  export type MagicItemCreateNestedOneWithoutPersMagicItemsInput = {
    create?: XOR<MagicItemCreateWithoutPersMagicItemsInput, MagicItemUncheckedCreateWithoutPersMagicItemsInput>
    connectOrCreate?: MagicItemCreateOrConnectWithoutPersMagicItemsInput
    connect?: MagicItemWhereUniqueInput
  }

  export type PersUpdateOneRequiredWithoutMagicItemsNestedInput = {
    create?: XOR<PersCreateWithoutMagicItemsInput, PersUncheckedCreateWithoutMagicItemsInput>
    connectOrCreate?: PersCreateOrConnectWithoutMagicItemsInput
    upsert?: PersUpsertWithoutMagicItemsInput
    connect?: PersWhereUniqueInput
    update?: XOR<XOR<PersUpdateToOneWithWhereWithoutMagicItemsInput, PersUpdateWithoutMagicItemsInput>, PersUncheckedUpdateWithoutMagicItemsInput>
  }

  export type MagicItemUpdateOneRequiredWithoutPersMagicItemsNestedInput = {
    create?: XOR<MagicItemCreateWithoutPersMagicItemsInput, MagicItemUncheckedCreateWithoutPersMagicItemsInput>
    connectOrCreate?: MagicItemCreateOrConnectWithoutPersMagicItemsInput
    upsert?: MagicItemUpsertWithoutPersMagicItemsInput
    connect?: MagicItemWhereUniqueInput
    update?: XOR<XOR<MagicItemUpdateToOneWithWhereWithoutPersMagicItemsInput, MagicItemUpdateWithoutPersMagicItemsInput>, MagicItemUncheckedUpdateWithoutPersMagicItemsInput>
  }

  export type ClassStartingEquipmentOptionCreateNestedManyWithoutEquipmentPackInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutEquipmentPackInput, ClassStartingEquipmentOptionUncheckedCreateWithoutEquipmentPackInput> | ClassStartingEquipmentOptionCreateWithoutEquipmentPackInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutEquipmentPackInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutEquipmentPackInput | ClassStartingEquipmentOptionCreateOrConnectWithoutEquipmentPackInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyEquipmentPackInputEnvelope
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
  }

  export type ClassStartingEquipmentOptionUncheckedCreateNestedManyWithoutEquipmentPackInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutEquipmentPackInput, ClassStartingEquipmentOptionUncheckedCreateWithoutEquipmentPackInput> | ClassStartingEquipmentOptionCreateWithoutEquipmentPackInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutEquipmentPackInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutEquipmentPackInput | ClassStartingEquipmentOptionCreateOrConnectWithoutEquipmentPackInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyEquipmentPackInputEnvelope
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
  }

  export type EnumEquipmentPackCategoryFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentPackCategory
  }

  export type ClassStartingEquipmentOptionUpdateManyWithoutEquipmentPackNestedInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutEquipmentPackInput, ClassStartingEquipmentOptionUncheckedCreateWithoutEquipmentPackInput> | ClassStartingEquipmentOptionCreateWithoutEquipmentPackInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutEquipmentPackInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutEquipmentPackInput | ClassStartingEquipmentOptionCreateOrConnectWithoutEquipmentPackInput[]
    upsert?: ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutEquipmentPackInput | ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutEquipmentPackInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyEquipmentPackInputEnvelope
    set?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    disconnect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    delete?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    update?: ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutEquipmentPackInput | ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutEquipmentPackInput[]
    updateMany?: ClassStartingEquipmentOptionUpdateManyWithWhereWithoutEquipmentPackInput | ClassStartingEquipmentOptionUpdateManyWithWhereWithoutEquipmentPackInput[]
    deleteMany?: ClassStartingEquipmentOptionScalarWhereInput | ClassStartingEquipmentOptionScalarWhereInput[]
  }

  export type ClassStartingEquipmentOptionUncheckedUpdateManyWithoutEquipmentPackNestedInput = {
    create?: XOR<ClassStartingEquipmentOptionCreateWithoutEquipmentPackInput, ClassStartingEquipmentOptionUncheckedCreateWithoutEquipmentPackInput> | ClassStartingEquipmentOptionCreateWithoutEquipmentPackInput[] | ClassStartingEquipmentOptionUncheckedCreateWithoutEquipmentPackInput[]
    connectOrCreate?: ClassStartingEquipmentOptionCreateOrConnectWithoutEquipmentPackInput | ClassStartingEquipmentOptionCreateOrConnectWithoutEquipmentPackInput[]
    upsert?: ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutEquipmentPackInput | ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutEquipmentPackInput[]
    createMany?: ClassStartingEquipmentOptionCreateManyEquipmentPackInputEnvelope
    set?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    disconnect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    delete?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    connect?: ClassStartingEquipmentOptionWhereUniqueInput | ClassStartingEquipmentOptionWhereUniqueInput[]
    update?: ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutEquipmentPackInput | ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutEquipmentPackInput[]
    updateMany?: ClassStartingEquipmentOptionUpdateManyWithWhereWithoutEquipmentPackInput | ClassStartingEquipmentOptionUpdateManyWithWhereWithoutEquipmentPackInput[]
    deleteMany?: ClassStartingEquipmentOptionScalarWhereInput | ClassStartingEquipmentOptionScalarWhereInput[]
  }

  export type ClassCreateNestedOneWithoutStartingEquipmentOptionInput = {
    create?: XOR<ClassCreateWithoutStartingEquipmentOptionInput, ClassUncheckedCreateWithoutStartingEquipmentOptionInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStartingEquipmentOptionInput
    connect?: ClassWhereUniqueInput
  }

  export type WeaponCreateNestedOneWithoutClassStartingEquipmentOptionInput = {
    create?: XOR<WeaponCreateWithoutClassStartingEquipmentOptionInput, WeaponUncheckedCreateWithoutClassStartingEquipmentOptionInput>
    connectOrCreate?: WeaponCreateOrConnectWithoutClassStartingEquipmentOptionInput
    connect?: WeaponWhereUniqueInput
  }

  export type ArmorCreateNestedOneWithoutClassStartingEquipmentOptionInput = {
    create?: XOR<ArmorCreateWithoutClassStartingEquipmentOptionInput, ArmorUncheckedCreateWithoutClassStartingEquipmentOptionInput>
    connectOrCreate?: ArmorCreateOrConnectWithoutClassStartingEquipmentOptionInput
    connect?: ArmorWhereUniqueInput
  }

  export type EquipmentPackCreateNestedOneWithoutClassStartingEquipmentOptionsInput = {
    create?: XOR<EquipmentPackCreateWithoutClassStartingEquipmentOptionsInput, EquipmentPackUncheckedCreateWithoutClassStartingEquipmentOptionsInput>
    connectOrCreate?: EquipmentPackCreateOrConnectWithoutClassStartingEquipmentOptionsInput
    connect?: EquipmentPackWhereUniqueInput
  }

  export type NullableEnumArmorTypeFieldUpdateOperationsInput = {
    set?: $Enums.ArmorType | null
  }

  export type NullableEnumWeaponTypeFieldUpdateOperationsInput = {
    set?: $Enums.WeaponType | null
  }

  export type ClassUpdateOneRequiredWithoutStartingEquipmentOptionNestedInput = {
    create?: XOR<ClassCreateWithoutStartingEquipmentOptionInput, ClassUncheckedCreateWithoutStartingEquipmentOptionInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStartingEquipmentOptionInput
    upsert?: ClassUpsertWithoutStartingEquipmentOptionInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutStartingEquipmentOptionInput, ClassUpdateWithoutStartingEquipmentOptionInput>, ClassUncheckedUpdateWithoutStartingEquipmentOptionInput>
  }

  export type WeaponUpdateOneWithoutClassStartingEquipmentOptionNestedInput = {
    create?: XOR<WeaponCreateWithoutClassStartingEquipmentOptionInput, WeaponUncheckedCreateWithoutClassStartingEquipmentOptionInput>
    connectOrCreate?: WeaponCreateOrConnectWithoutClassStartingEquipmentOptionInput
    upsert?: WeaponUpsertWithoutClassStartingEquipmentOptionInput
    disconnect?: WeaponWhereInput | boolean
    delete?: WeaponWhereInput | boolean
    connect?: WeaponWhereUniqueInput
    update?: XOR<XOR<WeaponUpdateToOneWithWhereWithoutClassStartingEquipmentOptionInput, WeaponUpdateWithoutClassStartingEquipmentOptionInput>, WeaponUncheckedUpdateWithoutClassStartingEquipmentOptionInput>
  }

  export type ArmorUpdateOneWithoutClassStartingEquipmentOptionNestedInput = {
    create?: XOR<ArmorCreateWithoutClassStartingEquipmentOptionInput, ArmorUncheckedCreateWithoutClassStartingEquipmentOptionInput>
    connectOrCreate?: ArmorCreateOrConnectWithoutClassStartingEquipmentOptionInput
    upsert?: ArmorUpsertWithoutClassStartingEquipmentOptionInput
    disconnect?: ArmorWhereInput | boolean
    delete?: ArmorWhereInput | boolean
    connect?: ArmorWhereUniqueInput
    update?: XOR<XOR<ArmorUpdateToOneWithWhereWithoutClassStartingEquipmentOptionInput, ArmorUpdateWithoutClassStartingEquipmentOptionInput>, ArmorUncheckedUpdateWithoutClassStartingEquipmentOptionInput>
  }

  export type EquipmentPackUpdateOneWithoutClassStartingEquipmentOptionsNestedInput = {
    create?: XOR<EquipmentPackCreateWithoutClassStartingEquipmentOptionsInput, EquipmentPackUncheckedCreateWithoutClassStartingEquipmentOptionsInput>
    connectOrCreate?: EquipmentPackCreateOrConnectWithoutClassStartingEquipmentOptionsInput
    upsert?: EquipmentPackUpsertWithoutClassStartingEquipmentOptionsInput
    disconnect?: EquipmentPackWhereInput | boolean
    delete?: EquipmentPackWhereInput | boolean
    connect?: EquipmentPackWhereUniqueInput
    update?: XOR<XOR<EquipmentPackUpdateToOneWithWhereWithoutClassStartingEquipmentOptionsInput, EquipmentPackUpdateWithoutClassStartingEquipmentOptionsInput>, EquipmentPackUncheckedUpdateWithoutClassStartingEquipmentOptionsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.Source | EnumSourceFieldRefInput<$PrismaModel>
    in?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceFilter<$PrismaModel> | $Enums.Source
  }

  export type NestedEnumSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Source | EnumSourceFieldRefInput<$PrismaModel>
    in?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Source[] | ListEnumSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceWithAggregatesFilter<$PrismaModel> | $Enums.Source
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSourceFilter<$PrismaModel>
    _max?: NestedEnumSourceFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumAbilityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Ability | EnumAbilityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAbilityNullableFilter<$PrismaModel> | $Enums.Ability | null
  }

  export type NestedEnumSpellcastingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SpellcastingType | EnumSpellcastingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SpellcastingType[] | ListEnumSpellcastingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpellcastingType[] | ListEnumSpellcastingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpellcastingTypeFilter<$PrismaModel> | $Enums.SpellcastingType
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumAbilityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Ability | EnumAbilityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAbilityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Ability | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAbilityNullableFilter<$PrismaModel>
    _max?: NestedEnumAbilityNullableFilter<$PrismaModel>
  }

  export type NestedEnumSpellcastingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpellcastingType | EnumSpellcastingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SpellcastingType[] | ListEnumSpellcastingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpellcastingType[] | ListEnumSpellcastingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpellcastingTypeWithAggregatesFilter<$PrismaModel> | $Enums.SpellcastingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpellcastingTypeFilter<$PrismaModel>
    _max?: NestedEnumSpellcastingTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumRestTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RestType | EnumRestTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RestType[] | ListEnumRestTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RestType[] | ListEnumRestTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRestTypeNullableFilter<$PrismaModel> | $Enums.RestType | null
  }

  export type NestedEnumFeatureDisplayTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureDisplayType | EnumFeatureDisplayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureDisplayType[] | ListEnumFeatureDisplayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureDisplayType[] | ListEnumFeatureDisplayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureDisplayTypeFilter<$PrismaModel> | $Enums.FeatureDisplayType
  }

  export type NestedEnumRestTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RestType | EnumRestTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RestType[] | ListEnumRestTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RestType[] | ListEnumRestTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRestTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RestType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRestTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumRestTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumFeatureDisplayTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatureDisplayType | EnumFeatureDisplayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeatureDisplayType[] | ListEnumFeatureDisplayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatureDisplayType[] | ListEnumFeatureDisplayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatureDisplayTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeatureDisplayType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeatureDisplayTypeFilter<$PrismaModel>
    _max?: NestedEnumFeatureDisplayTypeFilter<$PrismaModel>
  }

  export type NestedEnumRacesFilter<$PrismaModel = never> = {
    equals?: $Enums.Races | EnumRacesFieldRefInput<$PrismaModel>
    in?: $Enums.Races[] | ListEnumRacesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Races[] | ListEnumRacesFieldRefInput<$PrismaModel>
    not?: NestedEnumRacesFilter<$PrismaModel> | $Enums.Races
  }

  export type NestedEnumRacesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Races | EnumRacesFieldRefInput<$PrismaModel>
    in?: $Enums.Races[] | ListEnumRacesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Races[] | ListEnumRacesFieldRefInput<$PrismaModel>
    not?: NestedEnumRacesWithAggregatesFilter<$PrismaModel> | $Enums.Races
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRacesFilter<$PrismaModel>
    _max?: NestedEnumRacesFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSubracesFilter<$PrismaModel = never> = {
    equals?: $Enums.Subraces | EnumSubracesFieldRefInput<$PrismaModel>
    in?: $Enums.Subraces[] | ListEnumSubracesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Subraces[] | ListEnumSubracesFieldRefInput<$PrismaModel>
    not?: NestedEnumSubracesFilter<$PrismaModel> | $Enums.Subraces
  }

  export type NestedEnumSubracesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Subraces | EnumSubracesFieldRefInput<$PrismaModel>
    in?: $Enums.Subraces[] | ListEnumSubracesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Subraces[] | ListEnumSubracesFieldRefInput<$PrismaModel>
    not?: NestedEnumSubracesWithAggregatesFilter<$PrismaModel> | $Enums.Subraces
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubracesFilter<$PrismaModel>
    _max?: NestedEnumSubracesFilter<$PrismaModel>
  }

  export type NestedEnumVariantsFilter<$PrismaModel = never> = {
    equals?: $Enums.Variants | EnumVariantsFieldRefInput<$PrismaModel>
    in?: $Enums.Variants[] | ListEnumVariantsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Variants[] | ListEnumVariantsFieldRefInput<$PrismaModel>
    not?: NestedEnumVariantsFilter<$PrismaModel> | $Enums.Variants
  }

  export type NestedEnumVariantsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Variants | EnumVariantsFieldRefInput<$PrismaModel>
    in?: $Enums.Variants[] | ListEnumVariantsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Variants[] | ListEnumVariantsFieldRefInput<$PrismaModel>
    not?: NestedEnumVariantsWithAggregatesFilter<$PrismaModel> | $Enums.Variants
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVariantsFilter<$PrismaModel>
    _max?: NestedEnumVariantsFilter<$PrismaModel>
  }

  export type NestedEnumDamageTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DamageType | EnumDamageTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDamageTypeNullableFilter<$PrismaModel> | $Enums.DamageType | null
  }

  export type NestedEnumAOEShapesNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AOEShapes | EnumAOEShapesFieldRefInput<$PrismaModel> | null
    in?: $Enums.AOEShapes[] | ListEnumAOEShapesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AOEShapes[] | ListEnumAOEShapesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAOEShapesNullableFilter<$PrismaModel> | $Enums.AOEShapes | null
  }

  export type NestedEnumDamageTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DamageType | EnumDamageTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDamageTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DamageType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDamageTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDamageTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAOEShapesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AOEShapes | EnumAOEShapesFieldRefInput<$PrismaModel> | null
    in?: $Enums.AOEShapes[] | ListEnumAOEShapesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AOEShapes[] | ListEnumAOEShapesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAOEShapesNullableWithAggregatesFilter<$PrismaModel> | $Enums.AOEShapes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAOEShapesNullableFilter<$PrismaModel>
    _max?: NestedEnumAOEShapesNullableFilter<$PrismaModel>
  }

  export type NestedEnumBackgroundCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.BackgroundCategory | EnumBackgroundCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BackgroundCategory[] | ListEnumBackgroundCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BackgroundCategory[] | ListEnumBackgroundCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBackgroundCategoryFilter<$PrismaModel> | $Enums.BackgroundCategory
  }

  export type NestedEnumBackgroundCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BackgroundCategory | EnumBackgroundCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BackgroundCategory[] | ListEnumBackgroundCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BackgroundCategory[] | ListEnumBackgroundCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBackgroundCategoryWithAggregatesFilter<$PrismaModel> | $Enums.BackgroundCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBackgroundCategoryFilter<$PrismaModel>
    _max?: NestedEnumBackgroundCategoryFilter<$PrismaModel>
  }

  export type NestedEnumFeatCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatCategory | EnumFeatCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeatCategory[] | ListEnumFeatCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatCategory[] | ListEnumFeatCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatCategoryFilter<$PrismaModel> | $Enums.FeatCategory
  }

  export type NestedEnumFeatCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeatCategory | EnumFeatCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeatCategory[] | ListEnumFeatCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeatCategory[] | ListEnumFeatCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeatCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FeatCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeatCategoryFilter<$PrismaModel>
    _max?: NestedEnumFeatCategoryFilter<$PrismaModel>
  }

  export type NestedEnumMagicItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MagicItemType | EnumMagicItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MagicItemType[] | ListEnumMagicItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MagicItemType[] | ListEnumMagicItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMagicItemTypeFilter<$PrismaModel> | $Enums.MagicItemType
  }

  export type NestedEnumItemRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityFilter<$PrismaModel> | $Enums.ItemRarity
  }

  export type NestedEnumMagicItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MagicItemType | EnumMagicItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MagicItemType[] | ListEnumMagicItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MagicItemType[] | ListEnumMagicItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMagicItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.MagicItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMagicItemTypeFilter<$PrismaModel>
    _max?: NestedEnumMagicItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumItemRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityWithAggregatesFilter<$PrismaModel> | $Enums.ItemRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemRarityFilter<$PrismaModel>
    _max?: NestedEnumItemRarityFilter<$PrismaModel>
  }

  export type NestedEnumWeaponCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponCategory | EnumWeaponCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.WeaponCategory[] | ListEnumWeaponCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeaponCategory[] | ListEnumWeaponCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumWeaponCategoryFilter<$PrismaModel> | $Enums.WeaponCategory
  }

  export type NestedEnumDamageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DamageType | EnumDamageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDamageTypeFilter<$PrismaModel> | $Enums.DamageType
  }

  export type NestedEnumWeaponTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponType | EnumWeaponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWeaponTypeFilter<$PrismaModel> | $Enums.WeaponType
  }

  export type NestedEnumWeaponCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponCategory | EnumWeaponCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.WeaponCategory[] | ListEnumWeaponCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeaponCategory[] | ListEnumWeaponCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumWeaponCategoryWithAggregatesFilter<$PrismaModel> | $Enums.WeaponCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeaponCategoryFilter<$PrismaModel>
    _max?: NestedEnumWeaponCategoryFilter<$PrismaModel>
  }

  export type NestedEnumDamageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DamageType | EnumDamageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDamageTypeWithAggregatesFilter<$PrismaModel> | $Enums.DamageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDamageTypeFilter<$PrismaModel>
    _max?: NestedEnumDamageTypeFilter<$PrismaModel>
  }

  export type NestedEnumWeaponTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponType | EnumWeaponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWeaponTypeWithAggregatesFilter<$PrismaModel> | $Enums.WeaponType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeaponTypeFilter<$PrismaModel>
    _max?: NestedEnumWeaponTypeFilter<$PrismaModel>
  }

  export type NestedEnumArmorCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ArmorCategory | EnumArmorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ArmorCategory[] | ListEnumArmorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArmorCategory[] | ListEnumArmorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumArmorCategoryFilter<$PrismaModel> | $Enums.ArmorCategory
  }

  export type NestedEnumArmorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ArmorType | EnumArmorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArmorTypeFilter<$PrismaModel> | $Enums.ArmorType
  }

  export type NestedEnumArmorCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArmorCategory | EnumArmorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ArmorCategory[] | ListEnumArmorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArmorCategory[] | ListEnumArmorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumArmorCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ArmorCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArmorCategoryFilter<$PrismaModel>
    _max?: NestedEnumArmorCategoryFilter<$PrismaModel>
  }

  export type NestedEnumArmorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArmorType | EnumArmorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArmorTypeWithAggregatesFilter<$PrismaModel> | $Enums.ArmorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArmorTypeFilter<$PrismaModel>
    _max?: NestedEnumArmorTypeFilter<$PrismaModel>
  }

  export type NestedEnumSkillProficiencyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillProficiencyType | EnumSkillProficiencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SkillProficiencyType[] | ListEnumSkillProficiencyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillProficiencyType[] | ListEnumSkillProficiencyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillProficiencyTypeFilter<$PrismaModel> | $Enums.SkillProficiencyType
  }

  export type NestedEnumSkillsFilter<$PrismaModel = never> = {
    equals?: $Enums.Skills | EnumSkillsFieldRefInput<$PrismaModel>
    in?: $Enums.Skills[] | ListEnumSkillsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Skills[] | ListEnumSkillsFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillsFilter<$PrismaModel> | $Enums.Skills
  }

  export type NestedEnumSkillProficiencyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillProficiencyType | EnumSkillProficiencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SkillProficiencyType[] | ListEnumSkillProficiencyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillProficiencyType[] | ListEnumSkillProficiencyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillProficiencyTypeWithAggregatesFilter<$PrismaModel> | $Enums.SkillProficiencyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillProficiencyTypeFilter<$PrismaModel>
    _max?: NestedEnumSkillProficiencyTypeFilter<$PrismaModel>
  }

  export type NestedEnumSkillsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Skills | EnumSkillsFieldRefInput<$PrismaModel>
    in?: $Enums.Skills[] | ListEnumSkillsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Skills[] | ListEnumSkillsFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillsWithAggregatesFilter<$PrismaModel> | $Enums.Skills
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillsFilter<$PrismaModel>
    _max?: NestedEnumSkillsFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentPackCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentPackCategory | EnumEquipmentPackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentPackCategory[] | ListEnumEquipmentPackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentPackCategory[] | ListEnumEquipmentPackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentPackCategoryFilter<$PrismaModel> | $Enums.EquipmentPackCategory
  }

  export type NestedEnumEquipmentPackCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentPackCategory | EnumEquipmentPackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentPackCategory[] | ListEnumEquipmentPackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentPackCategory[] | ListEnumEquipmentPackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentPackCategoryWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentPackCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentPackCategoryFilter<$PrismaModel>
    _max?: NestedEnumEquipmentPackCategoryFilter<$PrismaModel>
  }

  export type NestedEnumArmorTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ArmorType | EnumArmorTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumArmorTypeNullableFilter<$PrismaModel> | $Enums.ArmorType | null
  }

  export type NestedEnumWeaponTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponType | EnumWeaponTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWeaponTypeNullableFilter<$PrismaModel> | $Enums.WeaponType | null
  }

  export type NestedEnumArmorTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArmorType | EnumArmorTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ArmorType[] | ListEnumArmorTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumArmorTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ArmorType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumArmorTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumArmorTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumWeaponTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeaponType | EnumWeaponTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.WeaponType[] | ListEnumWeaponTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumWeaponTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.WeaponType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumWeaponTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumWeaponTypeNullableFilter<$PrismaModel>
  }

  export type UserCreateWithoutCharacterInput = {
    login: string
    password?: string | null
    spellbook?: SpellbookCreateNestedManyWithoutUserInput
    pers?: PersCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCharacterInput = {
    userId?: number
    login: string
    password?: string | null
    spellbook?: SpellbookUncheckedCreateNestedManyWithoutUserInput
    pers?: PersUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCharacterInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCharacterInput, UserUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterSpellsCreateWithoutCharacterInput = {
    spell?: SpellCreateNestedOneWithoutCharacterSpellsInput
  }

  export type CharacterSpellsUncheckedCreateWithoutCharacterInput = {
    characterSpellId?: number
    spellId?: number | null
  }

  export type CharacterSpellsCreateOrConnectWithoutCharacterInput = {
    where: CharacterSpellsWhereUniqueInput
    create: XOR<CharacterSpellsCreateWithoutCharacterInput, CharacterSpellsUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterSpellsCreateManyCharacterInputEnvelope = {
    data: CharacterSpellsCreateManyCharacterInput | CharacterSpellsCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCharacterInput = {
    update: XOR<UserUpdateWithoutCharacterInput, UserUncheckedUpdateWithoutCharacterInput>
    create: XOR<UserCreateWithoutCharacterInput, UserUncheckedCreateWithoutCharacterInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCharacterInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCharacterInput, UserUncheckedUpdateWithoutCharacterInput>
  }

  export type UserUpdateWithoutCharacterInput = {
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    spellbook?: SpellbookUpdateManyWithoutUserNestedInput
    pers?: PersUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCharacterInput = {
    userId?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    spellbook?: SpellbookUncheckedUpdateManyWithoutUserNestedInput
    pers?: PersUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CharacterSpellsUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CharacterSpellsWhereUniqueInput
    update: XOR<CharacterSpellsUpdateWithoutCharacterInput, CharacterSpellsUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacterSpellsCreateWithoutCharacterInput, CharacterSpellsUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterSpellsUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CharacterSpellsWhereUniqueInput
    data: XOR<CharacterSpellsUpdateWithoutCharacterInput, CharacterSpellsUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterSpellsUpdateManyWithWhereWithoutCharacterInput = {
    where: CharacterSpellsScalarWhereInput
    data: XOR<CharacterSpellsUpdateManyMutationInput, CharacterSpellsUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterSpellsScalarWhereInput = {
    AND?: CharacterSpellsScalarWhereInput | CharacterSpellsScalarWhereInput[]
    OR?: CharacterSpellsScalarWhereInput[]
    NOT?: CharacterSpellsScalarWhereInput | CharacterSpellsScalarWhereInput[]
    characterSpellId?: IntFilter<"CharacterSpells"> | number
    characterId?: IntNullableFilter<"CharacterSpells"> | number | null
    spellId?: IntNullableFilter<"CharacterSpells"> | number | null
  }

  export type CharacterCreateWithoutCharacterSpellsInput = {
    name?: string | null
    user?: UserCreateNestedOneWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutCharacterSpellsInput = {
    characterId?: number
    name?: string | null
    userId?: number | null
  }

  export type CharacterCreateOrConnectWithoutCharacterSpellsInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutCharacterSpellsInput, CharacterUncheckedCreateWithoutCharacterSpellsInput>
  }

  export type SpellCreateWithoutCharacterSpellsInput = {
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    spellClasses?: SpellClassesCreateNestedManyWithoutSpellInput
    spellRaces?: SpellRacesCreateNestedManyWithoutSpellInput
    spellbookSpells?: SpellbookSpellsCreateNestedManyWithoutSpellInput
    subclasses?: SubclassCreateNestedManyWithoutExpandedSpellsInput
    perses?: PersCreateNestedManyWithoutSpellsInput
    features?: FeatureCreateNestedManyWithoutGivesSpellsInput
  }

  export type SpellUncheckedCreateWithoutCharacterSpellsInput = {
    spellId?: number
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    spellClasses?: SpellClassesUncheckedCreateNestedManyWithoutSpellInput
    spellRaces?: SpellRacesUncheckedCreateNestedManyWithoutSpellInput
    spellbookSpells?: SpellbookSpellsUncheckedCreateNestedManyWithoutSpellInput
    subclasses?: SubclassUncheckedCreateNestedManyWithoutExpandedSpellsInput
    perses?: PersUncheckedCreateNestedManyWithoutSpellsInput
    features?: FeatureUncheckedCreateNestedManyWithoutGivesSpellsInput
  }

  export type SpellCreateOrConnectWithoutCharacterSpellsInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutCharacterSpellsInput, SpellUncheckedCreateWithoutCharacterSpellsInput>
  }

  export type CharacterUpsertWithoutCharacterSpellsInput = {
    update: XOR<CharacterUpdateWithoutCharacterSpellsInput, CharacterUncheckedUpdateWithoutCharacterSpellsInput>
    create: XOR<CharacterCreateWithoutCharacterSpellsInput, CharacterUncheckedCreateWithoutCharacterSpellsInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutCharacterSpellsInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutCharacterSpellsInput, CharacterUncheckedUpdateWithoutCharacterSpellsInput>
  }

  export type CharacterUpdateWithoutCharacterSpellsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutCharacterSpellsInput = {
    characterId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellUpsertWithoutCharacterSpellsInput = {
    update: XOR<SpellUpdateWithoutCharacterSpellsInput, SpellUncheckedUpdateWithoutCharacterSpellsInput>
    create: XOR<SpellCreateWithoutCharacterSpellsInput, SpellUncheckedCreateWithoutCharacterSpellsInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutCharacterSpellsInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutCharacterSpellsInput, SpellUncheckedUpdateWithoutCharacterSpellsInput>
  }

  export type SpellUpdateWithoutCharacterSpellsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    spellClasses?: SpellClassesUpdateManyWithoutSpellNestedInput
    spellRaces?: SpellRacesUpdateManyWithoutSpellNestedInput
    spellbookSpells?: SpellbookSpellsUpdateManyWithoutSpellNestedInput
    subclasses?: SubclassUpdateManyWithoutExpandedSpellsNestedInput
    perses?: PersUpdateManyWithoutSpellsNestedInput
    features?: FeatureUpdateManyWithoutGivesSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutCharacterSpellsInput = {
    spellId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    spellClasses?: SpellClassesUncheckedUpdateManyWithoutSpellNestedInput
    spellRaces?: SpellRacesUncheckedUpdateManyWithoutSpellNestedInput
    spellbookSpells?: SpellbookSpellsUncheckedUpdateManyWithoutSpellNestedInput
    subclasses?: SubclassUncheckedUpdateManyWithoutExpandedSpellsNestedInput
    perses?: PersUncheckedUpdateManyWithoutSpellsNestedInput
    features?: FeatureUncheckedUpdateManyWithoutGivesSpellsNestedInput
  }

  export type CharacterSpellsCreateWithoutSpellInput = {
    character?: CharacterCreateNestedOneWithoutCharacterSpellsInput
  }

  export type CharacterSpellsUncheckedCreateWithoutSpellInput = {
    characterSpellId?: number
    characterId?: number | null
  }

  export type CharacterSpellsCreateOrConnectWithoutSpellInput = {
    where: CharacterSpellsWhereUniqueInput
    create: XOR<CharacterSpellsCreateWithoutSpellInput, CharacterSpellsUncheckedCreateWithoutSpellInput>
  }

  export type CharacterSpellsCreateManySpellInputEnvelope = {
    data: CharacterSpellsCreateManySpellInput | CharacterSpellsCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type SpellClassesCreateWithoutSpellInput = {
    className: string
  }

  export type SpellClassesUncheckedCreateWithoutSpellInput = {
    classId?: number
    className: string
  }

  export type SpellClassesCreateOrConnectWithoutSpellInput = {
    where: SpellClassesWhereUniqueInput
    create: XOR<SpellClassesCreateWithoutSpellInput, SpellClassesUncheckedCreateWithoutSpellInput>
  }

  export type SpellClassesCreateManySpellInputEnvelope = {
    data: SpellClassesCreateManySpellInput | SpellClassesCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type SpellRacesCreateWithoutSpellInput = {
    raceName?: string | null
  }

  export type SpellRacesUncheckedCreateWithoutSpellInput = {
    raceId?: number
    raceName?: string | null
  }

  export type SpellRacesCreateOrConnectWithoutSpellInput = {
    where: SpellRacesWhereUniqueInput
    create: XOR<SpellRacesCreateWithoutSpellInput, SpellRacesUncheckedCreateWithoutSpellInput>
  }

  export type SpellRacesCreateManySpellInputEnvelope = {
    data: SpellRacesCreateManySpellInput | SpellRacesCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type SpellbookSpellsCreateWithoutSpellInput = {
    spellbook?: SpellbookCreateNestedOneWithoutSpellbookSpellsInput
  }

  export type SpellbookSpellsUncheckedCreateWithoutSpellInput = {
    spellbookSpellId?: number
    spellbookId?: number | null
  }

  export type SpellbookSpellsCreateOrConnectWithoutSpellInput = {
    where: SpellbookSpellsWhereUniqueInput
    create: XOR<SpellbookSpellsCreateWithoutSpellInput, SpellbookSpellsUncheckedCreateWithoutSpellInput>
  }

  export type SpellbookSpellsCreateManySpellInputEnvelope = {
    data: SpellbookSpellsCreateManySpellInput | SpellbookSpellsCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type SubclassCreateWithoutExpandedSpellsInput = {
    name: string
    description?: string | null
    grantsSpells?: boolean
    languagesToChooseCount?: number
    languages?: SubclassCreatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    class: ClassCreateNestedOneWithoutSubclassesInput
    features?: SubclassFeatureCreateNestedManyWithoutSubclassInput
    perses?: PersCreateNestedManyWithoutSubclassInput
    persMulticlasses?: PersMulticlassCreateNestedManyWithoutSubclassInput
  }

  export type SubclassUncheckedCreateWithoutExpandedSpellsInput = {
    subclassId?: number
    classId: number
    name: string
    description?: string | null
    grantsSpells?: boolean
    languagesToChooseCount?: number
    languages?: SubclassCreatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    features?: SubclassFeatureUncheckedCreateNestedManyWithoutSubclassInput
    perses?: PersUncheckedCreateNestedManyWithoutSubclassInput
    persMulticlasses?: PersMulticlassUncheckedCreateNestedManyWithoutSubclassInput
  }

  export type SubclassCreateOrConnectWithoutExpandedSpellsInput = {
    where: SubclassWhereUniqueInput
    create: XOR<SubclassCreateWithoutExpandedSpellsInput, SubclassUncheckedCreateWithoutExpandedSpellsInput>
  }

  export type PersCreateWithoutSpellsInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    class: ClassCreateNestedOneWithoutPersesInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutSpellsInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutSpellsInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutSpellsInput, PersUncheckedCreateWithoutSpellsInput>
  }

  export type FeatureCreateWithoutGivesSpellsInput = {
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    classFeatures?: ClassFeatureCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutGivesSpellsInput = {
    featureId?: number
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    classFeatures?: ClassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitUncheckedCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureUncheckedCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureUncheckedCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutGivesSpellsInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutGivesSpellsInput, FeatureUncheckedCreateWithoutGivesSpellsInput>
  }

  export type CharacterSpellsUpsertWithWhereUniqueWithoutSpellInput = {
    where: CharacterSpellsWhereUniqueInput
    update: XOR<CharacterSpellsUpdateWithoutSpellInput, CharacterSpellsUncheckedUpdateWithoutSpellInput>
    create: XOR<CharacterSpellsCreateWithoutSpellInput, CharacterSpellsUncheckedCreateWithoutSpellInput>
  }

  export type CharacterSpellsUpdateWithWhereUniqueWithoutSpellInput = {
    where: CharacterSpellsWhereUniqueInput
    data: XOR<CharacterSpellsUpdateWithoutSpellInput, CharacterSpellsUncheckedUpdateWithoutSpellInput>
  }

  export type CharacterSpellsUpdateManyWithWhereWithoutSpellInput = {
    where: CharacterSpellsScalarWhereInput
    data: XOR<CharacterSpellsUpdateManyMutationInput, CharacterSpellsUncheckedUpdateManyWithoutSpellInput>
  }

  export type SpellClassesUpsertWithWhereUniqueWithoutSpellInput = {
    where: SpellClassesWhereUniqueInput
    update: XOR<SpellClassesUpdateWithoutSpellInput, SpellClassesUncheckedUpdateWithoutSpellInput>
    create: XOR<SpellClassesCreateWithoutSpellInput, SpellClassesUncheckedCreateWithoutSpellInput>
  }

  export type SpellClassesUpdateWithWhereUniqueWithoutSpellInput = {
    where: SpellClassesWhereUniqueInput
    data: XOR<SpellClassesUpdateWithoutSpellInput, SpellClassesUncheckedUpdateWithoutSpellInput>
  }

  export type SpellClassesUpdateManyWithWhereWithoutSpellInput = {
    where: SpellClassesScalarWhereInput
    data: XOR<SpellClassesUpdateManyMutationInput, SpellClassesUncheckedUpdateManyWithoutSpellInput>
  }

  export type SpellClassesScalarWhereInput = {
    AND?: SpellClassesScalarWhereInput | SpellClassesScalarWhereInput[]
    OR?: SpellClassesScalarWhereInput[]
    NOT?: SpellClassesScalarWhereInput | SpellClassesScalarWhereInput[]
    classId?: IntFilter<"SpellClasses"> | number
    spellId?: IntFilter<"SpellClasses"> | number
    className?: StringFilter<"SpellClasses"> | string
  }

  export type SpellRacesUpsertWithWhereUniqueWithoutSpellInput = {
    where: SpellRacesWhereUniqueInput
    update: XOR<SpellRacesUpdateWithoutSpellInput, SpellRacesUncheckedUpdateWithoutSpellInput>
    create: XOR<SpellRacesCreateWithoutSpellInput, SpellRacesUncheckedCreateWithoutSpellInput>
  }

  export type SpellRacesUpdateWithWhereUniqueWithoutSpellInput = {
    where: SpellRacesWhereUniqueInput
    data: XOR<SpellRacesUpdateWithoutSpellInput, SpellRacesUncheckedUpdateWithoutSpellInput>
  }

  export type SpellRacesUpdateManyWithWhereWithoutSpellInput = {
    where: SpellRacesScalarWhereInput
    data: XOR<SpellRacesUpdateManyMutationInput, SpellRacesUncheckedUpdateManyWithoutSpellInput>
  }

  export type SpellRacesScalarWhereInput = {
    AND?: SpellRacesScalarWhereInput | SpellRacesScalarWhereInput[]
    OR?: SpellRacesScalarWhereInput[]
    NOT?: SpellRacesScalarWhereInput | SpellRacesScalarWhereInput[]
    spellId?: IntNullableFilter<"SpellRaces"> | number | null
    raceId?: IntFilter<"SpellRaces"> | number
    raceName?: StringNullableFilter<"SpellRaces"> | string | null
  }

  export type SpellbookSpellsUpsertWithWhereUniqueWithoutSpellInput = {
    where: SpellbookSpellsWhereUniqueInput
    update: XOR<SpellbookSpellsUpdateWithoutSpellInput, SpellbookSpellsUncheckedUpdateWithoutSpellInput>
    create: XOR<SpellbookSpellsCreateWithoutSpellInput, SpellbookSpellsUncheckedCreateWithoutSpellInput>
  }

  export type SpellbookSpellsUpdateWithWhereUniqueWithoutSpellInput = {
    where: SpellbookSpellsWhereUniqueInput
    data: XOR<SpellbookSpellsUpdateWithoutSpellInput, SpellbookSpellsUncheckedUpdateWithoutSpellInput>
  }

  export type SpellbookSpellsUpdateManyWithWhereWithoutSpellInput = {
    where: SpellbookSpellsScalarWhereInput
    data: XOR<SpellbookSpellsUpdateManyMutationInput, SpellbookSpellsUncheckedUpdateManyWithoutSpellInput>
  }

  export type SpellbookSpellsScalarWhereInput = {
    AND?: SpellbookSpellsScalarWhereInput | SpellbookSpellsScalarWhereInput[]
    OR?: SpellbookSpellsScalarWhereInput[]
    NOT?: SpellbookSpellsScalarWhereInput | SpellbookSpellsScalarWhereInput[]
    spellbookSpellId?: IntFilter<"SpellbookSpells"> | number
    spellId?: IntNullableFilter<"SpellbookSpells"> | number | null
    spellbookId?: IntNullableFilter<"SpellbookSpells"> | number | null
  }

  export type SubclassUpsertWithWhereUniqueWithoutExpandedSpellsInput = {
    where: SubclassWhereUniqueInput
    update: XOR<SubclassUpdateWithoutExpandedSpellsInput, SubclassUncheckedUpdateWithoutExpandedSpellsInput>
    create: XOR<SubclassCreateWithoutExpandedSpellsInput, SubclassUncheckedCreateWithoutExpandedSpellsInput>
  }

  export type SubclassUpdateWithWhereUniqueWithoutExpandedSpellsInput = {
    where: SubclassWhereUniqueInput
    data: XOR<SubclassUpdateWithoutExpandedSpellsInput, SubclassUncheckedUpdateWithoutExpandedSpellsInput>
  }

  export type SubclassUpdateManyWithWhereWithoutExpandedSpellsInput = {
    where: SubclassScalarWhereInput
    data: XOR<SubclassUpdateManyMutationInput, SubclassUncheckedUpdateManyWithoutExpandedSpellsInput>
  }

  export type SubclassScalarWhereInput = {
    AND?: SubclassScalarWhereInput | SubclassScalarWhereInput[]
    OR?: SubclassScalarWhereInput[]
    NOT?: SubclassScalarWhereInput | SubclassScalarWhereInput[]
    subclassId?: IntFilter<"Subclass"> | number
    classId?: IntFilter<"Subclass"> | number
    name?: StringFilter<"Subclass"> | string
    description?: StringNullableFilter<"Subclass"> | string | null
    grantsSpells?: BoolFilter<"Subclass"> | boolean
    languagesToChooseCount?: IntFilter<"Subclass"> | number
    languages?: EnumLanguageNullableListFilter<"Subclass">
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Subclass">
  }

  export type PersUpsertWithWhereUniqueWithoutSpellsInput = {
    where: PersWhereUniqueInput
    update: XOR<PersUpdateWithoutSpellsInput, PersUncheckedUpdateWithoutSpellsInput>
    create: XOR<PersCreateWithoutSpellsInput, PersUncheckedCreateWithoutSpellsInput>
  }

  export type PersUpdateWithWhereUniqueWithoutSpellsInput = {
    where: PersWhereUniqueInput
    data: XOR<PersUpdateWithoutSpellsInput, PersUncheckedUpdateWithoutSpellsInput>
  }

  export type PersUpdateManyWithWhereWithoutSpellsInput = {
    where: PersScalarWhereInput
    data: XOR<PersUpdateManyMutationInput, PersUncheckedUpdateManyWithoutSpellsInput>
  }

  export type PersScalarWhereInput = {
    AND?: PersScalarWhereInput | PersScalarWhereInput[]
    OR?: PersScalarWhereInput[]
    NOT?: PersScalarWhereInput | PersScalarWhereInput[]
    persId?: IntFilter<"Pers"> | number
    userId?: IntFilter<"Pers"> | number
    name?: StringFilter<"Pers"> | string
    level?: IntFilter<"Pers"> | number
    currentSpellSlots?: IntNullableListFilter<"Pers">
    classId?: IntFilter<"Pers"> | number
    subclassId?: IntNullableFilter<"Pers"> | number | null
    backgroundId?: IntFilter<"Pers"> | number
    raceId?: IntFilter<"Pers"> | number
    subraceId?: IntNullableFilter<"Pers"> | number | null
    currentHp?: IntFilter<"Pers"> | number
    maxHp?: IntFilter<"Pers"> | number
    tempHp?: IntFilter<"Pers"> | number
    raceCustom?: StringFilter<"Pers"> | string
    classCustom?: StringFilter<"Pers"> | string
    alignment?: StringFilter<"Pers"> | string
    xp?: IntFilter<"Pers"> | number
    customBackground?: StringFilter<"Pers"> | string
    customFeatures?: StringFilter<"Pers"> | string
    customLanguagesKnown?: StringFilter<"Pers"> | string
    customEquipment?: StringFilter<"Pers"> | string
    personalityTraits?: StringFilter<"Pers"> | string
    ideals?: StringFilter<"Pers"> | string
    bonds?: StringFilter<"Pers"> | string
    flaws?: StringFilter<"Pers"> | string
    backstory?: StringFilter<"Pers"> | string
    notes?: StringFilter<"Pers"> | string
    str?: IntFilter<"Pers"> | number
    dex?: IntFilter<"Pers"> | number
    con?: IntFilter<"Pers"> | number
    int?: IntFilter<"Pers"> | number
    wis?: IntFilter<"Pers"> | number
    cha?: IntFilter<"Pers"> | number
    cp?: IntFilter<"Pers"> | number
    sp?: IntFilter<"Pers"> | number
    ep?: IntFilter<"Pers"> | number
    gp?: IntFilter<"Pers"> | number
    pp?: IntFilter<"Pers"> | number
    additionalSaveProficiencies?: EnumAbilityNullableListFilter<"Pers">
    miscSaveBonuses?: JsonNullableFilter<"Pers">
    createdAt?: DateTimeFilter<"Pers"> | Date | string
    updatedAt?: DateTimeFilter<"Pers"> | Date | string
  }

  export type FeatureUpsertWithWhereUniqueWithoutGivesSpellsInput = {
    where: FeatureWhereUniqueInput
    update: XOR<FeatureUpdateWithoutGivesSpellsInput, FeatureUncheckedUpdateWithoutGivesSpellsInput>
    create: XOR<FeatureCreateWithoutGivesSpellsInput, FeatureUncheckedCreateWithoutGivesSpellsInput>
  }

  export type FeatureUpdateWithWhereUniqueWithoutGivesSpellsInput = {
    where: FeatureWhereUniqueInput
    data: XOR<FeatureUpdateWithoutGivesSpellsInput, FeatureUncheckedUpdateWithoutGivesSpellsInput>
  }

  export type FeatureUpdateManyWithWhereWithoutGivesSpellsInput = {
    where: FeatureScalarWhereInput
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyWithoutGivesSpellsInput>
  }

  export type FeatureScalarWhereInput = {
    AND?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
    OR?: FeatureScalarWhereInput[]
    NOT?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
    featureId?: IntFilter<"Feature"> | number
    name?: StringFilter<"Feature"> | string
    description?: StringFilter<"Feature"> | string
    shortDescription?: StringNullableFilter<"Feature"> | string | null
    modifiesStats?: JsonNullableFilter<"Feature">
    limitedUsesPer?: EnumRestTypeNullableFilter<"Feature"> | $Enums.RestType | null
    usesCount?: IntNullableFilter<"Feature"> | number | null
    displayType?: EnumFeatureDisplayTypeFilter<"Feature"> | $Enums.FeatureDisplayType
    createdAt?: DateTimeFilter<"Feature"> | Date | string
    updatedAt?: DateTimeFilter<"Feature"> | Date | string
  }

  export type SpellCreateWithoutSpellClassesInput = {
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    characterSpells?: CharacterSpellsCreateNestedManyWithoutSpellInput
    spellRaces?: SpellRacesCreateNestedManyWithoutSpellInput
    spellbookSpells?: SpellbookSpellsCreateNestedManyWithoutSpellInput
    subclasses?: SubclassCreateNestedManyWithoutExpandedSpellsInput
    perses?: PersCreateNestedManyWithoutSpellsInput
    features?: FeatureCreateNestedManyWithoutGivesSpellsInput
  }

  export type SpellUncheckedCreateWithoutSpellClassesInput = {
    spellId?: number
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    characterSpells?: CharacterSpellsUncheckedCreateNestedManyWithoutSpellInput
    spellRaces?: SpellRacesUncheckedCreateNestedManyWithoutSpellInput
    spellbookSpells?: SpellbookSpellsUncheckedCreateNestedManyWithoutSpellInput
    subclasses?: SubclassUncheckedCreateNestedManyWithoutExpandedSpellsInput
    perses?: PersUncheckedCreateNestedManyWithoutSpellsInput
    features?: FeatureUncheckedCreateNestedManyWithoutGivesSpellsInput
  }

  export type SpellCreateOrConnectWithoutSpellClassesInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutSpellClassesInput, SpellUncheckedCreateWithoutSpellClassesInput>
  }

  export type SpellUpsertWithoutSpellClassesInput = {
    update: XOR<SpellUpdateWithoutSpellClassesInput, SpellUncheckedUpdateWithoutSpellClassesInput>
    create: XOR<SpellCreateWithoutSpellClassesInput, SpellUncheckedCreateWithoutSpellClassesInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutSpellClassesInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutSpellClassesInput, SpellUncheckedUpdateWithoutSpellClassesInput>
  }

  export type SpellUpdateWithoutSpellClassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    characterSpells?: CharacterSpellsUpdateManyWithoutSpellNestedInput
    spellRaces?: SpellRacesUpdateManyWithoutSpellNestedInput
    spellbookSpells?: SpellbookSpellsUpdateManyWithoutSpellNestedInput
    subclasses?: SubclassUpdateManyWithoutExpandedSpellsNestedInput
    perses?: PersUpdateManyWithoutSpellsNestedInput
    features?: FeatureUpdateManyWithoutGivesSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutSpellClassesInput = {
    spellId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    characterSpells?: CharacterSpellsUncheckedUpdateManyWithoutSpellNestedInput
    spellRaces?: SpellRacesUncheckedUpdateManyWithoutSpellNestedInput
    spellbookSpells?: SpellbookSpellsUncheckedUpdateManyWithoutSpellNestedInput
    subclasses?: SubclassUncheckedUpdateManyWithoutExpandedSpellsNestedInput
    perses?: PersUncheckedUpdateManyWithoutSpellsNestedInput
    features?: FeatureUncheckedUpdateManyWithoutGivesSpellsNestedInput
  }

  export type SpellCreateWithoutSpellRacesInput = {
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    characterSpells?: CharacterSpellsCreateNestedManyWithoutSpellInput
    spellClasses?: SpellClassesCreateNestedManyWithoutSpellInput
    spellbookSpells?: SpellbookSpellsCreateNestedManyWithoutSpellInput
    subclasses?: SubclassCreateNestedManyWithoutExpandedSpellsInput
    perses?: PersCreateNestedManyWithoutSpellsInput
    features?: FeatureCreateNestedManyWithoutGivesSpellsInput
  }

  export type SpellUncheckedCreateWithoutSpellRacesInput = {
    spellId?: number
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    characterSpells?: CharacterSpellsUncheckedCreateNestedManyWithoutSpellInput
    spellClasses?: SpellClassesUncheckedCreateNestedManyWithoutSpellInput
    spellbookSpells?: SpellbookSpellsUncheckedCreateNestedManyWithoutSpellInput
    subclasses?: SubclassUncheckedCreateNestedManyWithoutExpandedSpellsInput
    perses?: PersUncheckedCreateNestedManyWithoutSpellsInput
    features?: FeatureUncheckedCreateNestedManyWithoutGivesSpellsInput
  }

  export type SpellCreateOrConnectWithoutSpellRacesInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutSpellRacesInput, SpellUncheckedCreateWithoutSpellRacesInput>
  }

  export type SpellUpsertWithoutSpellRacesInput = {
    update: XOR<SpellUpdateWithoutSpellRacesInput, SpellUncheckedUpdateWithoutSpellRacesInput>
    create: XOR<SpellCreateWithoutSpellRacesInput, SpellUncheckedCreateWithoutSpellRacesInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutSpellRacesInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutSpellRacesInput, SpellUncheckedUpdateWithoutSpellRacesInput>
  }

  export type SpellUpdateWithoutSpellRacesInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    characterSpells?: CharacterSpellsUpdateManyWithoutSpellNestedInput
    spellClasses?: SpellClassesUpdateManyWithoutSpellNestedInput
    spellbookSpells?: SpellbookSpellsUpdateManyWithoutSpellNestedInput
    subclasses?: SubclassUpdateManyWithoutExpandedSpellsNestedInput
    perses?: PersUpdateManyWithoutSpellsNestedInput
    features?: FeatureUpdateManyWithoutGivesSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutSpellRacesInput = {
    spellId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    characterSpells?: CharacterSpellsUncheckedUpdateManyWithoutSpellNestedInput
    spellClasses?: SpellClassesUncheckedUpdateManyWithoutSpellNestedInput
    spellbookSpells?: SpellbookSpellsUncheckedUpdateManyWithoutSpellNestedInput
    subclasses?: SubclassUncheckedUpdateManyWithoutExpandedSpellsNestedInput
    perses?: PersUncheckedUpdateManyWithoutSpellsNestedInput
    features?: FeatureUncheckedUpdateManyWithoutGivesSpellsNestedInput
  }

  export type UserCreateWithoutSpellbookInput = {
    login: string
    password?: string | null
    character?: CharacterCreateNestedManyWithoutUserInput
    pers?: PersCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSpellbookInput = {
    userId?: number
    login: string
    password?: string | null
    character?: CharacterUncheckedCreateNestedManyWithoutUserInput
    pers?: PersUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSpellbookInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSpellbookInput, UserUncheckedCreateWithoutSpellbookInput>
  }

  export type SpellbookSpellsCreateWithoutSpellbookInput = {
    spell?: SpellCreateNestedOneWithoutSpellbookSpellsInput
  }

  export type SpellbookSpellsUncheckedCreateWithoutSpellbookInput = {
    spellbookSpellId?: number
    spellId?: number | null
  }

  export type SpellbookSpellsCreateOrConnectWithoutSpellbookInput = {
    where: SpellbookSpellsWhereUniqueInput
    create: XOR<SpellbookSpellsCreateWithoutSpellbookInput, SpellbookSpellsUncheckedCreateWithoutSpellbookInput>
  }

  export type SpellbookSpellsCreateManySpellbookInputEnvelope = {
    data: SpellbookSpellsCreateManySpellbookInput | SpellbookSpellsCreateManySpellbookInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSpellbookInput = {
    update: XOR<UserUpdateWithoutSpellbookInput, UserUncheckedUpdateWithoutSpellbookInput>
    create: XOR<UserCreateWithoutSpellbookInput, UserUncheckedCreateWithoutSpellbookInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSpellbookInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSpellbookInput, UserUncheckedUpdateWithoutSpellbookInput>
  }

  export type UserUpdateWithoutSpellbookInput = {
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateManyWithoutUserNestedInput
    pers?: PersUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSpellbookInput = {
    userId?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUncheckedUpdateManyWithoutUserNestedInput
    pers?: PersUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SpellbookSpellsUpsertWithWhereUniqueWithoutSpellbookInput = {
    where: SpellbookSpellsWhereUniqueInput
    update: XOR<SpellbookSpellsUpdateWithoutSpellbookInput, SpellbookSpellsUncheckedUpdateWithoutSpellbookInput>
    create: XOR<SpellbookSpellsCreateWithoutSpellbookInput, SpellbookSpellsUncheckedCreateWithoutSpellbookInput>
  }

  export type SpellbookSpellsUpdateWithWhereUniqueWithoutSpellbookInput = {
    where: SpellbookSpellsWhereUniqueInput
    data: XOR<SpellbookSpellsUpdateWithoutSpellbookInput, SpellbookSpellsUncheckedUpdateWithoutSpellbookInput>
  }

  export type SpellbookSpellsUpdateManyWithWhereWithoutSpellbookInput = {
    where: SpellbookSpellsScalarWhereInput
    data: XOR<SpellbookSpellsUpdateManyMutationInput, SpellbookSpellsUncheckedUpdateManyWithoutSpellbookInput>
  }

  export type SpellCreateWithoutSpellbookSpellsInput = {
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    characterSpells?: CharacterSpellsCreateNestedManyWithoutSpellInput
    spellClasses?: SpellClassesCreateNestedManyWithoutSpellInput
    spellRaces?: SpellRacesCreateNestedManyWithoutSpellInput
    subclasses?: SubclassCreateNestedManyWithoutExpandedSpellsInput
    perses?: PersCreateNestedManyWithoutSpellsInput
    features?: FeatureCreateNestedManyWithoutGivesSpellsInput
  }

  export type SpellUncheckedCreateWithoutSpellbookSpellsInput = {
    spellId?: number
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    characterSpells?: CharacterSpellsUncheckedCreateNestedManyWithoutSpellInput
    spellClasses?: SpellClassesUncheckedCreateNestedManyWithoutSpellInput
    spellRaces?: SpellRacesUncheckedCreateNestedManyWithoutSpellInput
    subclasses?: SubclassUncheckedCreateNestedManyWithoutExpandedSpellsInput
    perses?: PersUncheckedCreateNestedManyWithoutSpellsInput
    features?: FeatureUncheckedCreateNestedManyWithoutGivesSpellsInput
  }

  export type SpellCreateOrConnectWithoutSpellbookSpellsInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutSpellbookSpellsInput, SpellUncheckedCreateWithoutSpellbookSpellsInput>
  }

  export type SpellbookCreateWithoutSpellbookSpellsInput = {
    user?: UserCreateNestedOneWithoutSpellbookInput
  }

  export type SpellbookUncheckedCreateWithoutSpellbookSpellsInput = {
    spellbookId?: number
    userId?: number | null
  }

  export type SpellbookCreateOrConnectWithoutSpellbookSpellsInput = {
    where: SpellbookWhereUniqueInput
    create: XOR<SpellbookCreateWithoutSpellbookSpellsInput, SpellbookUncheckedCreateWithoutSpellbookSpellsInput>
  }

  export type SpellUpsertWithoutSpellbookSpellsInput = {
    update: XOR<SpellUpdateWithoutSpellbookSpellsInput, SpellUncheckedUpdateWithoutSpellbookSpellsInput>
    create: XOR<SpellCreateWithoutSpellbookSpellsInput, SpellUncheckedCreateWithoutSpellbookSpellsInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutSpellbookSpellsInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutSpellbookSpellsInput, SpellUncheckedUpdateWithoutSpellbookSpellsInput>
  }

  export type SpellUpdateWithoutSpellbookSpellsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    characterSpells?: CharacterSpellsUpdateManyWithoutSpellNestedInput
    spellClasses?: SpellClassesUpdateManyWithoutSpellNestedInput
    spellRaces?: SpellRacesUpdateManyWithoutSpellNestedInput
    subclasses?: SubclassUpdateManyWithoutExpandedSpellsNestedInput
    perses?: PersUpdateManyWithoutSpellsNestedInput
    features?: FeatureUpdateManyWithoutGivesSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutSpellbookSpellsInput = {
    spellId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    characterSpells?: CharacterSpellsUncheckedUpdateManyWithoutSpellNestedInput
    spellClasses?: SpellClassesUncheckedUpdateManyWithoutSpellNestedInput
    spellRaces?: SpellRacesUncheckedUpdateManyWithoutSpellNestedInput
    subclasses?: SubclassUncheckedUpdateManyWithoutExpandedSpellsNestedInput
    perses?: PersUncheckedUpdateManyWithoutSpellsNestedInput
    features?: FeatureUncheckedUpdateManyWithoutGivesSpellsNestedInput
  }

  export type SpellbookUpsertWithoutSpellbookSpellsInput = {
    update: XOR<SpellbookUpdateWithoutSpellbookSpellsInput, SpellbookUncheckedUpdateWithoutSpellbookSpellsInput>
    create: XOR<SpellbookCreateWithoutSpellbookSpellsInput, SpellbookUncheckedCreateWithoutSpellbookSpellsInput>
    where?: SpellbookWhereInput
  }

  export type SpellbookUpdateToOneWithWhereWithoutSpellbookSpellsInput = {
    where?: SpellbookWhereInput
    data: XOR<SpellbookUpdateWithoutSpellbookSpellsInput, SpellbookUncheckedUpdateWithoutSpellbookSpellsInput>
  }

  export type SpellbookUpdateWithoutSpellbookSpellsInput = {
    user?: UserUpdateOneWithoutSpellbookNestedInput
  }

  export type SpellbookUncheckedUpdateWithoutSpellbookSpellsInput = {
    spellbookId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterCreateWithoutUserInput = {
    name?: string | null
    characterSpells?: CharacterSpellsCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutUserInput = {
    characterId?: number
    name?: string | null
    characterSpells?: CharacterSpellsUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutUserInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput>
  }

  export type CharacterCreateManyUserInputEnvelope = {
    data: CharacterCreateManyUserInput | CharacterCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SpellbookCreateWithoutUserInput = {
    spellbookSpells?: SpellbookSpellsCreateNestedManyWithoutSpellbookInput
  }

  export type SpellbookUncheckedCreateWithoutUserInput = {
    spellbookId?: number
    spellbookSpells?: SpellbookSpellsUncheckedCreateNestedManyWithoutSpellbookInput
  }

  export type SpellbookCreateOrConnectWithoutUserInput = {
    where: SpellbookWhereUniqueInput
    create: XOR<SpellbookCreateWithoutUserInput, SpellbookUncheckedCreateWithoutUserInput>
  }

  export type SpellbookCreateManyUserInputEnvelope = {
    data: SpellbookCreateManyUserInput | SpellbookCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PersCreateWithoutUserInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutPersesInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutUserInput = {
    persId?: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutUserInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutUserInput, PersUncheckedCreateWithoutUserInput>
  }

  export type PersCreateManyUserInputEnvelope = {
    data: PersCreateManyUserInput | PersCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CharacterUpsertWithWhereUniqueWithoutUserInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutUserInput, CharacterUncheckedUpdateWithoutUserInput>
    create: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutUserInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutUserInput, CharacterUncheckedUpdateWithoutUserInput>
  }

  export type CharacterUpdateManyWithWhereWithoutUserInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutUserInput>
  }

  export type CharacterScalarWhereInput = {
    AND?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    OR?: CharacterScalarWhereInput[]
    NOT?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    characterId?: IntFilter<"Character"> | number
    name?: StringNullableFilter<"Character"> | string | null
    userId?: IntNullableFilter<"Character"> | number | null
  }

  export type SpellbookUpsertWithWhereUniqueWithoutUserInput = {
    where: SpellbookWhereUniqueInput
    update: XOR<SpellbookUpdateWithoutUserInput, SpellbookUncheckedUpdateWithoutUserInput>
    create: XOR<SpellbookCreateWithoutUserInput, SpellbookUncheckedCreateWithoutUserInput>
  }

  export type SpellbookUpdateWithWhereUniqueWithoutUserInput = {
    where: SpellbookWhereUniqueInput
    data: XOR<SpellbookUpdateWithoutUserInput, SpellbookUncheckedUpdateWithoutUserInput>
  }

  export type SpellbookUpdateManyWithWhereWithoutUserInput = {
    where: SpellbookScalarWhereInput
    data: XOR<SpellbookUpdateManyMutationInput, SpellbookUncheckedUpdateManyWithoutUserInput>
  }

  export type SpellbookScalarWhereInput = {
    AND?: SpellbookScalarWhereInput | SpellbookScalarWhereInput[]
    OR?: SpellbookScalarWhereInput[]
    NOT?: SpellbookScalarWhereInput | SpellbookScalarWhereInput[]
    spellbookId?: IntFilter<"Spellbook"> | number
    userId?: IntNullableFilter<"Spellbook"> | number | null
  }

  export type PersUpsertWithWhereUniqueWithoutUserInput = {
    where: PersWhereUniqueInput
    update: XOR<PersUpdateWithoutUserInput, PersUncheckedUpdateWithoutUserInput>
    create: XOR<PersCreateWithoutUserInput, PersUncheckedCreateWithoutUserInput>
  }

  export type PersUpdateWithWhereUniqueWithoutUserInput = {
    where: PersWhereUniqueInput
    data: XOR<PersUpdateWithoutUserInput, PersUncheckedUpdateWithoutUserInput>
  }

  export type PersUpdateManyWithWhereWithoutUserInput = {
    where: PersScalarWhereInput
    data: XOR<PersUpdateManyMutationInput, PersUncheckedUpdateManyWithoutUserInput>
  }

  export type SubclassCreateWithoutClassInput = {
    name: string
    description?: string | null
    grantsSpells?: boolean
    languagesToChooseCount?: number
    languages?: SubclassCreatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellCreateNestedManyWithoutSubclassesInput
    features?: SubclassFeatureCreateNestedManyWithoutSubclassInput
    perses?: PersCreateNestedManyWithoutSubclassInput
    persMulticlasses?: PersMulticlassCreateNestedManyWithoutSubclassInput
  }

  export type SubclassUncheckedCreateWithoutClassInput = {
    subclassId?: number
    name: string
    description?: string | null
    grantsSpells?: boolean
    languagesToChooseCount?: number
    languages?: SubclassCreatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellUncheckedCreateNestedManyWithoutSubclassesInput
    features?: SubclassFeatureUncheckedCreateNestedManyWithoutSubclassInput
    perses?: PersUncheckedCreateNestedManyWithoutSubclassInput
    persMulticlasses?: PersMulticlassUncheckedCreateNestedManyWithoutSubclassInput
  }

  export type SubclassCreateOrConnectWithoutClassInput = {
    where: SubclassWhereUniqueInput
    create: XOR<SubclassCreateWithoutClassInput, SubclassUncheckedCreateWithoutClassInput>
  }

  export type SubclassCreateManyClassInputEnvelope = {
    data: SubclassCreateManyClassInput | SubclassCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassFeatureCreateWithoutClassInput = {
    levelGranted: number
    grantsSpellSlots?: boolean
    feature: FeatureCreateNestedOneWithoutClassFeaturesInput
  }

  export type ClassFeatureUncheckedCreateWithoutClassInput = {
    classFeatureId?: number
    featureId: number
    levelGranted: number
    grantsSpellSlots?: boolean
  }

  export type ClassFeatureCreateOrConnectWithoutClassInput = {
    where: ClassFeatureWhereUniqueInput
    create: XOR<ClassFeatureCreateWithoutClassInput, ClassFeatureUncheckedCreateWithoutClassInput>
  }

  export type ClassFeatureCreateManyClassInputEnvelope = {
    data: ClassFeatureCreateManyClassInput | ClassFeatureCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type PersCreateWithoutClassInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutClassInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutClassInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutClassInput, PersUncheckedCreateWithoutClassInput>
  }

  export type PersCreateManyClassInputEnvelope = {
    data: PersCreateManyClassInput | PersCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type PersMulticlassCreateWithoutClassInput = {
    classLevel: number
    pers: PersCreateNestedOneWithoutMulticlassesInput
    subclass?: SubclassCreateNestedOneWithoutPersMulticlassesInput
  }

  export type PersMulticlassUncheckedCreateWithoutClassInput = {
    persMulticlassId?: number
    persId: number
    subclassId?: number | null
    classLevel: number
  }

  export type PersMulticlassCreateOrConnectWithoutClassInput = {
    where: PersMulticlassWhereUniqueInput
    create: XOR<PersMulticlassCreateWithoutClassInput, PersMulticlassUncheckedCreateWithoutClassInput>
  }

  export type PersMulticlassCreateManyClassInputEnvelope = {
    data: PersMulticlassCreateManyClassInput | PersMulticlassCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassStartingEquipmentOptionCreateWithoutClassInput = {
    choiceGroup: number
    option: string
    quantity?: number
    chooseAnyArmor?: boolean
    armorType?: $Enums.ArmorType | null
    chooseAnyWeapon?: boolean
    weaponType?: $Enums.WeaponType | null
    weaponCount?: number
    description?: string | null
    weapon?: WeaponCreateNestedOneWithoutClassStartingEquipmentOptionInput
    armor?: ArmorCreateNestedOneWithoutClassStartingEquipmentOptionInput
    equipmentPack?: EquipmentPackCreateNestedOneWithoutClassStartingEquipmentOptionsInput
  }

  export type ClassStartingEquipmentOptionUncheckedCreateWithoutClassInput = {
    optionId?: number
    choiceGroup: number
    option: string
    weaponId?: number | null
    armorId?: number | null
    equipmentPackId?: number | null
    quantity?: number
    chooseAnyArmor?: boolean
    armorType?: $Enums.ArmorType | null
    chooseAnyWeapon?: boolean
    weaponType?: $Enums.WeaponType | null
    weaponCount?: number
    description?: string | null
  }

  export type ClassStartingEquipmentOptionCreateOrConnectWithoutClassInput = {
    where: ClassStartingEquipmentOptionWhereUniqueInput
    create: XOR<ClassStartingEquipmentOptionCreateWithoutClassInput, ClassStartingEquipmentOptionUncheckedCreateWithoutClassInput>
  }

  export type ClassStartingEquipmentOptionCreateManyClassInputEnvelope = {
    data: ClassStartingEquipmentOptionCreateManyClassInput | ClassStartingEquipmentOptionCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type SubclassUpsertWithWhereUniqueWithoutClassInput = {
    where: SubclassWhereUniqueInput
    update: XOR<SubclassUpdateWithoutClassInput, SubclassUncheckedUpdateWithoutClassInput>
    create: XOR<SubclassCreateWithoutClassInput, SubclassUncheckedCreateWithoutClassInput>
  }

  export type SubclassUpdateWithWhereUniqueWithoutClassInput = {
    where: SubclassWhereUniqueInput
    data: XOR<SubclassUpdateWithoutClassInput, SubclassUncheckedUpdateWithoutClassInput>
  }

  export type SubclassUpdateManyWithWhereWithoutClassInput = {
    where: SubclassScalarWhereInput
    data: XOR<SubclassUpdateManyMutationInput, SubclassUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassFeatureUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassFeatureWhereUniqueInput
    update: XOR<ClassFeatureUpdateWithoutClassInput, ClassFeatureUncheckedUpdateWithoutClassInput>
    create: XOR<ClassFeatureCreateWithoutClassInput, ClassFeatureUncheckedCreateWithoutClassInput>
  }

  export type ClassFeatureUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassFeatureWhereUniqueInput
    data: XOR<ClassFeatureUpdateWithoutClassInput, ClassFeatureUncheckedUpdateWithoutClassInput>
  }

  export type ClassFeatureUpdateManyWithWhereWithoutClassInput = {
    where: ClassFeatureScalarWhereInput
    data: XOR<ClassFeatureUpdateManyMutationInput, ClassFeatureUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassFeatureScalarWhereInput = {
    AND?: ClassFeatureScalarWhereInput | ClassFeatureScalarWhereInput[]
    OR?: ClassFeatureScalarWhereInput[]
    NOT?: ClassFeatureScalarWhereInput | ClassFeatureScalarWhereInput[]
    classFeatureId?: IntFilter<"ClassFeature"> | number
    classId?: IntFilter<"ClassFeature"> | number
    featureId?: IntFilter<"ClassFeature"> | number
    levelGranted?: IntFilter<"ClassFeature"> | number
    grantsSpellSlots?: BoolFilter<"ClassFeature"> | boolean
  }

  export type PersUpsertWithWhereUniqueWithoutClassInput = {
    where: PersWhereUniqueInput
    update: XOR<PersUpdateWithoutClassInput, PersUncheckedUpdateWithoutClassInput>
    create: XOR<PersCreateWithoutClassInput, PersUncheckedCreateWithoutClassInput>
  }

  export type PersUpdateWithWhereUniqueWithoutClassInput = {
    where: PersWhereUniqueInput
    data: XOR<PersUpdateWithoutClassInput, PersUncheckedUpdateWithoutClassInput>
  }

  export type PersUpdateManyWithWhereWithoutClassInput = {
    where: PersScalarWhereInput
    data: XOR<PersUpdateManyMutationInput, PersUncheckedUpdateManyWithoutClassInput>
  }

  export type PersMulticlassUpsertWithWhereUniqueWithoutClassInput = {
    where: PersMulticlassWhereUniqueInput
    update: XOR<PersMulticlassUpdateWithoutClassInput, PersMulticlassUncheckedUpdateWithoutClassInput>
    create: XOR<PersMulticlassCreateWithoutClassInput, PersMulticlassUncheckedCreateWithoutClassInput>
  }

  export type PersMulticlassUpdateWithWhereUniqueWithoutClassInput = {
    where: PersMulticlassWhereUniqueInput
    data: XOR<PersMulticlassUpdateWithoutClassInput, PersMulticlassUncheckedUpdateWithoutClassInput>
  }

  export type PersMulticlassUpdateManyWithWhereWithoutClassInput = {
    where: PersMulticlassScalarWhereInput
    data: XOR<PersMulticlassUpdateManyMutationInput, PersMulticlassUncheckedUpdateManyWithoutClassInput>
  }

  export type PersMulticlassScalarWhereInput = {
    AND?: PersMulticlassScalarWhereInput | PersMulticlassScalarWhereInput[]
    OR?: PersMulticlassScalarWhereInput[]
    NOT?: PersMulticlassScalarWhereInput | PersMulticlassScalarWhereInput[]
    persMulticlassId?: IntFilter<"PersMulticlass"> | number
    persId?: IntFilter<"PersMulticlass"> | number
    classId?: IntFilter<"PersMulticlass"> | number
    subclassId?: IntNullableFilter<"PersMulticlass"> | number | null
    classLevel?: IntFilter<"PersMulticlass"> | number
  }

  export type ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassStartingEquipmentOptionWhereUniqueInput
    update: XOR<ClassStartingEquipmentOptionUpdateWithoutClassInput, ClassStartingEquipmentOptionUncheckedUpdateWithoutClassInput>
    create: XOR<ClassStartingEquipmentOptionCreateWithoutClassInput, ClassStartingEquipmentOptionUncheckedCreateWithoutClassInput>
  }

  export type ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassStartingEquipmentOptionWhereUniqueInput
    data: XOR<ClassStartingEquipmentOptionUpdateWithoutClassInput, ClassStartingEquipmentOptionUncheckedUpdateWithoutClassInput>
  }

  export type ClassStartingEquipmentOptionUpdateManyWithWhereWithoutClassInput = {
    where: ClassStartingEquipmentOptionScalarWhereInput
    data: XOR<ClassStartingEquipmentOptionUpdateManyMutationInput, ClassStartingEquipmentOptionUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassStartingEquipmentOptionScalarWhereInput = {
    AND?: ClassStartingEquipmentOptionScalarWhereInput | ClassStartingEquipmentOptionScalarWhereInput[]
    OR?: ClassStartingEquipmentOptionScalarWhereInput[]
    NOT?: ClassStartingEquipmentOptionScalarWhereInput | ClassStartingEquipmentOptionScalarWhereInput[]
    optionId?: IntFilter<"ClassStartingEquipmentOption"> | number
    classId?: IntFilter<"ClassStartingEquipmentOption"> | number
    choiceGroup?: IntFilter<"ClassStartingEquipmentOption"> | number
    option?: StringFilter<"ClassStartingEquipmentOption"> | string
    weaponId?: IntNullableFilter<"ClassStartingEquipmentOption"> | number | null
    armorId?: IntNullableFilter<"ClassStartingEquipmentOption"> | number | null
    equipmentPackId?: IntNullableFilter<"ClassStartingEquipmentOption"> | number | null
    quantity?: IntFilter<"ClassStartingEquipmentOption"> | number
    chooseAnyArmor?: BoolFilter<"ClassStartingEquipmentOption"> | boolean
    armorType?: EnumArmorTypeNullableFilter<"ClassStartingEquipmentOption"> | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFilter<"ClassStartingEquipmentOption"> | boolean
    weaponType?: EnumWeaponTypeNullableFilter<"ClassStartingEquipmentOption"> | $Enums.WeaponType | null
    weaponCount?: IntFilter<"ClassStartingEquipmentOption"> | number
    description?: StringNullableFilter<"ClassStartingEquipmentOption"> | string | null
  }

  export type SpellCreateWithoutSubclassesInput = {
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    characterSpells?: CharacterSpellsCreateNestedManyWithoutSpellInput
    spellClasses?: SpellClassesCreateNestedManyWithoutSpellInput
    spellRaces?: SpellRacesCreateNestedManyWithoutSpellInput
    spellbookSpells?: SpellbookSpellsCreateNestedManyWithoutSpellInput
    perses?: PersCreateNestedManyWithoutSpellsInput
    features?: FeatureCreateNestedManyWithoutGivesSpellsInput
  }

  export type SpellUncheckedCreateWithoutSubclassesInput = {
    spellId?: number
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    characterSpells?: CharacterSpellsUncheckedCreateNestedManyWithoutSpellInput
    spellClasses?: SpellClassesUncheckedCreateNestedManyWithoutSpellInput
    spellRaces?: SpellRacesUncheckedCreateNestedManyWithoutSpellInput
    spellbookSpells?: SpellbookSpellsUncheckedCreateNestedManyWithoutSpellInput
    perses?: PersUncheckedCreateNestedManyWithoutSpellsInput
    features?: FeatureUncheckedCreateNestedManyWithoutGivesSpellsInput
  }

  export type SpellCreateOrConnectWithoutSubclassesInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutSubclassesInput, SpellUncheckedCreateWithoutSubclassesInput>
  }

  export type ClassCreateWithoutSubclassesInput = {
    name: string
    hitDie: number
    primaryCastingStat?: $Enums.Ability | null
    spellcastingType?: $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassCreateabilityScoreUpLevelsInput | number[]
    subclassLevel?: number
    multiclassStrReq?: number
    multiclassDexReq?: number
    multiclassConReq?: number
    multiclassIntReq?: number
    multiclassWisReq?: number
    multiclassChaReq?: number
    armorProficiencies?: ClassCreatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassCreateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassCreatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassCreateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: number
    languages?: ClassCreatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    classFeatures?: ClassFeatureCreateNestedManyWithoutClassInput
    perses?: PersCreateNestedManyWithoutClassInput
    persMulticlasses?: PersMulticlassCreateNestedManyWithoutClassInput
    startingEquipmentOption?: ClassStartingEquipmentOptionCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSubclassesInput = {
    classId?: number
    name: string
    hitDie: number
    primaryCastingStat?: $Enums.Ability | null
    spellcastingType?: $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassCreateabilityScoreUpLevelsInput | number[]
    subclassLevel?: number
    multiclassStrReq?: number
    multiclassDexReq?: number
    multiclassConReq?: number
    multiclassIntReq?: number
    multiclassWisReq?: number
    multiclassChaReq?: number
    armorProficiencies?: ClassCreatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassCreateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassCreatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassCreateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: number
    languages?: ClassCreatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    classFeatures?: ClassFeatureUncheckedCreateNestedManyWithoutClassInput
    perses?: PersUncheckedCreateNestedManyWithoutClassInput
    persMulticlasses?: PersMulticlassUncheckedCreateNestedManyWithoutClassInput
    startingEquipmentOption?: ClassStartingEquipmentOptionUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSubclassesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSubclassesInput, ClassUncheckedCreateWithoutSubclassesInput>
  }

  export type SubclassFeatureCreateWithoutSubclassInput = {
    levelGranted: number
    grantsSpellSlots?: boolean
    feature: FeatureCreateNestedOneWithoutSubclassFeaturesInput
  }

  export type SubclassFeatureUncheckedCreateWithoutSubclassInput = {
    subclassFeatureId?: number
    featureId: number
    levelGranted: number
    grantsSpellSlots?: boolean
  }

  export type SubclassFeatureCreateOrConnectWithoutSubclassInput = {
    where: SubclassFeatureWhereUniqueInput
    create: XOR<SubclassFeatureCreateWithoutSubclassInput, SubclassFeatureUncheckedCreateWithoutSubclassInput>
  }

  export type SubclassFeatureCreateManySubclassInputEnvelope = {
    data: SubclassFeatureCreateManySubclassInput | SubclassFeatureCreateManySubclassInput[]
    skipDuplicates?: boolean
  }

  export type PersCreateWithoutSubclassInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    class: ClassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutSubclassInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutSubclassInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutSubclassInput, PersUncheckedCreateWithoutSubclassInput>
  }

  export type PersCreateManySubclassInputEnvelope = {
    data: PersCreateManySubclassInput | PersCreateManySubclassInput[]
    skipDuplicates?: boolean
  }

  export type PersMulticlassCreateWithoutSubclassInput = {
    classLevel: number
    pers: PersCreateNestedOneWithoutMulticlassesInput
    class: ClassCreateNestedOneWithoutPersMulticlassesInput
  }

  export type PersMulticlassUncheckedCreateWithoutSubclassInput = {
    persMulticlassId?: number
    persId: number
    classId: number
    classLevel: number
  }

  export type PersMulticlassCreateOrConnectWithoutSubclassInput = {
    where: PersMulticlassWhereUniqueInput
    create: XOR<PersMulticlassCreateWithoutSubclassInput, PersMulticlassUncheckedCreateWithoutSubclassInput>
  }

  export type PersMulticlassCreateManySubclassInputEnvelope = {
    data: PersMulticlassCreateManySubclassInput | PersMulticlassCreateManySubclassInput[]
    skipDuplicates?: boolean
  }

  export type SpellUpsertWithWhereUniqueWithoutSubclassesInput = {
    where: SpellWhereUniqueInput
    update: XOR<SpellUpdateWithoutSubclassesInput, SpellUncheckedUpdateWithoutSubclassesInput>
    create: XOR<SpellCreateWithoutSubclassesInput, SpellUncheckedCreateWithoutSubclassesInput>
  }

  export type SpellUpdateWithWhereUniqueWithoutSubclassesInput = {
    where: SpellWhereUniqueInput
    data: XOR<SpellUpdateWithoutSubclassesInput, SpellUncheckedUpdateWithoutSubclassesInput>
  }

  export type SpellUpdateManyWithWhereWithoutSubclassesInput = {
    where: SpellScalarWhereInput
    data: XOR<SpellUpdateManyMutationInput, SpellUncheckedUpdateManyWithoutSubclassesInput>
  }

  export type SpellScalarWhereInput = {
    AND?: SpellScalarWhereInput | SpellScalarWhereInput[]
    OR?: SpellScalarWhereInput[]
    NOT?: SpellScalarWhereInput | SpellScalarWhereInput[]
    spellId?: IntFilter<"Spell"> | number
    name?: StringFilter<"Spell"> | string
    level?: IntFilter<"Spell"> | number
    school?: StringNullableFilter<"Spell"> | string | null
    castingTime?: StringFilter<"Spell"> | string
    range?: StringFilter<"Spell"> | string
    components?: StringNullableFilter<"Spell"> | string | null
    duration?: StringFilter<"Spell"> | string
    description?: StringFilter<"Spell"> | string
    hasRitual?: StringNullableFilter<"Spell"> | string | null
    hasConcentration?: StringNullableFilter<"Spell"> | string | null
    source?: EnumSourceFilter<"Spell"> | $Enums.Source
  }

  export type ClassUpsertWithoutSubclassesInput = {
    update: XOR<ClassUpdateWithoutSubclassesInput, ClassUncheckedUpdateWithoutSubclassesInput>
    create: XOR<ClassCreateWithoutSubclassesInput, ClassUncheckedCreateWithoutSubclassesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutSubclassesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutSubclassesInput, ClassUncheckedUpdateWithoutSubclassesInput>
  }

  export type ClassUpdateWithoutSubclassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    hitDie?: IntFieldUpdateOperationsInput | number
    primaryCastingStat?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFieldUpdateOperationsInput | $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassUpdateabilityScoreUpLevelsInput | number[]
    subclassLevel?: IntFieldUpdateOperationsInput | number
    multiclassStrReq?: IntFieldUpdateOperationsInput | number
    multiclassDexReq?: IntFieldUpdateOperationsInput | number
    multiclassConReq?: IntFieldUpdateOperationsInput | number
    multiclassIntReq?: IntFieldUpdateOperationsInput | number
    multiclassWisReq?: IntFieldUpdateOperationsInput | number
    multiclassChaReq?: IntFieldUpdateOperationsInput | number
    armorProficiencies?: ClassUpdatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassUpdateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassUpdatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassUpdateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: ClassUpdatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classFeatures?: ClassFeatureUpdateManyWithoutClassNestedInput
    perses?: PersUpdateManyWithoutClassNestedInput
    persMulticlasses?: PersMulticlassUpdateManyWithoutClassNestedInput
    startingEquipmentOption?: ClassStartingEquipmentOptionUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSubclassesInput = {
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    hitDie?: IntFieldUpdateOperationsInput | number
    primaryCastingStat?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFieldUpdateOperationsInput | $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassUpdateabilityScoreUpLevelsInput | number[]
    subclassLevel?: IntFieldUpdateOperationsInput | number
    multiclassStrReq?: IntFieldUpdateOperationsInput | number
    multiclassDexReq?: IntFieldUpdateOperationsInput | number
    multiclassConReq?: IntFieldUpdateOperationsInput | number
    multiclassIntReq?: IntFieldUpdateOperationsInput | number
    multiclassWisReq?: IntFieldUpdateOperationsInput | number
    multiclassChaReq?: IntFieldUpdateOperationsInput | number
    armorProficiencies?: ClassUpdatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassUpdateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassUpdatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassUpdateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: ClassUpdatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classFeatures?: ClassFeatureUncheckedUpdateManyWithoutClassNestedInput
    perses?: PersUncheckedUpdateManyWithoutClassNestedInput
    persMulticlasses?: PersMulticlassUncheckedUpdateManyWithoutClassNestedInput
    startingEquipmentOption?: ClassStartingEquipmentOptionUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SubclassFeatureUpsertWithWhereUniqueWithoutSubclassInput = {
    where: SubclassFeatureWhereUniqueInput
    update: XOR<SubclassFeatureUpdateWithoutSubclassInput, SubclassFeatureUncheckedUpdateWithoutSubclassInput>
    create: XOR<SubclassFeatureCreateWithoutSubclassInput, SubclassFeatureUncheckedCreateWithoutSubclassInput>
  }

  export type SubclassFeatureUpdateWithWhereUniqueWithoutSubclassInput = {
    where: SubclassFeatureWhereUniqueInput
    data: XOR<SubclassFeatureUpdateWithoutSubclassInput, SubclassFeatureUncheckedUpdateWithoutSubclassInput>
  }

  export type SubclassFeatureUpdateManyWithWhereWithoutSubclassInput = {
    where: SubclassFeatureScalarWhereInput
    data: XOR<SubclassFeatureUpdateManyMutationInput, SubclassFeatureUncheckedUpdateManyWithoutSubclassInput>
  }

  export type SubclassFeatureScalarWhereInput = {
    AND?: SubclassFeatureScalarWhereInput | SubclassFeatureScalarWhereInput[]
    OR?: SubclassFeatureScalarWhereInput[]
    NOT?: SubclassFeatureScalarWhereInput | SubclassFeatureScalarWhereInput[]
    subclassFeatureId?: IntFilter<"SubclassFeature"> | number
    subclassId?: IntFilter<"SubclassFeature"> | number
    featureId?: IntFilter<"SubclassFeature"> | number
    levelGranted?: IntFilter<"SubclassFeature"> | number
    grantsSpellSlots?: BoolFilter<"SubclassFeature"> | boolean
  }

  export type PersUpsertWithWhereUniqueWithoutSubclassInput = {
    where: PersWhereUniqueInput
    update: XOR<PersUpdateWithoutSubclassInput, PersUncheckedUpdateWithoutSubclassInput>
    create: XOR<PersCreateWithoutSubclassInput, PersUncheckedCreateWithoutSubclassInput>
  }

  export type PersUpdateWithWhereUniqueWithoutSubclassInput = {
    where: PersWhereUniqueInput
    data: XOR<PersUpdateWithoutSubclassInput, PersUncheckedUpdateWithoutSubclassInput>
  }

  export type PersUpdateManyWithWhereWithoutSubclassInput = {
    where: PersScalarWhereInput
    data: XOR<PersUpdateManyMutationInput, PersUncheckedUpdateManyWithoutSubclassInput>
  }

  export type PersMulticlassUpsertWithWhereUniqueWithoutSubclassInput = {
    where: PersMulticlassWhereUniqueInput
    update: XOR<PersMulticlassUpdateWithoutSubclassInput, PersMulticlassUncheckedUpdateWithoutSubclassInput>
    create: XOR<PersMulticlassCreateWithoutSubclassInput, PersMulticlassUncheckedCreateWithoutSubclassInput>
  }

  export type PersMulticlassUpdateWithWhereUniqueWithoutSubclassInput = {
    where: PersMulticlassWhereUniqueInput
    data: XOR<PersMulticlassUpdateWithoutSubclassInput, PersMulticlassUncheckedUpdateWithoutSubclassInput>
  }

  export type PersMulticlassUpdateManyWithWhereWithoutSubclassInput = {
    where: PersMulticlassScalarWhereInput
    data: XOR<PersMulticlassUpdateManyMutationInput, PersMulticlassUncheckedUpdateManyWithoutSubclassInput>
  }

  export type UserCreateWithoutPersInput = {
    login: string
    password?: string | null
    character?: CharacterCreateNestedManyWithoutUserInput
    spellbook?: SpellbookCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPersInput = {
    userId?: number
    login: string
    password?: string | null
    character?: CharacterUncheckedCreateNestedManyWithoutUserInput
    spellbook?: SpellbookUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersInput, UserUncheckedCreateWithoutPersInput>
  }

  export type ClassCreateWithoutPersesInput = {
    name: string
    hitDie: number
    primaryCastingStat?: $Enums.Ability | null
    spellcastingType?: $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassCreateabilityScoreUpLevelsInput | number[]
    subclassLevel?: number
    multiclassStrReq?: number
    multiclassDexReq?: number
    multiclassConReq?: number
    multiclassIntReq?: number
    multiclassWisReq?: number
    multiclassChaReq?: number
    armorProficiencies?: ClassCreatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassCreateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassCreatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassCreateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: number
    languages?: ClassCreatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subclasses?: SubclassCreateNestedManyWithoutClassInput
    classFeatures?: ClassFeatureCreateNestedManyWithoutClassInput
    persMulticlasses?: PersMulticlassCreateNestedManyWithoutClassInput
    startingEquipmentOption?: ClassStartingEquipmentOptionCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutPersesInput = {
    classId?: number
    name: string
    hitDie: number
    primaryCastingStat?: $Enums.Ability | null
    spellcastingType?: $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassCreateabilityScoreUpLevelsInput | number[]
    subclassLevel?: number
    multiclassStrReq?: number
    multiclassDexReq?: number
    multiclassConReq?: number
    multiclassIntReq?: number
    multiclassWisReq?: number
    multiclassChaReq?: number
    armorProficiencies?: ClassCreatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassCreateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassCreatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassCreateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: number
    languages?: ClassCreatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subclasses?: SubclassUncheckedCreateNestedManyWithoutClassInput
    classFeatures?: ClassFeatureUncheckedCreateNestedManyWithoutClassInput
    persMulticlasses?: PersMulticlassUncheckedCreateNestedManyWithoutClassInput
    startingEquipmentOption?: ClassStartingEquipmentOptionUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutPersesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutPersesInput, ClassUncheckedCreateWithoutPersesInput>
  }

  export type SubclassCreateWithoutPersesInput = {
    name: string
    description?: string | null
    grantsSpells?: boolean
    languagesToChooseCount?: number
    languages?: SubclassCreatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellCreateNestedManyWithoutSubclassesInput
    class: ClassCreateNestedOneWithoutSubclassesInput
    features?: SubclassFeatureCreateNestedManyWithoutSubclassInput
    persMulticlasses?: PersMulticlassCreateNestedManyWithoutSubclassInput
  }

  export type SubclassUncheckedCreateWithoutPersesInput = {
    subclassId?: number
    classId: number
    name: string
    description?: string | null
    grantsSpells?: boolean
    languagesToChooseCount?: number
    languages?: SubclassCreatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellUncheckedCreateNestedManyWithoutSubclassesInput
    features?: SubclassFeatureUncheckedCreateNestedManyWithoutSubclassInput
    persMulticlasses?: PersMulticlassUncheckedCreateNestedManyWithoutSubclassInput
  }

  export type SubclassCreateOrConnectWithoutPersesInput = {
    where: SubclassWhereUniqueInput
    create: XOR<SubclassCreateWithoutPersesInput, SubclassUncheckedCreateWithoutPersesInput>
  }

  export type RaceCreateWithoutPersesInput = {
    name: $Enums.Races
    size?: RaceCreatesizeInput | $Enums.Size[]
    speed?: number
    burrowSpeed?: number
    flightSpeed?: number
    swimSpeed?: number
    climbSpeed?: number
    ac?: number
    source?: $Enums.Source
    languages?: RaceCreatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    ASI: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceCreateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceCreatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceCreateNestedManyWithoutRaceInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutRaceInput
    raceVariants?: RaceVariantCreateNestedManyWithoutRaceInput
    traits?: RaceTraitCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateWithoutPersesInput = {
    raceId?: number
    name: $Enums.Races
    size?: RaceCreatesizeInput | $Enums.Size[]
    speed?: number
    burrowSpeed?: number
    flightSpeed?: number
    swimSpeed?: number
    climbSpeed?: number
    ac?: number
    source?: $Enums.Source
    languages?: RaceCreatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    ASI: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceCreateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceCreatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceUncheckedCreateNestedManyWithoutRaceInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutRaceInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutRaceInput
    traits?: RaceTraitUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceCreateOrConnectWithoutPersesInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutPersesInput, RaceUncheckedCreateWithoutPersesInput>
  }

  export type SubraceCreateWithoutPersesInput = {
    name: $Enums.Subraces
    speedModifier?: number | null
    source?: $Enums.Source
    replacesASI?: boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceCreateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    toolProficiencies?: SubraceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceCreatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitCreateNestedManyWithoutSubracesInput
    race: RaceCreateNestedOneWithoutSubracesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutSubraceInput
    traits?: SubraceTraitCreateNestedManyWithoutSubraceInput
  }

  export type SubraceUncheckedCreateWithoutPersesInput = {
    subraceId?: number
    raceId: number
    name: $Enums.Subraces
    speedModifier?: number | null
    source?: $Enums.Source
    replacesASI?: boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceCreateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    toolProficiencies?: SubraceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceCreatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitUncheckedCreateNestedManyWithoutSubracesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutSubraceInput
    traits?: SubraceTraitUncheckedCreateNestedManyWithoutSubraceInput
  }

  export type SubraceCreateOrConnectWithoutPersesInput = {
    where: SubraceWhereUniqueInput
    create: XOR<SubraceCreateWithoutPersesInput, SubraceUncheckedCreateWithoutPersesInput>
  }

  export type BackgroundCreateWithoutPersesInput = {
    name: $Enums.BackgroundCategory
    source?: $Enums.Source
    toolProficiencies?: BackgroundCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: BackgroundCreateskillProficienciesInput | $Enums.Skills[]
    languagesToChooseCount?: number
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BackgroundUncheckedCreateWithoutPersesInput = {
    backgroundId?: number
    name: $Enums.BackgroundCategory
    source?: $Enums.Source
    toolProficiencies?: BackgroundCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: BackgroundCreateskillProficienciesInput | $Enums.Skills[]
    languagesToChooseCount?: number
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BackgroundCreateOrConnectWithoutPersesInput = {
    where: BackgroundWhereUniqueInput
    create: XOR<BackgroundCreateWithoutPersesInput, BackgroundUncheckedCreateWithoutPersesInput>
  }

  export type PersSkillCreateWithoutPersInput = {
    skillId: number
    proficiencyType?: $Enums.SkillProficiencyType
    customModifier?: number | null
    name: $Enums.Skills
  }

  export type PersSkillUncheckedCreateWithoutPersInput = {
    persSkillId?: number
    skillId: number
    proficiencyType?: $Enums.SkillProficiencyType
    customModifier?: number | null
    name: $Enums.Skills
  }

  export type PersSkillCreateOrConnectWithoutPersInput = {
    where: PersSkillWhereUniqueInput
    create: XOR<PersSkillCreateWithoutPersInput, PersSkillUncheckedCreateWithoutPersInput>
  }

  export type PersSkillCreateManyPersInputEnvelope = {
    data: PersSkillCreateManyPersInput | PersSkillCreateManyPersInput[]
    skipDuplicates?: boolean
  }

  export type PersMulticlassCreateWithoutPersInput = {
    classLevel: number
    class: ClassCreateNestedOneWithoutPersMulticlassesInput
    subclass?: SubclassCreateNestedOneWithoutPersMulticlassesInput
  }

  export type PersMulticlassUncheckedCreateWithoutPersInput = {
    persMulticlassId?: number
    classId: number
    subclassId?: number | null
    classLevel: number
  }

  export type PersMulticlassCreateOrConnectWithoutPersInput = {
    where: PersMulticlassWhereUniqueInput
    create: XOR<PersMulticlassCreateWithoutPersInput, PersMulticlassUncheckedCreateWithoutPersInput>
  }

  export type PersMulticlassCreateManyPersInputEnvelope = {
    data: PersMulticlassCreateManyPersInput | PersMulticlassCreateManyPersInput[]
    skipDuplicates?: boolean
  }

  export type PersFeatureCreateWithoutPersInput = {
    usesRemaining?: number | null
    feature: FeatureCreateNestedOneWithoutPersFeaturesInput
  }

  export type PersFeatureUncheckedCreateWithoutPersInput = {
    persFeatureId?: number
    featureId: number
    usesRemaining?: number | null
  }

  export type PersFeatureCreateOrConnectWithoutPersInput = {
    where: PersFeatureWhereUniqueInput
    create: XOR<PersFeatureCreateWithoutPersInput, PersFeatureUncheckedCreateWithoutPersInput>
  }

  export type PersFeatureCreateManyPersInputEnvelope = {
    data: PersFeatureCreateManyPersInput | PersFeatureCreateManyPersInput[]
    skipDuplicates?: boolean
  }

  export type SpellCreateWithoutPersesInput = {
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    characterSpells?: CharacterSpellsCreateNestedManyWithoutSpellInput
    spellClasses?: SpellClassesCreateNestedManyWithoutSpellInput
    spellRaces?: SpellRacesCreateNestedManyWithoutSpellInput
    spellbookSpells?: SpellbookSpellsCreateNestedManyWithoutSpellInput
    subclasses?: SubclassCreateNestedManyWithoutExpandedSpellsInput
    features?: FeatureCreateNestedManyWithoutGivesSpellsInput
  }

  export type SpellUncheckedCreateWithoutPersesInput = {
    spellId?: number
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    characterSpells?: CharacterSpellsUncheckedCreateNestedManyWithoutSpellInput
    spellClasses?: SpellClassesUncheckedCreateNestedManyWithoutSpellInput
    spellRaces?: SpellRacesUncheckedCreateNestedManyWithoutSpellInput
    spellbookSpells?: SpellbookSpellsUncheckedCreateNestedManyWithoutSpellInput
    subclasses?: SubclassUncheckedCreateNestedManyWithoutExpandedSpellsInput
    features?: FeatureUncheckedCreateNestedManyWithoutGivesSpellsInput
  }

  export type SpellCreateOrConnectWithoutPersesInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutPersesInput, SpellUncheckedCreateWithoutPersesInput>
  }

  export type PersFeatCreateWithoutPersInput = {
    feat: FeatCreateNestedOneWithoutPersFeatsInput
  }

  export type PersFeatUncheckedCreateWithoutPersInput = {
    persFeatId?: number
    featId: number
  }

  export type PersFeatCreateOrConnectWithoutPersInput = {
    where: PersFeatWhereUniqueInput
    create: XOR<PersFeatCreateWithoutPersInput, PersFeatUncheckedCreateWithoutPersInput>
  }

  export type PersFeatCreateManyPersInputEnvelope = {
    data: PersFeatCreateManyPersInput | PersFeatCreateManyPersInput[]
    skipDuplicates?: boolean
  }

  export type PersArmorCreateWithoutPersInput = {
    overrideBaseAC?: number | null
    miscACBonus?: number | null
    isProficient?: boolean
    equipped?: boolean
    armor: ArmorCreateNestedOneWithoutPersArmorInput
  }

  export type PersArmorUncheckedCreateWithoutPersInput = {
    persArmorId?: number
    armorId: number
    overrideBaseAC?: number | null
    miscACBonus?: number | null
    isProficient?: boolean
    equipped?: boolean
  }

  export type PersArmorCreateOrConnectWithoutPersInput = {
    where: PersArmorWhereUniqueInput
    create: XOR<PersArmorCreateWithoutPersInput, PersArmorUncheckedCreateWithoutPersInput>
  }

  export type PersArmorCreateManyPersInputEnvelope = {
    data: PersArmorCreateManyPersInput | PersArmorCreateManyPersInput[]
    skipDuplicates?: boolean
  }

  export type PersWeaponCreateWithoutPersInput = {
    overrideDamage?: string | null
    attackBonus?: number | null
    overrideName?: string | null
    overrideNormalRange?: number | null
    overrideLongRange?: number | null
    overrideDamageType?: $Enums.DamageType | null
    overrideAttackAbility?: $Enums.Ability | null
    isProficient?: boolean
    weapon: WeaponCreateNestedOneWithoutPersWeaponsInput
  }

  export type PersWeaponUncheckedCreateWithoutPersInput = {
    persWeaponId?: number
    weaponId: number
    overrideDamage?: string | null
    attackBonus?: number | null
    overrideName?: string | null
    overrideNormalRange?: number | null
    overrideLongRange?: number | null
    overrideDamageType?: $Enums.DamageType | null
    overrideAttackAbility?: $Enums.Ability | null
    isProficient?: boolean
  }

  export type PersWeaponCreateOrConnectWithoutPersInput = {
    where: PersWeaponWhereUniqueInput
    create: XOR<PersWeaponCreateWithoutPersInput, PersWeaponUncheckedCreateWithoutPersInput>
  }

  export type PersWeaponCreateManyPersInputEnvelope = {
    data: PersWeaponCreateManyPersInput | PersWeaponCreateManyPersInput[]
    skipDuplicates?: boolean
  }

  export type PersMagicItemCreateWithoutPersInput = {
    magicItem: MagicItemCreateNestedOneWithoutPersMagicItemsInput
  }

  export type PersMagicItemUncheckedCreateWithoutPersInput = {
    persMagicItemId?: number
    magicItemId: number
  }

  export type PersMagicItemCreateOrConnectWithoutPersInput = {
    where: PersMagicItemWhereUniqueInput
    create: XOR<PersMagicItemCreateWithoutPersInput, PersMagicItemUncheckedCreateWithoutPersInput>
  }

  export type PersMagicItemCreateManyPersInputEnvelope = {
    data: PersMagicItemCreateManyPersInput | PersMagicItemCreateManyPersInput[]
    skipDuplicates?: boolean
  }

  export type RaceVariantCreateWithoutPersesInput = {
    name: $Enums.Variants
    source: $Enums.Source
    exclusivityGroup?: string | null
    overridesRaceASI: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: number | null
    overridesFlightSpeed?: number | null
    replacesTraits?: RaceTraitCreateNestedManyWithoutRaceVariantsInput
    traits?: RaceVariantTraitCreateNestedManyWithoutRaceVariantInput
    race: RaceCreateNestedOneWithoutRaceVariantsInput
  }

  export type RaceVariantUncheckedCreateWithoutPersesInput = {
    raceVariantId?: number
    raceId: number
    name: $Enums.Variants
    source: $Enums.Source
    exclusivityGroup?: string | null
    overridesRaceASI: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: number | null
    overridesFlightSpeed?: number | null
    replacesTraits?: RaceTraitUncheckedCreateNestedManyWithoutRaceVariantsInput
    traits?: RaceVariantTraitUncheckedCreateNestedManyWithoutRaceVariantInput
  }

  export type RaceVariantCreateOrConnectWithoutPersesInput = {
    where: RaceVariantWhereUniqueInput
    create: XOR<RaceVariantCreateWithoutPersesInput, RaceVariantUncheckedCreateWithoutPersesInput>
  }

  export type RaceChoiceOptionCreateWithoutPersesInput = {
    choiceGroupName: string
    optionName: string
    description?: string | null
    selectMultiple?: boolean
    maxSelection?: number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionCreategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionCreategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    modifiesSpeed?: number | null
    draconicDamageType?: $Enums.DamageType | null
    breathWeaponShape?: $Enums.AOEShapes | null
    breathWeaponAOE?: string | null
    grantsTraits?: RaceChoiceOptionTraitCreateNestedManyWithoutRaceChoiceOptionInput
    race: RaceCreateNestedOneWithoutRaceChoiceOptionsInput
    subrace?: SubraceCreateNestedOneWithoutRaceChoiceOptionsInput
  }

  export type RaceChoiceOptionUncheckedCreateWithoutPersesInput = {
    optionId?: number
    raceId: number
    subraceId?: number | null
    choiceGroupName: string
    optionName: string
    description?: string | null
    selectMultiple?: boolean
    maxSelection?: number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionCreategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionCreategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    modifiesSpeed?: number | null
    draconicDamageType?: $Enums.DamageType | null
    breathWeaponShape?: $Enums.AOEShapes | null
    breathWeaponAOE?: string | null
    grantsTraits?: RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutRaceChoiceOptionInput
  }

  export type RaceChoiceOptionCreateOrConnectWithoutPersesInput = {
    where: RaceChoiceOptionWhereUniqueInput
    create: XOR<RaceChoiceOptionCreateWithoutPersesInput, RaceChoiceOptionUncheckedCreateWithoutPersesInput>
  }

  export type UserUpsertWithoutPersInput = {
    update: XOR<UserUpdateWithoutPersInput, UserUncheckedUpdateWithoutPersInput>
    create: XOR<UserCreateWithoutPersInput, UserUncheckedCreateWithoutPersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPersInput, UserUncheckedUpdateWithoutPersInput>
  }

  export type UserUpdateWithoutPersInput = {
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateManyWithoutUserNestedInput
    spellbook?: SpellbookUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPersInput = {
    userId?: IntFieldUpdateOperationsInput | number
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUncheckedUpdateManyWithoutUserNestedInput
    spellbook?: SpellbookUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassUpsertWithoutPersesInput = {
    update: XOR<ClassUpdateWithoutPersesInput, ClassUncheckedUpdateWithoutPersesInput>
    create: XOR<ClassCreateWithoutPersesInput, ClassUncheckedCreateWithoutPersesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutPersesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutPersesInput, ClassUncheckedUpdateWithoutPersesInput>
  }

  export type ClassUpdateWithoutPersesInput = {
    name?: StringFieldUpdateOperationsInput | string
    hitDie?: IntFieldUpdateOperationsInput | number
    primaryCastingStat?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFieldUpdateOperationsInput | $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassUpdateabilityScoreUpLevelsInput | number[]
    subclassLevel?: IntFieldUpdateOperationsInput | number
    multiclassStrReq?: IntFieldUpdateOperationsInput | number
    multiclassDexReq?: IntFieldUpdateOperationsInput | number
    multiclassConReq?: IntFieldUpdateOperationsInput | number
    multiclassIntReq?: IntFieldUpdateOperationsInput | number
    multiclassWisReq?: IntFieldUpdateOperationsInput | number
    multiclassChaReq?: IntFieldUpdateOperationsInput | number
    armorProficiencies?: ClassUpdatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassUpdateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassUpdatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassUpdateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: ClassUpdatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subclasses?: SubclassUpdateManyWithoutClassNestedInput
    classFeatures?: ClassFeatureUpdateManyWithoutClassNestedInput
    persMulticlasses?: PersMulticlassUpdateManyWithoutClassNestedInput
    startingEquipmentOption?: ClassStartingEquipmentOptionUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutPersesInput = {
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    hitDie?: IntFieldUpdateOperationsInput | number
    primaryCastingStat?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFieldUpdateOperationsInput | $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassUpdateabilityScoreUpLevelsInput | number[]
    subclassLevel?: IntFieldUpdateOperationsInput | number
    multiclassStrReq?: IntFieldUpdateOperationsInput | number
    multiclassDexReq?: IntFieldUpdateOperationsInput | number
    multiclassConReq?: IntFieldUpdateOperationsInput | number
    multiclassIntReq?: IntFieldUpdateOperationsInput | number
    multiclassWisReq?: IntFieldUpdateOperationsInput | number
    multiclassChaReq?: IntFieldUpdateOperationsInput | number
    armorProficiencies?: ClassUpdatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassUpdateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassUpdatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassUpdateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: ClassUpdatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subclasses?: SubclassUncheckedUpdateManyWithoutClassNestedInput
    classFeatures?: ClassFeatureUncheckedUpdateManyWithoutClassNestedInput
    persMulticlasses?: PersMulticlassUncheckedUpdateManyWithoutClassNestedInput
    startingEquipmentOption?: ClassStartingEquipmentOptionUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SubclassUpsertWithoutPersesInput = {
    update: XOR<SubclassUpdateWithoutPersesInput, SubclassUncheckedUpdateWithoutPersesInput>
    create: XOR<SubclassCreateWithoutPersesInput, SubclassUncheckedCreateWithoutPersesInput>
    where?: SubclassWhereInput
  }

  export type SubclassUpdateToOneWithWhereWithoutPersesInput = {
    where?: SubclassWhereInput
    data: XOR<SubclassUpdateWithoutPersesInput, SubclassUncheckedUpdateWithoutPersesInput>
  }

  export type SubclassUpdateWithoutPersesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellUpdateManyWithoutSubclassesNestedInput
    class?: ClassUpdateOneRequiredWithoutSubclassesNestedInput
    features?: SubclassFeatureUpdateManyWithoutSubclassNestedInput
    persMulticlasses?: PersMulticlassUpdateManyWithoutSubclassNestedInput
  }

  export type SubclassUncheckedUpdateWithoutPersesInput = {
    subclassId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellUncheckedUpdateManyWithoutSubclassesNestedInput
    features?: SubclassFeatureUncheckedUpdateManyWithoutSubclassNestedInput
    persMulticlasses?: PersMulticlassUncheckedUpdateManyWithoutSubclassNestedInput
  }

  export type RaceUpsertWithoutPersesInput = {
    update: XOR<RaceUpdateWithoutPersesInput, RaceUncheckedUpdateWithoutPersesInput>
    create: XOR<RaceCreateWithoutPersesInput, RaceUncheckedCreateWithoutPersesInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutPersesInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutPersesInput, RaceUncheckedUpdateWithoutPersesInput>
  }

  export type RaceUpdateWithoutPersesInput = {
    name?: EnumRacesFieldUpdateOperationsInput | $Enums.Races
    size?: RaceUpdatesizeInput | $Enums.Size[]
    speed?: IntFieldUpdateOperationsInput | number
    burrowSpeed?: IntFieldUpdateOperationsInput | number
    flightSpeed?: IntFieldUpdateOperationsInput | number
    swimSpeed?: IntFieldUpdateOperationsInput | number
    climbSpeed?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    languages?: RaceUpdatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    ASI?: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceUpdateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceUpdateManyWithoutRaceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutRaceNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutPersesInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumRacesFieldUpdateOperationsInput | $Enums.Races
    size?: RaceUpdatesizeInput | $Enums.Size[]
    speed?: IntFieldUpdateOperationsInput | number
    burrowSpeed?: IntFieldUpdateOperationsInput | number
    flightSpeed?: IntFieldUpdateOperationsInput | number
    swimSpeed?: IntFieldUpdateOperationsInput | number
    climbSpeed?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    languages?: RaceUpdatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    ASI?: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceUpdateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceUncheckedUpdateManyWithoutRaceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutRaceNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type SubraceUpsertWithoutPersesInput = {
    update: XOR<SubraceUpdateWithoutPersesInput, SubraceUncheckedUpdateWithoutPersesInput>
    create: XOR<SubraceCreateWithoutPersesInput, SubraceUncheckedCreateWithoutPersesInput>
    where?: SubraceWhereInput
  }

  export type SubraceUpdateToOneWithWhereWithoutPersesInput = {
    where?: SubraceWhereInput
    data: XOR<SubraceUpdateWithoutPersesInput, SubraceUncheckedUpdateWithoutPersesInput>
  }

  export type SubraceUpdateWithoutPersesInput = {
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitUpdateManyWithoutSubracesNestedInput
    race?: RaceUpdateOneRequiredWithoutSubracesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutSubraceNestedInput
    traits?: SubraceTraitUpdateManyWithoutSubraceNestedInput
  }

  export type SubraceUncheckedUpdateWithoutPersesInput = {
    subraceId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitUncheckedUpdateManyWithoutSubracesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutSubraceNestedInput
    traits?: SubraceTraitUncheckedUpdateManyWithoutSubraceNestedInput
  }

  export type BackgroundUpsertWithoutPersesInput = {
    update: XOR<BackgroundUpdateWithoutPersesInput, BackgroundUncheckedUpdateWithoutPersesInput>
    create: XOR<BackgroundCreateWithoutPersesInput, BackgroundUncheckedCreateWithoutPersesInput>
    where?: BackgroundWhereInput
  }

  export type BackgroundUpdateToOneWithWhereWithoutPersesInput = {
    where?: BackgroundWhereInput
    data: XOR<BackgroundUpdateWithoutPersesInput, BackgroundUncheckedUpdateWithoutPersesInput>
  }

  export type BackgroundUpdateWithoutPersesInput = {
    name?: EnumBackgroundCategoryFieldUpdateOperationsInput | $Enums.BackgroundCategory
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    toolProficiencies?: BackgroundUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: BackgroundUpdateskillProficienciesInput | $Enums.Skills[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BackgroundUncheckedUpdateWithoutPersesInput = {
    backgroundId?: IntFieldUpdateOperationsInput | number
    name?: EnumBackgroundCategoryFieldUpdateOperationsInput | $Enums.BackgroundCategory
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    toolProficiencies?: BackgroundUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: BackgroundUpdateskillProficienciesInput | $Enums.Skills[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PersSkillUpsertWithWhereUniqueWithoutPersInput = {
    where: PersSkillWhereUniqueInput
    update: XOR<PersSkillUpdateWithoutPersInput, PersSkillUncheckedUpdateWithoutPersInput>
    create: XOR<PersSkillCreateWithoutPersInput, PersSkillUncheckedCreateWithoutPersInput>
  }

  export type PersSkillUpdateWithWhereUniqueWithoutPersInput = {
    where: PersSkillWhereUniqueInput
    data: XOR<PersSkillUpdateWithoutPersInput, PersSkillUncheckedUpdateWithoutPersInput>
  }

  export type PersSkillUpdateManyWithWhereWithoutPersInput = {
    where: PersSkillScalarWhereInput
    data: XOR<PersSkillUpdateManyMutationInput, PersSkillUncheckedUpdateManyWithoutPersInput>
  }

  export type PersSkillScalarWhereInput = {
    AND?: PersSkillScalarWhereInput | PersSkillScalarWhereInput[]
    OR?: PersSkillScalarWhereInput[]
    NOT?: PersSkillScalarWhereInput | PersSkillScalarWhereInput[]
    persSkillId?: IntFilter<"PersSkill"> | number
    skillId?: IntFilter<"PersSkill"> | number
    persId?: IntFilter<"PersSkill"> | number
    proficiencyType?: EnumSkillProficiencyTypeFilter<"PersSkill"> | $Enums.SkillProficiencyType
    customModifier?: IntNullableFilter<"PersSkill"> | number | null
    name?: EnumSkillsFilter<"PersSkill"> | $Enums.Skills
  }

  export type PersMulticlassUpsertWithWhereUniqueWithoutPersInput = {
    where: PersMulticlassWhereUniqueInput
    update: XOR<PersMulticlassUpdateWithoutPersInput, PersMulticlassUncheckedUpdateWithoutPersInput>
    create: XOR<PersMulticlassCreateWithoutPersInput, PersMulticlassUncheckedCreateWithoutPersInput>
  }

  export type PersMulticlassUpdateWithWhereUniqueWithoutPersInput = {
    where: PersMulticlassWhereUniqueInput
    data: XOR<PersMulticlassUpdateWithoutPersInput, PersMulticlassUncheckedUpdateWithoutPersInput>
  }

  export type PersMulticlassUpdateManyWithWhereWithoutPersInput = {
    where: PersMulticlassScalarWhereInput
    data: XOR<PersMulticlassUpdateManyMutationInput, PersMulticlassUncheckedUpdateManyWithoutPersInput>
  }

  export type PersFeatureUpsertWithWhereUniqueWithoutPersInput = {
    where: PersFeatureWhereUniqueInput
    update: XOR<PersFeatureUpdateWithoutPersInput, PersFeatureUncheckedUpdateWithoutPersInput>
    create: XOR<PersFeatureCreateWithoutPersInput, PersFeatureUncheckedCreateWithoutPersInput>
  }

  export type PersFeatureUpdateWithWhereUniqueWithoutPersInput = {
    where: PersFeatureWhereUniqueInput
    data: XOR<PersFeatureUpdateWithoutPersInput, PersFeatureUncheckedUpdateWithoutPersInput>
  }

  export type PersFeatureUpdateManyWithWhereWithoutPersInput = {
    where: PersFeatureScalarWhereInput
    data: XOR<PersFeatureUpdateManyMutationInput, PersFeatureUncheckedUpdateManyWithoutPersInput>
  }

  export type PersFeatureScalarWhereInput = {
    AND?: PersFeatureScalarWhereInput | PersFeatureScalarWhereInput[]
    OR?: PersFeatureScalarWhereInput[]
    NOT?: PersFeatureScalarWhereInput | PersFeatureScalarWhereInput[]
    persFeatureId?: IntFilter<"PersFeature"> | number
    persId?: IntFilter<"PersFeature"> | number
    featureId?: IntFilter<"PersFeature"> | number
    usesRemaining?: IntNullableFilter<"PersFeature"> | number | null
  }

  export type SpellUpsertWithWhereUniqueWithoutPersesInput = {
    where: SpellWhereUniqueInput
    update: XOR<SpellUpdateWithoutPersesInput, SpellUncheckedUpdateWithoutPersesInput>
    create: XOR<SpellCreateWithoutPersesInput, SpellUncheckedCreateWithoutPersesInput>
  }

  export type SpellUpdateWithWhereUniqueWithoutPersesInput = {
    where: SpellWhereUniqueInput
    data: XOR<SpellUpdateWithoutPersesInput, SpellUncheckedUpdateWithoutPersesInput>
  }

  export type SpellUpdateManyWithWhereWithoutPersesInput = {
    where: SpellScalarWhereInput
    data: XOR<SpellUpdateManyMutationInput, SpellUncheckedUpdateManyWithoutPersesInput>
  }

  export type PersFeatUpsertWithWhereUniqueWithoutPersInput = {
    where: PersFeatWhereUniqueInput
    update: XOR<PersFeatUpdateWithoutPersInput, PersFeatUncheckedUpdateWithoutPersInput>
    create: XOR<PersFeatCreateWithoutPersInput, PersFeatUncheckedCreateWithoutPersInput>
  }

  export type PersFeatUpdateWithWhereUniqueWithoutPersInput = {
    where: PersFeatWhereUniqueInput
    data: XOR<PersFeatUpdateWithoutPersInput, PersFeatUncheckedUpdateWithoutPersInput>
  }

  export type PersFeatUpdateManyWithWhereWithoutPersInput = {
    where: PersFeatScalarWhereInput
    data: XOR<PersFeatUpdateManyMutationInput, PersFeatUncheckedUpdateManyWithoutPersInput>
  }

  export type PersFeatScalarWhereInput = {
    AND?: PersFeatScalarWhereInput | PersFeatScalarWhereInput[]
    OR?: PersFeatScalarWhereInput[]
    NOT?: PersFeatScalarWhereInput | PersFeatScalarWhereInput[]
    persFeatId?: IntFilter<"PersFeat"> | number
    featId?: IntFilter<"PersFeat"> | number
    persId?: IntFilter<"PersFeat"> | number
  }

  export type PersArmorUpsertWithWhereUniqueWithoutPersInput = {
    where: PersArmorWhereUniqueInput
    update: XOR<PersArmorUpdateWithoutPersInput, PersArmorUncheckedUpdateWithoutPersInput>
    create: XOR<PersArmorCreateWithoutPersInput, PersArmorUncheckedCreateWithoutPersInput>
  }

  export type PersArmorUpdateWithWhereUniqueWithoutPersInput = {
    where: PersArmorWhereUniqueInput
    data: XOR<PersArmorUpdateWithoutPersInput, PersArmorUncheckedUpdateWithoutPersInput>
  }

  export type PersArmorUpdateManyWithWhereWithoutPersInput = {
    where: PersArmorScalarWhereInput
    data: XOR<PersArmorUpdateManyMutationInput, PersArmorUncheckedUpdateManyWithoutPersInput>
  }

  export type PersArmorScalarWhereInput = {
    AND?: PersArmorScalarWhereInput | PersArmorScalarWhereInput[]
    OR?: PersArmorScalarWhereInput[]
    NOT?: PersArmorScalarWhereInput | PersArmorScalarWhereInput[]
    persArmorId?: IntFilter<"PersArmor"> | number
    armorId?: IntFilter<"PersArmor"> | number
    persId?: IntFilter<"PersArmor"> | number
    overrideBaseAC?: IntNullableFilter<"PersArmor"> | number | null
    miscACBonus?: IntNullableFilter<"PersArmor"> | number | null
    isProficient?: BoolFilter<"PersArmor"> | boolean
    equipped?: BoolFilter<"PersArmor"> | boolean
  }

  export type PersWeaponUpsertWithWhereUniqueWithoutPersInput = {
    where: PersWeaponWhereUniqueInput
    update: XOR<PersWeaponUpdateWithoutPersInput, PersWeaponUncheckedUpdateWithoutPersInput>
    create: XOR<PersWeaponCreateWithoutPersInput, PersWeaponUncheckedCreateWithoutPersInput>
  }

  export type PersWeaponUpdateWithWhereUniqueWithoutPersInput = {
    where: PersWeaponWhereUniqueInput
    data: XOR<PersWeaponUpdateWithoutPersInput, PersWeaponUncheckedUpdateWithoutPersInput>
  }

  export type PersWeaponUpdateManyWithWhereWithoutPersInput = {
    where: PersWeaponScalarWhereInput
    data: XOR<PersWeaponUpdateManyMutationInput, PersWeaponUncheckedUpdateManyWithoutPersInput>
  }

  export type PersWeaponScalarWhereInput = {
    AND?: PersWeaponScalarWhereInput | PersWeaponScalarWhereInput[]
    OR?: PersWeaponScalarWhereInput[]
    NOT?: PersWeaponScalarWhereInput | PersWeaponScalarWhereInput[]
    persWeaponId?: IntFilter<"PersWeapon"> | number
    persId?: IntFilter<"PersWeapon"> | number
    weaponId?: IntFilter<"PersWeapon"> | number
    overrideDamage?: StringNullableFilter<"PersWeapon"> | string | null
    attackBonus?: IntNullableFilter<"PersWeapon"> | number | null
    overrideName?: StringNullableFilter<"PersWeapon"> | string | null
    overrideNormalRange?: IntNullableFilter<"PersWeapon"> | number | null
    overrideLongRange?: IntNullableFilter<"PersWeapon"> | number | null
    overrideDamageType?: EnumDamageTypeNullableFilter<"PersWeapon"> | $Enums.DamageType | null
    overrideAttackAbility?: EnumAbilityNullableFilter<"PersWeapon"> | $Enums.Ability | null
    isProficient?: BoolFilter<"PersWeapon"> | boolean
  }

  export type PersMagicItemUpsertWithWhereUniqueWithoutPersInput = {
    where: PersMagicItemWhereUniqueInput
    update: XOR<PersMagicItemUpdateWithoutPersInput, PersMagicItemUncheckedUpdateWithoutPersInput>
    create: XOR<PersMagicItemCreateWithoutPersInput, PersMagicItemUncheckedCreateWithoutPersInput>
  }

  export type PersMagicItemUpdateWithWhereUniqueWithoutPersInput = {
    where: PersMagicItemWhereUniqueInput
    data: XOR<PersMagicItemUpdateWithoutPersInput, PersMagicItemUncheckedUpdateWithoutPersInput>
  }

  export type PersMagicItemUpdateManyWithWhereWithoutPersInput = {
    where: PersMagicItemScalarWhereInput
    data: XOR<PersMagicItemUpdateManyMutationInput, PersMagicItemUncheckedUpdateManyWithoutPersInput>
  }

  export type PersMagicItemScalarWhereInput = {
    AND?: PersMagicItemScalarWhereInput | PersMagicItemScalarWhereInput[]
    OR?: PersMagicItemScalarWhereInput[]
    NOT?: PersMagicItemScalarWhereInput | PersMagicItemScalarWhereInput[]
    persMagicItemId?: IntFilter<"PersMagicItem"> | number
    persId?: IntFilter<"PersMagicItem"> | number
    magicItemId?: IntFilter<"PersMagicItem"> | number
  }

  export type RaceVariantUpsertWithWhereUniqueWithoutPersesInput = {
    where: RaceVariantWhereUniqueInput
    update: XOR<RaceVariantUpdateWithoutPersesInput, RaceVariantUncheckedUpdateWithoutPersesInput>
    create: XOR<RaceVariantCreateWithoutPersesInput, RaceVariantUncheckedCreateWithoutPersesInput>
  }

  export type RaceVariantUpdateWithWhereUniqueWithoutPersesInput = {
    where: RaceVariantWhereUniqueInput
    data: XOR<RaceVariantUpdateWithoutPersesInput, RaceVariantUncheckedUpdateWithoutPersesInput>
  }

  export type RaceVariantUpdateManyWithWhereWithoutPersesInput = {
    where: RaceVariantScalarWhereInput
    data: XOR<RaceVariantUpdateManyMutationInput, RaceVariantUncheckedUpdateManyWithoutPersesInput>
  }

  export type RaceVariantScalarWhereInput = {
    AND?: RaceVariantScalarWhereInput | RaceVariantScalarWhereInput[]
    OR?: RaceVariantScalarWhereInput[]
    NOT?: RaceVariantScalarWhereInput | RaceVariantScalarWhereInput[]
    raceVariantId?: IntFilter<"RaceVariant"> | number
    raceId?: IntFilter<"RaceVariant"> | number
    name?: EnumVariantsFilter<"RaceVariant"> | $Enums.Variants
    source?: EnumSourceFilter<"RaceVariant"> | $Enums.Source
    exclusivityGroup?: StringNullableFilter<"RaceVariant"> | string | null
    overridesRaceASI?: JsonFilter<"RaceVariant">
    overridesRaceSpeed?: IntNullableFilter<"RaceVariant"> | number | null
    overridesFlightSpeed?: IntNullableFilter<"RaceVariant"> | number | null
  }

  export type RaceChoiceOptionUpsertWithWhereUniqueWithoutPersesInput = {
    where: RaceChoiceOptionWhereUniqueInput
    update: XOR<RaceChoiceOptionUpdateWithoutPersesInput, RaceChoiceOptionUncheckedUpdateWithoutPersesInput>
    create: XOR<RaceChoiceOptionCreateWithoutPersesInput, RaceChoiceOptionUncheckedCreateWithoutPersesInput>
  }

  export type RaceChoiceOptionUpdateWithWhereUniqueWithoutPersesInput = {
    where: RaceChoiceOptionWhereUniqueInput
    data: XOR<RaceChoiceOptionUpdateWithoutPersesInput, RaceChoiceOptionUncheckedUpdateWithoutPersesInput>
  }

  export type RaceChoiceOptionUpdateManyWithWhereWithoutPersesInput = {
    where: RaceChoiceOptionScalarWhereInput
    data: XOR<RaceChoiceOptionUpdateManyMutationInput, RaceChoiceOptionUncheckedUpdateManyWithoutPersesInput>
  }

  export type RaceChoiceOptionScalarWhereInput = {
    AND?: RaceChoiceOptionScalarWhereInput | RaceChoiceOptionScalarWhereInput[]
    OR?: RaceChoiceOptionScalarWhereInput[]
    NOT?: RaceChoiceOptionScalarWhereInput | RaceChoiceOptionScalarWhereInput[]
    optionId?: IntFilter<"RaceChoiceOption"> | number
    raceId?: IntFilter<"RaceChoiceOption"> | number
    subraceId?: IntNullableFilter<"RaceChoiceOption"> | number | null
    choiceGroupName?: StringFilter<"RaceChoiceOption"> | string
    optionName?: StringFilter<"RaceChoiceOption"> | string
    description?: StringNullableFilter<"RaceChoiceOption"> | string | null
    selectMultiple?: BoolFilter<"RaceChoiceOption"> | boolean
    maxSelection?: IntFilter<"RaceChoiceOption"> | number
    grantsASI?: JsonNullableFilter<"RaceChoiceOption">
    grantsSkillProficiencies?: EnumSkillsNullableListFilter<"RaceChoiceOption">
    grantsLanguages?: EnumLanguageNullableListFilter<"RaceChoiceOption">
    languagesToChooseCount?: IntFilter<"RaceChoiceOption"> | number
    modifiesSpeed?: IntNullableFilter<"RaceChoiceOption"> | number | null
    draconicDamageType?: EnumDamageTypeNullableFilter<"RaceChoiceOption"> | $Enums.DamageType | null
    breathWeaponShape?: EnumAOEShapesNullableFilter<"RaceChoiceOption"> | $Enums.AOEShapes | null
    breathWeaponAOE?: StringNullableFilter<"RaceChoiceOption"> | string | null
  }

  export type PersCreateWithoutMulticlassesInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    class: ClassCreateNestedOneWithoutPersesInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutMulticlassesInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutMulticlassesInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutMulticlassesInput, PersUncheckedCreateWithoutMulticlassesInput>
  }

  export type ClassCreateWithoutPersMulticlassesInput = {
    name: string
    hitDie: number
    primaryCastingStat?: $Enums.Ability | null
    spellcastingType?: $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassCreateabilityScoreUpLevelsInput | number[]
    subclassLevel?: number
    multiclassStrReq?: number
    multiclassDexReq?: number
    multiclassConReq?: number
    multiclassIntReq?: number
    multiclassWisReq?: number
    multiclassChaReq?: number
    armorProficiencies?: ClassCreatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassCreateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassCreatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassCreateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: number
    languages?: ClassCreatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subclasses?: SubclassCreateNestedManyWithoutClassInput
    classFeatures?: ClassFeatureCreateNestedManyWithoutClassInput
    perses?: PersCreateNestedManyWithoutClassInput
    startingEquipmentOption?: ClassStartingEquipmentOptionCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutPersMulticlassesInput = {
    classId?: number
    name: string
    hitDie: number
    primaryCastingStat?: $Enums.Ability | null
    spellcastingType?: $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassCreateabilityScoreUpLevelsInput | number[]
    subclassLevel?: number
    multiclassStrReq?: number
    multiclassDexReq?: number
    multiclassConReq?: number
    multiclassIntReq?: number
    multiclassWisReq?: number
    multiclassChaReq?: number
    armorProficiencies?: ClassCreatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassCreateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassCreatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassCreateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: number
    languages?: ClassCreatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subclasses?: SubclassUncheckedCreateNestedManyWithoutClassInput
    classFeatures?: ClassFeatureUncheckedCreateNestedManyWithoutClassInput
    perses?: PersUncheckedCreateNestedManyWithoutClassInput
    startingEquipmentOption?: ClassStartingEquipmentOptionUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutPersMulticlassesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutPersMulticlassesInput, ClassUncheckedCreateWithoutPersMulticlassesInput>
  }

  export type SubclassCreateWithoutPersMulticlassesInput = {
    name: string
    description?: string | null
    grantsSpells?: boolean
    languagesToChooseCount?: number
    languages?: SubclassCreatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellCreateNestedManyWithoutSubclassesInput
    class: ClassCreateNestedOneWithoutSubclassesInput
    features?: SubclassFeatureCreateNestedManyWithoutSubclassInput
    perses?: PersCreateNestedManyWithoutSubclassInput
  }

  export type SubclassUncheckedCreateWithoutPersMulticlassesInput = {
    subclassId?: number
    classId: number
    name: string
    description?: string | null
    grantsSpells?: boolean
    languagesToChooseCount?: number
    languages?: SubclassCreatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellUncheckedCreateNestedManyWithoutSubclassesInput
    features?: SubclassFeatureUncheckedCreateNestedManyWithoutSubclassInput
    perses?: PersUncheckedCreateNestedManyWithoutSubclassInput
  }

  export type SubclassCreateOrConnectWithoutPersMulticlassesInput = {
    where: SubclassWhereUniqueInput
    create: XOR<SubclassCreateWithoutPersMulticlassesInput, SubclassUncheckedCreateWithoutPersMulticlassesInput>
  }

  export type PersUpsertWithoutMulticlassesInput = {
    update: XOR<PersUpdateWithoutMulticlassesInput, PersUncheckedUpdateWithoutMulticlassesInput>
    create: XOR<PersCreateWithoutMulticlassesInput, PersUncheckedCreateWithoutMulticlassesInput>
    where?: PersWhereInput
  }

  export type PersUpdateToOneWithWhereWithoutMulticlassesInput = {
    where?: PersWhereInput
    data: XOR<PersUpdateWithoutMulticlassesInput, PersUncheckedUpdateWithoutMulticlassesInput>
  }

  export type PersUpdateWithoutMulticlassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutMulticlassesInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type ClassUpsertWithoutPersMulticlassesInput = {
    update: XOR<ClassUpdateWithoutPersMulticlassesInput, ClassUncheckedUpdateWithoutPersMulticlassesInput>
    create: XOR<ClassCreateWithoutPersMulticlassesInput, ClassUncheckedCreateWithoutPersMulticlassesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutPersMulticlassesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutPersMulticlassesInput, ClassUncheckedUpdateWithoutPersMulticlassesInput>
  }

  export type ClassUpdateWithoutPersMulticlassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    hitDie?: IntFieldUpdateOperationsInput | number
    primaryCastingStat?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFieldUpdateOperationsInput | $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassUpdateabilityScoreUpLevelsInput | number[]
    subclassLevel?: IntFieldUpdateOperationsInput | number
    multiclassStrReq?: IntFieldUpdateOperationsInput | number
    multiclassDexReq?: IntFieldUpdateOperationsInput | number
    multiclassConReq?: IntFieldUpdateOperationsInput | number
    multiclassIntReq?: IntFieldUpdateOperationsInput | number
    multiclassWisReq?: IntFieldUpdateOperationsInput | number
    multiclassChaReq?: IntFieldUpdateOperationsInput | number
    armorProficiencies?: ClassUpdatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassUpdateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassUpdatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassUpdateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: ClassUpdatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subclasses?: SubclassUpdateManyWithoutClassNestedInput
    classFeatures?: ClassFeatureUpdateManyWithoutClassNestedInput
    perses?: PersUpdateManyWithoutClassNestedInput
    startingEquipmentOption?: ClassStartingEquipmentOptionUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutPersMulticlassesInput = {
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    hitDie?: IntFieldUpdateOperationsInput | number
    primaryCastingStat?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFieldUpdateOperationsInput | $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassUpdateabilityScoreUpLevelsInput | number[]
    subclassLevel?: IntFieldUpdateOperationsInput | number
    multiclassStrReq?: IntFieldUpdateOperationsInput | number
    multiclassDexReq?: IntFieldUpdateOperationsInput | number
    multiclassConReq?: IntFieldUpdateOperationsInput | number
    multiclassIntReq?: IntFieldUpdateOperationsInput | number
    multiclassWisReq?: IntFieldUpdateOperationsInput | number
    multiclassChaReq?: IntFieldUpdateOperationsInput | number
    armorProficiencies?: ClassUpdatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassUpdateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassUpdatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassUpdateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: ClassUpdatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subclasses?: SubclassUncheckedUpdateManyWithoutClassNestedInput
    classFeatures?: ClassFeatureUncheckedUpdateManyWithoutClassNestedInput
    perses?: PersUncheckedUpdateManyWithoutClassNestedInput
    startingEquipmentOption?: ClassStartingEquipmentOptionUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SubclassUpsertWithoutPersMulticlassesInput = {
    update: XOR<SubclassUpdateWithoutPersMulticlassesInput, SubclassUncheckedUpdateWithoutPersMulticlassesInput>
    create: XOR<SubclassCreateWithoutPersMulticlassesInput, SubclassUncheckedCreateWithoutPersMulticlassesInput>
    where?: SubclassWhereInput
  }

  export type SubclassUpdateToOneWithWhereWithoutPersMulticlassesInput = {
    where?: SubclassWhereInput
    data: XOR<SubclassUpdateWithoutPersMulticlassesInput, SubclassUncheckedUpdateWithoutPersMulticlassesInput>
  }

  export type SubclassUpdateWithoutPersMulticlassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellUpdateManyWithoutSubclassesNestedInput
    class?: ClassUpdateOneRequiredWithoutSubclassesNestedInput
    features?: SubclassFeatureUpdateManyWithoutSubclassNestedInput
    perses?: PersUpdateManyWithoutSubclassNestedInput
  }

  export type SubclassUncheckedUpdateWithoutPersMulticlassesInput = {
    subclassId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellUncheckedUpdateManyWithoutSubclassesNestedInput
    features?: SubclassFeatureUncheckedUpdateManyWithoutSubclassNestedInput
    perses?: PersUncheckedUpdateManyWithoutSubclassNestedInput
  }

  export type FeatureCreateWithoutPersFeaturesInput = {
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutPersFeaturesInput = {
    featureId?: number
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellUncheckedCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitUncheckedCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureUncheckedCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutPersFeaturesInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutPersFeaturesInput, FeatureUncheckedCreateWithoutPersFeaturesInput>
  }

  export type PersCreateWithoutFeaturesInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    class: ClassCreateNestedOneWithoutPersesInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutFeaturesInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutFeaturesInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutFeaturesInput, PersUncheckedCreateWithoutFeaturesInput>
  }

  export type FeatureUpsertWithoutPersFeaturesInput = {
    update: XOR<FeatureUpdateWithoutPersFeaturesInput, FeatureUncheckedUpdateWithoutPersFeaturesInput>
    create: XOR<FeatureCreateWithoutPersFeaturesInput, FeatureUncheckedCreateWithoutPersFeaturesInput>
    where?: FeatureWhereInput
  }

  export type FeatureUpdateToOneWithWhereWithoutPersFeaturesInput = {
    where?: FeatureWhereInput
    data: XOR<FeatureUpdateWithoutPersFeaturesInput, FeatureUncheckedUpdateWithoutPersFeaturesInput>
  }

  export type FeatureUpdateWithoutPersFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateWithoutPersFeaturesInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUncheckedUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type PersUpsertWithoutFeaturesInput = {
    update: XOR<PersUpdateWithoutFeaturesInput, PersUncheckedUpdateWithoutFeaturesInput>
    create: XOR<PersCreateWithoutFeaturesInput, PersUncheckedCreateWithoutFeaturesInput>
    where?: PersWhereInput
  }

  export type PersUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: PersWhereInput
    data: XOR<PersUpdateWithoutFeaturesInput, PersUncheckedUpdateWithoutFeaturesInput>
  }

  export type PersUpdateWithoutFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutFeaturesInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type SpellCreateWithoutFeaturesInput = {
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    characterSpells?: CharacterSpellsCreateNestedManyWithoutSpellInput
    spellClasses?: SpellClassesCreateNestedManyWithoutSpellInput
    spellRaces?: SpellRacesCreateNestedManyWithoutSpellInput
    spellbookSpells?: SpellbookSpellsCreateNestedManyWithoutSpellInput
    subclasses?: SubclassCreateNestedManyWithoutExpandedSpellsInput
    perses?: PersCreateNestedManyWithoutSpellsInput
  }

  export type SpellUncheckedCreateWithoutFeaturesInput = {
    spellId?: number
    name: string
    level: number
    school?: string | null
    castingTime: string
    range: string
    components?: string | null
    duration: string
    description: string
    hasRitual?: string | null
    hasConcentration?: string | null
    source?: $Enums.Source
    characterSpells?: CharacterSpellsUncheckedCreateNestedManyWithoutSpellInput
    spellClasses?: SpellClassesUncheckedCreateNestedManyWithoutSpellInput
    spellRaces?: SpellRacesUncheckedCreateNestedManyWithoutSpellInput
    spellbookSpells?: SpellbookSpellsUncheckedCreateNestedManyWithoutSpellInput
    subclasses?: SubclassUncheckedCreateNestedManyWithoutExpandedSpellsInput
    perses?: PersUncheckedCreateNestedManyWithoutSpellsInput
  }

  export type SpellCreateOrConnectWithoutFeaturesInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutFeaturesInput, SpellUncheckedCreateWithoutFeaturesInput>
  }

  export type ClassFeatureCreateWithoutFeatureInput = {
    levelGranted: number
    grantsSpellSlots?: boolean
    class: ClassCreateNestedOneWithoutClassFeaturesInput
  }

  export type ClassFeatureUncheckedCreateWithoutFeatureInput = {
    classFeatureId?: number
    classId: number
    levelGranted: number
    grantsSpellSlots?: boolean
  }

  export type ClassFeatureCreateOrConnectWithoutFeatureInput = {
    where: ClassFeatureWhereUniqueInput
    create: XOR<ClassFeatureCreateWithoutFeatureInput, ClassFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type ClassFeatureCreateManyFeatureInputEnvelope = {
    data: ClassFeatureCreateManyFeatureInput | ClassFeatureCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type SubclassFeatureCreateWithoutFeatureInput = {
    levelGranted: number
    grantsSpellSlots?: boolean
    subclass: SubclassCreateNestedOneWithoutFeaturesInput
  }

  export type SubclassFeatureUncheckedCreateWithoutFeatureInput = {
    subclassFeatureId?: number
    subclassId: number
    levelGranted: number
    grantsSpellSlots?: boolean
  }

  export type SubclassFeatureCreateOrConnectWithoutFeatureInput = {
    where: SubclassFeatureWhereUniqueInput
    create: XOR<SubclassFeatureCreateWithoutFeatureInput, SubclassFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type SubclassFeatureCreateManyFeatureInputEnvelope = {
    data: SubclassFeatureCreateManyFeatureInput | SubclassFeatureCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type RaceTraitCreateWithoutFeatureInput = {
    race: RaceCreateNestedOneWithoutTraitsInput
    subraces?: SubraceCreateNestedManyWithoutReplacesTraitsInput
    raceVariants?: RaceVariantCreateNestedManyWithoutReplacesTraitsInput
  }

  export type RaceTraitUncheckedCreateWithoutFeatureInput = {
    raceTraitId?: number
    raceId: number
    subraces?: SubraceUncheckedCreateNestedManyWithoutReplacesTraitsInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutReplacesTraitsInput
  }

  export type RaceTraitCreateOrConnectWithoutFeatureInput = {
    where: RaceTraitWhereUniqueInput
    create: XOR<RaceTraitCreateWithoutFeatureInput, RaceTraitUncheckedCreateWithoutFeatureInput>
  }

  export type RaceTraitCreateManyFeatureInputEnvelope = {
    data: RaceTraitCreateManyFeatureInput | RaceTraitCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type SubraceTraitCreateWithoutFeatureInput = {
    subrace: SubraceCreateNestedOneWithoutTraitsInput
  }

  export type SubraceTraitUncheckedCreateWithoutFeatureInput = {
    subraceTraitId?: number
    subraceId: number
  }

  export type SubraceTraitCreateOrConnectWithoutFeatureInput = {
    where: SubraceTraitWhereUniqueInput
    create: XOR<SubraceTraitCreateWithoutFeatureInput, SubraceTraitUncheckedCreateWithoutFeatureInput>
  }

  export type SubraceTraitCreateManyFeatureInputEnvelope = {
    data: SubraceTraitCreateManyFeatureInput | SubraceTraitCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type RaceVariantTraitCreateWithoutFeatureInput = {
    raceVariant: RaceVariantCreateNestedOneWithoutTraitsInput
  }

  export type RaceVariantTraitUncheckedCreateWithoutFeatureInput = {
    raceVariantTraitId?: number
    raceVariantId: number
  }

  export type RaceVariantTraitCreateOrConnectWithoutFeatureInput = {
    where: RaceVariantTraitWhereUniqueInput
    create: XOR<RaceVariantTraitCreateWithoutFeatureInput, RaceVariantTraitUncheckedCreateWithoutFeatureInput>
  }

  export type RaceVariantTraitCreateManyFeatureInputEnvelope = {
    data: RaceVariantTraitCreateManyFeatureInput | RaceVariantTraitCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type RaceChoiceOptionTraitCreateWithoutFeatureInput = {
    raceChoiceOption: RaceChoiceOptionCreateNestedOneWithoutGrantsTraitsInput
  }

  export type RaceChoiceOptionTraitUncheckedCreateWithoutFeatureInput = {
    raceChoiceOptionTraitId?: number
    optionId: number
  }

  export type RaceChoiceOptionTraitCreateOrConnectWithoutFeatureInput = {
    where: RaceChoiceOptionTraitWhereUniqueInput
    create: XOR<RaceChoiceOptionTraitCreateWithoutFeatureInput, RaceChoiceOptionTraitUncheckedCreateWithoutFeatureInput>
  }

  export type RaceChoiceOptionTraitCreateManyFeatureInputEnvelope = {
    data: RaceChoiceOptionTraitCreateManyFeatureInput | RaceChoiceOptionTraitCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type FeatFeatureCreateWithoutFeatureInput = {
    feat: FeatCreateNestedOneWithoutFeatFeaturesInput
  }

  export type FeatFeatureUncheckedCreateWithoutFeatureInput = {
    featFeatureId?: number
    featId: number
  }

  export type FeatFeatureCreateOrConnectWithoutFeatureInput = {
    where: FeatFeatureWhereUniqueInput
    create: XOR<FeatFeatureCreateWithoutFeatureInput, FeatFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type FeatFeatureCreateManyFeatureInputEnvelope = {
    data: FeatFeatureCreateManyFeatureInput | FeatFeatureCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type MagicItemFeatureCreateWithoutFeatureInput = {
    magicItem: MagicItemCreateNestedOneWithoutFeaturesInput
  }

  export type MagicItemFeatureUncheckedCreateWithoutFeatureInput = {
    magicItemFeatureId?: number
    magicItemId: number
  }

  export type MagicItemFeatureCreateOrConnectWithoutFeatureInput = {
    where: MagicItemFeatureWhereUniqueInput
    create: XOR<MagicItemFeatureCreateWithoutFeatureInput, MagicItemFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type MagicItemFeatureCreateManyFeatureInputEnvelope = {
    data: MagicItemFeatureCreateManyFeatureInput | MagicItemFeatureCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type PersFeatureCreateWithoutFeatureInput = {
    usesRemaining?: number | null
    pers: PersCreateNestedOneWithoutFeaturesInput
  }

  export type PersFeatureUncheckedCreateWithoutFeatureInput = {
    persFeatureId?: number
    persId: number
    usesRemaining?: number | null
  }

  export type PersFeatureCreateOrConnectWithoutFeatureInput = {
    where: PersFeatureWhereUniqueInput
    create: XOR<PersFeatureCreateWithoutFeatureInput, PersFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type PersFeatureCreateManyFeatureInputEnvelope = {
    data: PersFeatureCreateManyFeatureInput | PersFeatureCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type SpellUpsertWithWhereUniqueWithoutFeaturesInput = {
    where: SpellWhereUniqueInput
    update: XOR<SpellUpdateWithoutFeaturesInput, SpellUncheckedUpdateWithoutFeaturesInput>
    create: XOR<SpellCreateWithoutFeaturesInput, SpellUncheckedCreateWithoutFeaturesInput>
  }

  export type SpellUpdateWithWhereUniqueWithoutFeaturesInput = {
    where: SpellWhereUniqueInput
    data: XOR<SpellUpdateWithoutFeaturesInput, SpellUncheckedUpdateWithoutFeaturesInput>
  }

  export type SpellUpdateManyWithWhereWithoutFeaturesInput = {
    where: SpellScalarWhereInput
    data: XOR<SpellUpdateManyMutationInput, SpellUncheckedUpdateManyWithoutFeaturesInput>
  }

  export type ClassFeatureUpsertWithWhereUniqueWithoutFeatureInput = {
    where: ClassFeatureWhereUniqueInput
    update: XOR<ClassFeatureUpdateWithoutFeatureInput, ClassFeatureUncheckedUpdateWithoutFeatureInput>
    create: XOR<ClassFeatureCreateWithoutFeatureInput, ClassFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type ClassFeatureUpdateWithWhereUniqueWithoutFeatureInput = {
    where: ClassFeatureWhereUniqueInput
    data: XOR<ClassFeatureUpdateWithoutFeatureInput, ClassFeatureUncheckedUpdateWithoutFeatureInput>
  }

  export type ClassFeatureUpdateManyWithWhereWithoutFeatureInput = {
    where: ClassFeatureScalarWhereInput
    data: XOR<ClassFeatureUpdateManyMutationInput, ClassFeatureUncheckedUpdateManyWithoutFeatureInput>
  }

  export type SubclassFeatureUpsertWithWhereUniqueWithoutFeatureInput = {
    where: SubclassFeatureWhereUniqueInput
    update: XOR<SubclassFeatureUpdateWithoutFeatureInput, SubclassFeatureUncheckedUpdateWithoutFeatureInput>
    create: XOR<SubclassFeatureCreateWithoutFeatureInput, SubclassFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type SubclassFeatureUpdateWithWhereUniqueWithoutFeatureInput = {
    where: SubclassFeatureWhereUniqueInput
    data: XOR<SubclassFeatureUpdateWithoutFeatureInput, SubclassFeatureUncheckedUpdateWithoutFeatureInput>
  }

  export type SubclassFeatureUpdateManyWithWhereWithoutFeatureInput = {
    where: SubclassFeatureScalarWhereInput
    data: XOR<SubclassFeatureUpdateManyMutationInput, SubclassFeatureUncheckedUpdateManyWithoutFeatureInput>
  }

  export type RaceTraitUpsertWithWhereUniqueWithoutFeatureInput = {
    where: RaceTraitWhereUniqueInput
    update: XOR<RaceTraitUpdateWithoutFeatureInput, RaceTraitUncheckedUpdateWithoutFeatureInput>
    create: XOR<RaceTraitCreateWithoutFeatureInput, RaceTraitUncheckedCreateWithoutFeatureInput>
  }

  export type RaceTraitUpdateWithWhereUniqueWithoutFeatureInput = {
    where: RaceTraitWhereUniqueInput
    data: XOR<RaceTraitUpdateWithoutFeatureInput, RaceTraitUncheckedUpdateWithoutFeatureInput>
  }

  export type RaceTraitUpdateManyWithWhereWithoutFeatureInput = {
    where: RaceTraitScalarWhereInput
    data: XOR<RaceTraitUpdateManyMutationInput, RaceTraitUncheckedUpdateManyWithoutFeatureInput>
  }

  export type RaceTraitScalarWhereInput = {
    AND?: RaceTraitScalarWhereInput | RaceTraitScalarWhereInput[]
    OR?: RaceTraitScalarWhereInput[]
    NOT?: RaceTraitScalarWhereInput | RaceTraitScalarWhereInput[]
    raceTraitId?: IntFilter<"RaceTrait"> | number
    raceId?: IntFilter<"RaceTrait"> | number
    featureId?: IntFilter<"RaceTrait"> | number
  }

  export type SubraceTraitUpsertWithWhereUniqueWithoutFeatureInput = {
    where: SubraceTraitWhereUniqueInput
    update: XOR<SubraceTraitUpdateWithoutFeatureInput, SubraceTraitUncheckedUpdateWithoutFeatureInput>
    create: XOR<SubraceTraitCreateWithoutFeatureInput, SubraceTraitUncheckedCreateWithoutFeatureInput>
  }

  export type SubraceTraitUpdateWithWhereUniqueWithoutFeatureInput = {
    where: SubraceTraitWhereUniqueInput
    data: XOR<SubraceTraitUpdateWithoutFeatureInput, SubraceTraitUncheckedUpdateWithoutFeatureInput>
  }

  export type SubraceTraitUpdateManyWithWhereWithoutFeatureInput = {
    where: SubraceTraitScalarWhereInput
    data: XOR<SubraceTraitUpdateManyMutationInput, SubraceTraitUncheckedUpdateManyWithoutFeatureInput>
  }

  export type SubraceTraitScalarWhereInput = {
    AND?: SubraceTraitScalarWhereInput | SubraceTraitScalarWhereInput[]
    OR?: SubraceTraitScalarWhereInput[]
    NOT?: SubraceTraitScalarWhereInput | SubraceTraitScalarWhereInput[]
    subraceTraitId?: IntFilter<"SubraceTrait"> | number
    subraceId?: IntFilter<"SubraceTrait"> | number
    featureId?: IntFilter<"SubraceTrait"> | number
  }

  export type RaceVariantTraitUpsertWithWhereUniqueWithoutFeatureInput = {
    where: RaceVariantTraitWhereUniqueInput
    update: XOR<RaceVariantTraitUpdateWithoutFeatureInput, RaceVariantTraitUncheckedUpdateWithoutFeatureInput>
    create: XOR<RaceVariantTraitCreateWithoutFeatureInput, RaceVariantTraitUncheckedCreateWithoutFeatureInput>
  }

  export type RaceVariantTraitUpdateWithWhereUniqueWithoutFeatureInput = {
    where: RaceVariantTraitWhereUniqueInput
    data: XOR<RaceVariantTraitUpdateWithoutFeatureInput, RaceVariantTraitUncheckedUpdateWithoutFeatureInput>
  }

  export type RaceVariantTraitUpdateManyWithWhereWithoutFeatureInput = {
    where: RaceVariantTraitScalarWhereInput
    data: XOR<RaceVariantTraitUpdateManyMutationInput, RaceVariantTraitUncheckedUpdateManyWithoutFeatureInput>
  }

  export type RaceVariantTraitScalarWhereInput = {
    AND?: RaceVariantTraitScalarWhereInput | RaceVariantTraitScalarWhereInput[]
    OR?: RaceVariantTraitScalarWhereInput[]
    NOT?: RaceVariantTraitScalarWhereInput | RaceVariantTraitScalarWhereInput[]
    raceVariantTraitId?: IntFilter<"RaceVariantTrait"> | number
    raceVariantId?: IntFilter<"RaceVariantTrait"> | number
    featureId?: IntFilter<"RaceVariantTrait"> | number
  }

  export type RaceChoiceOptionTraitUpsertWithWhereUniqueWithoutFeatureInput = {
    where: RaceChoiceOptionTraitWhereUniqueInput
    update: XOR<RaceChoiceOptionTraitUpdateWithoutFeatureInput, RaceChoiceOptionTraitUncheckedUpdateWithoutFeatureInput>
    create: XOR<RaceChoiceOptionTraitCreateWithoutFeatureInput, RaceChoiceOptionTraitUncheckedCreateWithoutFeatureInput>
  }

  export type RaceChoiceOptionTraitUpdateWithWhereUniqueWithoutFeatureInput = {
    where: RaceChoiceOptionTraitWhereUniqueInput
    data: XOR<RaceChoiceOptionTraitUpdateWithoutFeatureInput, RaceChoiceOptionTraitUncheckedUpdateWithoutFeatureInput>
  }

  export type RaceChoiceOptionTraitUpdateManyWithWhereWithoutFeatureInput = {
    where: RaceChoiceOptionTraitScalarWhereInput
    data: XOR<RaceChoiceOptionTraitUpdateManyMutationInput, RaceChoiceOptionTraitUncheckedUpdateManyWithoutFeatureInput>
  }

  export type RaceChoiceOptionTraitScalarWhereInput = {
    AND?: RaceChoiceOptionTraitScalarWhereInput | RaceChoiceOptionTraitScalarWhereInput[]
    OR?: RaceChoiceOptionTraitScalarWhereInput[]
    NOT?: RaceChoiceOptionTraitScalarWhereInput | RaceChoiceOptionTraitScalarWhereInput[]
    raceChoiceOptionTraitId?: IntFilter<"RaceChoiceOptionTrait"> | number
    optionId?: IntFilter<"RaceChoiceOptionTrait"> | number
    featureId?: IntFilter<"RaceChoiceOptionTrait"> | number
  }

  export type FeatFeatureUpsertWithWhereUniqueWithoutFeatureInput = {
    where: FeatFeatureWhereUniqueInput
    update: XOR<FeatFeatureUpdateWithoutFeatureInput, FeatFeatureUncheckedUpdateWithoutFeatureInput>
    create: XOR<FeatFeatureCreateWithoutFeatureInput, FeatFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type FeatFeatureUpdateWithWhereUniqueWithoutFeatureInput = {
    where: FeatFeatureWhereUniqueInput
    data: XOR<FeatFeatureUpdateWithoutFeatureInput, FeatFeatureUncheckedUpdateWithoutFeatureInput>
  }

  export type FeatFeatureUpdateManyWithWhereWithoutFeatureInput = {
    where: FeatFeatureScalarWhereInput
    data: XOR<FeatFeatureUpdateManyMutationInput, FeatFeatureUncheckedUpdateManyWithoutFeatureInput>
  }

  export type FeatFeatureScalarWhereInput = {
    AND?: FeatFeatureScalarWhereInput | FeatFeatureScalarWhereInput[]
    OR?: FeatFeatureScalarWhereInput[]
    NOT?: FeatFeatureScalarWhereInput | FeatFeatureScalarWhereInput[]
    featFeatureId?: IntFilter<"FeatFeature"> | number
    featId?: IntFilter<"FeatFeature"> | number
    featureId?: IntFilter<"FeatFeature"> | number
  }

  export type MagicItemFeatureUpsertWithWhereUniqueWithoutFeatureInput = {
    where: MagicItemFeatureWhereUniqueInput
    update: XOR<MagicItemFeatureUpdateWithoutFeatureInput, MagicItemFeatureUncheckedUpdateWithoutFeatureInput>
    create: XOR<MagicItemFeatureCreateWithoutFeatureInput, MagicItemFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type MagicItemFeatureUpdateWithWhereUniqueWithoutFeatureInput = {
    where: MagicItemFeatureWhereUniqueInput
    data: XOR<MagicItemFeatureUpdateWithoutFeatureInput, MagicItemFeatureUncheckedUpdateWithoutFeatureInput>
  }

  export type MagicItemFeatureUpdateManyWithWhereWithoutFeatureInput = {
    where: MagicItemFeatureScalarWhereInput
    data: XOR<MagicItemFeatureUpdateManyMutationInput, MagicItemFeatureUncheckedUpdateManyWithoutFeatureInput>
  }

  export type MagicItemFeatureScalarWhereInput = {
    AND?: MagicItemFeatureScalarWhereInput | MagicItemFeatureScalarWhereInput[]
    OR?: MagicItemFeatureScalarWhereInput[]
    NOT?: MagicItemFeatureScalarWhereInput | MagicItemFeatureScalarWhereInput[]
    magicItemFeatureId?: IntFilter<"MagicItemFeature"> | number
    magicItemId?: IntFilter<"MagicItemFeature"> | number
    featureId?: IntFilter<"MagicItemFeature"> | number
  }

  export type PersFeatureUpsertWithWhereUniqueWithoutFeatureInput = {
    where: PersFeatureWhereUniqueInput
    update: XOR<PersFeatureUpdateWithoutFeatureInput, PersFeatureUncheckedUpdateWithoutFeatureInput>
    create: XOR<PersFeatureCreateWithoutFeatureInput, PersFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type PersFeatureUpdateWithWhereUniqueWithoutFeatureInput = {
    where: PersFeatureWhereUniqueInput
    data: XOR<PersFeatureUpdateWithoutFeatureInput, PersFeatureUncheckedUpdateWithoutFeatureInput>
  }

  export type PersFeatureUpdateManyWithWhereWithoutFeatureInput = {
    where: PersFeatureScalarWhereInput
    data: XOR<PersFeatureUpdateManyMutationInput, PersFeatureUncheckedUpdateManyWithoutFeatureInput>
  }

  export type FeatureCreateWithoutClassFeaturesInput = {
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellCreateNestedManyWithoutFeaturesInput
    subclassFeatures?: SubclassFeatureCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutClassFeaturesInput = {
    featureId?: number
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellUncheckedCreateNestedManyWithoutFeaturesInput
    subclassFeatures?: SubclassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitUncheckedCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureUncheckedCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureUncheckedCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutClassFeaturesInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutClassFeaturesInput, FeatureUncheckedCreateWithoutClassFeaturesInput>
  }

  export type ClassCreateWithoutClassFeaturesInput = {
    name: string
    hitDie: number
    primaryCastingStat?: $Enums.Ability | null
    spellcastingType?: $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassCreateabilityScoreUpLevelsInput | number[]
    subclassLevel?: number
    multiclassStrReq?: number
    multiclassDexReq?: number
    multiclassConReq?: number
    multiclassIntReq?: number
    multiclassWisReq?: number
    multiclassChaReq?: number
    armorProficiencies?: ClassCreatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassCreateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassCreatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassCreateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: number
    languages?: ClassCreatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subclasses?: SubclassCreateNestedManyWithoutClassInput
    perses?: PersCreateNestedManyWithoutClassInput
    persMulticlasses?: PersMulticlassCreateNestedManyWithoutClassInput
    startingEquipmentOption?: ClassStartingEquipmentOptionCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutClassFeaturesInput = {
    classId?: number
    name: string
    hitDie: number
    primaryCastingStat?: $Enums.Ability | null
    spellcastingType?: $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassCreateabilityScoreUpLevelsInput | number[]
    subclassLevel?: number
    multiclassStrReq?: number
    multiclassDexReq?: number
    multiclassConReq?: number
    multiclassIntReq?: number
    multiclassWisReq?: number
    multiclassChaReq?: number
    armorProficiencies?: ClassCreatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassCreateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassCreatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassCreateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: number
    languages?: ClassCreatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subclasses?: SubclassUncheckedCreateNestedManyWithoutClassInput
    perses?: PersUncheckedCreateNestedManyWithoutClassInput
    persMulticlasses?: PersMulticlassUncheckedCreateNestedManyWithoutClassInput
    startingEquipmentOption?: ClassStartingEquipmentOptionUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutClassFeaturesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutClassFeaturesInput, ClassUncheckedCreateWithoutClassFeaturesInput>
  }

  export type FeatureUpsertWithoutClassFeaturesInput = {
    update: XOR<FeatureUpdateWithoutClassFeaturesInput, FeatureUncheckedUpdateWithoutClassFeaturesInput>
    create: XOR<FeatureCreateWithoutClassFeaturesInput, FeatureUncheckedCreateWithoutClassFeaturesInput>
    where?: FeatureWhereInput
  }

  export type FeatureUpdateToOneWithWhereWithoutClassFeaturesInput = {
    where?: FeatureWhereInput
    data: XOR<FeatureUpdateWithoutClassFeaturesInput, FeatureUncheckedUpdateWithoutClassFeaturesInput>
  }

  export type FeatureUpdateWithoutClassFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUpdateManyWithoutFeaturesNestedInput
    subclassFeatures?: SubclassFeatureUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateWithoutClassFeaturesInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUncheckedUpdateManyWithoutFeaturesNestedInput
    subclassFeatures?: SubclassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type ClassUpsertWithoutClassFeaturesInput = {
    update: XOR<ClassUpdateWithoutClassFeaturesInput, ClassUncheckedUpdateWithoutClassFeaturesInput>
    create: XOR<ClassCreateWithoutClassFeaturesInput, ClassUncheckedCreateWithoutClassFeaturesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutClassFeaturesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutClassFeaturesInput, ClassUncheckedUpdateWithoutClassFeaturesInput>
  }

  export type ClassUpdateWithoutClassFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    hitDie?: IntFieldUpdateOperationsInput | number
    primaryCastingStat?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFieldUpdateOperationsInput | $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassUpdateabilityScoreUpLevelsInput | number[]
    subclassLevel?: IntFieldUpdateOperationsInput | number
    multiclassStrReq?: IntFieldUpdateOperationsInput | number
    multiclassDexReq?: IntFieldUpdateOperationsInput | number
    multiclassConReq?: IntFieldUpdateOperationsInput | number
    multiclassIntReq?: IntFieldUpdateOperationsInput | number
    multiclassWisReq?: IntFieldUpdateOperationsInput | number
    multiclassChaReq?: IntFieldUpdateOperationsInput | number
    armorProficiencies?: ClassUpdatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassUpdateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassUpdatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassUpdateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: ClassUpdatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subclasses?: SubclassUpdateManyWithoutClassNestedInput
    perses?: PersUpdateManyWithoutClassNestedInput
    persMulticlasses?: PersMulticlassUpdateManyWithoutClassNestedInput
    startingEquipmentOption?: ClassStartingEquipmentOptionUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutClassFeaturesInput = {
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    hitDie?: IntFieldUpdateOperationsInput | number
    primaryCastingStat?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFieldUpdateOperationsInput | $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassUpdateabilityScoreUpLevelsInput | number[]
    subclassLevel?: IntFieldUpdateOperationsInput | number
    multiclassStrReq?: IntFieldUpdateOperationsInput | number
    multiclassDexReq?: IntFieldUpdateOperationsInput | number
    multiclassConReq?: IntFieldUpdateOperationsInput | number
    multiclassIntReq?: IntFieldUpdateOperationsInput | number
    multiclassWisReq?: IntFieldUpdateOperationsInput | number
    multiclassChaReq?: IntFieldUpdateOperationsInput | number
    armorProficiencies?: ClassUpdatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassUpdateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassUpdatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassUpdateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: ClassUpdatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subclasses?: SubclassUncheckedUpdateManyWithoutClassNestedInput
    perses?: PersUncheckedUpdateManyWithoutClassNestedInput
    persMulticlasses?: PersMulticlassUncheckedUpdateManyWithoutClassNestedInput
    startingEquipmentOption?: ClassStartingEquipmentOptionUncheckedUpdateManyWithoutClassNestedInput
  }

  export type FeatureCreateWithoutSubclassFeaturesInput = {
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutSubclassFeaturesInput = {
    featureId?: number
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellUncheckedCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitUncheckedCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureUncheckedCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureUncheckedCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutSubclassFeaturesInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutSubclassFeaturesInput, FeatureUncheckedCreateWithoutSubclassFeaturesInput>
  }

  export type SubclassCreateWithoutFeaturesInput = {
    name: string
    description?: string | null
    grantsSpells?: boolean
    languagesToChooseCount?: number
    languages?: SubclassCreatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellCreateNestedManyWithoutSubclassesInput
    class: ClassCreateNestedOneWithoutSubclassesInput
    perses?: PersCreateNestedManyWithoutSubclassInput
    persMulticlasses?: PersMulticlassCreateNestedManyWithoutSubclassInput
  }

  export type SubclassUncheckedCreateWithoutFeaturesInput = {
    subclassId?: number
    classId: number
    name: string
    description?: string | null
    grantsSpells?: boolean
    languagesToChooseCount?: number
    languages?: SubclassCreatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellUncheckedCreateNestedManyWithoutSubclassesInput
    perses?: PersUncheckedCreateNestedManyWithoutSubclassInput
    persMulticlasses?: PersMulticlassUncheckedCreateNestedManyWithoutSubclassInput
  }

  export type SubclassCreateOrConnectWithoutFeaturesInput = {
    where: SubclassWhereUniqueInput
    create: XOR<SubclassCreateWithoutFeaturesInput, SubclassUncheckedCreateWithoutFeaturesInput>
  }

  export type FeatureUpsertWithoutSubclassFeaturesInput = {
    update: XOR<FeatureUpdateWithoutSubclassFeaturesInput, FeatureUncheckedUpdateWithoutSubclassFeaturesInput>
    create: XOR<FeatureCreateWithoutSubclassFeaturesInput, FeatureUncheckedCreateWithoutSubclassFeaturesInput>
    where?: FeatureWhereInput
  }

  export type FeatureUpdateToOneWithWhereWithoutSubclassFeaturesInput = {
    where?: FeatureWhereInput
    data: XOR<FeatureUpdateWithoutSubclassFeaturesInput, FeatureUncheckedUpdateWithoutSubclassFeaturesInput>
  }

  export type FeatureUpdateWithoutSubclassFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateWithoutSubclassFeaturesInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUncheckedUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type SubclassUpsertWithoutFeaturesInput = {
    update: XOR<SubclassUpdateWithoutFeaturesInput, SubclassUncheckedUpdateWithoutFeaturesInput>
    create: XOR<SubclassCreateWithoutFeaturesInput, SubclassUncheckedCreateWithoutFeaturesInput>
    where?: SubclassWhereInput
  }

  export type SubclassUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: SubclassWhereInput
    data: XOR<SubclassUpdateWithoutFeaturesInput, SubclassUncheckedUpdateWithoutFeaturesInput>
  }

  export type SubclassUpdateWithoutFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellUpdateManyWithoutSubclassesNestedInput
    class?: ClassUpdateOneRequiredWithoutSubclassesNestedInput
    perses?: PersUpdateManyWithoutSubclassNestedInput
    persMulticlasses?: PersMulticlassUpdateManyWithoutSubclassNestedInput
  }

  export type SubclassUncheckedUpdateWithoutFeaturesInput = {
    subclassId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellUncheckedUpdateManyWithoutSubclassesNestedInput
    perses?: PersUncheckedUpdateManyWithoutSubclassNestedInput
    persMulticlasses?: PersMulticlassUncheckedUpdateManyWithoutSubclassNestedInput
  }

  export type FeatureCreateWithoutRaceTraitsInput = {
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutRaceTraitsInput = {
    featureId?: number
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellUncheckedCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureUncheckedCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureUncheckedCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutRaceTraitsInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutRaceTraitsInput, FeatureUncheckedCreateWithoutRaceTraitsInput>
  }

  export type RaceCreateWithoutTraitsInput = {
    name: $Enums.Races
    size?: RaceCreatesizeInput | $Enums.Size[]
    speed?: number
    burrowSpeed?: number
    flightSpeed?: number
    swimSpeed?: number
    climbSpeed?: number
    ac?: number
    source?: $Enums.Source
    languages?: RaceCreatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    ASI: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceCreateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceCreatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceCreateNestedManyWithoutRaceInput
    perses?: PersCreateNestedManyWithoutRaceInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutRaceInput
    raceVariants?: RaceVariantCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateWithoutTraitsInput = {
    raceId?: number
    name: $Enums.Races
    size?: RaceCreatesizeInput | $Enums.Size[]
    speed?: number
    burrowSpeed?: number
    flightSpeed?: number
    swimSpeed?: number
    climbSpeed?: number
    ac?: number
    source?: $Enums.Source
    languages?: RaceCreatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    ASI: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceCreateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceCreatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceUncheckedCreateNestedManyWithoutRaceInput
    perses?: PersUncheckedCreateNestedManyWithoutRaceInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutRaceInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceCreateOrConnectWithoutTraitsInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutTraitsInput, RaceUncheckedCreateWithoutTraitsInput>
  }

  export type SubraceCreateWithoutReplacesTraitsInput = {
    name: $Enums.Subraces
    speedModifier?: number | null
    source?: $Enums.Source
    replacesASI?: boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceCreateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    toolProficiencies?: SubraceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceCreatearmorProficienciesInput | $Enums.ArmorType[]
    race: RaceCreateNestedOneWithoutSubracesInput
    perses?: PersCreateNestedManyWithoutSubraceInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutSubraceInput
    traits?: SubraceTraitCreateNestedManyWithoutSubraceInput
  }

  export type SubraceUncheckedCreateWithoutReplacesTraitsInput = {
    subraceId?: number
    raceId: number
    name: $Enums.Subraces
    speedModifier?: number | null
    source?: $Enums.Source
    replacesASI?: boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceCreateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    toolProficiencies?: SubraceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceCreatearmorProficienciesInput | $Enums.ArmorType[]
    perses?: PersUncheckedCreateNestedManyWithoutSubraceInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutSubraceInput
    traits?: SubraceTraitUncheckedCreateNestedManyWithoutSubraceInput
  }

  export type SubraceCreateOrConnectWithoutReplacesTraitsInput = {
    where: SubraceWhereUniqueInput
    create: XOR<SubraceCreateWithoutReplacesTraitsInput, SubraceUncheckedCreateWithoutReplacesTraitsInput>
  }

  export type RaceVariantCreateWithoutReplacesTraitsInput = {
    name: $Enums.Variants
    source: $Enums.Source
    exclusivityGroup?: string | null
    overridesRaceASI: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: number | null
    overridesFlightSpeed?: number | null
    traits?: RaceVariantTraitCreateNestedManyWithoutRaceVariantInput
    race: RaceCreateNestedOneWithoutRaceVariantsInput
    perses?: PersCreateNestedManyWithoutRaceVariantsInput
  }

  export type RaceVariantUncheckedCreateWithoutReplacesTraitsInput = {
    raceVariantId?: number
    raceId: number
    name: $Enums.Variants
    source: $Enums.Source
    exclusivityGroup?: string | null
    overridesRaceASI: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: number | null
    overridesFlightSpeed?: number | null
    traits?: RaceVariantTraitUncheckedCreateNestedManyWithoutRaceVariantInput
    perses?: PersUncheckedCreateNestedManyWithoutRaceVariantsInput
  }

  export type RaceVariantCreateOrConnectWithoutReplacesTraitsInput = {
    where: RaceVariantWhereUniqueInput
    create: XOR<RaceVariantCreateWithoutReplacesTraitsInput, RaceVariantUncheckedCreateWithoutReplacesTraitsInput>
  }

  export type FeatureUpsertWithoutRaceTraitsInput = {
    update: XOR<FeatureUpdateWithoutRaceTraitsInput, FeatureUncheckedUpdateWithoutRaceTraitsInput>
    create: XOR<FeatureCreateWithoutRaceTraitsInput, FeatureUncheckedCreateWithoutRaceTraitsInput>
    where?: FeatureWhereInput
  }

  export type FeatureUpdateToOneWithWhereWithoutRaceTraitsInput = {
    where?: FeatureWhereInput
    data: XOR<FeatureUpdateWithoutRaceTraitsInput, FeatureUncheckedUpdateWithoutRaceTraitsInput>
  }

  export type FeatureUpdateWithoutRaceTraitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateWithoutRaceTraitsInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUncheckedUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type RaceUpsertWithoutTraitsInput = {
    update: XOR<RaceUpdateWithoutTraitsInput, RaceUncheckedUpdateWithoutTraitsInput>
    create: XOR<RaceCreateWithoutTraitsInput, RaceUncheckedCreateWithoutTraitsInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutTraitsInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutTraitsInput, RaceUncheckedUpdateWithoutTraitsInput>
  }

  export type RaceUpdateWithoutTraitsInput = {
    name?: EnumRacesFieldUpdateOperationsInput | $Enums.Races
    size?: RaceUpdatesizeInput | $Enums.Size[]
    speed?: IntFieldUpdateOperationsInput | number
    burrowSpeed?: IntFieldUpdateOperationsInput | number
    flightSpeed?: IntFieldUpdateOperationsInput | number
    swimSpeed?: IntFieldUpdateOperationsInput | number
    climbSpeed?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    languages?: RaceUpdatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    ASI?: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceUpdateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceUpdateManyWithoutRaceNestedInput
    perses?: PersUpdateManyWithoutRaceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutRaceNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutTraitsInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumRacesFieldUpdateOperationsInput | $Enums.Races
    size?: RaceUpdatesizeInput | $Enums.Size[]
    speed?: IntFieldUpdateOperationsInput | number
    burrowSpeed?: IntFieldUpdateOperationsInput | number
    flightSpeed?: IntFieldUpdateOperationsInput | number
    swimSpeed?: IntFieldUpdateOperationsInput | number
    climbSpeed?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    languages?: RaceUpdatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    ASI?: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceUpdateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceUncheckedUpdateManyWithoutRaceNestedInput
    perses?: PersUncheckedUpdateManyWithoutRaceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutRaceNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type SubraceUpsertWithWhereUniqueWithoutReplacesTraitsInput = {
    where: SubraceWhereUniqueInput
    update: XOR<SubraceUpdateWithoutReplacesTraitsInput, SubraceUncheckedUpdateWithoutReplacesTraitsInput>
    create: XOR<SubraceCreateWithoutReplacesTraitsInput, SubraceUncheckedCreateWithoutReplacesTraitsInput>
  }

  export type SubraceUpdateWithWhereUniqueWithoutReplacesTraitsInput = {
    where: SubraceWhereUniqueInput
    data: XOR<SubraceUpdateWithoutReplacesTraitsInput, SubraceUncheckedUpdateWithoutReplacesTraitsInput>
  }

  export type SubraceUpdateManyWithWhereWithoutReplacesTraitsInput = {
    where: SubraceScalarWhereInput
    data: XOR<SubraceUpdateManyMutationInput, SubraceUncheckedUpdateManyWithoutReplacesTraitsInput>
  }

  export type SubraceScalarWhereInput = {
    AND?: SubraceScalarWhereInput | SubraceScalarWhereInput[]
    OR?: SubraceScalarWhereInput[]
    NOT?: SubraceScalarWhereInput | SubraceScalarWhereInput[]
    subraceId?: IntFilter<"Subrace"> | number
    raceId?: IntFilter<"Subrace"> | number
    name?: EnumSubracesFilter<"Subrace"> | $Enums.Subraces
    speedModifier?: IntNullableFilter<"Subrace"> | number | null
    source?: EnumSourceFilter<"Subrace"> | $Enums.Source
    replacesASI?: BoolFilter<"Subrace"> | boolean
    additionalASI?: JsonNullableFilter<"Subrace">
    additionalLanguages?: EnumLanguageNullableListFilter<"Subrace">
    languagesToChooseCount?: IntFilter<"Subrace"> | number
    toolProficiencies?: EnumToolCategoryNullableListFilter<"Subrace">
    skillProficiencies?: JsonNullableFilter<"Subrace">
    weaponProficiencies?: EnumWeaponCategoryNullableListFilter<"Subrace">
    armorProficiencies?: EnumArmorTypeNullableListFilter<"Subrace">
  }

  export type RaceVariantUpsertWithWhereUniqueWithoutReplacesTraitsInput = {
    where: RaceVariantWhereUniqueInput
    update: XOR<RaceVariantUpdateWithoutReplacesTraitsInput, RaceVariantUncheckedUpdateWithoutReplacesTraitsInput>
    create: XOR<RaceVariantCreateWithoutReplacesTraitsInput, RaceVariantUncheckedCreateWithoutReplacesTraitsInput>
  }

  export type RaceVariantUpdateWithWhereUniqueWithoutReplacesTraitsInput = {
    where: RaceVariantWhereUniqueInput
    data: XOR<RaceVariantUpdateWithoutReplacesTraitsInput, RaceVariantUncheckedUpdateWithoutReplacesTraitsInput>
  }

  export type RaceVariantUpdateManyWithWhereWithoutReplacesTraitsInput = {
    where: RaceVariantScalarWhereInput
    data: XOR<RaceVariantUpdateManyMutationInput, RaceVariantUncheckedUpdateManyWithoutReplacesTraitsInput>
  }

  export type FeatureCreateWithoutSubraceTraitsInput = {
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutSubraceTraitsInput = {
    featureId?: number
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellUncheckedCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureUncheckedCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureUncheckedCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutSubraceTraitsInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutSubraceTraitsInput, FeatureUncheckedCreateWithoutSubraceTraitsInput>
  }

  export type SubraceCreateWithoutTraitsInput = {
    name: $Enums.Subraces
    speedModifier?: number | null
    source?: $Enums.Source
    replacesASI?: boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceCreateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    toolProficiencies?: SubraceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceCreatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitCreateNestedManyWithoutSubracesInput
    race: RaceCreateNestedOneWithoutSubracesInput
    perses?: PersCreateNestedManyWithoutSubraceInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutSubraceInput
  }

  export type SubraceUncheckedCreateWithoutTraitsInput = {
    subraceId?: number
    raceId: number
    name: $Enums.Subraces
    speedModifier?: number | null
    source?: $Enums.Source
    replacesASI?: boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceCreateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    toolProficiencies?: SubraceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceCreatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitUncheckedCreateNestedManyWithoutSubracesInput
    perses?: PersUncheckedCreateNestedManyWithoutSubraceInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutSubraceInput
  }

  export type SubraceCreateOrConnectWithoutTraitsInput = {
    where: SubraceWhereUniqueInput
    create: XOR<SubraceCreateWithoutTraitsInput, SubraceUncheckedCreateWithoutTraitsInput>
  }

  export type FeatureUpsertWithoutSubraceTraitsInput = {
    update: XOR<FeatureUpdateWithoutSubraceTraitsInput, FeatureUncheckedUpdateWithoutSubraceTraitsInput>
    create: XOR<FeatureCreateWithoutSubraceTraitsInput, FeatureUncheckedCreateWithoutSubraceTraitsInput>
    where?: FeatureWhereInput
  }

  export type FeatureUpdateToOneWithWhereWithoutSubraceTraitsInput = {
    where?: FeatureWhereInput
    data: XOR<FeatureUpdateWithoutSubraceTraitsInput, FeatureUncheckedUpdateWithoutSubraceTraitsInput>
  }

  export type FeatureUpdateWithoutSubraceTraitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateWithoutSubraceTraitsInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUncheckedUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type SubraceUpsertWithoutTraitsInput = {
    update: XOR<SubraceUpdateWithoutTraitsInput, SubraceUncheckedUpdateWithoutTraitsInput>
    create: XOR<SubraceCreateWithoutTraitsInput, SubraceUncheckedCreateWithoutTraitsInput>
    where?: SubraceWhereInput
  }

  export type SubraceUpdateToOneWithWhereWithoutTraitsInput = {
    where?: SubraceWhereInput
    data: XOR<SubraceUpdateWithoutTraitsInput, SubraceUncheckedUpdateWithoutTraitsInput>
  }

  export type SubraceUpdateWithoutTraitsInput = {
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitUpdateManyWithoutSubracesNestedInput
    race?: RaceUpdateOneRequiredWithoutSubracesNestedInput
    perses?: PersUpdateManyWithoutSubraceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutSubraceNestedInput
  }

  export type SubraceUncheckedUpdateWithoutTraitsInput = {
    subraceId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitUncheckedUpdateManyWithoutSubracesNestedInput
    perses?: PersUncheckedUpdateManyWithoutSubraceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutSubraceNestedInput
  }

  export type FeatureCreateWithoutRaceVariantTraitsInput = {
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutRaceVariantTraitsInput = {
    featureId?: number
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellUncheckedCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitUncheckedCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureUncheckedCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureUncheckedCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutRaceVariantTraitsInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutRaceVariantTraitsInput, FeatureUncheckedCreateWithoutRaceVariantTraitsInput>
  }

  export type RaceVariantCreateWithoutTraitsInput = {
    name: $Enums.Variants
    source: $Enums.Source
    exclusivityGroup?: string | null
    overridesRaceASI: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: number | null
    overridesFlightSpeed?: number | null
    replacesTraits?: RaceTraitCreateNestedManyWithoutRaceVariantsInput
    race: RaceCreateNestedOneWithoutRaceVariantsInput
    perses?: PersCreateNestedManyWithoutRaceVariantsInput
  }

  export type RaceVariantUncheckedCreateWithoutTraitsInput = {
    raceVariantId?: number
    raceId: number
    name: $Enums.Variants
    source: $Enums.Source
    exclusivityGroup?: string | null
    overridesRaceASI: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: number | null
    overridesFlightSpeed?: number | null
    replacesTraits?: RaceTraitUncheckedCreateNestedManyWithoutRaceVariantsInput
    perses?: PersUncheckedCreateNestedManyWithoutRaceVariantsInput
  }

  export type RaceVariantCreateOrConnectWithoutTraitsInput = {
    where: RaceVariantWhereUniqueInput
    create: XOR<RaceVariantCreateWithoutTraitsInput, RaceVariantUncheckedCreateWithoutTraitsInput>
  }

  export type FeatureUpsertWithoutRaceVariantTraitsInput = {
    update: XOR<FeatureUpdateWithoutRaceVariantTraitsInput, FeatureUncheckedUpdateWithoutRaceVariantTraitsInput>
    create: XOR<FeatureCreateWithoutRaceVariantTraitsInput, FeatureUncheckedCreateWithoutRaceVariantTraitsInput>
    where?: FeatureWhereInput
  }

  export type FeatureUpdateToOneWithWhereWithoutRaceVariantTraitsInput = {
    where?: FeatureWhereInput
    data: XOR<FeatureUpdateWithoutRaceVariantTraitsInput, FeatureUncheckedUpdateWithoutRaceVariantTraitsInput>
  }

  export type FeatureUpdateWithoutRaceVariantTraitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateWithoutRaceVariantTraitsInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUncheckedUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type RaceVariantUpsertWithoutTraitsInput = {
    update: XOR<RaceVariantUpdateWithoutTraitsInput, RaceVariantUncheckedUpdateWithoutTraitsInput>
    create: XOR<RaceVariantCreateWithoutTraitsInput, RaceVariantUncheckedCreateWithoutTraitsInput>
    where?: RaceVariantWhereInput
  }

  export type RaceVariantUpdateToOneWithWhereWithoutTraitsInput = {
    where?: RaceVariantWhereInput
    data: XOR<RaceVariantUpdateWithoutTraitsInput, RaceVariantUncheckedUpdateWithoutTraitsInput>
  }

  export type RaceVariantUpdateWithoutTraitsInput = {
    name?: EnumVariantsFieldUpdateOperationsInput | $Enums.Variants
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    exclusivityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    overridesRaceASI?: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    overridesFlightSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    replacesTraits?: RaceTraitUpdateManyWithoutRaceVariantsNestedInput
    race?: RaceUpdateOneRequiredWithoutRaceVariantsNestedInput
    perses?: PersUpdateManyWithoutRaceVariantsNestedInput
  }

  export type RaceVariantUncheckedUpdateWithoutTraitsInput = {
    raceVariantId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumVariantsFieldUpdateOperationsInput | $Enums.Variants
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    exclusivityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    overridesRaceASI?: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    overridesFlightSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    replacesTraits?: RaceTraitUncheckedUpdateManyWithoutRaceVariantsNestedInput
    perses?: PersUncheckedUpdateManyWithoutRaceVariantsNestedInput
  }

  export type FeatureCreateWithoutRaceChoiceOptionsTraitsInput = {
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutRaceChoiceOptionsTraitsInput = {
    featureId?: number
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellUncheckedCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitUncheckedCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitUncheckedCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureUncheckedCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureUncheckedCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutRaceChoiceOptionsTraitsInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutRaceChoiceOptionsTraitsInput, FeatureUncheckedCreateWithoutRaceChoiceOptionsTraitsInput>
  }

  export type RaceChoiceOptionCreateWithoutGrantsTraitsInput = {
    choiceGroupName: string
    optionName: string
    description?: string | null
    selectMultiple?: boolean
    maxSelection?: number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionCreategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionCreategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    modifiesSpeed?: number | null
    draconicDamageType?: $Enums.DamageType | null
    breathWeaponShape?: $Enums.AOEShapes | null
    breathWeaponAOE?: string | null
    race: RaceCreateNestedOneWithoutRaceChoiceOptionsInput
    subrace?: SubraceCreateNestedOneWithoutRaceChoiceOptionsInput
    perses?: PersCreateNestedManyWithoutRaceChoiceOptionsInput
  }

  export type RaceChoiceOptionUncheckedCreateWithoutGrantsTraitsInput = {
    optionId?: number
    raceId: number
    subraceId?: number | null
    choiceGroupName: string
    optionName: string
    description?: string | null
    selectMultiple?: boolean
    maxSelection?: number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionCreategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionCreategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    modifiesSpeed?: number | null
    draconicDamageType?: $Enums.DamageType | null
    breathWeaponShape?: $Enums.AOEShapes | null
    breathWeaponAOE?: string | null
    perses?: PersUncheckedCreateNestedManyWithoutRaceChoiceOptionsInput
  }

  export type RaceChoiceOptionCreateOrConnectWithoutGrantsTraitsInput = {
    where: RaceChoiceOptionWhereUniqueInput
    create: XOR<RaceChoiceOptionCreateWithoutGrantsTraitsInput, RaceChoiceOptionUncheckedCreateWithoutGrantsTraitsInput>
  }

  export type FeatureUpsertWithoutRaceChoiceOptionsTraitsInput = {
    update: XOR<FeatureUpdateWithoutRaceChoiceOptionsTraitsInput, FeatureUncheckedUpdateWithoutRaceChoiceOptionsTraitsInput>
    create: XOR<FeatureCreateWithoutRaceChoiceOptionsTraitsInput, FeatureUncheckedCreateWithoutRaceChoiceOptionsTraitsInput>
    where?: FeatureWhereInput
  }

  export type FeatureUpdateToOneWithWhereWithoutRaceChoiceOptionsTraitsInput = {
    where?: FeatureWhereInput
    data: XOR<FeatureUpdateWithoutRaceChoiceOptionsTraitsInput, FeatureUncheckedUpdateWithoutRaceChoiceOptionsTraitsInput>
  }

  export type FeatureUpdateWithoutRaceChoiceOptionsTraitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateWithoutRaceChoiceOptionsTraitsInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUncheckedUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUncheckedUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type RaceChoiceOptionUpsertWithoutGrantsTraitsInput = {
    update: XOR<RaceChoiceOptionUpdateWithoutGrantsTraitsInput, RaceChoiceOptionUncheckedUpdateWithoutGrantsTraitsInput>
    create: XOR<RaceChoiceOptionCreateWithoutGrantsTraitsInput, RaceChoiceOptionUncheckedCreateWithoutGrantsTraitsInput>
    where?: RaceChoiceOptionWhereInput
  }

  export type RaceChoiceOptionUpdateToOneWithWhereWithoutGrantsTraitsInput = {
    where?: RaceChoiceOptionWhereInput
    data: XOR<RaceChoiceOptionUpdateWithoutGrantsTraitsInput, RaceChoiceOptionUncheckedUpdateWithoutGrantsTraitsInput>
  }

  export type RaceChoiceOptionUpdateWithoutGrantsTraitsInput = {
    choiceGroupName?: StringFieldUpdateOperationsInput | string
    optionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    selectMultiple?: BoolFieldUpdateOperationsInput | boolean
    maxSelection?: IntFieldUpdateOperationsInput | number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionUpdategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionUpdategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    modifiesSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    draconicDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    breathWeaponShape?: NullableEnumAOEShapesFieldUpdateOperationsInput | $Enums.AOEShapes | null
    breathWeaponAOE?: NullableStringFieldUpdateOperationsInput | string | null
    race?: RaceUpdateOneRequiredWithoutRaceChoiceOptionsNestedInput
    subrace?: SubraceUpdateOneWithoutRaceChoiceOptionsNestedInput
    perses?: PersUpdateManyWithoutRaceChoiceOptionsNestedInput
  }

  export type RaceChoiceOptionUncheckedUpdateWithoutGrantsTraitsInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    choiceGroupName?: StringFieldUpdateOperationsInput | string
    optionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    selectMultiple?: BoolFieldUpdateOperationsInput | boolean
    maxSelection?: IntFieldUpdateOperationsInput | number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionUpdategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionUpdategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    modifiesSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    draconicDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    breathWeaponShape?: NullableEnumAOEShapesFieldUpdateOperationsInput | $Enums.AOEShapes | null
    breathWeaponAOE?: NullableStringFieldUpdateOperationsInput | string | null
    perses?: PersUncheckedUpdateManyWithoutRaceChoiceOptionsNestedInput
  }

  export type FeatureCreateWithoutFeatFeaturesInput = {
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutFeatFeaturesInput = {
    featureId?: number
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellUncheckedCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitUncheckedCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutFeatureInput
    magicItemFeatures?: MagicItemFeatureUncheckedCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutFeatFeaturesInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutFeatFeaturesInput, FeatureUncheckedCreateWithoutFeatFeaturesInput>
  }

  export type FeatCreateWithoutFeatFeaturesInput = {
    name: string
    category: $Enums.FeatCategory
    shortDescription: string
    longDescription: string
    languagesToChooseCount?: number
    languages?: FeatCreatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featAbilityBoost?: FeatAbilityBoostCreateNestedOneWithoutFeatInput
    persFeats?: PersFeatCreateNestedManyWithoutFeatInput
  }

  export type FeatUncheckedCreateWithoutFeatFeaturesInput = {
    featId?: number
    name: string
    category: $Enums.FeatCategory
    shortDescription: string
    longDescription: string
    languagesToChooseCount?: number
    languages?: FeatCreatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featAbilityBoost?: FeatAbilityBoostUncheckedCreateNestedOneWithoutFeatInput
    persFeats?: PersFeatUncheckedCreateNestedManyWithoutFeatInput
  }

  export type FeatCreateOrConnectWithoutFeatFeaturesInput = {
    where: FeatWhereUniqueInput
    create: XOR<FeatCreateWithoutFeatFeaturesInput, FeatUncheckedCreateWithoutFeatFeaturesInput>
  }

  export type FeatureUpsertWithoutFeatFeaturesInput = {
    update: XOR<FeatureUpdateWithoutFeatFeaturesInput, FeatureUncheckedUpdateWithoutFeatFeaturesInput>
    create: XOR<FeatureCreateWithoutFeatFeaturesInput, FeatureUncheckedCreateWithoutFeatFeaturesInput>
    where?: FeatureWhereInput
  }

  export type FeatureUpdateToOneWithWhereWithoutFeatFeaturesInput = {
    where?: FeatureWhereInput
    data: XOR<FeatureUpdateWithoutFeatFeaturesInput, FeatureUncheckedUpdateWithoutFeatFeaturesInput>
  }

  export type FeatureUpdateWithoutFeatFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateWithoutFeatFeaturesInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUncheckedUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type FeatUpsertWithoutFeatFeaturesInput = {
    update: XOR<FeatUpdateWithoutFeatFeaturesInput, FeatUncheckedUpdateWithoutFeatFeaturesInput>
    create: XOR<FeatCreateWithoutFeatFeaturesInput, FeatUncheckedCreateWithoutFeatFeaturesInput>
    where?: FeatWhereInput
  }

  export type FeatUpdateToOneWithWhereWithoutFeatFeaturesInput = {
    where?: FeatWhereInput
    data: XOR<FeatUpdateWithoutFeatFeaturesInput, FeatUncheckedUpdateWithoutFeatFeaturesInput>
  }

  export type FeatUpdateWithoutFeatFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatCategoryFieldUpdateOperationsInput | $Enums.FeatCategory
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: FeatUpdatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featAbilityBoost?: FeatAbilityBoostUpdateOneWithoutFeatNestedInput
    persFeats?: PersFeatUpdateManyWithoutFeatNestedInput
  }

  export type FeatUncheckedUpdateWithoutFeatFeaturesInput = {
    featId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatCategoryFieldUpdateOperationsInput | $Enums.FeatCategory
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: FeatUpdatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featAbilityBoost?: FeatAbilityBoostUncheckedUpdateOneWithoutFeatNestedInput
    persFeats?: PersFeatUncheckedUpdateManyWithoutFeatNestedInput
  }

  export type FeatureCreateWithoutMagicItemFeaturesInput = {
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutMagicItemFeaturesInput = {
    featureId?: number
    name: string
    description: string
    shortDescription?: string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: $Enums.RestType | null
    usesCount?: number | null
    displayType?: $Enums.FeatureDisplayType
    createdAt?: Date | string
    updatedAt?: Date | string
    givesSpells?: SpellUncheckedCreateNestedManyWithoutFeaturesInput
    classFeatures?: ClassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    subclassFeatures?: SubclassFeatureUncheckedCreateNestedManyWithoutFeatureInput
    raceTraits?: RaceTraitUncheckedCreateNestedManyWithoutFeatureInput
    subraceTraits?: SubraceTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceVariantTraits?: RaceVariantTraitUncheckedCreateNestedManyWithoutFeatureInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutFeatureInput
    featFeatures?: FeatFeatureUncheckedCreateNestedManyWithoutFeatureInput
    persFeatures?: PersFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutMagicItemFeaturesInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutMagicItemFeaturesInput, FeatureUncheckedCreateWithoutMagicItemFeaturesInput>
  }

  export type MagicItemCreateWithoutFeaturesInput = {
    name: string
    itemType: $Enums.MagicItemType
    rarity: $Enums.ItemRarity
    description: string
    bonusToAC?: number | null
    bonusToAttackRoll?: number | null
    bonusToDamage?: number | null
    persMagicItems?: PersMagicItemCreateNestedManyWithoutMagicItemInput
  }

  export type MagicItemUncheckedCreateWithoutFeaturesInput = {
    magicItemId?: number
    name: string
    itemType: $Enums.MagicItemType
    rarity: $Enums.ItemRarity
    description: string
    bonusToAC?: number | null
    bonusToAttackRoll?: number | null
    bonusToDamage?: number | null
    persMagicItems?: PersMagicItemUncheckedCreateNestedManyWithoutMagicItemInput
  }

  export type MagicItemCreateOrConnectWithoutFeaturesInput = {
    where: MagicItemWhereUniqueInput
    create: XOR<MagicItemCreateWithoutFeaturesInput, MagicItemUncheckedCreateWithoutFeaturesInput>
  }

  export type FeatureUpsertWithoutMagicItemFeaturesInput = {
    update: XOR<FeatureUpdateWithoutMagicItemFeaturesInput, FeatureUncheckedUpdateWithoutMagicItemFeaturesInput>
    create: XOR<FeatureCreateWithoutMagicItemFeaturesInput, FeatureUncheckedCreateWithoutMagicItemFeaturesInput>
    where?: FeatureWhereInput
  }

  export type FeatureUpdateToOneWithWhereWithoutMagicItemFeaturesInput = {
    where?: FeatureWhereInput
    data: XOR<FeatureUpdateWithoutMagicItemFeaturesInput, FeatureUncheckedUpdateWithoutMagicItemFeaturesInput>
  }

  export type FeatureUpdateWithoutMagicItemFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateWithoutMagicItemFeaturesInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givesSpells?: SpellUncheckedUpdateManyWithoutFeaturesNestedInput
    classFeatures?: ClassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type MagicItemUpsertWithoutFeaturesInput = {
    update: XOR<MagicItemUpdateWithoutFeaturesInput, MagicItemUncheckedUpdateWithoutFeaturesInput>
    create: XOR<MagicItemCreateWithoutFeaturesInput, MagicItemUncheckedCreateWithoutFeaturesInput>
    where?: MagicItemWhereInput
  }

  export type MagicItemUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: MagicItemWhereInput
    data: XOR<MagicItemUpdateWithoutFeaturesInput, MagicItemUncheckedUpdateWithoutFeaturesInput>
  }

  export type MagicItemUpdateWithoutFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    itemType?: EnumMagicItemTypeFieldUpdateOperationsInput | $Enums.MagicItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: StringFieldUpdateOperationsInput | string
    bonusToAC?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToAttackRoll?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToDamage?: NullableIntFieldUpdateOperationsInput | number | null
    persMagicItems?: PersMagicItemUpdateManyWithoutMagicItemNestedInput
  }

  export type MagicItemUncheckedUpdateWithoutFeaturesInput = {
    magicItemId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    itemType?: EnumMagicItemTypeFieldUpdateOperationsInput | $Enums.MagicItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: StringFieldUpdateOperationsInput | string
    bonusToAC?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToAttackRoll?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToDamage?: NullableIntFieldUpdateOperationsInput | number | null
    persMagicItems?: PersMagicItemUncheckedUpdateManyWithoutMagicItemNestedInput
  }

  export type SubraceCreateWithoutRaceInput = {
    name: $Enums.Subraces
    speedModifier?: number | null
    source?: $Enums.Source
    replacesASI?: boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceCreateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    toolProficiencies?: SubraceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceCreatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitCreateNestedManyWithoutSubracesInput
    perses?: PersCreateNestedManyWithoutSubraceInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutSubraceInput
    traits?: SubraceTraitCreateNestedManyWithoutSubraceInput
  }

  export type SubraceUncheckedCreateWithoutRaceInput = {
    subraceId?: number
    name: $Enums.Subraces
    speedModifier?: number | null
    source?: $Enums.Source
    replacesASI?: boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceCreateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    toolProficiencies?: SubraceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceCreatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitUncheckedCreateNestedManyWithoutSubracesInput
    perses?: PersUncheckedCreateNestedManyWithoutSubraceInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutSubraceInput
    traits?: SubraceTraitUncheckedCreateNestedManyWithoutSubraceInput
  }

  export type SubraceCreateOrConnectWithoutRaceInput = {
    where: SubraceWhereUniqueInput
    create: XOR<SubraceCreateWithoutRaceInput, SubraceUncheckedCreateWithoutRaceInput>
  }

  export type SubraceCreateManyRaceInputEnvelope = {
    data: SubraceCreateManyRaceInput | SubraceCreateManyRaceInput[]
    skipDuplicates?: boolean
  }

  export type PersCreateWithoutRaceInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    class: ClassCreateNestedOneWithoutPersesInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutRaceInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutRaceInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutRaceInput, PersUncheckedCreateWithoutRaceInput>
  }

  export type PersCreateManyRaceInputEnvelope = {
    data: PersCreateManyRaceInput | PersCreateManyRaceInput[]
    skipDuplicates?: boolean
  }

  export type RaceChoiceOptionCreateWithoutRaceInput = {
    choiceGroupName: string
    optionName: string
    description?: string | null
    selectMultiple?: boolean
    maxSelection?: number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionCreategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionCreategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    modifiesSpeed?: number | null
    draconicDamageType?: $Enums.DamageType | null
    breathWeaponShape?: $Enums.AOEShapes | null
    breathWeaponAOE?: string | null
    grantsTraits?: RaceChoiceOptionTraitCreateNestedManyWithoutRaceChoiceOptionInput
    subrace?: SubraceCreateNestedOneWithoutRaceChoiceOptionsInput
    perses?: PersCreateNestedManyWithoutRaceChoiceOptionsInput
  }

  export type RaceChoiceOptionUncheckedCreateWithoutRaceInput = {
    optionId?: number
    subraceId?: number | null
    choiceGroupName: string
    optionName: string
    description?: string | null
    selectMultiple?: boolean
    maxSelection?: number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionCreategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionCreategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    modifiesSpeed?: number | null
    draconicDamageType?: $Enums.DamageType | null
    breathWeaponShape?: $Enums.AOEShapes | null
    breathWeaponAOE?: string | null
    grantsTraits?: RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutRaceChoiceOptionInput
    perses?: PersUncheckedCreateNestedManyWithoutRaceChoiceOptionsInput
  }

  export type RaceChoiceOptionCreateOrConnectWithoutRaceInput = {
    where: RaceChoiceOptionWhereUniqueInput
    create: XOR<RaceChoiceOptionCreateWithoutRaceInput, RaceChoiceOptionUncheckedCreateWithoutRaceInput>
  }

  export type RaceChoiceOptionCreateManyRaceInputEnvelope = {
    data: RaceChoiceOptionCreateManyRaceInput | RaceChoiceOptionCreateManyRaceInput[]
    skipDuplicates?: boolean
  }

  export type RaceVariantCreateWithoutRaceInput = {
    name: $Enums.Variants
    source: $Enums.Source
    exclusivityGroup?: string | null
    overridesRaceASI: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: number | null
    overridesFlightSpeed?: number | null
    replacesTraits?: RaceTraitCreateNestedManyWithoutRaceVariantsInput
    traits?: RaceVariantTraitCreateNestedManyWithoutRaceVariantInput
    perses?: PersCreateNestedManyWithoutRaceVariantsInput
  }

  export type RaceVariantUncheckedCreateWithoutRaceInput = {
    raceVariantId?: number
    name: $Enums.Variants
    source: $Enums.Source
    exclusivityGroup?: string | null
    overridesRaceASI: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: number | null
    overridesFlightSpeed?: number | null
    replacesTraits?: RaceTraitUncheckedCreateNestedManyWithoutRaceVariantsInput
    traits?: RaceVariantTraitUncheckedCreateNestedManyWithoutRaceVariantInput
    perses?: PersUncheckedCreateNestedManyWithoutRaceVariantsInput
  }

  export type RaceVariantCreateOrConnectWithoutRaceInput = {
    where: RaceVariantWhereUniqueInput
    create: XOR<RaceVariantCreateWithoutRaceInput, RaceVariantUncheckedCreateWithoutRaceInput>
  }

  export type RaceVariantCreateManyRaceInputEnvelope = {
    data: RaceVariantCreateManyRaceInput | RaceVariantCreateManyRaceInput[]
    skipDuplicates?: boolean
  }

  export type RaceTraitCreateWithoutRaceInput = {
    feature: FeatureCreateNestedOneWithoutRaceTraitsInput
    subraces?: SubraceCreateNestedManyWithoutReplacesTraitsInput
    raceVariants?: RaceVariantCreateNestedManyWithoutReplacesTraitsInput
  }

  export type RaceTraitUncheckedCreateWithoutRaceInput = {
    raceTraitId?: number
    featureId: number
    subraces?: SubraceUncheckedCreateNestedManyWithoutReplacesTraitsInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutReplacesTraitsInput
  }

  export type RaceTraitCreateOrConnectWithoutRaceInput = {
    where: RaceTraitWhereUniqueInput
    create: XOR<RaceTraitCreateWithoutRaceInput, RaceTraitUncheckedCreateWithoutRaceInput>
  }

  export type RaceTraitCreateManyRaceInputEnvelope = {
    data: RaceTraitCreateManyRaceInput | RaceTraitCreateManyRaceInput[]
    skipDuplicates?: boolean
  }

  export type SubraceUpsertWithWhereUniqueWithoutRaceInput = {
    where: SubraceWhereUniqueInput
    update: XOR<SubraceUpdateWithoutRaceInput, SubraceUncheckedUpdateWithoutRaceInput>
    create: XOR<SubraceCreateWithoutRaceInput, SubraceUncheckedCreateWithoutRaceInput>
  }

  export type SubraceUpdateWithWhereUniqueWithoutRaceInput = {
    where: SubraceWhereUniqueInput
    data: XOR<SubraceUpdateWithoutRaceInput, SubraceUncheckedUpdateWithoutRaceInput>
  }

  export type SubraceUpdateManyWithWhereWithoutRaceInput = {
    where: SubraceScalarWhereInput
    data: XOR<SubraceUpdateManyMutationInput, SubraceUncheckedUpdateManyWithoutRaceInput>
  }

  export type PersUpsertWithWhereUniqueWithoutRaceInput = {
    where: PersWhereUniqueInput
    update: XOR<PersUpdateWithoutRaceInput, PersUncheckedUpdateWithoutRaceInput>
    create: XOR<PersCreateWithoutRaceInput, PersUncheckedCreateWithoutRaceInput>
  }

  export type PersUpdateWithWhereUniqueWithoutRaceInput = {
    where: PersWhereUniqueInput
    data: XOR<PersUpdateWithoutRaceInput, PersUncheckedUpdateWithoutRaceInput>
  }

  export type PersUpdateManyWithWhereWithoutRaceInput = {
    where: PersScalarWhereInput
    data: XOR<PersUpdateManyMutationInput, PersUncheckedUpdateManyWithoutRaceInput>
  }

  export type RaceChoiceOptionUpsertWithWhereUniqueWithoutRaceInput = {
    where: RaceChoiceOptionWhereUniqueInput
    update: XOR<RaceChoiceOptionUpdateWithoutRaceInput, RaceChoiceOptionUncheckedUpdateWithoutRaceInput>
    create: XOR<RaceChoiceOptionCreateWithoutRaceInput, RaceChoiceOptionUncheckedCreateWithoutRaceInput>
  }

  export type RaceChoiceOptionUpdateWithWhereUniqueWithoutRaceInput = {
    where: RaceChoiceOptionWhereUniqueInput
    data: XOR<RaceChoiceOptionUpdateWithoutRaceInput, RaceChoiceOptionUncheckedUpdateWithoutRaceInput>
  }

  export type RaceChoiceOptionUpdateManyWithWhereWithoutRaceInput = {
    where: RaceChoiceOptionScalarWhereInput
    data: XOR<RaceChoiceOptionUpdateManyMutationInput, RaceChoiceOptionUncheckedUpdateManyWithoutRaceInput>
  }

  export type RaceVariantUpsertWithWhereUniqueWithoutRaceInput = {
    where: RaceVariantWhereUniqueInput
    update: XOR<RaceVariantUpdateWithoutRaceInput, RaceVariantUncheckedUpdateWithoutRaceInput>
    create: XOR<RaceVariantCreateWithoutRaceInput, RaceVariantUncheckedCreateWithoutRaceInput>
  }

  export type RaceVariantUpdateWithWhereUniqueWithoutRaceInput = {
    where: RaceVariantWhereUniqueInput
    data: XOR<RaceVariantUpdateWithoutRaceInput, RaceVariantUncheckedUpdateWithoutRaceInput>
  }

  export type RaceVariantUpdateManyWithWhereWithoutRaceInput = {
    where: RaceVariantScalarWhereInput
    data: XOR<RaceVariantUpdateManyMutationInput, RaceVariantUncheckedUpdateManyWithoutRaceInput>
  }

  export type RaceTraitUpsertWithWhereUniqueWithoutRaceInput = {
    where: RaceTraitWhereUniqueInput
    update: XOR<RaceTraitUpdateWithoutRaceInput, RaceTraitUncheckedUpdateWithoutRaceInput>
    create: XOR<RaceTraitCreateWithoutRaceInput, RaceTraitUncheckedCreateWithoutRaceInput>
  }

  export type RaceTraitUpdateWithWhereUniqueWithoutRaceInput = {
    where: RaceTraitWhereUniqueInput
    data: XOR<RaceTraitUpdateWithoutRaceInput, RaceTraitUncheckedUpdateWithoutRaceInput>
  }

  export type RaceTraitUpdateManyWithWhereWithoutRaceInput = {
    where: RaceTraitScalarWhereInput
    data: XOR<RaceTraitUpdateManyMutationInput, RaceTraitUncheckedUpdateManyWithoutRaceInput>
  }

  export type RaceTraitCreateWithoutSubracesInput = {
    feature: FeatureCreateNestedOneWithoutRaceTraitsInput
    race: RaceCreateNestedOneWithoutTraitsInput
    raceVariants?: RaceVariantCreateNestedManyWithoutReplacesTraitsInput
  }

  export type RaceTraitUncheckedCreateWithoutSubracesInput = {
    raceTraitId?: number
    raceId: number
    featureId: number
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutReplacesTraitsInput
  }

  export type RaceTraitCreateOrConnectWithoutSubracesInput = {
    where: RaceTraitWhereUniqueInput
    create: XOR<RaceTraitCreateWithoutSubracesInput, RaceTraitUncheckedCreateWithoutSubracesInput>
  }

  export type RaceCreateWithoutSubracesInput = {
    name: $Enums.Races
    size?: RaceCreatesizeInput | $Enums.Size[]
    speed?: number
    burrowSpeed?: number
    flightSpeed?: number
    swimSpeed?: number
    climbSpeed?: number
    ac?: number
    source?: $Enums.Source
    languages?: RaceCreatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    ASI: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceCreateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceCreatearmorProficienciesInput | $Enums.ArmorType[]
    perses?: PersCreateNestedManyWithoutRaceInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutRaceInput
    raceVariants?: RaceVariantCreateNestedManyWithoutRaceInput
    traits?: RaceTraitCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateWithoutSubracesInput = {
    raceId?: number
    name: $Enums.Races
    size?: RaceCreatesizeInput | $Enums.Size[]
    speed?: number
    burrowSpeed?: number
    flightSpeed?: number
    swimSpeed?: number
    climbSpeed?: number
    ac?: number
    source?: $Enums.Source
    languages?: RaceCreatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    ASI: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceCreateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceCreatearmorProficienciesInput | $Enums.ArmorType[]
    perses?: PersUncheckedCreateNestedManyWithoutRaceInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutRaceInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutRaceInput
    traits?: RaceTraitUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceCreateOrConnectWithoutSubracesInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutSubracesInput, RaceUncheckedCreateWithoutSubracesInput>
  }

  export type PersCreateWithoutSubraceInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    class: ClassCreateNestedOneWithoutPersesInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutSubraceInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutSubraceInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutSubraceInput, PersUncheckedCreateWithoutSubraceInput>
  }

  export type PersCreateManySubraceInputEnvelope = {
    data: PersCreateManySubraceInput | PersCreateManySubraceInput[]
    skipDuplicates?: boolean
  }

  export type RaceChoiceOptionCreateWithoutSubraceInput = {
    choiceGroupName: string
    optionName: string
    description?: string | null
    selectMultiple?: boolean
    maxSelection?: number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionCreategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionCreategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    modifiesSpeed?: number | null
    draconicDamageType?: $Enums.DamageType | null
    breathWeaponShape?: $Enums.AOEShapes | null
    breathWeaponAOE?: string | null
    grantsTraits?: RaceChoiceOptionTraitCreateNestedManyWithoutRaceChoiceOptionInput
    race: RaceCreateNestedOneWithoutRaceChoiceOptionsInput
    perses?: PersCreateNestedManyWithoutRaceChoiceOptionsInput
  }

  export type RaceChoiceOptionUncheckedCreateWithoutSubraceInput = {
    optionId?: number
    raceId: number
    choiceGroupName: string
    optionName: string
    description?: string | null
    selectMultiple?: boolean
    maxSelection?: number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionCreategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionCreategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    modifiesSpeed?: number | null
    draconicDamageType?: $Enums.DamageType | null
    breathWeaponShape?: $Enums.AOEShapes | null
    breathWeaponAOE?: string | null
    grantsTraits?: RaceChoiceOptionTraitUncheckedCreateNestedManyWithoutRaceChoiceOptionInput
    perses?: PersUncheckedCreateNestedManyWithoutRaceChoiceOptionsInput
  }

  export type RaceChoiceOptionCreateOrConnectWithoutSubraceInput = {
    where: RaceChoiceOptionWhereUniqueInput
    create: XOR<RaceChoiceOptionCreateWithoutSubraceInput, RaceChoiceOptionUncheckedCreateWithoutSubraceInput>
  }

  export type RaceChoiceOptionCreateManySubraceInputEnvelope = {
    data: RaceChoiceOptionCreateManySubraceInput | RaceChoiceOptionCreateManySubraceInput[]
    skipDuplicates?: boolean
  }

  export type SubraceTraitCreateWithoutSubraceInput = {
    feature: FeatureCreateNestedOneWithoutSubraceTraitsInput
  }

  export type SubraceTraitUncheckedCreateWithoutSubraceInput = {
    subraceTraitId?: number
    featureId: number
  }

  export type SubraceTraitCreateOrConnectWithoutSubraceInput = {
    where: SubraceTraitWhereUniqueInput
    create: XOR<SubraceTraitCreateWithoutSubraceInput, SubraceTraitUncheckedCreateWithoutSubraceInput>
  }

  export type SubraceTraitCreateManySubraceInputEnvelope = {
    data: SubraceTraitCreateManySubraceInput | SubraceTraitCreateManySubraceInput[]
    skipDuplicates?: boolean
  }

  export type RaceTraitUpsertWithWhereUniqueWithoutSubracesInput = {
    where: RaceTraitWhereUniqueInput
    update: XOR<RaceTraitUpdateWithoutSubracesInput, RaceTraitUncheckedUpdateWithoutSubracesInput>
    create: XOR<RaceTraitCreateWithoutSubracesInput, RaceTraitUncheckedCreateWithoutSubracesInput>
  }

  export type RaceTraitUpdateWithWhereUniqueWithoutSubracesInput = {
    where: RaceTraitWhereUniqueInput
    data: XOR<RaceTraitUpdateWithoutSubracesInput, RaceTraitUncheckedUpdateWithoutSubracesInput>
  }

  export type RaceTraitUpdateManyWithWhereWithoutSubracesInput = {
    where: RaceTraitScalarWhereInput
    data: XOR<RaceTraitUpdateManyMutationInput, RaceTraitUncheckedUpdateManyWithoutSubracesInput>
  }

  export type RaceUpsertWithoutSubracesInput = {
    update: XOR<RaceUpdateWithoutSubracesInput, RaceUncheckedUpdateWithoutSubracesInput>
    create: XOR<RaceCreateWithoutSubracesInput, RaceUncheckedCreateWithoutSubracesInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutSubracesInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutSubracesInput, RaceUncheckedUpdateWithoutSubracesInput>
  }

  export type RaceUpdateWithoutSubracesInput = {
    name?: EnumRacesFieldUpdateOperationsInput | $Enums.Races
    size?: RaceUpdatesizeInput | $Enums.Size[]
    speed?: IntFieldUpdateOperationsInput | number
    burrowSpeed?: IntFieldUpdateOperationsInput | number
    flightSpeed?: IntFieldUpdateOperationsInput | number
    swimSpeed?: IntFieldUpdateOperationsInput | number
    climbSpeed?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    languages?: RaceUpdatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    ASI?: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceUpdateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    perses?: PersUpdateManyWithoutRaceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutRaceNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutSubracesInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumRacesFieldUpdateOperationsInput | $Enums.Races
    size?: RaceUpdatesizeInput | $Enums.Size[]
    speed?: IntFieldUpdateOperationsInput | number
    burrowSpeed?: IntFieldUpdateOperationsInput | number
    flightSpeed?: IntFieldUpdateOperationsInput | number
    swimSpeed?: IntFieldUpdateOperationsInput | number
    climbSpeed?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    languages?: RaceUpdatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    ASI?: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceUpdateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    perses?: PersUncheckedUpdateManyWithoutRaceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutRaceNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type PersUpsertWithWhereUniqueWithoutSubraceInput = {
    where: PersWhereUniqueInput
    update: XOR<PersUpdateWithoutSubraceInput, PersUncheckedUpdateWithoutSubraceInput>
    create: XOR<PersCreateWithoutSubraceInput, PersUncheckedCreateWithoutSubraceInput>
  }

  export type PersUpdateWithWhereUniqueWithoutSubraceInput = {
    where: PersWhereUniqueInput
    data: XOR<PersUpdateWithoutSubraceInput, PersUncheckedUpdateWithoutSubraceInput>
  }

  export type PersUpdateManyWithWhereWithoutSubraceInput = {
    where: PersScalarWhereInput
    data: XOR<PersUpdateManyMutationInput, PersUncheckedUpdateManyWithoutSubraceInput>
  }

  export type RaceChoiceOptionUpsertWithWhereUniqueWithoutSubraceInput = {
    where: RaceChoiceOptionWhereUniqueInput
    update: XOR<RaceChoiceOptionUpdateWithoutSubraceInput, RaceChoiceOptionUncheckedUpdateWithoutSubraceInput>
    create: XOR<RaceChoiceOptionCreateWithoutSubraceInput, RaceChoiceOptionUncheckedCreateWithoutSubraceInput>
  }

  export type RaceChoiceOptionUpdateWithWhereUniqueWithoutSubraceInput = {
    where: RaceChoiceOptionWhereUniqueInput
    data: XOR<RaceChoiceOptionUpdateWithoutSubraceInput, RaceChoiceOptionUncheckedUpdateWithoutSubraceInput>
  }

  export type RaceChoiceOptionUpdateManyWithWhereWithoutSubraceInput = {
    where: RaceChoiceOptionScalarWhereInput
    data: XOR<RaceChoiceOptionUpdateManyMutationInput, RaceChoiceOptionUncheckedUpdateManyWithoutSubraceInput>
  }

  export type SubraceTraitUpsertWithWhereUniqueWithoutSubraceInput = {
    where: SubraceTraitWhereUniqueInput
    update: XOR<SubraceTraitUpdateWithoutSubraceInput, SubraceTraitUncheckedUpdateWithoutSubraceInput>
    create: XOR<SubraceTraitCreateWithoutSubraceInput, SubraceTraitUncheckedCreateWithoutSubraceInput>
  }

  export type SubraceTraitUpdateWithWhereUniqueWithoutSubraceInput = {
    where: SubraceTraitWhereUniqueInput
    data: XOR<SubraceTraitUpdateWithoutSubraceInput, SubraceTraitUncheckedUpdateWithoutSubraceInput>
  }

  export type SubraceTraitUpdateManyWithWhereWithoutSubraceInput = {
    where: SubraceTraitScalarWhereInput
    data: XOR<SubraceTraitUpdateManyMutationInput, SubraceTraitUncheckedUpdateManyWithoutSubraceInput>
  }

  export type RaceTraitCreateWithoutRaceVariantsInput = {
    feature: FeatureCreateNestedOneWithoutRaceTraitsInput
    race: RaceCreateNestedOneWithoutTraitsInput
    subraces?: SubraceCreateNestedManyWithoutReplacesTraitsInput
  }

  export type RaceTraitUncheckedCreateWithoutRaceVariantsInput = {
    raceTraitId?: number
    raceId: number
    featureId: number
    subraces?: SubraceUncheckedCreateNestedManyWithoutReplacesTraitsInput
  }

  export type RaceTraitCreateOrConnectWithoutRaceVariantsInput = {
    where: RaceTraitWhereUniqueInput
    create: XOR<RaceTraitCreateWithoutRaceVariantsInput, RaceTraitUncheckedCreateWithoutRaceVariantsInput>
  }

  export type RaceVariantTraitCreateWithoutRaceVariantInput = {
    feature: FeatureCreateNestedOneWithoutRaceVariantTraitsInput
  }

  export type RaceVariantTraitUncheckedCreateWithoutRaceVariantInput = {
    raceVariantTraitId?: number
    featureId: number
  }

  export type RaceVariantTraitCreateOrConnectWithoutRaceVariantInput = {
    where: RaceVariantTraitWhereUniqueInput
    create: XOR<RaceVariantTraitCreateWithoutRaceVariantInput, RaceVariantTraitUncheckedCreateWithoutRaceVariantInput>
  }

  export type RaceVariantTraitCreateManyRaceVariantInputEnvelope = {
    data: RaceVariantTraitCreateManyRaceVariantInput | RaceVariantTraitCreateManyRaceVariantInput[]
    skipDuplicates?: boolean
  }

  export type RaceCreateWithoutRaceVariantsInput = {
    name: $Enums.Races
    size?: RaceCreatesizeInput | $Enums.Size[]
    speed?: number
    burrowSpeed?: number
    flightSpeed?: number
    swimSpeed?: number
    climbSpeed?: number
    ac?: number
    source?: $Enums.Source
    languages?: RaceCreatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    ASI: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceCreateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceCreatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceCreateNestedManyWithoutRaceInput
    perses?: PersCreateNestedManyWithoutRaceInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutRaceInput
    traits?: RaceTraitCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateWithoutRaceVariantsInput = {
    raceId?: number
    name: $Enums.Races
    size?: RaceCreatesizeInput | $Enums.Size[]
    speed?: number
    burrowSpeed?: number
    flightSpeed?: number
    swimSpeed?: number
    climbSpeed?: number
    ac?: number
    source?: $Enums.Source
    languages?: RaceCreatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    ASI: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceCreateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceCreatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceUncheckedCreateNestedManyWithoutRaceInput
    perses?: PersUncheckedCreateNestedManyWithoutRaceInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutRaceInput
    traits?: RaceTraitUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceCreateOrConnectWithoutRaceVariantsInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutRaceVariantsInput, RaceUncheckedCreateWithoutRaceVariantsInput>
  }

  export type PersCreateWithoutRaceVariantsInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    class: ClassCreateNestedOneWithoutPersesInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutRaceVariantsInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutRaceVariantsInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutRaceVariantsInput, PersUncheckedCreateWithoutRaceVariantsInput>
  }

  export type RaceTraitUpsertWithWhereUniqueWithoutRaceVariantsInput = {
    where: RaceTraitWhereUniqueInput
    update: XOR<RaceTraitUpdateWithoutRaceVariantsInput, RaceTraitUncheckedUpdateWithoutRaceVariantsInput>
    create: XOR<RaceTraitCreateWithoutRaceVariantsInput, RaceTraitUncheckedCreateWithoutRaceVariantsInput>
  }

  export type RaceTraitUpdateWithWhereUniqueWithoutRaceVariantsInput = {
    where: RaceTraitWhereUniqueInput
    data: XOR<RaceTraitUpdateWithoutRaceVariantsInput, RaceTraitUncheckedUpdateWithoutRaceVariantsInput>
  }

  export type RaceTraitUpdateManyWithWhereWithoutRaceVariantsInput = {
    where: RaceTraitScalarWhereInput
    data: XOR<RaceTraitUpdateManyMutationInput, RaceTraitUncheckedUpdateManyWithoutRaceVariantsInput>
  }

  export type RaceVariantTraitUpsertWithWhereUniqueWithoutRaceVariantInput = {
    where: RaceVariantTraitWhereUniqueInput
    update: XOR<RaceVariantTraitUpdateWithoutRaceVariantInput, RaceVariantTraitUncheckedUpdateWithoutRaceVariantInput>
    create: XOR<RaceVariantTraitCreateWithoutRaceVariantInput, RaceVariantTraitUncheckedCreateWithoutRaceVariantInput>
  }

  export type RaceVariantTraitUpdateWithWhereUniqueWithoutRaceVariantInput = {
    where: RaceVariantTraitWhereUniqueInput
    data: XOR<RaceVariantTraitUpdateWithoutRaceVariantInput, RaceVariantTraitUncheckedUpdateWithoutRaceVariantInput>
  }

  export type RaceVariantTraitUpdateManyWithWhereWithoutRaceVariantInput = {
    where: RaceVariantTraitScalarWhereInput
    data: XOR<RaceVariantTraitUpdateManyMutationInput, RaceVariantTraitUncheckedUpdateManyWithoutRaceVariantInput>
  }

  export type RaceUpsertWithoutRaceVariantsInput = {
    update: XOR<RaceUpdateWithoutRaceVariantsInput, RaceUncheckedUpdateWithoutRaceVariantsInput>
    create: XOR<RaceCreateWithoutRaceVariantsInput, RaceUncheckedCreateWithoutRaceVariantsInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutRaceVariantsInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutRaceVariantsInput, RaceUncheckedUpdateWithoutRaceVariantsInput>
  }

  export type RaceUpdateWithoutRaceVariantsInput = {
    name?: EnumRacesFieldUpdateOperationsInput | $Enums.Races
    size?: RaceUpdatesizeInput | $Enums.Size[]
    speed?: IntFieldUpdateOperationsInput | number
    burrowSpeed?: IntFieldUpdateOperationsInput | number
    flightSpeed?: IntFieldUpdateOperationsInput | number
    swimSpeed?: IntFieldUpdateOperationsInput | number
    climbSpeed?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    languages?: RaceUpdatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    ASI?: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceUpdateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceUpdateManyWithoutRaceNestedInput
    perses?: PersUpdateManyWithoutRaceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutRaceVariantsInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumRacesFieldUpdateOperationsInput | $Enums.Races
    size?: RaceUpdatesizeInput | $Enums.Size[]
    speed?: IntFieldUpdateOperationsInput | number
    burrowSpeed?: IntFieldUpdateOperationsInput | number
    flightSpeed?: IntFieldUpdateOperationsInput | number
    swimSpeed?: IntFieldUpdateOperationsInput | number
    climbSpeed?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    languages?: RaceUpdatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    ASI?: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceUpdateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceUncheckedUpdateManyWithoutRaceNestedInput
    perses?: PersUncheckedUpdateManyWithoutRaceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type PersUpsertWithWhereUniqueWithoutRaceVariantsInput = {
    where: PersWhereUniqueInput
    update: XOR<PersUpdateWithoutRaceVariantsInput, PersUncheckedUpdateWithoutRaceVariantsInput>
    create: XOR<PersCreateWithoutRaceVariantsInput, PersUncheckedCreateWithoutRaceVariantsInput>
  }

  export type PersUpdateWithWhereUniqueWithoutRaceVariantsInput = {
    where: PersWhereUniqueInput
    data: XOR<PersUpdateWithoutRaceVariantsInput, PersUncheckedUpdateWithoutRaceVariantsInput>
  }

  export type PersUpdateManyWithWhereWithoutRaceVariantsInput = {
    where: PersScalarWhereInput
    data: XOR<PersUpdateManyMutationInput, PersUncheckedUpdateManyWithoutRaceVariantsInput>
  }

  export type RaceChoiceOptionTraitCreateWithoutRaceChoiceOptionInput = {
    feature: FeatureCreateNestedOneWithoutRaceChoiceOptionsTraitsInput
  }

  export type RaceChoiceOptionTraitUncheckedCreateWithoutRaceChoiceOptionInput = {
    raceChoiceOptionTraitId?: number
    featureId: number
  }

  export type RaceChoiceOptionTraitCreateOrConnectWithoutRaceChoiceOptionInput = {
    where: RaceChoiceOptionTraitWhereUniqueInput
    create: XOR<RaceChoiceOptionTraitCreateWithoutRaceChoiceOptionInput, RaceChoiceOptionTraitUncheckedCreateWithoutRaceChoiceOptionInput>
  }

  export type RaceChoiceOptionTraitCreateManyRaceChoiceOptionInputEnvelope = {
    data: RaceChoiceOptionTraitCreateManyRaceChoiceOptionInput | RaceChoiceOptionTraitCreateManyRaceChoiceOptionInput[]
    skipDuplicates?: boolean
  }

  export type RaceCreateWithoutRaceChoiceOptionsInput = {
    name: $Enums.Races
    size?: RaceCreatesizeInput | $Enums.Size[]
    speed?: number
    burrowSpeed?: number
    flightSpeed?: number
    swimSpeed?: number
    climbSpeed?: number
    ac?: number
    source?: $Enums.Source
    languages?: RaceCreatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    ASI: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceCreateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceCreatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceCreateNestedManyWithoutRaceInput
    perses?: PersCreateNestedManyWithoutRaceInput
    raceVariants?: RaceVariantCreateNestedManyWithoutRaceInput
    traits?: RaceTraitCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateWithoutRaceChoiceOptionsInput = {
    raceId?: number
    name: $Enums.Races
    size?: RaceCreatesizeInput | $Enums.Size[]
    speed?: number
    burrowSpeed?: number
    flightSpeed?: number
    swimSpeed?: number
    climbSpeed?: number
    ac?: number
    source?: $Enums.Source
    languages?: RaceCreatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    ASI: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceCreateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceCreatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceUncheckedCreateNestedManyWithoutRaceInput
    perses?: PersUncheckedCreateNestedManyWithoutRaceInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutRaceInput
    traits?: RaceTraitUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceCreateOrConnectWithoutRaceChoiceOptionsInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutRaceChoiceOptionsInput, RaceUncheckedCreateWithoutRaceChoiceOptionsInput>
  }

  export type SubraceCreateWithoutRaceChoiceOptionsInput = {
    name: $Enums.Subraces
    speedModifier?: number | null
    source?: $Enums.Source
    replacesASI?: boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceCreateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    toolProficiencies?: SubraceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceCreatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitCreateNestedManyWithoutSubracesInput
    race: RaceCreateNestedOneWithoutSubracesInput
    perses?: PersCreateNestedManyWithoutSubraceInput
    traits?: SubraceTraitCreateNestedManyWithoutSubraceInput
  }

  export type SubraceUncheckedCreateWithoutRaceChoiceOptionsInput = {
    subraceId?: number
    raceId: number
    name: $Enums.Subraces
    speedModifier?: number | null
    source?: $Enums.Source
    replacesASI?: boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceCreateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    toolProficiencies?: SubraceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceCreatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitUncheckedCreateNestedManyWithoutSubracesInput
    perses?: PersUncheckedCreateNestedManyWithoutSubraceInput
    traits?: SubraceTraitUncheckedCreateNestedManyWithoutSubraceInput
  }

  export type SubraceCreateOrConnectWithoutRaceChoiceOptionsInput = {
    where: SubraceWhereUniqueInput
    create: XOR<SubraceCreateWithoutRaceChoiceOptionsInput, SubraceUncheckedCreateWithoutRaceChoiceOptionsInput>
  }

  export type PersCreateWithoutRaceChoiceOptionsInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    class: ClassCreateNestedOneWithoutPersesInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutRaceChoiceOptionsInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutRaceChoiceOptionsInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutRaceChoiceOptionsInput, PersUncheckedCreateWithoutRaceChoiceOptionsInput>
  }

  export type RaceChoiceOptionTraitUpsertWithWhereUniqueWithoutRaceChoiceOptionInput = {
    where: RaceChoiceOptionTraitWhereUniqueInput
    update: XOR<RaceChoiceOptionTraitUpdateWithoutRaceChoiceOptionInput, RaceChoiceOptionTraitUncheckedUpdateWithoutRaceChoiceOptionInput>
    create: XOR<RaceChoiceOptionTraitCreateWithoutRaceChoiceOptionInput, RaceChoiceOptionTraitUncheckedCreateWithoutRaceChoiceOptionInput>
  }

  export type RaceChoiceOptionTraitUpdateWithWhereUniqueWithoutRaceChoiceOptionInput = {
    where: RaceChoiceOptionTraitWhereUniqueInput
    data: XOR<RaceChoiceOptionTraitUpdateWithoutRaceChoiceOptionInput, RaceChoiceOptionTraitUncheckedUpdateWithoutRaceChoiceOptionInput>
  }

  export type RaceChoiceOptionTraitUpdateManyWithWhereWithoutRaceChoiceOptionInput = {
    where: RaceChoiceOptionTraitScalarWhereInput
    data: XOR<RaceChoiceOptionTraitUpdateManyMutationInput, RaceChoiceOptionTraitUncheckedUpdateManyWithoutRaceChoiceOptionInput>
  }

  export type RaceUpsertWithoutRaceChoiceOptionsInput = {
    update: XOR<RaceUpdateWithoutRaceChoiceOptionsInput, RaceUncheckedUpdateWithoutRaceChoiceOptionsInput>
    create: XOR<RaceCreateWithoutRaceChoiceOptionsInput, RaceUncheckedCreateWithoutRaceChoiceOptionsInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutRaceChoiceOptionsInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutRaceChoiceOptionsInput, RaceUncheckedUpdateWithoutRaceChoiceOptionsInput>
  }

  export type RaceUpdateWithoutRaceChoiceOptionsInput = {
    name?: EnumRacesFieldUpdateOperationsInput | $Enums.Races
    size?: RaceUpdatesizeInput | $Enums.Size[]
    speed?: IntFieldUpdateOperationsInput | number
    burrowSpeed?: IntFieldUpdateOperationsInput | number
    flightSpeed?: IntFieldUpdateOperationsInput | number
    swimSpeed?: IntFieldUpdateOperationsInput | number
    climbSpeed?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    languages?: RaceUpdatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    ASI?: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceUpdateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceUpdateManyWithoutRaceNestedInput
    perses?: PersUpdateManyWithoutRaceNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutRaceChoiceOptionsInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumRacesFieldUpdateOperationsInput | $Enums.Races
    size?: RaceUpdatesizeInput | $Enums.Size[]
    speed?: IntFieldUpdateOperationsInput | number
    burrowSpeed?: IntFieldUpdateOperationsInput | number
    flightSpeed?: IntFieldUpdateOperationsInput | number
    swimSpeed?: IntFieldUpdateOperationsInput | number
    climbSpeed?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    languages?: RaceUpdatelanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    ASI?: JsonNullValueInput | InputJsonValue
    toolProficiencies?: RaceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: RaceUpdateskillProficienciesInput | $Enums.Skills[]
    weaponProficiencies?: RaceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: RaceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    subraces?: SubraceUncheckedUpdateManyWithoutRaceNestedInput
    perses?: PersUncheckedUpdateManyWithoutRaceNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutRaceNestedInput
    traits?: RaceTraitUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type SubraceUpsertWithoutRaceChoiceOptionsInput = {
    update: XOR<SubraceUpdateWithoutRaceChoiceOptionsInput, SubraceUncheckedUpdateWithoutRaceChoiceOptionsInput>
    create: XOR<SubraceCreateWithoutRaceChoiceOptionsInput, SubraceUncheckedCreateWithoutRaceChoiceOptionsInput>
    where?: SubraceWhereInput
  }

  export type SubraceUpdateToOneWithWhereWithoutRaceChoiceOptionsInput = {
    where?: SubraceWhereInput
    data: XOR<SubraceUpdateWithoutRaceChoiceOptionsInput, SubraceUncheckedUpdateWithoutRaceChoiceOptionsInput>
  }

  export type SubraceUpdateWithoutRaceChoiceOptionsInput = {
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitUpdateManyWithoutSubracesNestedInput
    race?: RaceUpdateOneRequiredWithoutSubracesNestedInput
    perses?: PersUpdateManyWithoutSubraceNestedInput
    traits?: SubraceTraitUpdateManyWithoutSubraceNestedInput
  }

  export type SubraceUncheckedUpdateWithoutRaceChoiceOptionsInput = {
    subraceId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitUncheckedUpdateManyWithoutSubracesNestedInput
    perses?: PersUncheckedUpdateManyWithoutSubraceNestedInput
    traits?: SubraceTraitUncheckedUpdateManyWithoutSubraceNestedInput
  }

  export type PersUpsertWithWhereUniqueWithoutRaceChoiceOptionsInput = {
    where: PersWhereUniqueInput
    update: XOR<PersUpdateWithoutRaceChoiceOptionsInput, PersUncheckedUpdateWithoutRaceChoiceOptionsInput>
    create: XOR<PersCreateWithoutRaceChoiceOptionsInput, PersUncheckedCreateWithoutRaceChoiceOptionsInput>
  }

  export type PersUpdateWithWhereUniqueWithoutRaceChoiceOptionsInput = {
    where: PersWhereUniqueInput
    data: XOR<PersUpdateWithoutRaceChoiceOptionsInput, PersUncheckedUpdateWithoutRaceChoiceOptionsInput>
  }

  export type PersUpdateManyWithWhereWithoutRaceChoiceOptionsInput = {
    where: PersScalarWhereInput
    data: XOR<PersUpdateManyMutationInput, PersUncheckedUpdateManyWithoutRaceChoiceOptionsInput>
  }

  export type PersCreateWithoutBackgroundInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    class: ClassCreateNestedOneWithoutPersesInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutBackgroundInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutBackgroundInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutBackgroundInput, PersUncheckedCreateWithoutBackgroundInput>
  }

  export type PersCreateManyBackgroundInputEnvelope = {
    data: PersCreateManyBackgroundInput | PersCreateManyBackgroundInput[]
    skipDuplicates?: boolean
  }

  export type PersUpsertWithWhereUniqueWithoutBackgroundInput = {
    where: PersWhereUniqueInput
    update: XOR<PersUpdateWithoutBackgroundInput, PersUncheckedUpdateWithoutBackgroundInput>
    create: XOR<PersCreateWithoutBackgroundInput, PersUncheckedCreateWithoutBackgroundInput>
  }

  export type PersUpdateWithWhereUniqueWithoutBackgroundInput = {
    where: PersWhereUniqueInput
    data: XOR<PersUpdateWithoutBackgroundInput, PersUncheckedUpdateWithoutBackgroundInput>
  }

  export type PersUpdateManyWithWhereWithoutBackgroundInput = {
    where: PersScalarWhereInput
    data: XOR<PersUpdateManyMutationInput, PersUncheckedUpdateManyWithoutBackgroundInput>
  }

  export type FeatFeatureCreateWithoutFeatInput = {
    feature: FeatureCreateNestedOneWithoutFeatFeaturesInput
  }

  export type FeatFeatureUncheckedCreateWithoutFeatInput = {
    featFeatureId?: number
    featureId: number
  }

  export type FeatFeatureCreateOrConnectWithoutFeatInput = {
    where: FeatFeatureWhereUniqueInput
    create: XOR<FeatFeatureCreateWithoutFeatInput, FeatFeatureUncheckedCreateWithoutFeatInput>
  }

  export type FeatFeatureCreateManyFeatInputEnvelope = {
    data: FeatFeatureCreateManyFeatInput | FeatFeatureCreateManyFeatInput[]
    skipDuplicates?: boolean
  }

  export type FeatAbilityBoostCreateWithoutFeatInput = {
    ability?: $Enums.Ability | null
    increaseValue: number
    abilitiesToChoose?: FeatAbilityBoostCreateabilitiesToChooseInput | $Enums.Ability[]
    maxValue?: number
  }

  export type FeatAbilityBoostUncheckedCreateWithoutFeatInput = {
    boostId?: number
    ability?: $Enums.Ability | null
    increaseValue: number
    abilitiesToChoose?: FeatAbilityBoostCreateabilitiesToChooseInput | $Enums.Ability[]
    maxValue?: number
  }

  export type FeatAbilityBoostCreateOrConnectWithoutFeatInput = {
    where: FeatAbilityBoostWhereUniqueInput
    create: XOR<FeatAbilityBoostCreateWithoutFeatInput, FeatAbilityBoostUncheckedCreateWithoutFeatInput>
  }

  export type PersFeatCreateWithoutFeatInput = {
    pers: PersCreateNestedOneWithoutFeatsInput
  }

  export type PersFeatUncheckedCreateWithoutFeatInput = {
    persFeatId?: number
    persId: number
  }

  export type PersFeatCreateOrConnectWithoutFeatInput = {
    where: PersFeatWhereUniqueInput
    create: XOR<PersFeatCreateWithoutFeatInput, PersFeatUncheckedCreateWithoutFeatInput>
  }

  export type PersFeatCreateManyFeatInputEnvelope = {
    data: PersFeatCreateManyFeatInput | PersFeatCreateManyFeatInput[]
    skipDuplicates?: boolean
  }

  export type FeatFeatureUpsertWithWhereUniqueWithoutFeatInput = {
    where: FeatFeatureWhereUniqueInput
    update: XOR<FeatFeatureUpdateWithoutFeatInput, FeatFeatureUncheckedUpdateWithoutFeatInput>
    create: XOR<FeatFeatureCreateWithoutFeatInput, FeatFeatureUncheckedCreateWithoutFeatInput>
  }

  export type FeatFeatureUpdateWithWhereUniqueWithoutFeatInput = {
    where: FeatFeatureWhereUniqueInput
    data: XOR<FeatFeatureUpdateWithoutFeatInput, FeatFeatureUncheckedUpdateWithoutFeatInput>
  }

  export type FeatFeatureUpdateManyWithWhereWithoutFeatInput = {
    where: FeatFeatureScalarWhereInput
    data: XOR<FeatFeatureUpdateManyMutationInput, FeatFeatureUncheckedUpdateManyWithoutFeatInput>
  }

  export type FeatAbilityBoostUpsertWithoutFeatInput = {
    update: XOR<FeatAbilityBoostUpdateWithoutFeatInput, FeatAbilityBoostUncheckedUpdateWithoutFeatInput>
    create: XOR<FeatAbilityBoostCreateWithoutFeatInput, FeatAbilityBoostUncheckedCreateWithoutFeatInput>
    where?: FeatAbilityBoostWhereInput
  }

  export type FeatAbilityBoostUpdateToOneWithWhereWithoutFeatInput = {
    where?: FeatAbilityBoostWhereInput
    data: XOR<FeatAbilityBoostUpdateWithoutFeatInput, FeatAbilityBoostUncheckedUpdateWithoutFeatInput>
  }

  export type FeatAbilityBoostUpdateWithoutFeatInput = {
    ability?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    increaseValue?: IntFieldUpdateOperationsInput | number
    abilitiesToChoose?: FeatAbilityBoostUpdateabilitiesToChooseInput | $Enums.Ability[]
    maxValue?: IntFieldUpdateOperationsInput | number
  }

  export type FeatAbilityBoostUncheckedUpdateWithoutFeatInput = {
    boostId?: IntFieldUpdateOperationsInput | number
    ability?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    increaseValue?: IntFieldUpdateOperationsInput | number
    abilitiesToChoose?: FeatAbilityBoostUpdateabilitiesToChooseInput | $Enums.Ability[]
    maxValue?: IntFieldUpdateOperationsInput | number
  }

  export type PersFeatUpsertWithWhereUniqueWithoutFeatInput = {
    where: PersFeatWhereUniqueInput
    update: XOR<PersFeatUpdateWithoutFeatInput, PersFeatUncheckedUpdateWithoutFeatInput>
    create: XOR<PersFeatCreateWithoutFeatInput, PersFeatUncheckedCreateWithoutFeatInput>
  }

  export type PersFeatUpdateWithWhereUniqueWithoutFeatInput = {
    where: PersFeatWhereUniqueInput
    data: XOR<PersFeatUpdateWithoutFeatInput, PersFeatUncheckedUpdateWithoutFeatInput>
  }

  export type PersFeatUpdateManyWithWhereWithoutFeatInput = {
    where: PersFeatScalarWhereInput
    data: XOR<PersFeatUpdateManyMutationInput, PersFeatUncheckedUpdateManyWithoutFeatInput>
  }

  export type FeatCreateWithoutFeatAbilityBoostInput = {
    name: string
    category: $Enums.FeatCategory
    shortDescription: string
    longDescription: string
    languagesToChooseCount?: number
    languages?: FeatCreatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featFeatures?: FeatFeatureCreateNestedManyWithoutFeatInput
    persFeats?: PersFeatCreateNestedManyWithoutFeatInput
  }

  export type FeatUncheckedCreateWithoutFeatAbilityBoostInput = {
    featId?: number
    name: string
    category: $Enums.FeatCategory
    shortDescription: string
    longDescription: string
    languagesToChooseCount?: number
    languages?: FeatCreatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featFeatures?: FeatFeatureUncheckedCreateNestedManyWithoutFeatInput
    persFeats?: PersFeatUncheckedCreateNestedManyWithoutFeatInput
  }

  export type FeatCreateOrConnectWithoutFeatAbilityBoostInput = {
    where: FeatWhereUniqueInput
    create: XOR<FeatCreateWithoutFeatAbilityBoostInput, FeatUncheckedCreateWithoutFeatAbilityBoostInput>
  }

  export type FeatUpsertWithoutFeatAbilityBoostInput = {
    update: XOR<FeatUpdateWithoutFeatAbilityBoostInput, FeatUncheckedUpdateWithoutFeatAbilityBoostInput>
    create: XOR<FeatCreateWithoutFeatAbilityBoostInput, FeatUncheckedCreateWithoutFeatAbilityBoostInput>
    where?: FeatWhereInput
  }

  export type FeatUpdateToOneWithWhereWithoutFeatAbilityBoostInput = {
    where?: FeatWhereInput
    data: XOR<FeatUpdateWithoutFeatAbilityBoostInput, FeatUncheckedUpdateWithoutFeatAbilityBoostInput>
  }

  export type FeatUpdateWithoutFeatAbilityBoostInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatCategoryFieldUpdateOperationsInput | $Enums.FeatCategory
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: FeatUpdatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featFeatures?: FeatFeatureUpdateManyWithoutFeatNestedInput
    persFeats?: PersFeatUpdateManyWithoutFeatNestedInput
  }

  export type FeatUncheckedUpdateWithoutFeatAbilityBoostInput = {
    featId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatCategoryFieldUpdateOperationsInput | $Enums.FeatCategory
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: FeatUpdatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featFeatures?: FeatFeatureUncheckedUpdateManyWithoutFeatNestedInput
    persFeats?: PersFeatUncheckedUpdateManyWithoutFeatNestedInput
  }

  export type FeatCreateWithoutPersFeatsInput = {
    name: string
    category: $Enums.FeatCategory
    shortDescription: string
    longDescription: string
    languagesToChooseCount?: number
    languages?: FeatCreatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featFeatures?: FeatFeatureCreateNestedManyWithoutFeatInput
    featAbilityBoost?: FeatAbilityBoostCreateNestedOneWithoutFeatInput
  }

  export type FeatUncheckedCreateWithoutPersFeatsInput = {
    featId?: number
    name: string
    category: $Enums.FeatCategory
    shortDescription: string
    longDescription: string
    languagesToChooseCount?: number
    languages?: FeatCreatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featFeatures?: FeatFeatureUncheckedCreateNestedManyWithoutFeatInput
    featAbilityBoost?: FeatAbilityBoostUncheckedCreateNestedOneWithoutFeatInput
  }

  export type FeatCreateOrConnectWithoutPersFeatsInput = {
    where: FeatWhereUniqueInput
    create: XOR<FeatCreateWithoutPersFeatsInput, FeatUncheckedCreateWithoutPersFeatsInput>
  }

  export type PersCreateWithoutFeatsInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    class: ClassCreateNestedOneWithoutPersesInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutFeatsInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutFeatsInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutFeatsInput, PersUncheckedCreateWithoutFeatsInput>
  }

  export type FeatUpsertWithoutPersFeatsInput = {
    update: XOR<FeatUpdateWithoutPersFeatsInput, FeatUncheckedUpdateWithoutPersFeatsInput>
    create: XOR<FeatCreateWithoutPersFeatsInput, FeatUncheckedCreateWithoutPersFeatsInput>
    where?: FeatWhereInput
  }

  export type FeatUpdateToOneWithWhereWithoutPersFeatsInput = {
    where?: FeatWhereInput
    data: XOR<FeatUpdateWithoutPersFeatsInput, FeatUncheckedUpdateWithoutPersFeatsInput>
  }

  export type FeatUpdateWithoutPersFeatsInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatCategoryFieldUpdateOperationsInput | $Enums.FeatCategory
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: FeatUpdatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featFeatures?: FeatFeatureUpdateManyWithoutFeatNestedInput
    featAbilityBoost?: FeatAbilityBoostUpdateOneWithoutFeatNestedInput
  }

  export type FeatUncheckedUpdateWithoutPersFeatsInput = {
    featId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFeatCategoryFieldUpdateOperationsInput | $Enums.FeatCategory
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: FeatUpdatelanguagesInput | $Enums.Language[]
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    featFeatures?: FeatFeatureUncheckedUpdateManyWithoutFeatNestedInput
    featAbilityBoost?: FeatAbilityBoostUncheckedUpdateOneWithoutFeatNestedInput
  }

  export type PersUpsertWithoutFeatsInput = {
    update: XOR<PersUpdateWithoutFeatsInput, PersUncheckedUpdateWithoutFeatsInput>
    create: XOR<PersCreateWithoutFeatsInput, PersUncheckedCreateWithoutFeatsInput>
    where?: PersWhereInput
  }

  export type PersUpdateToOneWithWhereWithoutFeatsInput = {
    where?: PersWhereInput
    data: XOR<PersUpdateWithoutFeatsInput, PersUncheckedUpdateWithoutFeatsInput>
  }

  export type PersUpdateWithoutFeatsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutFeatsInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type MagicItemFeatureCreateWithoutMagicItemInput = {
    feature: FeatureCreateNestedOneWithoutMagicItemFeaturesInput
  }

  export type MagicItemFeatureUncheckedCreateWithoutMagicItemInput = {
    magicItemFeatureId?: number
    featureId: number
  }

  export type MagicItemFeatureCreateOrConnectWithoutMagicItemInput = {
    where: MagicItemFeatureWhereUniqueInput
    create: XOR<MagicItemFeatureCreateWithoutMagicItemInput, MagicItemFeatureUncheckedCreateWithoutMagicItemInput>
  }

  export type MagicItemFeatureCreateManyMagicItemInputEnvelope = {
    data: MagicItemFeatureCreateManyMagicItemInput | MagicItemFeatureCreateManyMagicItemInput[]
    skipDuplicates?: boolean
  }

  export type PersMagicItemCreateWithoutMagicItemInput = {
    pers: PersCreateNestedOneWithoutMagicItemsInput
  }

  export type PersMagicItemUncheckedCreateWithoutMagicItemInput = {
    persMagicItemId?: number
    persId: number
  }

  export type PersMagicItemCreateOrConnectWithoutMagicItemInput = {
    where: PersMagicItemWhereUniqueInput
    create: XOR<PersMagicItemCreateWithoutMagicItemInput, PersMagicItemUncheckedCreateWithoutMagicItemInput>
  }

  export type PersMagicItemCreateManyMagicItemInputEnvelope = {
    data: PersMagicItemCreateManyMagicItemInput | PersMagicItemCreateManyMagicItemInput[]
    skipDuplicates?: boolean
  }

  export type MagicItemFeatureUpsertWithWhereUniqueWithoutMagicItemInput = {
    where: MagicItemFeatureWhereUniqueInput
    update: XOR<MagicItemFeatureUpdateWithoutMagicItemInput, MagicItemFeatureUncheckedUpdateWithoutMagicItemInput>
    create: XOR<MagicItemFeatureCreateWithoutMagicItemInput, MagicItemFeatureUncheckedCreateWithoutMagicItemInput>
  }

  export type MagicItemFeatureUpdateWithWhereUniqueWithoutMagicItemInput = {
    where: MagicItemFeatureWhereUniqueInput
    data: XOR<MagicItemFeatureUpdateWithoutMagicItemInput, MagicItemFeatureUncheckedUpdateWithoutMagicItemInput>
  }

  export type MagicItemFeatureUpdateManyWithWhereWithoutMagicItemInput = {
    where: MagicItemFeatureScalarWhereInput
    data: XOR<MagicItemFeatureUpdateManyMutationInput, MagicItemFeatureUncheckedUpdateManyWithoutMagicItemInput>
  }

  export type PersMagicItemUpsertWithWhereUniqueWithoutMagicItemInput = {
    where: PersMagicItemWhereUniqueInput
    update: XOR<PersMagicItemUpdateWithoutMagicItemInput, PersMagicItemUncheckedUpdateWithoutMagicItemInput>
    create: XOR<PersMagicItemCreateWithoutMagicItemInput, PersMagicItemUncheckedCreateWithoutMagicItemInput>
  }

  export type PersMagicItemUpdateWithWhereUniqueWithoutMagicItemInput = {
    where: PersMagicItemWhereUniqueInput
    data: XOR<PersMagicItemUpdateWithoutMagicItemInput, PersMagicItemUncheckedUpdateWithoutMagicItemInput>
  }

  export type PersMagicItemUpdateManyWithWhereWithoutMagicItemInput = {
    where: PersMagicItemScalarWhereInput
    data: XOR<PersMagicItemUpdateManyMutationInput, PersMagicItemUncheckedUpdateManyWithoutMagicItemInput>
  }

  export type PersWeaponCreateWithoutWeaponInput = {
    overrideDamage?: string | null
    attackBonus?: number | null
    overrideName?: string | null
    overrideNormalRange?: number | null
    overrideLongRange?: number | null
    overrideDamageType?: $Enums.DamageType | null
    overrideAttackAbility?: $Enums.Ability | null
    isProficient?: boolean
    pers: PersCreateNestedOneWithoutWeaponsInput
  }

  export type PersWeaponUncheckedCreateWithoutWeaponInput = {
    persWeaponId?: number
    persId: number
    overrideDamage?: string | null
    attackBonus?: number | null
    overrideName?: string | null
    overrideNormalRange?: number | null
    overrideLongRange?: number | null
    overrideDamageType?: $Enums.DamageType | null
    overrideAttackAbility?: $Enums.Ability | null
    isProficient?: boolean
  }

  export type PersWeaponCreateOrConnectWithoutWeaponInput = {
    where: PersWeaponWhereUniqueInput
    create: XOR<PersWeaponCreateWithoutWeaponInput, PersWeaponUncheckedCreateWithoutWeaponInput>
  }

  export type PersWeaponCreateManyWeaponInputEnvelope = {
    data: PersWeaponCreateManyWeaponInput | PersWeaponCreateManyWeaponInput[]
    skipDuplicates?: boolean
  }

  export type ClassStartingEquipmentOptionCreateWithoutWeaponInput = {
    choiceGroup: number
    option: string
    quantity?: number
    chooseAnyArmor?: boolean
    armorType?: $Enums.ArmorType | null
    chooseAnyWeapon?: boolean
    weaponType?: $Enums.WeaponType | null
    weaponCount?: number
    description?: string | null
    class: ClassCreateNestedOneWithoutStartingEquipmentOptionInput
    armor?: ArmorCreateNestedOneWithoutClassStartingEquipmentOptionInput
    equipmentPack?: EquipmentPackCreateNestedOneWithoutClassStartingEquipmentOptionsInput
  }

  export type ClassStartingEquipmentOptionUncheckedCreateWithoutWeaponInput = {
    optionId?: number
    classId: number
    choiceGroup: number
    option: string
    armorId?: number | null
    equipmentPackId?: number | null
    quantity?: number
    chooseAnyArmor?: boolean
    armorType?: $Enums.ArmorType | null
    chooseAnyWeapon?: boolean
    weaponType?: $Enums.WeaponType | null
    weaponCount?: number
    description?: string | null
  }

  export type ClassStartingEquipmentOptionCreateOrConnectWithoutWeaponInput = {
    where: ClassStartingEquipmentOptionWhereUniqueInput
    create: XOR<ClassStartingEquipmentOptionCreateWithoutWeaponInput, ClassStartingEquipmentOptionUncheckedCreateWithoutWeaponInput>
  }

  export type ClassStartingEquipmentOptionCreateManyWeaponInputEnvelope = {
    data: ClassStartingEquipmentOptionCreateManyWeaponInput | ClassStartingEquipmentOptionCreateManyWeaponInput[]
    skipDuplicates?: boolean
  }

  export type PersWeaponUpsertWithWhereUniqueWithoutWeaponInput = {
    where: PersWeaponWhereUniqueInput
    update: XOR<PersWeaponUpdateWithoutWeaponInput, PersWeaponUncheckedUpdateWithoutWeaponInput>
    create: XOR<PersWeaponCreateWithoutWeaponInput, PersWeaponUncheckedCreateWithoutWeaponInput>
  }

  export type PersWeaponUpdateWithWhereUniqueWithoutWeaponInput = {
    where: PersWeaponWhereUniqueInput
    data: XOR<PersWeaponUpdateWithoutWeaponInput, PersWeaponUncheckedUpdateWithoutWeaponInput>
  }

  export type PersWeaponUpdateManyWithWhereWithoutWeaponInput = {
    where: PersWeaponScalarWhereInput
    data: XOR<PersWeaponUpdateManyMutationInput, PersWeaponUncheckedUpdateManyWithoutWeaponInput>
  }

  export type ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutWeaponInput = {
    where: ClassStartingEquipmentOptionWhereUniqueInput
    update: XOR<ClassStartingEquipmentOptionUpdateWithoutWeaponInput, ClassStartingEquipmentOptionUncheckedUpdateWithoutWeaponInput>
    create: XOR<ClassStartingEquipmentOptionCreateWithoutWeaponInput, ClassStartingEquipmentOptionUncheckedCreateWithoutWeaponInput>
  }

  export type ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutWeaponInput = {
    where: ClassStartingEquipmentOptionWhereUniqueInput
    data: XOR<ClassStartingEquipmentOptionUpdateWithoutWeaponInput, ClassStartingEquipmentOptionUncheckedUpdateWithoutWeaponInput>
  }

  export type ClassStartingEquipmentOptionUpdateManyWithWhereWithoutWeaponInput = {
    where: ClassStartingEquipmentOptionScalarWhereInput
    data: XOR<ClassStartingEquipmentOptionUpdateManyMutationInput, ClassStartingEquipmentOptionUncheckedUpdateManyWithoutWeaponInput>
  }

  export type PersArmorCreateWithoutArmorInput = {
    overrideBaseAC?: number | null
    miscACBonus?: number | null
    isProficient?: boolean
    equipped?: boolean
    pers: PersCreateNestedOneWithoutArmorsInput
  }

  export type PersArmorUncheckedCreateWithoutArmorInput = {
    persArmorId?: number
    persId: number
    overrideBaseAC?: number | null
    miscACBonus?: number | null
    isProficient?: boolean
    equipped?: boolean
  }

  export type PersArmorCreateOrConnectWithoutArmorInput = {
    where: PersArmorWhereUniqueInput
    create: XOR<PersArmorCreateWithoutArmorInput, PersArmorUncheckedCreateWithoutArmorInput>
  }

  export type PersArmorCreateManyArmorInputEnvelope = {
    data: PersArmorCreateManyArmorInput | PersArmorCreateManyArmorInput[]
    skipDuplicates?: boolean
  }

  export type ClassStartingEquipmentOptionCreateWithoutArmorInput = {
    choiceGroup: number
    option: string
    quantity?: number
    chooseAnyArmor?: boolean
    armorType?: $Enums.ArmorType | null
    chooseAnyWeapon?: boolean
    weaponType?: $Enums.WeaponType | null
    weaponCount?: number
    description?: string | null
    class: ClassCreateNestedOneWithoutStartingEquipmentOptionInput
    weapon?: WeaponCreateNestedOneWithoutClassStartingEquipmentOptionInput
    equipmentPack?: EquipmentPackCreateNestedOneWithoutClassStartingEquipmentOptionsInput
  }

  export type ClassStartingEquipmentOptionUncheckedCreateWithoutArmorInput = {
    optionId?: number
    classId: number
    choiceGroup: number
    option: string
    weaponId?: number | null
    equipmentPackId?: number | null
    quantity?: number
    chooseAnyArmor?: boolean
    armorType?: $Enums.ArmorType | null
    chooseAnyWeapon?: boolean
    weaponType?: $Enums.WeaponType | null
    weaponCount?: number
    description?: string | null
  }

  export type ClassStartingEquipmentOptionCreateOrConnectWithoutArmorInput = {
    where: ClassStartingEquipmentOptionWhereUniqueInput
    create: XOR<ClassStartingEquipmentOptionCreateWithoutArmorInput, ClassStartingEquipmentOptionUncheckedCreateWithoutArmorInput>
  }

  export type ClassStartingEquipmentOptionCreateManyArmorInputEnvelope = {
    data: ClassStartingEquipmentOptionCreateManyArmorInput | ClassStartingEquipmentOptionCreateManyArmorInput[]
    skipDuplicates?: boolean
  }

  export type PersArmorUpsertWithWhereUniqueWithoutArmorInput = {
    where: PersArmorWhereUniqueInput
    update: XOR<PersArmorUpdateWithoutArmorInput, PersArmorUncheckedUpdateWithoutArmorInput>
    create: XOR<PersArmorCreateWithoutArmorInput, PersArmorUncheckedCreateWithoutArmorInput>
  }

  export type PersArmorUpdateWithWhereUniqueWithoutArmorInput = {
    where: PersArmorWhereUniqueInput
    data: XOR<PersArmorUpdateWithoutArmorInput, PersArmorUncheckedUpdateWithoutArmorInput>
  }

  export type PersArmorUpdateManyWithWhereWithoutArmorInput = {
    where: PersArmorScalarWhereInput
    data: XOR<PersArmorUpdateManyMutationInput, PersArmorUncheckedUpdateManyWithoutArmorInput>
  }

  export type ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutArmorInput = {
    where: ClassStartingEquipmentOptionWhereUniqueInput
    update: XOR<ClassStartingEquipmentOptionUpdateWithoutArmorInput, ClassStartingEquipmentOptionUncheckedUpdateWithoutArmorInput>
    create: XOR<ClassStartingEquipmentOptionCreateWithoutArmorInput, ClassStartingEquipmentOptionUncheckedCreateWithoutArmorInput>
  }

  export type ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutArmorInput = {
    where: ClassStartingEquipmentOptionWhereUniqueInput
    data: XOR<ClassStartingEquipmentOptionUpdateWithoutArmorInput, ClassStartingEquipmentOptionUncheckedUpdateWithoutArmorInput>
  }

  export type ClassStartingEquipmentOptionUpdateManyWithWhereWithoutArmorInput = {
    where: ClassStartingEquipmentOptionScalarWhereInput
    data: XOR<ClassStartingEquipmentOptionUpdateManyMutationInput, ClassStartingEquipmentOptionUncheckedUpdateManyWithoutArmorInput>
  }

  export type PersCreateWithoutSkillsInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    class: ClassCreateNestedOneWithoutPersesInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutSkillsInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutSkillsInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutSkillsInput, PersUncheckedCreateWithoutSkillsInput>
  }

  export type PersUpsertWithoutSkillsInput = {
    update: XOR<PersUpdateWithoutSkillsInput, PersUncheckedUpdateWithoutSkillsInput>
    create: XOR<PersCreateWithoutSkillsInput, PersUncheckedCreateWithoutSkillsInput>
    where?: PersWhereInput
  }

  export type PersUpdateToOneWithWhereWithoutSkillsInput = {
    where?: PersWhereInput
    data: XOR<PersUpdateWithoutSkillsInput, PersUncheckedUpdateWithoutSkillsInput>
  }

  export type PersUpdateWithoutSkillsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutSkillsInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type PersCreateWithoutWeaponsInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    class: ClassCreateNestedOneWithoutPersesInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutWeaponsInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutWeaponsInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutWeaponsInput, PersUncheckedCreateWithoutWeaponsInput>
  }

  export type WeaponCreateWithoutPersWeaponsInput = {
    name: $Enums.WeaponCategory
    damage: string
    damageType: $Enums.DamageType
    weaponType: $Enums.WeaponType
    properties?: WeaponCreatepropertiesInput | $Enums.WeaponProperty[]
    versatileDamage?: string | null
    normalRange?: number | null
    longRange?: number | null
    classStartingEquipmentOption?: ClassStartingEquipmentOptionCreateNestedManyWithoutWeaponInput
  }

  export type WeaponUncheckedCreateWithoutPersWeaponsInput = {
    weaponId?: number
    name: $Enums.WeaponCategory
    damage: string
    damageType: $Enums.DamageType
    weaponType: $Enums.WeaponType
    properties?: WeaponCreatepropertiesInput | $Enums.WeaponProperty[]
    versatileDamage?: string | null
    normalRange?: number | null
    longRange?: number | null
    classStartingEquipmentOption?: ClassStartingEquipmentOptionUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type WeaponCreateOrConnectWithoutPersWeaponsInput = {
    where: WeaponWhereUniqueInput
    create: XOR<WeaponCreateWithoutPersWeaponsInput, WeaponUncheckedCreateWithoutPersWeaponsInput>
  }

  export type PersUpsertWithoutWeaponsInput = {
    update: XOR<PersUpdateWithoutWeaponsInput, PersUncheckedUpdateWithoutWeaponsInput>
    create: XOR<PersCreateWithoutWeaponsInput, PersUncheckedCreateWithoutWeaponsInput>
    where?: PersWhereInput
  }

  export type PersUpdateToOneWithWhereWithoutWeaponsInput = {
    where?: PersWhereInput
    data: XOR<PersUpdateWithoutWeaponsInput, PersUncheckedUpdateWithoutWeaponsInput>
  }

  export type PersUpdateWithoutWeaponsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutWeaponsInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type WeaponUpsertWithoutPersWeaponsInput = {
    update: XOR<WeaponUpdateWithoutPersWeaponsInput, WeaponUncheckedUpdateWithoutPersWeaponsInput>
    create: XOR<WeaponCreateWithoutPersWeaponsInput, WeaponUncheckedCreateWithoutPersWeaponsInput>
    where?: WeaponWhereInput
  }

  export type WeaponUpdateToOneWithWhereWithoutPersWeaponsInput = {
    where?: WeaponWhereInput
    data: XOR<WeaponUpdateWithoutPersWeaponsInput, WeaponUncheckedUpdateWithoutPersWeaponsInput>
  }

  export type WeaponUpdateWithoutPersWeaponsInput = {
    name?: EnumWeaponCategoryFieldUpdateOperationsInput | $Enums.WeaponCategory
    damage?: StringFieldUpdateOperationsInput | string
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    weaponType?: EnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType
    properties?: WeaponUpdatepropertiesInput | $Enums.WeaponProperty[]
    versatileDamage?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableIntFieldUpdateOperationsInput | number | null
    longRange?: NullableIntFieldUpdateOperationsInput | number | null
    classStartingEquipmentOption?: ClassStartingEquipmentOptionUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateWithoutPersWeaponsInput = {
    weaponId?: IntFieldUpdateOperationsInput | number
    name?: EnumWeaponCategoryFieldUpdateOperationsInput | $Enums.WeaponCategory
    damage?: StringFieldUpdateOperationsInput | string
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    weaponType?: EnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType
    properties?: WeaponUpdatepropertiesInput | $Enums.WeaponProperty[]
    versatileDamage?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableIntFieldUpdateOperationsInput | number | null
    longRange?: NullableIntFieldUpdateOperationsInput | number | null
    classStartingEquipmentOption?: ClassStartingEquipmentOptionUncheckedUpdateManyWithoutWeaponNestedInput
  }

  export type PersCreateWithoutArmorsInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    class: ClassCreateNestedOneWithoutPersesInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutArmorsInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    magicItems?: PersMagicItemUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutArmorsInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutArmorsInput, PersUncheckedCreateWithoutArmorsInput>
  }

  export type ArmorCreateWithoutPersArmorInput = {
    name: $Enums.ArmorCategory
    armorType: $Enums.ArmorType
    baseAC: number
    strengthReq?: number | null
    stealthDisadvantage?: boolean
    classStartingEquipmentOption?: ClassStartingEquipmentOptionCreateNestedManyWithoutArmorInput
  }

  export type ArmorUncheckedCreateWithoutPersArmorInput = {
    armorId?: number
    name: $Enums.ArmorCategory
    armorType: $Enums.ArmorType
    baseAC: number
    strengthReq?: number | null
    stealthDisadvantage?: boolean
    classStartingEquipmentOption?: ClassStartingEquipmentOptionUncheckedCreateNestedManyWithoutArmorInput
  }

  export type ArmorCreateOrConnectWithoutPersArmorInput = {
    where: ArmorWhereUniqueInput
    create: XOR<ArmorCreateWithoutPersArmorInput, ArmorUncheckedCreateWithoutPersArmorInput>
  }

  export type PersUpsertWithoutArmorsInput = {
    update: XOR<PersUpdateWithoutArmorsInput, PersUncheckedUpdateWithoutArmorsInput>
    create: XOR<PersCreateWithoutArmorsInput, PersUncheckedCreateWithoutArmorsInput>
    where?: PersWhereInput
  }

  export type PersUpdateToOneWithWhereWithoutArmorsInput = {
    where?: PersWhereInput
    data: XOR<PersUpdateWithoutArmorsInput, PersUncheckedUpdateWithoutArmorsInput>
  }

  export type PersUpdateWithoutArmorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutArmorsInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type ArmorUpsertWithoutPersArmorInput = {
    update: XOR<ArmorUpdateWithoutPersArmorInput, ArmorUncheckedUpdateWithoutPersArmorInput>
    create: XOR<ArmorCreateWithoutPersArmorInput, ArmorUncheckedCreateWithoutPersArmorInput>
    where?: ArmorWhereInput
  }

  export type ArmorUpdateToOneWithWhereWithoutPersArmorInput = {
    where?: ArmorWhereInput
    data: XOR<ArmorUpdateWithoutPersArmorInput, ArmorUncheckedUpdateWithoutPersArmorInput>
  }

  export type ArmorUpdateWithoutPersArmorInput = {
    name?: EnumArmorCategoryFieldUpdateOperationsInput | $Enums.ArmorCategory
    armorType?: EnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType
    baseAC?: IntFieldUpdateOperationsInput | number
    strengthReq?: NullableIntFieldUpdateOperationsInput | number | null
    stealthDisadvantage?: BoolFieldUpdateOperationsInput | boolean
    classStartingEquipmentOption?: ClassStartingEquipmentOptionUpdateManyWithoutArmorNestedInput
  }

  export type ArmorUncheckedUpdateWithoutPersArmorInput = {
    armorId?: IntFieldUpdateOperationsInput | number
    name?: EnumArmorCategoryFieldUpdateOperationsInput | $Enums.ArmorCategory
    armorType?: EnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType
    baseAC?: IntFieldUpdateOperationsInput | number
    strengthReq?: NullableIntFieldUpdateOperationsInput | number | null
    stealthDisadvantage?: BoolFieldUpdateOperationsInput | boolean
    classStartingEquipmentOption?: ClassStartingEquipmentOptionUncheckedUpdateManyWithoutArmorNestedInput
  }

  export type PersCreateWithoutMagicItemsInput = {
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersInput
    class: ClassCreateNestedOneWithoutPersesInput
    subclass?: SubclassCreateNestedOneWithoutPersesInput
    race: RaceCreateNestedOneWithoutPersesInput
    subrace?: SubraceCreateNestedOneWithoutPersesInput
    background: BackgroundCreateNestedOneWithoutPersesInput
    skills?: PersSkillCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassCreateNestedManyWithoutPersInput
    features?: PersFeatureCreateNestedManyWithoutPersInput
    spells?: SpellCreateNestedManyWithoutPersesInput
    feats?: PersFeatCreateNestedManyWithoutPersInput
    armors?: PersArmorCreateNestedManyWithoutPersInput
    weapons?: PersWeaponCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionCreateNestedManyWithoutPersesInput
  }

  export type PersUncheckedCreateWithoutMagicItemsInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: PersSkillUncheckedCreateNestedManyWithoutPersInput
    multiclasses?: PersMulticlassUncheckedCreateNestedManyWithoutPersInput
    features?: PersFeatureUncheckedCreateNestedManyWithoutPersInput
    spells?: SpellUncheckedCreateNestedManyWithoutPersesInput
    feats?: PersFeatUncheckedCreateNestedManyWithoutPersInput
    armors?: PersArmorUncheckedCreateNestedManyWithoutPersInput
    weapons?: PersWeaponUncheckedCreateNestedManyWithoutPersInput
    raceVariants?: RaceVariantUncheckedCreateNestedManyWithoutPersesInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedCreateNestedManyWithoutPersesInput
  }

  export type PersCreateOrConnectWithoutMagicItemsInput = {
    where: PersWhereUniqueInput
    create: XOR<PersCreateWithoutMagicItemsInput, PersUncheckedCreateWithoutMagicItemsInput>
  }

  export type MagicItemCreateWithoutPersMagicItemsInput = {
    name: string
    itemType: $Enums.MagicItemType
    rarity: $Enums.ItemRarity
    description: string
    bonusToAC?: number | null
    bonusToAttackRoll?: number | null
    bonusToDamage?: number | null
    features?: MagicItemFeatureCreateNestedManyWithoutMagicItemInput
  }

  export type MagicItemUncheckedCreateWithoutPersMagicItemsInput = {
    magicItemId?: number
    name: string
    itemType: $Enums.MagicItemType
    rarity: $Enums.ItemRarity
    description: string
    bonusToAC?: number | null
    bonusToAttackRoll?: number | null
    bonusToDamage?: number | null
    features?: MagicItemFeatureUncheckedCreateNestedManyWithoutMagicItemInput
  }

  export type MagicItemCreateOrConnectWithoutPersMagicItemsInput = {
    where: MagicItemWhereUniqueInput
    create: XOR<MagicItemCreateWithoutPersMagicItemsInput, MagicItemUncheckedCreateWithoutPersMagicItemsInput>
  }

  export type PersUpsertWithoutMagicItemsInput = {
    update: XOR<PersUpdateWithoutMagicItemsInput, PersUncheckedUpdateWithoutMagicItemsInput>
    create: XOR<PersCreateWithoutMagicItemsInput, PersUncheckedCreateWithoutMagicItemsInput>
    where?: PersWhereInput
  }

  export type PersUpdateToOneWithWhereWithoutMagicItemsInput = {
    where?: PersWhereInput
    data: XOR<PersUpdateWithoutMagicItemsInput, PersUncheckedUpdateWithoutMagicItemsInput>
  }

  export type PersUpdateWithoutMagicItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutMagicItemsInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type MagicItemUpsertWithoutPersMagicItemsInput = {
    update: XOR<MagicItemUpdateWithoutPersMagicItemsInput, MagicItemUncheckedUpdateWithoutPersMagicItemsInput>
    create: XOR<MagicItemCreateWithoutPersMagicItemsInput, MagicItemUncheckedCreateWithoutPersMagicItemsInput>
    where?: MagicItemWhereInput
  }

  export type MagicItemUpdateToOneWithWhereWithoutPersMagicItemsInput = {
    where?: MagicItemWhereInput
    data: XOR<MagicItemUpdateWithoutPersMagicItemsInput, MagicItemUncheckedUpdateWithoutPersMagicItemsInput>
  }

  export type MagicItemUpdateWithoutPersMagicItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    itemType?: EnumMagicItemTypeFieldUpdateOperationsInput | $Enums.MagicItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: StringFieldUpdateOperationsInput | string
    bonusToAC?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToAttackRoll?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToDamage?: NullableIntFieldUpdateOperationsInput | number | null
    features?: MagicItemFeatureUpdateManyWithoutMagicItemNestedInput
  }

  export type MagicItemUncheckedUpdateWithoutPersMagicItemsInput = {
    magicItemId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    itemType?: EnumMagicItemTypeFieldUpdateOperationsInput | $Enums.MagicItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: StringFieldUpdateOperationsInput | string
    bonusToAC?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToAttackRoll?: NullableIntFieldUpdateOperationsInput | number | null
    bonusToDamage?: NullableIntFieldUpdateOperationsInput | number | null
    features?: MagicItemFeatureUncheckedUpdateManyWithoutMagicItemNestedInput
  }

  export type ClassStartingEquipmentOptionCreateWithoutEquipmentPackInput = {
    choiceGroup: number
    option: string
    quantity?: number
    chooseAnyArmor?: boolean
    armorType?: $Enums.ArmorType | null
    chooseAnyWeapon?: boolean
    weaponType?: $Enums.WeaponType | null
    weaponCount?: number
    description?: string | null
    class: ClassCreateNestedOneWithoutStartingEquipmentOptionInput
    weapon?: WeaponCreateNestedOneWithoutClassStartingEquipmentOptionInput
    armor?: ArmorCreateNestedOneWithoutClassStartingEquipmentOptionInput
  }

  export type ClassStartingEquipmentOptionUncheckedCreateWithoutEquipmentPackInput = {
    optionId?: number
    classId: number
    choiceGroup: number
    option: string
    weaponId?: number | null
    armorId?: number | null
    quantity?: number
    chooseAnyArmor?: boolean
    armorType?: $Enums.ArmorType | null
    chooseAnyWeapon?: boolean
    weaponType?: $Enums.WeaponType | null
    weaponCount?: number
    description?: string | null
  }

  export type ClassStartingEquipmentOptionCreateOrConnectWithoutEquipmentPackInput = {
    where: ClassStartingEquipmentOptionWhereUniqueInput
    create: XOR<ClassStartingEquipmentOptionCreateWithoutEquipmentPackInput, ClassStartingEquipmentOptionUncheckedCreateWithoutEquipmentPackInput>
  }

  export type ClassStartingEquipmentOptionCreateManyEquipmentPackInputEnvelope = {
    data: ClassStartingEquipmentOptionCreateManyEquipmentPackInput | ClassStartingEquipmentOptionCreateManyEquipmentPackInput[]
    skipDuplicates?: boolean
  }

  export type ClassStartingEquipmentOptionUpsertWithWhereUniqueWithoutEquipmentPackInput = {
    where: ClassStartingEquipmentOptionWhereUniqueInput
    update: XOR<ClassStartingEquipmentOptionUpdateWithoutEquipmentPackInput, ClassStartingEquipmentOptionUncheckedUpdateWithoutEquipmentPackInput>
    create: XOR<ClassStartingEquipmentOptionCreateWithoutEquipmentPackInput, ClassStartingEquipmentOptionUncheckedCreateWithoutEquipmentPackInput>
  }

  export type ClassStartingEquipmentOptionUpdateWithWhereUniqueWithoutEquipmentPackInput = {
    where: ClassStartingEquipmentOptionWhereUniqueInput
    data: XOR<ClassStartingEquipmentOptionUpdateWithoutEquipmentPackInput, ClassStartingEquipmentOptionUncheckedUpdateWithoutEquipmentPackInput>
  }

  export type ClassStartingEquipmentOptionUpdateManyWithWhereWithoutEquipmentPackInput = {
    where: ClassStartingEquipmentOptionScalarWhereInput
    data: XOR<ClassStartingEquipmentOptionUpdateManyMutationInput, ClassStartingEquipmentOptionUncheckedUpdateManyWithoutEquipmentPackInput>
  }

  export type ClassCreateWithoutStartingEquipmentOptionInput = {
    name: string
    hitDie: number
    primaryCastingStat?: $Enums.Ability | null
    spellcastingType?: $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassCreateabilityScoreUpLevelsInput | number[]
    subclassLevel?: number
    multiclassStrReq?: number
    multiclassDexReq?: number
    multiclassConReq?: number
    multiclassIntReq?: number
    multiclassWisReq?: number
    multiclassChaReq?: number
    armorProficiencies?: ClassCreatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassCreateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassCreatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassCreateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: number
    languages?: ClassCreatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subclasses?: SubclassCreateNestedManyWithoutClassInput
    classFeatures?: ClassFeatureCreateNestedManyWithoutClassInput
    perses?: PersCreateNestedManyWithoutClassInput
    persMulticlasses?: PersMulticlassCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutStartingEquipmentOptionInput = {
    classId?: number
    name: string
    hitDie: number
    primaryCastingStat?: $Enums.Ability | null
    spellcastingType?: $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassCreateabilityScoreUpLevelsInput | number[]
    subclassLevel?: number
    multiclassStrReq?: number
    multiclassDexReq?: number
    multiclassConReq?: number
    multiclassIntReq?: number
    multiclassWisReq?: number
    multiclassChaReq?: number
    armorProficiencies?: ClassCreatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassCreateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassCreatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassCreateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassCreatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: number
    languages?: ClassCreatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subclasses?: SubclassUncheckedCreateNestedManyWithoutClassInput
    classFeatures?: ClassFeatureUncheckedCreateNestedManyWithoutClassInput
    perses?: PersUncheckedCreateNestedManyWithoutClassInput
    persMulticlasses?: PersMulticlassUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutStartingEquipmentOptionInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutStartingEquipmentOptionInput, ClassUncheckedCreateWithoutStartingEquipmentOptionInput>
  }

  export type WeaponCreateWithoutClassStartingEquipmentOptionInput = {
    name: $Enums.WeaponCategory
    damage: string
    damageType: $Enums.DamageType
    weaponType: $Enums.WeaponType
    properties?: WeaponCreatepropertiesInput | $Enums.WeaponProperty[]
    versatileDamage?: string | null
    normalRange?: number | null
    longRange?: number | null
    persWeapons?: PersWeaponCreateNestedManyWithoutWeaponInput
  }

  export type WeaponUncheckedCreateWithoutClassStartingEquipmentOptionInput = {
    weaponId?: number
    name: $Enums.WeaponCategory
    damage: string
    damageType: $Enums.DamageType
    weaponType: $Enums.WeaponType
    properties?: WeaponCreatepropertiesInput | $Enums.WeaponProperty[]
    versatileDamage?: string | null
    normalRange?: number | null
    longRange?: number | null
    persWeapons?: PersWeaponUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type WeaponCreateOrConnectWithoutClassStartingEquipmentOptionInput = {
    where: WeaponWhereUniqueInput
    create: XOR<WeaponCreateWithoutClassStartingEquipmentOptionInput, WeaponUncheckedCreateWithoutClassStartingEquipmentOptionInput>
  }

  export type ArmorCreateWithoutClassStartingEquipmentOptionInput = {
    name: $Enums.ArmorCategory
    armorType: $Enums.ArmorType
    baseAC: number
    strengthReq?: number | null
    stealthDisadvantage?: boolean
    persArmor?: PersArmorCreateNestedManyWithoutArmorInput
  }

  export type ArmorUncheckedCreateWithoutClassStartingEquipmentOptionInput = {
    armorId?: number
    name: $Enums.ArmorCategory
    armorType: $Enums.ArmorType
    baseAC: number
    strengthReq?: number | null
    stealthDisadvantage?: boolean
    persArmor?: PersArmorUncheckedCreateNestedManyWithoutArmorInput
  }

  export type ArmorCreateOrConnectWithoutClassStartingEquipmentOptionInput = {
    where: ArmorWhereUniqueInput
    create: XOR<ArmorCreateWithoutClassStartingEquipmentOptionInput, ArmorUncheckedCreateWithoutClassStartingEquipmentOptionInput>
  }

  export type EquipmentPackCreateWithoutClassStartingEquipmentOptionsInput = {
    name: $Enums.EquipmentPackCategory
    description: string
    items: JsonNullValueInput | InputJsonValue
  }

  export type EquipmentPackUncheckedCreateWithoutClassStartingEquipmentOptionsInput = {
    equipmentPackId?: number
    name: $Enums.EquipmentPackCategory
    description: string
    items: JsonNullValueInput | InputJsonValue
  }

  export type EquipmentPackCreateOrConnectWithoutClassStartingEquipmentOptionsInput = {
    where: EquipmentPackWhereUniqueInput
    create: XOR<EquipmentPackCreateWithoutClassStartingEquipmentOptionsInput, EquipmentPackUncheckedCreateWithoutClassStartingEquipmentOptionsInput>
  }

  export type ClassUpsertWithoutStartingEquipmentOptionInput = {
    update: XOR<ClassUpdateWithoutStartingEquipmentOptionInput, ClassUncheckedUpdateWithoutStartingEquipmentOptionInput>
    create: XOR<ClassCreateWithoutStartingEquipmentOptionInput, ClassUncheckedCreateWithoutStartingEquipmentOptionInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutStartingEquipmentOptionInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutStartingEquipmentOptionInput, ClassUncheckedUpdateWithoutStartingEquipmentOptionInput>
  }

  export type ClassUpdateWithoutStartingEquipmentOptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    hitDie?: IntFieldUpdateOperationsInput | number
    primaryCastingStat?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFieldUpdateOperationsInput | $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassUpdateabilityScoreUpLevelsInput | number[]
    subclassLevel?: IntFieldUpdateOperationsInput | number
    multiclassStrReq?: IntFieldUpdateOperationsInput | number
    multiclassDexReq?: IntFieldUpdateOperationsInput | number
    multiclassConReq?: IntFieldUpdateOperationsInput | number
    multiclassIntReq?: IntFieldUpdateOperationsInput | number
    multiclassWisReq?: IntFieldUpdateOperationsInput | number
    multiclassChaReq?: IntFieldUpdateOperationsInput | number
    armorProficiencies?: ClassUpdatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassUpdateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassUpdatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassUpdateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: ClassUpdatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subclasses?: SubclassUpdateManyWithoutClassNestedInput
    classFeatures?: ClassFeatureUpdateManyWithoutClassNestedInput
    perses?: PersUpdateManyWithoutClassNestedInput
    persMulticlasses?: PersMulticlassUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutStartingEquipmentOptionInput = {
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    hitDie?: IntFieldUpdateOperationsInput | number
    primaryCastingStat?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    spellcastingType?: EnumSpellcastingTypeFieldUpdateOperationsInput | $Enums.SpellcastingType
    abilityScoreUpLevels?: ClassUpdateabilityScoreUpLevelsInput | number[]
    subclassLevel?: IntFieldUpdateOperationsInput | number
    multiclassStrReq?: IntFieldUpdateOperationsInput | number
    multiclassDexReq?: IntFieldUpdateOperationsInput | number
    multiclassConReq?: IntFieldUpdateOperationsInput | number
    multiclassIntReq?: IntFieldUpdateOperationsInput | number
    multiclassWisReq?: IntFieldUpdateOperationsInput | number
    multiclassChaReq?: IntFieldUpdateOperationsInput | number
    armorProficiencies?: ClassUpdatearmorProficienciesInput | $Enums.ArmorType[]
    weaponProficiencies?: ClassUpdateweaponProficienciesInput | $Enums.WeaponType[]
    savingThrows?: ClassUpdatesavingThrowsInput | $Enums.Ability[]
    skillProficiencies?: ClassUpdateskillProficienciesInput | $Enums.Ability[]
    toolProficiencies?: ClassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: ClassUpdatelanguagesInput | $Enums.Language[]
    specialSpellSlotProgression?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subclasses?: SubclassUncheckedUpdateManyWithoutClassNestedInput
    classFeatures?: ClassFeatureUncheckedUpdateManyWithoutClassNestedInput
    perses?: PersUncheckedUpdateManyWithoutClassNestedInput
    persMulticlasses?: PersMulticlassUncheckedUpdateManyWithoutClassNestedInput
  }

  export type WeaponUpsertWithoutClassStartingEquipmentOptionInput = {
    update: XOR<WeaponUpdateWithoutClassStartingEquipmentOptionInput, WeaponUncheckedUpdateWithoutClassStartingEquipmentOptionInput>
    create: XOR<WeaponCreateWithoutClassStartingEquipmentOptionInput, WeaponUncheckedCreateWithoutClassStartingEquipmentOptionInput>
    where?: WeaponWhereInput
  }

  export type WeaponUpdateToOneWithWhereWithoutClassStartingEquipmentOptionInput = {
    where?: WeaponWhereInput
    data: XOR<WeaponUpdateWithoutClassStartingEquipmentOptionInput, WeaponUncheckedUpdateWithoutClassStartingEquipmentOptionInput>
  }

  export type WeaponUpdateWithoutClassStartingEquipmentOptionInput = {
    name?: EnumWeaponCategoryFieldUpdateOperationsInput | $Enums.WeaponCategory
    damage?: StringFieldUpdateOperationsInput | string
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    weaponType?: EnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType
    properties?: WeaponUpdatepropertiesInput | $Enums.WeaponProperty[]
    versatileDamage?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableIntFieldUpdateOperationsInput | number | null
    longRange?: NullableIntFieldUpdateOperationsInput | number | null
    persWeapons?: PersWeaponUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateWithoutClassStartingEquipmentOptionInput = {
    weaponId?: IntFieldUpdateOperationsInput | number
    name?: EnumWeaponCategoryFieldUpdateOperationsInput | $Enums.WeaponCategory
    damage?: StringFieldUpdateOperationsInput | string
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    weaponType?: EnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType
    properties?: WeaponUpdatepropertiesInput | $Enums.WeaponProperty[]
    versatileDamage?: NullableStringFieldUpdateOperationsInput | string | null
    normalRange?: NullableIntFieldUpdateOperationsInput | number | null
    longRange?: NullableIntFieldUpdateOperationsInput | number | null
    persWeapons?: PersWeaponUncheckedUpdateManyWithoutWeaponNestedInput
  }

  export type ArmorUpsertWithoutClassStartingEquipmentOptionInput = {
    update: XOR<ArmorUpdateWithoutClassStartingEquipmentOptionInput, ArmorUncheckedUpdateWithoutClassStartingEquipmentOptionInput>
    create: XOR<ArmorCreateWithoutClassStartingEquipmentOptionInput, ArmorUncheckedCreateWithoutClassStartingEquipmentOptionInput>
    where?: ArmorWhereInput
  }

  export type ArmorUpdateToOneWithWhereWithoutClassStartingEquipmentOptionInput = {
    where?: ArmorWhereInput
    data: XOR<ArmorUpdateWithoutClassStartingEquipmentOptionInput, ArmorUncheckedUpdateWithoutClassStartingEquipmentOptionInput>
  }

  export type ArmorUpdateWithoutClassStartingEquipmentOptionInput = {
    name?: EnumArmorCategoryFieldUpdateOperationsInput | $Enums.ArmorCategory
    armorType?: EnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType
    baseAC?: IntFieldUpdateOperationsInput | number
    strengthReq?: NullableIntFieldUpdateOperationsInput | number | null
    stealthDisadvantage?: BoolFieldUpdateOperationsInput | boolean
    persArmor?: PersArmorUpdateManyWithoutArmorNestedInput
  }

  export type ArmorUncheckedUpdateWithoutClassStartingEquipmentOptionInput = {
    armorId?: IntFieldUpdateOperationsInput | number
    name?: EnumArmorCategoryFieldUpdateOperationsInput | $Enums.ArmorCategory
    armorType?: EnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType
    baseAC?: IntFieldUpdateOperationsInput | number
    strengthReq?: NullableIntFieldUpdateOperationsInput | number | null
    stealthDisadvantage?: BoolFieldUpdateOperationsInput | boolean
    persArmor?: PersArmorUncheckedUpdateManyWithoutArmorNestedInput
  }

  export type EquipmentPackUpsertWithoutClassStartingEquipmentOptionsInput = {
    update: XOR<EquipmentPackUpdateWithoutClassStartingEquipmentOptionsInput, EquipmentPackUncheckedUpdateWithoutClassStartingEquipmentOptionsInput>
    create: XOR<EquipmentPackCreateWithoutClassStartingEquipmentOptionsInput, EquipmentPackUncheckedCreateWithoutClassStartingEquipmentOptionsInput>
    where?: EquipmentPackWhereInput
  }

  export type EquipmentPackUpdateToOneWithWhereWithoutClassStartingEquipmentOptionsInput = {
    where?: EquipmentPackWhereInput
    data: XOR<EquipmentPackUpdateWithoutClassStartingEquipmentOptionsInput, EquipmentPackUncheckedUpdateWithoutClassStartingEquipmentOptionsInput>
  }

  export type EquipmentPackUpdateWithoutClassStartingEquipmentOptionsInput = {
    name?: EnumEquipmentPackCategoryFieldUpdateOperationsInput | $Enums.EquipmentPackCategory
    description?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
  }

  export type EquipmentPackUncheckedUpdateWithoutClassStartingEquipmentOptionsInput = {
    equipmentPackId?: IntFieldUpdateOperationsInput | number
    name?: EnumEquipmentPackCategoryFieldUpdateOperationsInput | $Enums.EquipmentPackCategory
    description?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
  }

  export type CharacterSpellsCreateManyCharacterInput = {
    characterSpellId?: number
    spellId?: number | null
  }

  export type CharacterSpellsUpdateWithoutCharacterInput = {
    spell?: SpellUpdateOneWithoutCharacterSpellsNestedInput
  }

  export type CharacterSpellsUncheckedUpdateWithoutCharacterInput = {
    characterSpellId?: IntFieldUpdateOperationsInput | number
    spellId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterSpellsUncheckedUpdateManyWithoutCharacterInput = {
    characterSpellId?: IntFieldUpdateOperationsInput | number
    spellId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterSpellsCreateManySpellInput = {
    characterSpellId?: number
    characterId?: number | null
  }

  export type SpellClassesCreateManySpellInput = {
    classId?: number
    className: string
  }

  export type SpellRacesCreateManySpellInput = {
    raceId?: number
    raceName?: string | null
  }

  export type SpellbookSpellsCreateManySpellInput = {
    spellbookSpellId?: number
    spellbookId?: number | null
  }

  export type CharacterSpellsUpdateWithoutSpellInput = {
    character?: CharacterUpdateOneWithoutCharacterSpellsNestedInput
  }

  export type CharacterSpellsUncheckedUpdateWithoutSpellInput = {
    characterSpellId?: IntFieldUpdateOperationsInput | number
    characterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterSpellsUncheckedUpdateManyWithoutSpellInput = {
    characterSpellId?: IntFieldUpdateOperationsInput | number
    characterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellClassesUpdateWithoutSpellInput = {
    className?: StringFieldUpdateOperationsInput | string
  }

  export type SpellClassesUncheckedUpdateWithoutSpellInput = {
    classId?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
  }

  export type SpellClassesUncheckedUpdateManyWithoutSpellInput = {
    classId?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
  }

  export type SpellRacesUpdateWithoutSpellInput = {
    raceName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellRacesUncheckedUpdateWithoutSpellInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    raceName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellRacesUncheckedUpdateManyWithoutSpellInput = {
    raceId?: IntFieldUpdateOperationsInput | number
    raceName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellbookSpellsUpdateWithoutSpellInput = {
    spellbook?: SpellbookUpdateOneWithoutSpellbookSpellsNestedInput
  }

  export type SpellbookSpellsUncheckedUpdateWithoutSpellInput = {
    spellbookSpellId?: IntFieldUpdateOperationsInput | number
    spellbookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellbookSpellsUncheckedUpdateManyWithoutSpellInput = {
    spellbookSpellId?: IntFieldUpdateOperationsInput | number
    spellbookId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubclassUpdateWithoutExpandedSpellsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    class?: ClassUpdateOneRequiredWithoutSubclassesNestedInput
    features?: SubclassFeatureUpdateManyWithoutSubclassNestedInput
    perses?: PersUpdateManyWithoutSubclassNestedInput
    persMulticlasses?: PersMulticlassUpdateManyWithoutSubclassNestedInput
  }

  export type SubclassUncheckedUpdateWithoutExpandedSpellsInput = {
    subclassId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    features?: SubclassFeatureUncheckedUpdateManyWithoutSubclassNestedInput
    perses?: PersUncheckedUpdateManyWithoutSubclassNestedInput
    persMulticlasses?: PersMulticlassUncheckedUpdateManyWithoutSubclassNestedInput
  }

  export type SubclassUncheckedUpdateManyWithoutExpandedSpellsInput = {
    subclassId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
  }

  export type PersUpdateWithoutSpellsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutSpellsInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateManyWithoutSpellsInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureUpdateWithoutGivesSpellsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classFeatures?: ClassFeatureUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateWithoutGivesSpellsInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classFeatures?: ClassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    subclassFeatures?: SubclassFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    raceTraits?: RaceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    subraceTraits?: SubraceTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceVariantTraits?: RaceVariantTraitUncheckedUpdateManyWithoutFeatureNestedInput
    raceChoiceOptionsTraits?: RaceChoiceOptionTraitUncheckedUpdateManyWithoutFeatureNestedInput
    featFeatures?: FeatFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    magicItemFeatures?: MagicItemFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    persFeatures?: PersFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateManyWithoutGivesSpellsInput = {
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    modifiesStats?: NullableJsonNullValueInput | InputJsonValue
    limitedUsesPer?: NullableEnumRestTypeFieldUpdateOperationsInput | $Enums.RestType | null
    usesCount?: NullableIntFieldUpdateOperationsInput | number | null
    displayType?: EnumFeatureDisplayTypeFieldUpdateOperationsInput | $Enums.FeatureDisplayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpellbookSpellsCreateManySpellbookInput = {
    spellbookSpellId?: number
    spellId?: number | null
  }

  export type SpellbookSpellsUpdateWithoutSpellbookInput = {
    spell?: SpellUpdateOneWithoutSpellbookSpellsNestedInput
  }

  export type SpellbookSpellsUncheckedUpdateWithoutSpellbookInput = {
    spellbookSpellId?: IntFieldUpdateOperationsInput | number
    spellId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellbookSpellsUncheckedUpdateManyWithoutSpellbookInput = {
    spellbookSpellId?: IntFieldUpdateOperationsInput | number
    spellId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterCreateManyUserInput = {
    characterId?: number
    name?: string | null
  }

  export type SpellbookCreateManyUserInput = {
    spellbookId?: number
  }

  export type PersCreateManyUserInput = {
    persId?: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterSpells?: CharacterSpellsUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutUserInput = {
    characterId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterSpells?: CharacterSpellsUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutUserInput = {
    characterId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellbookUpdateWithoutUserInput = {
    spellbookSpells?: SpellbookSpellsUpdateManyWithoutSpellbookNestedInput
  }

  export type SpellbookUncheckedUpdateWithoutUserInput = {
    spellbookId?: IntFieldUpdateOperationsInput | number
    spellbookSpells?: SpellbookSpellsUncheckedUpdateManyWithoutSpellbookNestedInput
  }

  export type SpellbookUncheckedUpdateManyWithoutUserInput = {
    spellbookId?: IntFieldUpdateOperationsInput | number
  }

  export type PersUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutUserInput = {
    persId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateManyWithoutUserInput = {
    persId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubclassCreateManyClassInput = {
    subclassId?: number
    name: string
    description?: string | null
    grantsSpells?: boolean
    languagesToChooseCount?: number
    languages?: SubclassCreatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassCreatetoolProficienciesInput | $Enums.ToolCategory[]
  }

  export type ClassFeatureCreateManyClassInput = {
    classFeatureId?: number
    featureId: number
    levelGranted: number
    grantsSpellSlots?: boolean
  }

  export type PersCreateManyClassInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    subclassId?: number | null
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersMulticlassCreateManyClassInput = {
    persMulticlassId?: number
    persId: number
    subclassId?: number | null
    classLevel: number
  }

  export type ClassStartingEquipmentOptionCreateManyClassInput = {
    optionId?: number
    choiceGroup: number
    option: string
    weaponId?: number | null
    armorId?: number | null
    equipmentPackId?: number | null
    quantity?: number
    chooseAnyArmor?: boolean
    armorType?: $Enums.ArmorType | null
    chooseAnyWeapon?: boolean
    weaponType?: $Enums.WeaponType | null
    weaponCount?: number
    description?: string | null
  }

  export type SubclassUpdateWithoutClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellUpdateManyWithoutSubclassesNestedInput
    features?: SubclassFeatureUpdateManyWithoutSubclassNestedInput
    perses?: PersUpdateManyWithoutSubclassNestedInput
    persMulticlasses?: PersMulticlassUpdateManyWithoutSubclassNestedInput
  }

  export type SubclassUncheckedUpdateWithoutClassInput = {
    subclassId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    expandedSpells?: SpellUncheckedUpdateManyWithoutSubclassesNestedInput
    features?: SubclassFeatureUncheckedUpdateManyWithoutSubclassNestedInput
    perses?: PersUncheckedUpdateManyWithoutSubclassNestedInput
    persMulticlasses?: PersMulticlassUncheckedUpdateManyWithoutSubclassNestedInput
  }

  export type SubclassUncheckedUpdateManyWithoutClassInput = {
    subclassId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grantsSpells?: BoolFieldUpdateOperationsInput | boolean
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    languages?: SubclassUpdatelanguagesInput | $Enums.Language[]
    toolProficiencies?: SubclassUpdatetoolProficienciesInput | $Enums.ToolCategory[]
  }

  export type ClassFeatureUpdateWithoutClassInput = {
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
    feature?: FeatureUpdateOneRequiredWithoutClassFeaturesNestedInput
  }

  export type ClassFeatureUncheckedUpdateWithoutClassInput = {
    classFeatureId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassFeatureUncheckedUpdateManyWithoutClassInput = {
    classFeatureId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersUpdateWithoutClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutClassInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateManyWithoutClassInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersMulticlassUpdateWithoutClassInput = {
    classLevel?: IntFieldUpdateOperationsInput | number
    pers?: PersUpdateOneRequiredWithoutMulticlassesNestedInput
    subclass?: SubclassUpdateOneWithoutPersMulticlassesNestedInput
  }

  export type PersMulticlassUncheckedUpdateWithoutClassInput = {
    persMulticlassId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    classLevel?: IntFieldUpdateOperationsInput | number
  }

  export type PersMulticlassUncheckedUpdateManyWithoutClassInput = {
    persMulticlassId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    classLevel?: IntFieldUpdateOperationsInput | number
  }

  export type ClassStartingEquipmentOptionUpdateWithoutClassInput = {
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUpdateOneWithoutClassStartingEquipmentOptionNestedInput
    armor?: ArmorUpdateOneWithoutClassStartingEquipmentOptionNestedInput
    equipmentPack?: EquipmentPackUpdateOneWithoutClassStartingEquipmentOptionsNestedInput
  }

  export type ClassStartingEquipmentOptionUncheckedUpdateWithoutClassInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableIntFieldUpdateOperationsInput | number | null
    armorId?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentPackId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassStartingEquipmentOptionUncheckedUpdateManyWithoutClassInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableIntFieldUpdateOperationsInput | number | null
    armorId?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentPackId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubclassFeatureCreateManySubclassInput = {
    subclassFeatureId?: number
    featureId: number
    levelGranted: number
    grantsSpellSlots?: boolean
  }

  export type PersCreateManySubclassInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    backgroundId: number
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersMulticlassCreateManySubclassInput = {
    persMulticlassId?: number
    persId: number
    classId: number
    classLevel: number
  }

  export type SpellUpdateWithoutSubclassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    characterSpells?: CharacterSpellsUpdateManyWithoutSpellNestedInput
    spellClasses?: SpellClassesUpdateManyWithoutSpellNestedInput
    spellRaces?: SpellRacesUpdateManyWithoutSpellNestedInput
    spellbookSpells?: SpellbookSpellsUpdateManyWithoutSpellNestedInput
    perses?: PersUpdateManyWithoutSpellsNestedInput
    features?: FeatureUpdateManyWithoutGivesSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutSubclassesInput = {
    spellId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    characterSpells?: CharacterSpellsUncheckedUpdateManyWithoutSpellNestedInput
    spellClasses?: SpellClassesUncheckedUpdateManyWithoutSpellNestedInput
    spellRaces?: SpellRacesUncheckedUpdateManyWithoutSpellNestedInput
    spellbookSpells?: SpellbookSpellsUncheckedUpdateManyWithoutSpellNestedInput
    perses?: PersUncheckedUpdateManyWithoutSpellsNestedInput
    features?: FeatureUncheckedUpdateManyWithoutGivesSpellsNestedInput
  }

  export type SpellUncheckedUpdateManyWithoutSubclassesInput = {
    spellId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
  }

  export type SubclassFeatureUpdateWithoutSubclassInput = {
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
    feature?: FeatureUpdateOneRequiredWithoutSubclassFeaturesNestedInput
  }

  export type SubclassFeatureUncheckedUpdateWithoutSubclassInput = {
    subclassFeatureId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubclassFeatureUncheckedUpdateManyWithoutSubclassInput = {
    subclassFeatureId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersUpdateWithoutSubclassInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutSubclassInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateManyWithoutSubclassInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersMulticlassUpdateWithoutSubclassInput = {
    classLevel?: IntFieldUpdateOperationsInput | number
    pers?: PersUpdateOneRequiredWithoutMulticlassesNestedInput
    class?: ClassUpdateOneRequiredWithoutPersMulticlassesNestedInput
  }

  export type PersMulticlassUncheckedUpdateWithoutSubclassInput = {
    persMulticlassId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    classLevel?: IntFieldUpdateOperationsInput | number
  }

  export type PersMulticlassUncheckedUpdateManyWithoutSubclassInput = {
    persMulticlassId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    classLevel?: IntFieldUpdateOperationsInput | number
  }

  export type PersSkillCreateManyPersInput = {
    persSkillId?: number
    skillId: number
    proficiencyType?: $Enums.SkillProficiencyType
    customModifier?: number | null
    name: $Enums.Skills
  }

  export type PersMulticlassCreateManyPersInput = {
    persMulticlassId?: number
    classId: number
    subclassId?: number | null
    classLevel: number
  }

  export type PersFeatureCreateManyPersInput = {
    persFeatureId?: number
    featureId: number
    usesRemaining?: number | null
  }

  export type PersFeatCreateManyPersInput = {
    persFeatId?: number
    featId: number
  }

  export type PersArmorCreateManyPersInput = {
    persArmorId?: number
    armorId: number
    overrideBaseAC?: number | null
    miscACBonus?: number | null
    isProficient?: boolean
    equipped?: boolean
  }

  export type PersWeaponCreateManyPersInput = {
    persWeaponId?: number
    weaponId: number
    overrideDamage?: string | null
    attackBonus?: number | null
    overrideName?: string | null
    overrideNormalRange?: number | null
    overrideLongRange?: number | null
    overrideDamageType?: $Enums.DamageType | null
    overrideAttackAbility?: $Enums.Ability | null
    isProficient?: boolean
  }

  export type PersMagicItemCreateManyPersInput = {
    persMagicItemId?: number
    magicItemId: number
  }

  export type PersSkillUpdateWithoutPersInput = {
    skillId?: IntFieldUpdateOperationsInput | number
    proficiencyType?: EnumSkillProficiencyTypeFieldUpdateOperationsInput | $Enums.SkillProficiencyType
    customModifier?: NullableIntFieldUpdateOperationsInput | number | null
    name?: EnumSkillsFieldUpdateOperationsInput | $Enums.Skills
  }

  export type PersSkillUncheckedUpdateWithoutPersInput = {
    persSkillId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    proficiencyType?: EnumSkillProficiencyTypeFieldUpdateOperationsInput | $Enums.SkillProficiencyType
    customModifier?: NullableIntFieldUpdateOperationsInput | number | null
    name?: EnumSkillsFieldUpdateOperationsInput | $Enums.Skills
  }

  export type PersSkillUncheckedUpdateManyWithoutPersInput = {
    persSkillId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    proficiencyType?: EnumSkillProficiencyTypeFieldUpdateOperationsInput | $Enums.SkillProficiencyType
    customModifier?: NullableIntFieldUpdateOperationsInput | number | null
    name?: EnumSkillsFieldUpdateOperationsInput | $Enums.Skills
  }

  export type PersMulticlassUpdateWithoutPersInput = {
    classLevel?: IntFieldUpdateOperationsInput | number
    class?: ClassUpdateOneRequiredWithoutPersMulticlassesNestedInput
    subclass?: SubclassUpdateOneWithoutPersMulticlassesNestedInput
  }

  export type PersMulticlassUncheckedUpdateWithoutPersInput = {
    persMulticlassId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    classLevel?: IntFieldUpdateOperationsInput | number
  }

  export type PersMulticlassUncheckedUpdateManyWithoutPersInput = {
    persMulticlassId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    classLevel?: IntFieldUpdateOperationsInput | number
  }

  export type PersFeatureUpdateWithoutPersInput = {
    usesRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    feature?: FeatureUpdateOneRequiredWithoutPersFeaturesNestedInput
  }

  export type PersFeatureUncheckedUpdateWithoutPersInput = {
    persFeatureId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    usesRemaining?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersFeatureUncheckedUpdateManyWithoutPersInput = {
    persFeatureId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    usesRemaining?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellUpdateWithoutPersesInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    characterSpells?: CharacterSpellsUpdateManyWithoutSpellNestedInput
    spellClasses?: SpellClassesUpdateManyWithoutSpellNestedInput
    spellRaces?: SpellRacesUpdateManyWithoutSpellNestedInput
    spellbookSpells?: SpellbookSpellsUpdateManyWithoutSpellNestedInput
    subclasses?: SubclassUpdateManyWithoutExpandedSpellsNestedInput
    features?: FeatureUpdateManyWithoutGivesSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutPersesInput = {
    spellId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    characterSpells?: CharacterSpellsUncheckedUpdateManyWithoutSpellNestedInput
    spellClasses?: SpellClassesUncheckedUpdateManyWithoutSpellNestedInput
    spellRaces?: SpellRacesUncheckedUpdateManyWithoutSpellNestedInput
    spellbookSpells?: SpellbookSpellsUncheckedUpdateManyWithoutSpellNestedInput
    subclasses?: SubclassUncheckedUpdateManyWithoutExpandedSpellsNestedInput
    features?: FeatureUncheckedUpdateManyWithoutGivesSpellsNestedInput
  }

  export type SpellUncheckedUpdateManyWithoutPersesInput = {
    spellId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
  }

  export type PersFeatUpdateWithoutPersInput = {
    feat?: FeatUpdateOneRequiredWithoutPersFeatsNestedInput
  }

  export type PersFeatUncheckedUpdateWithoutPersInput = {
    persFeatId?: IntFieldUpdateOperationsInput | number
    featId?: IntFieldUpdateOperationsInput | number
  }

  export type PersFeatUncheckedUpdateManyWithoutPersInput = {
    persFeatId?: IntFieldUpdateOperationsInput | number
    featId?: IntFieldUpdateOperationsInput | number
  }

  export type PersArmorUpdateWithoutPersInput = {
    overrideBaseAC?: NullableIntFieldUpdateOperationsInput | number | null
    miscACBonus?: NullableIntFieldUpdateOperationsInput | number | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
    equipped?: BoolFieldUpdateOperationsInput | boolean
    armor?: ArmorUpdateOneRequiredWithoutPersArmorNestedInput
  }

  export type PersArmorUncheckedUpdateWithoutPersInput = {
    persArmorId?: IntFieldUpdateOperationsInput | number
    armorId?: IntFieldUpdateOperationsInput | number
    overrideBaseAC?: NullableIntFieldUpdateOperationsInput | number | null
    miscACBonus?: NullableIntFieldUpdateOperationsInput | number | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
    equipped?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersArmorUncheckedUpdateManyWithoutPersInput = {
    persArmorId?: IntFieldUpdateOperationsInput | number
    armorId?: IntFieldUpdateOperationsInput | number
    overrideBaseAC?: NullableIntFieldUpdateOperationsInput | number | null
    miscACBonus?: NullableIntFieldUpdateOperationsInput | number | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
    equipped?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersWeaponUpdateWithoutPersInput = {
    overrideDamage?: NullableStringFieldUpdateOperationsInput | string | null
    attackBonus?: NullableIntFieldUpdateOperationsInput | number | null
    overrideName?: NullableStringFieldUpdateOperationsInput | string | null
    overrideNormalRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideLongRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    overrideAttackAbility?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
    weapon?: WeaponUpdateOneRequiredWithoutPersWeaponsNestedInput
  }

  export type PersWeaponUncheckedUpdateWithoutPersInput = {
    persWeaponId?: IntFieldUpdateOperationsInput | number
    weaponId?: IntFieldUpdateOperationsInput | number
    overrideDamage?: NullableStringFieldUpdateOperationsInput | string | null
    attackBonus?: NullableIntFieldUpdateOperationsInput | number | null
    overrideName?: NullableStringFieldUpdateOperationsInput | string | null
    overrideNormalRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideLongRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    overrideAttackAbility?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersWeaponUncheckedUpdateManyWithoutPersInput = {
    persWeaponId?: IntFieldUpdateOperationsInput | number
    weaponId?: IntFieldUpdateOperationsInput | number
    overrideDamage?: NullableStringFieldUpdateOperationsInput | string | null
    attackBonus?: NullableIntFieldUpdateOperationsInput | number | null
    overrideName?: NullableStringFieldUpdateOperationsInput | string | null
    overrideNormalRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideLongRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    overrideAttackAbility?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersMagicItemUpdateWithoutPersInput = {
    magicItem?: MagicItemUpdateOneRequiredWithoutPersMagicItemsNestedInput
  }

  export type PersMagicItemUncheckedUpdateWithoutPersInput = {
    persMagicItemId?: IntFieldUpdateOperationsInput | number
    magicItemId?: IntFieldUpdateOperationsInput | number
  }

  export type PersMagicItemUncheckedUpdateManyWithoutPersInput = {
    persMagicItemId?: IntFieldUpdateOperationsInput | number
    magicItemId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceVariantUpdateWithoutPersesInput = {
    name?: EnumVariantsFieldUpdateOperationsInput | $Enums.Variants
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    exclusivityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    overridesRaceASI?: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    overridesFlightSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    replacesTraits?: RaceTraitUpdateManyWithoutRaceVariantsNestedInput
    traits?: RaceVariantTraitUpdateManyWithoutRaceVariantNestedInput
    race?: RaceUpdateOneRequiredWithoutRaceVariantsNestedInput
  }

  export type RaceVariantUncheckedUpdateWithoutPersesInput = {
    raceVariantId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumVariantsFieldUpdateOperationsInput | $Enums.Variants
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    exclusivityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    overridesRaceASI?: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    overridesFlightSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    replacesTraits?: RaceTraitUncheckedUpdateManyWithoutRaceVariantsNestedInput
    traits?: RaceVariantTraitUncheckedUpdateManyWithoutRaceVariantNestedInput
  }

  export type RaceVariantUncheckedUpdateManyWithoutPersesInput = {
    raceVariantId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumVariantsFieldUpdateOperationsInput | $Enums.Variants
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    exclusivityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    overridesRaceASI?: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    overridesFlightSpeed?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RaceChoiceOptionUpdateWithoutPersesInput = {
    choiceGroupName?: StringFieldUpdateOperationsInput | string
    optionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    selectMultiple?: BoolFieldUpdateOperationsInput | boolean
    maxSelection?: IntFieldUpdateOperationsInput | number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionUpdategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionUpdategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    modifiesSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    draconicDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    breathWeaponShape?: NullableEnumAOEShapesFieldUpdateOperationsInput | $Enums.AOEShapes | null
    breathWeaponAOE?: NullableStringFieldUpdateOperationsInput | string | null
    grantsTraits?: RaceChoiceOptionTraitUpdateManyWithoutRaceChoiceOptionNestedInput
    race?: RaceUpdateOneRequiredWithoutRaceChoiceOptionsNestedInput
    subrace?: SubraceUpdateOneWithoutRaceChoiceOptionsNestedInput
  }

  export type RaceChoiceOptionUncheckedUpdateWithoutPersesInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    choiceGroupName?: StringFieldUpdateOperationsInput | string
    optionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    selectMultiple?: BoolFieldUpdateOperationsInput | boolean
    maxSelection?: IntFieldUpdateOperationsInput | number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionUpdategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionUpdategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    modifiesSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    draconicDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    breathWeaponShape?: NullableEnumAOEShapesFieldUpdateOperationsInput | $Enums.AOEShapes | null
    breathWeaponAOE?: NullableStringFieldUpdateOperationsInput | string | null
    grantsTraits?: RaceChoiceOptionTraitUncheckedUpdateManyWithoutRaceChoiceOptionNestedInput
  }

  export type RaceChoiceOptionUncheckedUpdateManyWithoutPersesInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    choiceGroupName?: StringFieldUpdateOperationsInput | string
    optionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    selectMultiple?: BoolFieldUpdateOperationsInput | boolean
    maxSelection?: IntFieldUpdateOperationsInput | number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionUpdategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionUpdategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    modifiesSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    draconicDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    breathWeaponShape?: NullableEnumAOEShapesFieldUpdateOperationsInput | $Enums.AOEShapes | null
    breathWeaponAOE?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassFeatureCreateManyFeatureInput = {
    classFeatureId?: number
    classId: number
    levelGranted: number
    grantsSpellSlots?: boolean
  }

  export type SubclassFeatureCreateManyFeatureInput = {
    subclassFeatureId?: number
    subclassId: number
    levelGranted: number
    grantsSpellSlots?: boolean
  }

  export type RaceTraitCreateManyFeatureInput = {
    raceTraitId?: number
    raceId: number
  }

  export type SubraceTraitCreateManyFeatureInput = {
    subraceTraitId?: number
    subraceId: number
  }

  export type RaceVariantTraitCreateManyFeatureInput = {
    raceVariantTraitId?: number
    raceVariantId: number
  }

  export type RaceChoiceOptionTraitCreateManyFeatureInput = {
    raceChoiceOptionTraitId?: number
    optionId: number
  }

  export type FeatFeatureCreateManyFeatureInput = {
    featFeatureId?: number
    featId: number
  }

  export type MagicItemFeatureCreateManyFeatureInput = {
    magicItemFeatureId?: number
    magicItemId: number
  }

  export type PersFeatureCreateManyFeatureInput = {
    persFeatureId?: number
    persId: number
    usesRemaining?: number | null
  }

  export type SpellUpdateWithoutFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    characterSpells?: CharacterSpellsUpdateManyWithoutSpellNestedInput
    spellClasses?: SpellClassesUpdateManyWithoutSpellNestedInput
    spellRaces?: SpellRacesUpdateManyWithoutSpellNestedInput
    spellbookSpells?: SpellbookSpellsUpdateManyWithoutSpellNestedInput
    subclasses?: SubclassUpdateManyWithoutExpandedSpellsNestedInput
    perses?: PersUpdateManyWithoutSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutFeaturesInput = {
    spellId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    characterSpells?: CharacterSpellsUncheckedUpdateManyWithoutSpellNestedInput
    spellClasses?: SpellClassesUncheckedUpdateManyWithoutSpellNestedInput
    spellRaces?: SpellRacesUncheckedUpdateManyWithoutSpellNestedInput
    spellbookSpells?: SpellbookSpellsUncheckedUpdateManyWithoutSpellNestedInput
    subclasses?: SubclassUncheckedUpdateManyWithoutExpandedSpellsNestedInput
    perses?: PersUncheckedUpdateManyWithoutSpellsNestedInput
  }

  export type SpellUncheckedUpdateManyWithoutFeaturesInput = {
    spellId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    school?: NullableStringFieldUpdateOperationsInput | string | null
    castingTime?: StringFieldUpdateOperationsInput | string
    range?: StringFieldUpdateOperationsInput | string
    components?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hasRitual?: NullableStringFieldUpdateOperationsInput | string | null
    hasConcentration?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
  }

  export type ClassFeatureUpdateWithoutFeatureInput = {
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassUpdateOneRequiredWithoutClassFeaturesNestedInput
  }

  export type ClassFeatureUncheckedUpdateWithoutFeatureInput = {
    classFeatureId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassFeatureUncheckedUpdateManyWithoutFeatureInput = {
    classFeatureId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubclassFeatureUpdateWithoutFeatureInput = {
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
    subclass?: SubclassUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type SubclassFeatureUncheckedUpdateWithoutFeatureInput = {
    subclassFeatureId?: IntFieldUpdateOperationsInput | number
    subclassId?: IntFieldUpdateOperationsInput | number
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubclassFeatureUncheckedUpdateManyWithoutFeatureInput = {
    subclassFeatureId?: IntFieldUpdateOperationsInput | number
    subclassId?: IntFieldUpdateOperationsInput | number
    levelGranted?: IntFieldUpdateOperationsInput | number
    grantsSpellSlots?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RaceTraitUpdateWithoutFeatureInput = {
    race?: RaceUpdateOneRequiredWithoutTraitsNestedInput
    subraces?: SubraceUpdateManyWithoutReplacesTraitsNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutReplacesTraitsNestedInput
  }

  export type RaceTraitUncheckedUpdateWithoutFeatureInput = {
    raceTraitId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraces?: SubraceUncheckedUpdateManyWithoutReplacesTraitsNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutReplacesTraitsNestedInput
  }

  export type RaceTraitUncheckedUpdateManyWithoutFeatureInput = {
    raceTraitId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
  }

  export type SubraceTraitUpdateWithoutFeatureInput = {
    subrace?: SubraceUpdateOneRequiredWithoutTraitsNestedInput
  }

  export type SubraceTraitUncheckedUpdateWithoutFeatureInput = {
    subraceTraitId?: IntFieldUpdateOperationsInput | number
    subraceId?: IntFieldUpdateOperationsInput | number
  }

  export type SubraceTraitUncheckedUpdateManyWithoutFeatureInput = {
    subraceTraitId?: IntFieldUpdateOperationsInput | number
    subraceId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceVariantTraitUpdateWithoutFeatureInput = {
    raceVariant?: RaceVariantUpdateOneRequiredWithoutTraitsNestedInput
  }

  export type RaceVariantTraitUncheckedUpdateWithoutFeatureInput = {
    raceVariantTraitId?: IntFieldUpdateOperationsInput | number
    raceVariantId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceVariantTraitUncheckedUpdateManyWithoutFeatureInput = {
    raceVariantTraitId?: IntFieldUpdateOperationsInput | number
    raceVariantId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceChoiceOptionTraitUpdateWithoutFeatureInput = {
    raceChoiceOption?: RaceChoiceOptionUpdateOneRequiredWithoutGrantsTraitsNestedInput
  }

  export type RaceChoiceOptionTraitUncheckedUpdateWithoutFeatureInput = {
    raceChoiceOptionTraitId?: IntFieldUpdateOperationsInput | number
    optionId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceChoiceOptionTraitUncheckedUpdateManyWithoutFeatureInput = {
    raceChoiceOptionTraitId?: IntFieldUpdateOperationsInput | number
    optionId?: IntFieldUpdateOperationsInput | number
  }

  export type FeatFeatureUpdateWithoutFeatureInput = {
    feat?: FeatUpdateOneRequiredWithoutFeatFeaturesNestedInput
  }

  export type FeatFeatureUncheckedUpdateWithoutFeatureInput = {
    featFeatureId?: IntFieldUpdateOperationsInput | number
    featId?: IntFieldUpdateOperationsInput | number
  }

  export type FeatFeatureUncheckedUpdateManyWithoutFeatureInput = {
    featFeatureId?: IntFieldUpdateOperationsInput | number
    featId?: IntFieldUpdateOperationsInput | number
  }

  export type MagicItemFeatureUpdateWithoutFeatureInput = {
    magicItem?: MagicItemUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type MagicItemFeatureUncheckedUpdateWithoutFeatureInput = {
    magicItemFeatureId?: IntFieldUpdateOperationsInput | number
    magicItemId?: IntFieldUpdateOperationsInput | number
  }

  export type MagicItemFeatureUncheckedUpdateManyWithoutFeatureInput = {
    magicItemFeatureId?: IntFieldUpdateOperationsInput | number
    magicItemId?: IntFieldUpdateOperationsInput | number
  }

  export type PersFeatureUpdateWithoutFeatureInput = {
    usesRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    pers?: PersUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type PersFeatureUncheckedUpdateWithoutFeatureInput = {
    persFeatureId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    usesRemaining?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersFeatureUncheckedUpdateManyWithoutFeatureInput = {
    persFeatureId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    usesRemaining?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubraceUpdateWithoutReplacesTraitsInput = {
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    race?: RaceUpdateOneRequiredWithoutSubracesNestedInput
    perses?: PersUpdateManyWithoutSubraceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutSubraceNestedInput
    traits?: SubraceTraitUpdateManyWithoutSubraceNestedInput
  }

  export type SubraceUncheckedUpdateWithoutReplacesTraitsInput = {
    subraceId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    perses?: PersUncheckedUpdateManyWithoutSubraceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutSubraceNestedInput
    traits?: SubraceTraitUncheckedUpdateManyWithoutSubraceNestedInput
  }

  export type SubraceUncheckedUpdateManyWithoutReplacesTraitsInput = {
    subraceId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
  }

  export type RaceVariantUpdateWithoutReplacesTraitsInput = {
    name?: EnumVariantsFieldUpdateOperationsInput | $Enums.Variants
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    exclusivityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    overridesRaceASI?: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    overridesFlightSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    traits?: RaceVariantTraitUpdateManyWithoutRaceVariantNestedInput
    race?: RaceUpdateOneRequiredWithoutRaceVariantsNestedInput
    perses?: PersUpdateManyWithoutRaceVariantsNestedInput
  }

  export type RaceVariantUncheckedUpdateWithoutReplacesTraitsInput = {
    raceVariantId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumVariantsFieldUpdateOperationsInput | $Enums.Variants
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    exclusivityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    overridesRaceASI?: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    overridesFlightSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    traits?: RaceVariantTraitUncheckedUpdateManyWithoutRaceVariantNestedInput
    perses?: PersUncheckedUpdateManyWithoutRaceVariantsNestedInput
  }

  export type RaceVariantUncheckedUpdateManyWithoutReplacesTraitsInput = {
    raceVariantId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    name?: EnumVariantsFieldUpdateOperationsInput | $Enums.Variants
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    exclusivityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    overridesRaceASI?: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    overridesFlightSpeed?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubraceCreateManyRaceInput = {
    subraceId?: number
    name: $Enums.Subraces
    speedModifier?: number | null
    source?: $Enums.Source
    replacesASI?: boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceCreateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    toolProficiencies?: SubraceCreatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceCreateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceCreatearmorProficienciesInput | $Enums.ArmorType[]
  }

  export type PersCreateManyRaceInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RaceChoiceOptionCreateManyRaceInput = {
    optionId?: number
    subraceId?: number | null
    choiceGroupName: string
    optionName: string
    description?: string | null
    selectMultiple?: boolean
    maxSelection?: number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionCreategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionCreategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    modifiesSpeed?: number | null
    draconicDamageType?: $Enums.DamageType | null
    breathWeaponShape?: $Enums.AOEShapes | null
    breathWeaponAOE?: string | null
  }

  export type RaceVariantCreateManyRaceInput = {
    raceVariantId?: number
    name: $Enums.Variants
    source: $Enums.Source
    exclusivityGroup?: string | null
    overridesRaceASI: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: number | null
    overridesFlightSpeed?: number | null
  }

  export type RaceTraitCreateManyRaceInput = {
    raceTraitId?: number
    featureId: number
  }

  export type SubraceUpdateWithoutRaceInput = {
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitUpdateManyWithoutSubracesNestedInput
    perses?: PersUpdateManyWithoutSubraceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutSubraceNestedInput
    traits?: SubraceTraitUpdateManyWithoutSubraceNestedInput
  }

  export type SubraceUncheckedUpdateWithoutRaceInput = {
    subraceId?: IntFieldUpdateOperationsInput | number
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
    replacesTraits?: RaceTraitUncheckedUpdateManyWithoutSubracesNestedInput
    perses?: PersUncheckedUpdateManyWithoutSubraceNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutSubraceNestedInput
    traits?: SubraceTraitUncheckedUpdateManyWithoutSubraceNestedInput
  }

  export type SubraceUncheckedUpdateManyWithoutRaceInput = {
    subraceId?: IntFieldUpdateOperationsInput | number
    name?: EnumSubracesFieldUpdateOperationsInput | $Enums.Subraces
    speedModifier?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    replacesASI?: BoolFieldUpdateOperationsInput | boolean
    additionalASI?: NullableJsonNullValueInput | InputJsonValue
    additionalLanguages?: SubraceUpdateadditionalLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    toolProficiencies?: SubraceUpdatetoolProficienciesInput | $Enums.ToolCategory[]
    skillProficiencies?: NullableJsonNullValueInput | InputJsonValue
    weaponProficiencies?: SubraceUpdateweaponProficienciesInput | $Enums.WeaponCategory[]
    armorProficiencies?: SubraceUpdatearmorProficienciesInput | $Enums.ArmorType[]
  }

  export type PersUpdateWithoutRaceInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutRaceInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateManyWithoutRaceInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaceChoiceOptionUpdateWithoutRaceInput = {
    choiceGroupName?: StringFieldUpdateOperationsInput | string
    optionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    selectMultiple?: BoolFieldUpdateOperationsInput | boolean
    maxSelection?: IntFieldUpdateOperationsInput | number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionUpdategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionUpdategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    modifiesSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    draconicDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    breathWeaponShape?: NullableEnumAOEShapesFieldUpdateOperationsInput | $Enums.AOEShapes | null
    breathWeaponAOE?: NullableStringFieldUpdateOperationsInput | string | null
    grantsTraits?: RaceChoiceOptionTraitUpdateManyWithoutRaceChoiceOptionNestedInput
    subrace?: SubraceUpdateOneWithoutRaceChoiceOptionsNestedInput
    perses?: PersUpdateManyWithoutRaceChoiceOptionsNestedInput
  }

  export type RaceChoiceOptionUncheckedUpdateWithoutRaceInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    choiceGroupName?: StringFieldUpdateOperationsInput | string
    optionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    selectMultiple?: BoolFieldUpdateOperationsInput | boolean
    maxSelection?: IntFieldUpdateOperationsInput | number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionUpdategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionUpdategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    modifiesSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    draconicDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    breathWeaponShape?: NullableEnumAOEShapesFieldUpdateOperationsInput | $Enums.AOEShapes | null
    breathWeaponAOE?: NullableStringFieldUpdateOperationsInput | string | null
    grantsTraits?: RaceChoiceOptionTraitUncheckedUpdateManyWithoutRaceChoiceOptionNestedInput
    perses?: PersUncheckedUpdateManyWithoutRaceChoiceOptionsNestedInput
  }

  export type RaceChoiceOptionUncheckedUpdateManyWithoutRaceInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    choiceGroupName?: StringFieldUpdateOperationsInput | string
    optionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    selectMultiple?: BoolFieldUpdateOperationsInput | boolean
    maxSelection?: IntFieldUpdateOperationsInput | number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionUpdategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionUpdategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    modifiesSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    draconicDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    breathWeaponShape?: NullableEnumAOEShapesFieldUpdateOperationsInput | $Enums.AOEShapes | null
    breathWeaponAOE?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RaceVariantUpdateWithoutRaceInput = {
    name?: EnumVariantsFieldUpdateOperationsInput | $Enums.Variants
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    exclusivityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    overridesRaceASI?: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    overridesFlightSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    replacesTraits?: RaceTraitUpdateManyWithoutRaceVariantsNestedInput
    traits?: RaceVariantTraitUpdateManyWithoutRaceVariantNestedInput
    perses?: PersUpdateManyWithoutRaceVariantsNestedInput
  }

  export type RaceVariantUncheckedUpdateWithoutRaceInput = {
    raceVariantId?: IntFieldUpdateOperationsInput | number
    name?: EnumVariantsFieldUpdateOperationsInput | $Enums.Variants
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    exclusivityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    overridesRaceASI?: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    overridesFlightSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    replacesTraits?: RaceTraitUncheckedUpdateManyWithoutRaceVariantsNestedInput
    traits?: RaceVariantTraitUncheckedUpdateManyWithoutRaceVariantNestedInput
    perses?: PersUncheckedUpdateManyWithoutRaceVariantsNestedInput
  }

  export type RaceVariantUncheckedUpdateManyWithoutRaceInput = {
    raceVariantId?: IntFieldUpdateOperationsInput | number
    name?: EnumVariantsFieldUpdateOperationsInput | $Enums.Variants
    source?: EnumSourceFieldUpdateOperationsInput | $Enums.Source
    exclusivityGroup?: NullableStringFieldUpdateOperationsInput | string | null
    overridesRaceASI?: JsonNullValueInput | InputJsonValue
    overridesRaceSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    overridesFlightSpeed?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RaceTraitUpdateWithoutRaceInput = {
    feature?: FeatureUpdateOneRequiredWithoutRaceTraitsNestedInput
    subraces?: SubraceUpdateManyWithoutReplacesTraitsNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutReplacesTraitsNestedInput
  }

  export type RaceTraitUncheckedUpdateWithoutRaceInput = {
    raceTraitId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    subraces?: SubraceUncheckedUpdateManyWithoutReplacesTraitsNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutReplacesTraitsNestedInput
  }

  export type RaceTraitUncheckedUpdateManyWithoutRaceInput = {
    raceTraitId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type PersCreateManySubraceInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    backgroundId: number
    raceId: number
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RaceChoiceOptionCreateManySubraceInput = {
    optionId?: number
    raceId: number
    choiceGroupName: string
    optionName: string
    description?: string | null
    selectMultiple?: boolean
    maxSelection?: number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionCreategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionCreategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: number
    modifiesSpeed?: number | null
    draconicDamageType?: $Enums.DamageType | null
    breathWeaponShape?: $Enums.AOEShapes | null
    breathWeaponAOE?: string | null
  }

  export type SubraceTraitCreateManySubraceInput = {
    subraceTraitId?: number
    featureId: number
  }

  export type RaceTraitUpdateWithoutSubracesInput = {
    feature?: FeatureUpdateOneRequiredWithoutRaceTraitsNestedInput
    race?: RaceUpdateOneRequiredWithoutTraitsNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutReplacesTraitsNestedInput
  }

  export type RaceTraitUncheckedUpdateWithoutSubracesInput = {
    raceTraitId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutReplacesTraitsNestedInput
  }

  export type RaceTraitUncheckedUpdateManyWithoutSubracesInput = {
    raceTraitId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type PersUpdateWithoutSubraceInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutSubraceInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateManyWithoutSubraceInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaceChoiceOptionUpdateWithoutSubraceInput = {
    choiceGroupName?: StringFieldUpdateOperationsInput | string
    optionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    selectMultiple?: BoolFieldUpdateOperationsInput | boolean
    maxSelection?: IntFieldUpdateOperationsInput | number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionUpdategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionUpdategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    modifiesSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    draconicDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    breathWeaponShape?: NullableEnumAOEShapesFieldUpdateOperationsInput | $Enums.AOEShapes | null
    breathWeaponAOE?: NullableStringFieldUpdateOperationsInput | string | null
    grantsTraits?: RaceChoiceOptionTraitUpdateManyWithoutRaceChoiceOptionNestedInput
    race?: RaceUpdateOneRequiredWithoutRaceChoiceOptionsNestedInput
    perses?: PersUpdateManyWithoutRaceChoiceOptionsNestedInput
  }

  export type RaceChoiceOptionUncheckedUpdateWithoutSubraceInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    choiceGroupName?: StringFieldUpdateOperationsInput | string
    optionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    selectMultiple?: BoolFieldUpdateOperationsInput | boolean
    maxSelection?: IntFieldUpdateOperationsInput | number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionUpdategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionUpdategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    modifiesSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    draconicDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    breathWeaponShape?: NullableEnumAOEShapesFieldUpdateOperationsInput | $Enums.AOEShapes | null
    breathWeaponAOE?: NullableStringFieldUpdateOperationsInput | string | null
    grantsTraits?: RaceChoiceOptionTraitUncheckedUpdateManyWithoutRaceChoiceOptionNestedInput
    perses?: PersUncheckedUpdateManyWithoutRaceChoiceOptionsNestedInput
  }

  export type RaceChoiceOptionUncheckedUpdateManyWithoutSubraceInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    choiceGroupName?: StringFieldUpdateOperationsInput | string
    optionName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    selectMultiple?: BoolFieldUpdateOperationsInput | boolean
    maxSelection?: IntFieldUpdateOperationsInput | number
    grantsASI?: NullableJsonNullValueInput | InputJsonValue
    grantsSkillProficiencies?: RaceChoiceOptionUpdategrantsSkillProficienciesInput | $Enums.Skills[]
    grantsLanguages?: RaceChoiceOptionUpdategrantsLanguagesInput | $Enums.Language[]
    languagesToChooseCount?: IntFieldUpdateOperationsInput | number
    modifiesSpeed?: NullableIntFieldUpdateOperationsInput | number | null
    draconicDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    breathWeaponShape?: NullableEnumAOEShapesFieldUpdateOperationsInput | $Enums.AOEShapes | null
    breathWeaponAOE?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubraceTraitUpdateWithoutSubraceInput = {
    feature?: FeatureUpdateOneRequiredWithoutSubraceTraitsNestedInput
  }

  export type SubraceTraitUncheckedUpdateWithoutSubraceInput = {
    subraceTraitId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type SubraceTraitUncheckedUpdateManyWithoutSubraceInput = {
    subraceTraitId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceVariantTraitCreateManyRaceVariantInput = {
    raceVariantTraitId?: number
    featureId: number
  }

  export type RaceTraitUpdateWithoutRaceVariantsInput = {
    feature?: FeatureUpdateOneRequiredWithoutRaceTraitsNestedInput
    race?: RaceUpdateOneRequiredWithoutTraitsNestedInput
    subraces?: SubraceUpdateManyWithoutReplacesTraitsNestedInput
  }

  export type RaceTraitUncheckedUpdateWithoutRaceVariantsInput = {
    raceTraitId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    subraces?: SubraceUncheckedUpdateManyWithoutReplacesTraitsNestedInput
  }

  export type RaceTraitUncheckedUpdateManyWithoutRaceVariantsInput = {
    raceTraitId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceVariantTraitUpdateWithoutRaceVariantInput = {
    feature?: FeatureUpdateOneRequiredWithoutRaceVariantTraitsNestedInput
  }

  export type RaceVariantTraitUncheckedUpdateWithoutRaceVariantInput = {
    raceVariantTraitId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceVariantTraitUncheckedUpdateManyWithoutRaceVariantInput = {
    raceVariantTraitId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type PersUpdateWithoutRaceVariantsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutRaceVariantsInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateManyWithoutRaceVariantsInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaceChoiceOptionTraitCreateManyRaceChoiceOptionInput = {
    raceChoiceOptionTraitId?: number
    featureId: number
  }

  export type RaceChoiceOptionTraitUpdateWithoutRaceChoiceOptionInput = {
    feature?: FeatureUpdateOneRequiredWithoutRaceChoiceOptionsTraitsNestedInput
  }

  export type RaceChoiceOptionTraitUncheckedUpdateWithoutRaceChoiceOptionInput = {
    raceChoiceOptionTraitId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceChoiceOptionTraitUncheckedUpdateManyWithoutRaceChoiceOptionInput = {
    raceChoiceOptionTraitId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type PersUpdateWithoutRaceChoiceOptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    background?: BackgroundUpdateOneRequiredWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutRaceChoiceOptionsInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateManyWithoutRaceChoiceOptionsInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    backgroundId?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersCreateManyBackgroundInput = {
    persId?: number
    userId: number
    name: string
    level?: number
    currentSpellSlots?: PersCreatecurrentSpellSlotsInput | number[]
    classId: number
    subclassId?: number | null
    raceId: number
    subraceId?: number | null
    currentHp: number
    maxHp: number
    tempHp?: number
    raceCustom?: string
    classCustom?: string
    alignment?: string
    xp?: number
    customBackground?: string
    customFeatures?: string
    customLanguagesKnown?: string
    customEquipment?: string
    personalityTraits?: string
    ideals?: string
    bonds?: string
    flaws?: string
    backstory?: string
    notes?: string
    str: number
    dex: number
    con: number
    int: number
    wis: number
    cha: number
    cp?: number
    sp?: number
    ep?: number
    gp?: number
    pp?: number
    additionalSaveProficiencies?: PersCreateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersUpdateWithoutBackgroundInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersNestedInput
    class?: ClassUpdateOneRequiredWithoutPersesNestedInput
    subclass?: SubclassUpdateOneWithoutPersesNestedInput
    race?: RaceUpdateOneRequiredWithoutPersesNestedInput
    subrace?: SubraceUpdateOneWithoutPersesNestedInput
    skills?: PersSkillUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUpdateManyWithoutPersNestedInput
    features?: PersFeatureUpdateManyWithoutPersNestedInput
    spells?: SpellUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUpdateManyWithoutPersNestedInput
    armors?: PersArmorUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateWithoutBackgroundInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: PersSkillUncheckedUpdateManyWithoutPersNestedInput
    multiclasses?: PersMulticlassUncheckedUpdateManyWithoutPersNestedInput
    features?: PersFeatureUncheckedUpdateManyWithoutPersNestedInput
    spells?: SpellUncheckedUpdateManyWithoutPersesNestedInput
    feats?: PersFeatUncheckedUpdateManyWithoutPersNestedInput
    armors?: PersArmorUncheckedUpdateManyWithoutPersNestedInput
    weapons?: PersWeaponUncheckedUpdateManyWithoutPersNestedInput
    magicItems?: PersMagicItemUncheckedUpdateManyWithoutPersNestedInput
    raceVariants?: RaceVariantUncheckedUpdateManyWithoutPersesNestedInput
    raceChoiceOptions?: RaceChoiceOptionUncheckedUpdateManyWithoutPersesNestedInput
  }

  export type PersUncheckedUpdateManyWithoutBackgroundInput = {
    persId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentSpellSlots?: PersUpdatecurrentSpellSlotsInput | number[]
    classId?: IntFieldUpdateOperationsInput | number
    subclassId?: NullableIntFieldUpdateOperationsInput | number | null
    raceId?: IntFieldUpdateOperationsInput | number
    subraceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentHp?: IntFieldUpdateOperationsInput | number
    maxHp?: IntFieldUpdateOperationsInput | number
    tempHp?: IntFieldUpdateOperationsInput | number
    raceCustom?: StringFieldUpdateOperationsInput | string
    classCustom?: StringFieldUpdateOperationsInput | string
    alignment?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    customBackground?: StringFieldUpdateOperationsInput | string
    customFeatures?: StringFieldUpdateOperationsInput | string
    customLanguagesKnown?: StringFieldUpdateOperationsInput | string
    customEquipment?: StringFieldUpdateOperationsInput | string
    personalityTraits?: StringFieldUpdateOperationsInput | string
    ideals?: StringFieldUpdateOperationsInput | string
    bonds?: StringFieldUpdateOperationsInput | string
    flaws?: StringFieldUpdateOperationsInput | string
    backstory?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    str?: IntFieldUpdateOperationsInput | number
    dex?: IntFieldUpdateOperationsInput | number
    con?: IntFieldUpdateOperationsInput | number
    int?: IntFieldUpdateOperationsInput | number
    wis?: IntFieldUpdateOperationsInput | number
    cha?: IntFieldUpdateOperationsInput | number
    cp?: IntFieldUpdateOperationsInput | number
    sp?: IntFieldUpdateOperationsInput | number
    ep?: IntFieldUpdateOperationsInput | number
    gp?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    additionalSaveProficiencies?: PersUpdateadditionalSaveProficienciesInput | $Enums.Ability[]
    miscSaveBonuses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatFeatureCreateManyFeatInput = {
    featFeatureId?: number
    featureId: number
  }

  export type PersFeatCreateManyFeatInput = {
    persFeatId?: number
    persId: number
  }

  export type FeatFeatureUpdateWithoutFeatInput = {
    feature?: FeatureUpdateOneRequiredWithoutFeatFeaturesNestedInput
  }

  export type FeatFeatureUncheckedUpdateWithoutFeatInput = {
    featFeatureId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type FeatFeatureUncheckedUpdateManyWithoutFeatInput = {
    featFeatureId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type PersFeatUpdateWithoutFeatInput = {
    pers?: PersUpdateOneRequiredWithoutFeatsNestedInput
  }

  export type PersFeatUncheckedUpdateWithoutFeatInput = {
    persFeatId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
  }

  export type PersFeatUncheckedUpdateManyWithoutFeatInput = {
    persFeatId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
  }

  export type MagicItemFeatureCreateManyMagicItemInput = {
    magicItemFeatureId?: number
    featureId: number
  }

  export type PersMagicItemCreateManyMagicItemInput = {
    persMagicItemId?: number
    persId: number
  }

  export type MagicItemFeatureUpdateWithoutMagicItemInput = {
    feature?: FeatureUpdateOneRequiredWithoutMagicItemFeaturesNestedInput
  }

  export type MagicItemFeatureUncheckedUpdateWithoutMagicItemInput = {
    magicItemFeatureId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type MagicItemFeatureUncheckedUpdateManyWithoutMagicItemInput = {
    magicItemFeatureId?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
  }

  export type PersMagicItemUpdateWithoutMagicItemInput = {
    pers?: PersUpdateOneRequiredWithoutMagicItemsNestedInput
  }

  export type PersMagicItemUncheckedUpdateWithoutMagicItemInput = {
    persMagicItemId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
  }

  export type PersMagicItemUncheckedUpdateManyWithoutMagicItemInput = {
    persMagicItemId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
  }

  export type PersWeaponCreateManyWeaponInput = {
    persWeaponId?: number
    persId: number
    overrideDamage?: string | null
    attackBonus?: number | null
    overrideName?: string | null
    overrideNormalRange?: number | null
    overrideLongRange?: number | null
    overrideDamageType?: $Enums.DamageType | null
    overrideAttackAbility?: $Enums.Ability | null
    isProficient?: boolean
  }

  export type ClassStartingEquipmentOptionCreateManyWeaponInput = {
    optionId?: number
    classId: number
    choiceGroup: number
    option: string
    armorId?: number | null
    equipmentPackId?: number | null
    quantity?: number
    chooseAnyArmor?: boolean
    armorType?: $Enums.ArmorType | null
    chooseAnyWeapon?: boolean
    weaponType?: $Enums.WeaponType | null
    weaponCount?: number
    description?: string | null
  }

  export type PersWeaponUpdateWithoutWeaponInput = {
    overrideDamage?: NullableStringFieldUpdateOperationsInput | string | null
    attackBonus?: NullableIntFieldUpdateOperationsInput | number | null
    overrideName?: NullableStringFieldUpdateOperationsInput | string | null
    overrideNormalRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideLongRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    overrideAttackAbility?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
    pers?: PersUpdateOneRequiredWithoutWeaponsNestedInput
  }

  export type PersWeaponUncheckedUpdateWithoutWeaponInput = {
    persWeaponId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    overrideDamage?: NullableStringFieldUpdateOperationsInput | string | null
    attackBonus?: NullableIntFieldUpdateOperationsInput | number | null
    overrideName?: NullableStringFieldUpdateOperationsInput | string | null
    overrideNormalRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideLongRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    overrideAttackAbility?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersWeaponUncheckedUpdateManyWithoutWeaponInput = {
    persWeaponId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    overrideDamage?: NullableStringFieldUpdateOperationsInput | string | null
    attackBonus?: NullableIntFieldUpdateOperationsInput | number | null
    overrideName?: NullableStringFieldUpdateOperationsInput | string | null
    overrideNormalRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideLongRange?: NullableIntFieldUpdateOperationsInput | number | null
    overrideDamageType?: NullableEnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType | null
    overrideAttackAbility?: NullableEnumAbilityFieldUpdateOperationsInput | $Enums.Ability | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassStartingEquipmentOptionUpdateWithoutWeaponInput = {
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class?: ClassUpdateOneRequiredWithoutStartingEquipmentOptionNestedInput
    armor?: ArmorUpdateOneWithoutClassStartingEquipmentOptionNestedInput
    equipmentPack?: EquipmentPackUpdateOneWithoutClassStartingEquipmentOptionsNestedInput
  }

  export type ClassStartingEquipmentOptionUncheckedUpdateWithoutWeaponInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    armorId?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentPackId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassStartingEquipmentOptionUncheckedUpdateManyWithoutWeaponInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    armorId?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentPackId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersArmorCreateManyArmorInput = {
    persArmorId?: number
    persId: number
    overrideBaseAC?: number | null
    miscACBonus?: number | null
    isProficient?: boolean
    equipped?: boolean
  }

  export type ClassStartingEquipmentOptionCreateManyArmorInput = {
    optionId?: number
    classId: number
    choiceGroup: number
    option: string
    weaponId?: number | null
    equipmentPackId?: number | null
    quantity?: number
    chooseAnyArmor?: boolean
    armorType?: $Enums.ArmorType | null
    chooseAnyWeapon?: boolean
    weaponType?: $Enums.WeaponType | null
    weaponCount?: number
    description?: string | null
  }

  export type PersArmorUpdateWithoutArmorInput = {
    overrideBaseAC?: NullableIntFieldUpdateOperationsInput | number | null
    miscACBonus?: NullableIntFieldUpdateOperationsInput | number | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
    equipped?: BoolFieldUpdateOperationsInput | boolean
    pers?: PersUpdateOneRequiredWithoutArmorsNestedInput
  }

  export type PersArmorUncheckedUpdateWithoutArmorInput = {
    persArmorId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    overrideBaseAC?: NullableIntFieldUpdateOperationsInput | number | null
    miscACBonus?: NullableIntFieldUpdateOperationsInput | number | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
    equipped?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersArmorUncheckedUpdateManyWithoutArmorInput = {
    persArmorId?: IntFieldUpdateOperationsInput | number
    persId?: IntFieldUpdateOperationsInput | number
    overrideBaseAC?: NullableIntFieldUpdateOperationsInput | number | null
    miscACBonus?: NullableIntFieldUpdateOperationsInput | number | null
    isProficient?: BoolFieldUpdateOperationsInput | boolean
    equipped?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassStartingEquipmentOptionUpdateWithoutArmorInput = {
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class?: ClassUpdateOneRequiredWithoutStartingEquipmentOptionNestedInput
    weapon?: WeaponUpdateOneWithoutClassStartingEquipmentOptionNestedInput
    equipmentPack?: EquipmentPackUpdateOneWithoutClassStartingEquipmentOptionsNestedInput
  }

  export type ClassStartingEquipmentOptionUncheckedUpdateWithoutArmorInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentPackId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassStartingEquipmentOptionUncheckedUpdateManyWithoutArmorInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableIntFieldUpdateOperationsInput | number | null
    equipmentPackId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassStartingEquipmentOptionCreateManyEquipmentPackInput = {
    optionId?: number
    classId: number
    choiceGroup: number
    option: string
    weaponId?: number | null
    armorId?: number | null
    quantity?: number
    chooseAnyArmor?: boolean
    armorType?: $Enums.ArmorType | null
    chooseAnyWeapon?: boolean
    weaponType?: $Enums.WeaponType | null
    weaponCount?: number
    description?: string | null
  }

  export type ClassStartingEquipmentOptionUpdateWithoutEquipmentPackInput = {
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class?: ClassUpdateOneRequiredWithoutStartingEquipmentOptionNestedInput
    weapon?: WeaponUpdateOneWithoutClassStartingEquipmentOptionNestedInput
    armor?: ArmorUpdateOneWithoutClassStartingEquipmentOptionNestedInput
  }

  export type ClassStartingEquipmentOptionUncheckedUpdateWithoutEquipmentPackInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableIntFieldUpdateOperationsInput | number | null
    armorId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassStartingEquipmentOptionUncheckedUpdateManyWithoutEquipmentPackInput = {
    optionId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    choiceGroup?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableIntFieldUpdateOperationsInput | number | null
    armorId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    chooseAnyArmor?: BoolFieldUpdateOperationsInput | boolean
    armorType?: NullableEnumArmorTypeFieldUpdateOperationsInput | $Enums.ArmorType | null
    chooseAnyWeapon?: BoolFieldUpdateOperationsInput | boolean
    weaponType?: NullableEnumWeaponTypeFieldUpdateOperationsInput | $Enums.WeaponType | null
    weaponCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}